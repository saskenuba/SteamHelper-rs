// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_marketingmessages.steamclient.proto`

// @@protoc_insertion_point(message:CMarketingMessages_GetActiveMarketingMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetActiveMarketingMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetActiveMarketingMessages_Request.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetActiveMarketingMessages_Request.anonymous_user)
    pub anonymous_user: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetActiveMarketingMessages_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetActiveMarketingMessages_Request {
    fn default() -> &'a CMarketingMessages_GetActiveMarketingMessages_Request {
        <CMarketingMessages_GetActiveMarketingMessages_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetActiveMarketingMessages_Request {
    pub fn new() -> CMarketingMessages_GetActiveMarketingMessages_Request {
        ::std::default::Default::default()
    }

    // optional string country = 1;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool anonymous_user = 2;

    pub fn anonymous_user(&self) -> bool {
        self.anonymous_user.unwrap_or(false)
    }

    pub fn clear_anonymous_user(&mut self) {
        self.anonymous_user = ::std::option::Option::None;
    }

    pub fn has_anonymous_user(&self) -> bool {
        self.anonymous_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anonymous_user(&mut self, v: bool) {
        self.anonymous_user = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country",
            |m: &CMarketingMessages_GetActiveMarketingMessages_Request| { &m.country },
            |m: &mut CMarketingMessages_GetActiveMarketingMessages_Request| { &mut m.country },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "anonymous_user",
            |m: &CMarketingMessages_GetActiveMarketingMessages_Request| { &m.anonymous_user },
            |m: &mut CMarketingMessages_GetActiveMarketingMessages_Request| { &mut m.anonymous_user },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetActiveMarketingMessages_Request>(
            "CMarketingMessages_GetActiveMarketingMessages_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetActiveMarketingMessages_Request {
    const NAME: &'static str = "CMarketingMessages_GetActiveMarketingMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.anonymous_user = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.anonymous_user {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.country.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.anonymous_user {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetActiveMarketingMessages_Request {
        CMarketingMessages_GetActiveMarketingMessages_Request::new()
    }

    fn clear(&mut self) {
        self.country = ::std::option::Option::None;
        self.anonymous_user = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetActiveMarketingMessages_Request {
        static instance: CMarketingMessages_GetActiveMarketingMessages_Request = CMarketingMessages_GetActiveMarketingMessages_Request {
            country: ::std::option::Option::None,
            anonymous_user: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetActiveMarketingMessages_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetActiveMarketingMessages_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetActiveMarketingMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetActiveMarketingMessages_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessageProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessageProto {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessageProto.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<EMarketingMessageType>>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.visibility)
    pub visibility: ::std::option::Option<crate::EnumOrUnknown<EMarketingMessageVisibility>>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.priority)
    pub priority: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.association_type)
    pub association_type: ::std::option::Option<crate::EnumOrUnknown<EMarketingMessageAssociationType>>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.associated_id)
    pub associated_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.associated_name)
    pub associated_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.start_date)
    pub start_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.end_date)
    pub end_date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.country_allow)
    pub country_allow: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.country_deny)
    pub country_deny: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.ownership_restrictions_overridden)
    pub ownership_restrictions_overridden: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_own_appid)
    pub must_own_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_not_own_appid)
    pub must_not_own_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_own_packageid)
    pub must_own_packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_not_own_packageid)
    pub must_not_own_packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.must_have_launched_appid)
    pub must_have_launched_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.additional_restrictions)
    pub additional_restrictions: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.template_type)
    pub template_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.template_vars)
    pub template_vars: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.creator_name)
    pub creator_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.template_vars_json)
    pub template_vars_json: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessageProto.additional_restrictions_json)
    pub additional_restrictions_json: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessageProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessageProto {
    fn default() -> &'a CMarketingMessageProto {
        <CMarketingMessageProto as crate::Message>::default_instance()
    }
}

impl CMarketingMessageProto {
    pub fn new() -> CMarketingMessageProto {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EMarketingMessageType type = 3;

    pub fn type_(&self) -> EMarketingMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(EMarketingMessageType::k_EMarketingMessageInvalid),
            None => EMarketingMessageType::k_EMarketingMessageInvalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EMarketingMessageType) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EMarketingMessageVisibility visibility = 4;

    pub fn visibility(&self) -> EMarketingMessageVisibility {
        match self.visibility {
            Some(e) => e.enum_value_or(EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta),
            None => EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta,
        }
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: EMarketingMessageVisibility) {
        self.visibility = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 priority = 5;

    pub fn priority(&self) -> u32 {
        self.priority.unwrap_or(0)
    }

    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: u32) {
        self.priority = ::std::option::Option::Some(v);
    }

    // optional .EMarketingMessageAssociationType association_type = 6;

    pub fn association_type(&self) -> EMarketingMessageAssociationType {
        match self.association_type {
            Some(e) => e.enum_value_or(EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation),
            None => EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation,
        }
    }

    pub fn clear_association_type(&mut self) {
        self.association_type = ::std::option::Option::None;
    }

    pub fn has_association_type(&self) -> bool {
        self.association_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_association_type(&mut self, v: EMarketingMessageAssociationType) {
        self.association_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 associated_id = 7;

    pub fn associated_id(&self) -> u32 {
        self.associated_id.unwrap_or(0)
    }

    pub fn clear_associated_id(&mut self) {
        self.associated_id = ::std::option::Option::None;
    }

    pub fn has_associated_id(&self) -> bool {
        self.associated_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_id(&mut self, v: u32) {
        self.associated_id = ::std::option::Option::Some(v);
    }

    // optional string associated_name = 8;

    pub fn associated_name(&self) -> &str {
        match self.associated_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_associated_name(&mut self) {
        self.associated_name = ::std::option::Option::None;
    }

    pub fn has_associated_name(&self) -> bool {
        self.associated_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_name(&mut self, v: ::std::string::String) {
        self.associated_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_associated_name(&mut self) -> &mut ::std::string::String {
        if self.associated_name.is_none() {
            self.associated_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.associated_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_associated_name(&mut self) -> ::std::string::String {
        self.associated_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 start_date = 9;

    pub fn start_date(&self) -> u32 {
        self.start_date.unwrap_or(0)
    }

    pub fn clear_start_date(&mut self) {
        self.start_date = ::std::option::Option::None;
    }

    pub fn has_start_date(&self) -> bool {
        self.start_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_date(&mut self, v: u32) {
        self.start_date = ::std::option::Option::Some(v);
    }

    // optional uint32 end_date = 10;

    pub fn end_date(&self) -> u32 {
        self.end_date.unwrap_or(0)
    }

    pub fn clear_end_date(&mut self) {
        self.end_date = ::std::option::Option::None;
    }

    pub fn has_end_date(&self) -> bool {
        self.end_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_date(&mut self, v: u32) {
        self.end_date = ::std::option::Option::Some(v);
    }

    // optional string country_allow = 11;

    pub fn country_allow(&self) -> &str {
        match self.country_allow.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_allow(&mut self) {
        self.country_allow = ::std::option::Option::None;
    }

    pub fn has_country_allow(&self) -> bool {
        self.country_allow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_allow(&mut self, v: ::std::string::String) {
        self.country_allow = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_allow(&mut self) -> &mut ::std::string::String {
        if self.country_allow.is_none() {
            self.country_allow = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_allow.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_allow(&mut self) -> ::std::string::String {
        self.country_allow.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_deny = 12;

    pub fn country_deny(&self) -> &str {
        match self.country_deny.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_deny(&mut self) {
        self.country_deny = ::std::option::Option::None;
    }

    pub fn has_country_deny(&self) -> bool {
        self.country_deny.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_deny(&mut self, v: ::std::string::String) {
        self.country_deny = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_deny(&mut self) -> &mut ::std::string::String {
        if self.country_deny.is_none() {
            self.country_deny = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_deny.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_deny(&mut self) -> ::std::string::String {
        self.country_deny.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool ownership_restrictions_overridden = 13;

    pub fn ownership_restrictions_overridden(&self) -> bool {
        self.ownership_restrictions_overridden.unwrap_or(false)
    }

    pub fn clear_ownership_restrictions_overridden(&mut self) {
        self.ownership_restrictions_overridden = ::std::option::Option::None;
    }

    pub fn has_ownership_restrictions_overridden(&self) -> bool {
        self.ownership_restrictions_overridden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ownership_restrictions_overridden(&mut self, v: bool) {
        self.ownership_restrictions_overridden = ::std::option::Option::Some(v);
    }

    // optional uint32 must_own_appid = 14;

    pub fn must_own_appid(&self) -> u32 {
        self.must_own_appid.unwrap_or(0)
    }

    pub fn clear_must_own_appid(&mut self) {
        self.must_own_appid = ::std::option::Option::None;
    }

    pub fn has_must_own_appid(&self) -> bool {
        self.must_own_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_own_appid(&mut self, v: u32) {
        self.must_own_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 must_not_own_appid = 15;

    pub fn must_not_own_appid(&self) -> u32 {
        self.must_not_own_appid.unwrap_or(0)
    }

    pub fn clear_must_not_own_appid(&mut self) {
        self.must_not_own_appid = ::std::option::Option::None;
    }

    pub fn has_must_not_own_appid(&self) -> bool {
        self.must_not_own_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_not_own_appid(&mut self, v: u32) {
        self.must_not_own_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 must_own_packageid = 16;

    pub fn must_own_packageid(&self) -> u32 {
        self.must_own_packageid.unwrap_or(0)
    }

    pub fn clear_must_own_packageid(&mut self) {
        self.must_own_packageid = ::std::option::Option::None;
    }

    pub fn has_must_own_packageid(&self) -> bool {
        self.must_own_packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_own_packageid(&mut self, v: u32) {
        self.must_own_packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 must_not_own_packageid = 17;

    pub fn must_not_own_packageid(&self) -> u32 {
        self.must_not_own_packageid.unwrap_or(0)
    }

    pub fn clear_must_not_own_packageid(&mut self) {
        self.must_not_own_packageid = ::std::option::Option::None;
    }

    pub fn has_must_not_own_packageid(&self) -> bool {
        self.must_not_own_packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_not_own_packageid(&mut self, v: u32) {
        self.must_not_own_packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 must_have_launched_appid = 18;

    pub fn must_have_launched_appid(&self) -> u32 {
        self.must_have_launched_appid.unwrap_or(0)
    }

    pub fn clear_must_have_launched_appid(&mut self) {
        self.must_have_launched_appid = ::std::option::Option::None;
    }

    pub fn has_must_have_launched_appid(&self) -> bool {
        self.must_have_launched_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_must_have_launched_appid(&mut self, v: u32) {
        self.must_have_launched_appid = ::std::option::Option::Some(v);
    }

    // optional string additional_restrictions = 19;

    pub fn additional_restrictions(&self) -> &str {
        match self.additional_restrictions.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_additional_restrictions(&mut self) {
        self.additional_restrictions = ::std::option::Option::None;
    }

    pub fn has_additional_restrictions(&self) -> bool {
        self.additional_restrictions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_restrictions(&mut self, v: ::std::string::String) {
        self.additional_restrictions = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_restrictions(&mut self) -> &mut ::std::string::String {
        if self.additional_restrictions.is_none() {
            self.additional_restrictions = ::std::option::Option::Some(::std::string::String::new());
        }
        self.additional_restrictions.as_mut().unwrap()
    }

    // Take field
    pub fn take_additional_restrictions(&mut self) -> ::std::string::String {
        self.additional_restrictions.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_type = 20;

    pub fn template_type(&self) -> &str {
        match self.template_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: ::std::string::String) {
        self.template_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_type(&mut self) -> &mut ::std::string::String {
        if self.template_type.is_none() {
            self.template_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_type(&mut self) -> ::std::string::String {
        self.template_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_vars = 21;

    pub fn template_vars(&self) -> &str {
        match self.template_vars.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_vars(&mut self) {
        self.template_vars = ::std::option::Option::None;
    }

    pub fn has_template_vars(&self) -> bool {
        self.template_vars.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_vars(&mut self, v: ::std::string::String) {
        self.template_vars = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_vars(&mut self) -> &mut ::std::string::String {
        if self.template_vars.is_none() {
            self.template_vars = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_vars.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_vars(&mut self) -> ::std::string::String {
        self.template_vars.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 flags = 22;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional string creator_name = 23;

    pub fn creator_name(&self) -> &str {
        match self.creator_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_creator_name(&mut self) {
        self.creator_name = ::std::option::Option::None;
    }

    pub fn has_creator_name(&self) -> bool {
        self.creator_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_name(&mut self, v: ::std::string::String) {
        self.creator_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creator_name(&mut self) -> &mut ::std::string::String {
        if self.creator_name.is_none() {
            self.creator_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.creator_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_creator_name(&mut self) -> ::std::string::String {
        self.creator_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_vars_json = 24;

    pub fn template_vars_json(&self) -> &str {
        match self.template_vars_json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_vars_json(&mut self) {
        self.template_vars_json = ::std::option::Option::None;
    }

    pub fn has_template_vars_json(&self) -> bool {
        self.template_vars_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_vars_json(&mut self, v: ::std::string::String) {
        self.template_vars_json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_vars_json(&mut self) -> &mut ::std::string::String {
        if self.template_vars_json.is_none() {
            self.template_vars_json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_vars_json.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_vars_json(&mut self) -> ::std::string::String {
        self.template_vars_json.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string additional_restrictions_json = 25;

    pub fn additional_restrictions_json(&self) -> &str {
        match self.additional_restrictions_json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_additional_restrictions_json(&mut self) {
        self.additional_restrictions_json = ::std::option::Option::None;
    }

    pub fn has_additional_restrictions_json(&self) -> bool {
        self.additional_restrictions_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_restrictions_json(&mut self, v: ::std::string::String) {
        self.additional_restrictions_json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_restrictions_json(&mut self) -> &mut ::std::string::String {
        if self.additional_restrictions_json.is_none() {
            self.additional_restrictions_json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.additional_restrictions_json.as_mut().unwrap()
    }

    // Take field
    pub fn take_additional_restrictions_json(&mut self) -> ::std::string::String {
        self.additional_restrictions_json.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(25);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessageProto| { &m.gid },
            |m: &mut CMarketingMessageProto| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMarketingMessageProto| { &m.title },
            |m: &mut CMarketingMessageProto| { &mut m.title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMarketingMessageProto| { &m.type_ },
            |m: &mut CMarketingMessageProto| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "visibility",
            |m: &CMarketingMessageProto| { &m.visibility },
            |m: &mut CMarketingMessageProto| { &mut m.visibility },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "priority",
            |m: &CMarketingMessageProto| { &m.priority },
            |m: &mut CMarketingMessageProto| { &mut m.priority },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "association_type",
            |m: &CMarketingMessageProto| { &m.association_type },
            |m: &mut CMarketingMessageProto| { &mut m.association_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "associated_id",
            |m: &CMarketingMessageProto| { &m.associated_id },
            |m: &mut CMarketingMessageProto| { &mut m.associated_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "associated_name",
            |m: &CMarketingMessageProto| { &m.associated_name },
            |m: &mut CMarketingMessageProto| { &mut m.associated_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_date",
            |m: &CMarketingMessageProto| { &m.start_date },
            |m: &mut CMarketingMessageProto| { &mut m.start_date },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_date",
            |m: &CMarketingMessageProto| { &m.end_date },
            |m: &mut CMarketingMessageProto| { &mut m.end_date },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_allow",
            |m: &CMarketingMessageProto| { &m.country_allow },
            |m: &mut CMarketingMessageProto| { &mut m.country_allow },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_deny",
            |m: &CMarketingMessageProto| { &m.country_deny },
            |m: &mut CMarketingMessageProto| { &mut m.country_deny },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ownership_restrictions_overridden",
            |m: &CMarketingMessageProto| { &m.ownership_restrictions_overridden },
            |m: &mut CMarketingMessageProto| { &mut m.ownership_restrictions_overridden },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "must_own_appid",
            |m: &CMarketingMessageProto| { &m.must_own_appid },
            |m: &mut CMarketingMessageProto| { &mut m.must_own_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "must_not_own_appid",
            |m: &CMarketingMessageProto| { &m.must_not_own_appid },
            |m: &mut CMarketingMessageProto| { &mut m.must_not_own_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "must_own_packageid",
            |m: &CMarketingMessageProto| { &m.must_own_packageid },
            |m: &mut CMarketingMessageProto| { &mut m.must_own_packageid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "must_not_own_packageid",
            |m: &CMarketingMessageProto| { &m.must_not_own_packageid },
            |m: &mut CMarketingMessageProto| { &mut m.must_not_own_packageid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "must_have_launched_appid",
            |m: &CMarketingMessageProto| { &m.must_have_launched_appid },
            |m: &mut CMarketingMessageProto| { &mut m.must_have_launched_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_restrictions",
            |m: &CMarketingMessageProto| { &m.additional_restrictions },
            |m: &mut CMarketingMessageProto| { &mut m.additional_restrictions },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "template_type",
            |m: &CMarketingMessageProto| { &m.template_type },
            |m: &mut CMarketingMessageProto| { &mut m.template_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "template_vars",
            |m: &CMarketingMessageProto| { &m.template_vars },
            |m: &mut CMarketingMessageProto| { &mut m.template_vars },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CMarketingMessageProto| { &m.flags },
            |m: &mut CMarketingMessageProto| { &mut m.flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "creator_name",
            |m: &CMarketingMessageProto| { &m.creator_name },
            |m: &mut CMarketingMessageProto| { &mut m.creator_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "template_vars_json",
            |m: &CMarketingMessageProto| { &m.template_vars_json },
            |m: &mut CMarketingMessageProto| { &mut m.template_vars_json },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "additional_restrictions_json",
            |m: &CMarketingMessageProto| { &m.additional_restrictions_json },
            |m: &mut CMarketingMessageProto| { &mut m.additional_restrictions_json },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessageProto>(
            "CMarketingMessageProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessageProto {
    const NAME: &'static str = "CMarketingMessageProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.visibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.priority = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.association_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.associated_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.associated_name = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.start_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.end_date = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.country_allow = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.country_deny = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.ownership_restrictions_overridden = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.must_own_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.must_not_own_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.must_own_packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.must_not_own_packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.must_have_launched_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                154 => {
                    self.additional_restrictions = ::std::option::Option::Some(is.read_string()?);
                },
                162 => {
                    self.template_type = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.template_vars = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                186 => {
                    self.creator_name = ::std::option::Option::Some(is.read_string()?);
                },
                194 => {
                    self.template_vars_json = ::std::option::Option::Some(is.read_string()?);
                },
                202 => {
                    self.additional_restrictions_json = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.visibility {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.priority {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.association_type {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.associated_id {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.associated_name.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.start_date {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.end_date {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.country_allow.as_ref() {
            my_size += crate::rt::string_size(11, &v);
        }
        if let Some(v) = self.country_deny.as_ref() {
            my_size += crate::rt::string_size(12, &v);
        }
        if let Some(v) = self.ownership_restrictions_overridden {
            my_size += 1 + 1;
        }
        if let Some(v) = self.must_own_appid {
            my_size += crate::rt::uint32_size(14, v);
        }
        if let Some(v) = self.must_not_own_appid {
            my_size += crate::rt::uint32_size(15, v);
        }
        if let Some(v) = self.must_own_packageid {
            my_size += crate::rt::uint32_size(16, v);
        }
        if let Some(v) = self.must_not_own_packageid {
            my_size += crate::rt::uint32_size(17, v);
        }
        if let Some(v) = self.must_have_launched_appid {
            my_size += crate::rt::uint32_size(18, v);
        }
        if let Some(v) = self.additional_restrictions.as_ref() {
            my_size += crate::rt::string_size(19, &v);
        }
        if let Some(v) = self.template_type.as_ref() {
            my_size += crate::rt::string_size(20, &v);
        }
        if let Some(v) = self.template_vars.as_ref() {
            my_size += crate::rt::string_size(21, &v);
        }
        if let Some(v) = self.flags {
            my_size += crate::rt::uint32_size(22, v);
        }
        if let Some(v) = self.creator_name.as_ref() {
            my_size += crate::rt::string_size(23, &v);
        }
        if let Some(v) = self.template_vars_json.as_ref() {
            my_size += crate::rt::string_size(24, &v);
        }
        if let Some(v) = self.additional_restrictions_json.as_ref() {
            my_size += crate::rt::string_size(25, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.visibility {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.priority {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.association_type {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.associated_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.associated_name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.start_date {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.end_date {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.country_allow.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.country_deny.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.ownership_restrictions_overridden {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.must_own_appid {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.must_not_own_appid {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.must_own_packageid {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.must_not_own_packageid {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.must_have_launched_appid {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.additional_restrictions.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.template_type.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.template_vars.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.creator_name.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.template_vars_json.as_ref() {
            os.write_string(24, v)?;
        }
        if let Some(v) = self.additional_restrictions_json.as_ref() {
            os.write_string(25, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessageProto {
        CMarketingMessageProto::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.priority = ::std::option::Option::None;
        self.association_type = ::std::option::Option::None;
        self.associated_id = ::std::option::Option::None;
        self.associated_name = ::std::option::Option::None;
        self.start_date = ::std::option::Option::None;
        self.end_date = ::std::option::Option::None;
        self.country_allow = ::std::option::Option::None;
        self.country_deny = ::std::option::Option::None;
        self.ownership_restrictions_overridden = ::std::option::Option::None;
        self.must_own_appid = ::std::option::Option::None;
        self.must_not_own_appid = ::std::option::Option::None;
        self.must_own_packageid = ::std::option::Option::None;
        self.must_not_own_packageid = ::std::option::Option::None;
        self.must_have_launched_appid = ::std::option::Option::None;
        self.additional_restrictions = ::std::option::Option::None;
        self.template_type = ::std::option::Option::None;
        self.template_vars = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.creator_name = ::std::option::Option::None;
        self.template_vars_json = ::std::option::Option::None;
        self.additional_restrictions_json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessageProto {
        static instance: CMarketingMessageProto = CMarketingMessageProto {
            gid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            priority: ::std::option::Option::None,
            association_type: ::std::option::Option::None,
            associated_id: ::std::option::Option::None,
            associated_name: ::std::option::Option::None,
            start_date: ::std::option::Option::None,
            end_date: ::std::option::Option::None,
            country_allow: ::std::option::Option::None,
            country_deny: ::std::option::Option::None,
            ownership_restrictions_overridden: ::std::option::Option::None,
            must_own_appid: ::std::option::Option::None,
            must_not_own_appid: ::std::option::Option::None,
            must_own_packageid: ::std::option::Option::None,
            must_not_own_packageid: ::std::option::Option::None,
            must_have_launched_appid: ::std::option::Option::None,
            additional_restrictions: ::std::option::Option::None,
            template_type: ::std::option::Option::None,
            template_vars: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            creator_name: ::std::option::Option::None,
            template_vars_json: ::std::option::Option::None,
            additional_restrictions_json: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessageProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessageProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessageProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessageProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetActiveMarketingMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetActiveMarketingMessages_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetActiveMarketingMessages_Response.messages)
    pub messages: ::std::vec::Vec<CMarketingMessageProto>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetActiveMarketingMessages_Response.time_next_message_age)
    pub time_next_message_age: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetActiveMarketingMessages_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetActiveMarketingMessages_Response {
    fn default() -> &'a CMarketingMessages_GetActiveMarketingMessages_Response {
        <CMarketingMessages_GetActiveMarketingMessages_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetActiveMarketingMessages_Response {
    pub fn new() -> CMarketingMessages_GetActiveMarketingMessages_Response {
        ::std::default::Default::default()
    }

    // repeated .CMarketingMessageProto messages = 1;

    pub fn messages(&self) -> &[CMarketingMessageProto] {
        &self.messages
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<CMarketingMessageProto>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<CMarketingMessageProto> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<CMarketingMessageProto> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    // optional uint32 time_next_message_age = 2;

    pub fn time_next_message_age(&self) -> u32 {
        self.time_next_message_age.unwrap_or(0)
    }

    pub fn clear_time_next_message_age(&mut self) {
        self.time_next_message_age = ::std::option::Option::None;
    }

    pub fn has_time_next_message_age(&self) -> bool {
        self.time_next_message_age.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_next_message_age(&mut self, v: u32) {
        self.time_next_message_age = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CMarketingMessages_GetActiveMarketingMessages_Response| { &m.messages },
            |m: &mut CMarketingMessages_GetActiveMarketingMessages_Response| { &mut m.messages },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_next_message_age",
            |m: &CMarketingMessages_GetActiveMarketingMessages_Response| { &m.time_next_message_age },
            |m: &mut CMarketingMessages_GetActiveMarketingMessages_Response| { &mut m.time_next_message_age },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetActiveMarketingMessages_Response>(
            "CMarketingMessages_GetActiveMarketingMessages_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetActiveMarketingMessages_Response {
    const NAME: &'static str = "CMarketingMessages_GetActiveMarketingMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                16 => {
                    self.time_next_message_age = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.time_next_message_age {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.messages {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.time_next_message_age {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetActiveMarketingMessages_Response {
        CMarketingMessages_GetActiveMarketingMessages_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.time_next_message_age = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetActiveMarketingMessages_Response {
        static instance: CMarketingMessages_GetActiveMarketingMessages_Response = CMarketingMessages_GetActiveMarketingMessages_Response {
            messages: ::std::vec::Vec::new(),
            time_next_message_age: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetActiveMarketingMessages_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetActiveMarketingMessages_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetActiveMarketingMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetActiveMarketingMessages_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessagesForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.include_seen_messages)
    pub include_seen_messages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.elanguage)
    pub elanguage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.operating_system)
    pub operating_system: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.client_package_version)
    pub client_package_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.context)
    pub context: crate::MessageField<super::steammessages_storebrowse_steamclient::StoreBrowseContext>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Request.data_request)
    pub data_request: crate::MessageField<super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesForUser_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessagesForUser_Request {
    fn default() -> &'a CMarketingMessages_GetMarketingMessagesForUser_Request {
        <CMarketingMessages_GetMarketingMessagesForUser_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessagesForUser_Request {
    pub fn new() -> CMarketingMessages_GetMarketingMessagesForUser_Request {
        ::std::default::Default::default()
    }

    // optional bool include_seen_messages = 1;

    pub fn include_seen_messages(&self) -> bool {
        self.include_seen_messages.unwrap_or(false)
    }

    pub fn clear_include_seen_messages(&mut self) {
        self.include_seen_messages = ::std::option::Option::None;
    }

    pub fn has_include_seen_messages(&self) -> bool {
        self.include_seen_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_seen_messages(&mut self, v: bool) {
        self.include_seen_messages = ::std::option::Option::Some(v);
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 elanguage = 3;

    pub fn elanguage(&self) -> i32 {
        self.elanguage.unwrap_or(0)
    }

    pub fn clear_elanguage(&mut self) {
        self.elanguage = ::std::option::Option::None;
    }

    pub fn has_elanguage(&self) -> bool {
        self.elanguage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elanguage(&mut self, v: i32) {
        self.elanguage = ::std::option::Option::Some(v);
    }

    // optional int32 operating_system = 4;

    pub fn operating_system(&self) -> i32 {
        self.operating_system.unwrap_or(0)
    }

    pub fn clear_operating_system(&mut self) {
        self.operating_system = ::std::option::Option::None;
    }

    pub fn has_operating_system(&self) -> bool {
        self.operating_system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operating_system(&mut self, v: i32) {
        self.operating_system = ::std::option::Option::Some(v);
    }

    // optional int32 client_package_version = 5;

    pub fn client_package_version(&self) -> i32 {
        self.client_package_version.unwrap_or(0)
    }

    pub fn clear_client_package_version(&mut self) {
        self.client_package_version = ::std::option::Option::None;
    }

    pub fn has_client_package_version(&self) -> bool {
        self.client_package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_package_version(&mut self, v: i32) {
        self.client_package_version = ::std::option::Option::Some(v);
    }

    // optional .StoreBrowseContext context = 6;

    pub fn context(&self) -> &super::steammessages_storebrowse_steamclient::StoreBrowseContext {
        self.context.as_ref().unwrap_or_else(|| <super::steammessages_storebrowse_steamclient::StoreBrowseContext as crate::Message>::default_instance())
    }

    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: super::steammessages_storebrowse_steamclient::StoreBrowseContext) {
        self.context = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut super::steammessages_storebrowse_steamclient::StoreBrowseContext {
        self.context.mut_or_insert_default()
    }

    // Take field
    pub fn take_context(&mut self) -> super::steammessages_storebrowse_steamclient::StoreBrowseContext {
        self.context.take().unwrap_or_else(|| super::steammessages_storebrowse_steamclient::StoreBrowseContext::new())
    }

    // optional .StoreBrowseItemDataRequest data_request = 7;

    pub fn data_request(&self) -> &super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest {
        self.data_request.as_ref().unwrap_or_else(|| <super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest as crate::Message>::default_instance())
    }

    pub fn clear_data_request(&mut self) {
        self.data_request.clear();
    }

    pub fn has_data_request(&self) -> bool {
        self.data_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_request(&mut self, v: super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest) {
        self.data_request = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_request(&mut self) -> &mut super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest {
        self.data_request.mut_or_insert_default()
    }

    // Take field
    pub fn take_data_request(&mut self) -> super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest {
        self.data_request.take().unwrap_or_else(|| super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_seen_messages",
            |m: &CMarketingMessages_GetMarketingMessagesForUser_Request| { &m.include_seen_messages },
            |m: &mut CMarketingMessages_GetMarketingMessagesForUser_Request| { &mut m.include_seen_messages },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CMarketingMessages_GetMarketingMessagesForUser_Request| { &m.country_code },
            |m: &mut CMarketingMessages_GetMarketingMessagesForUser_Request| { &mut m.country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "elanguage",
            |m: &CMarketingMessages_GetMarketingMessagesForUser_Request| { &m.elanguage },
            |m: &mut CMarketingMessages_GetMarketingMessagesForUser_Request| { &mut m.elanguage },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "operating_system",
            |m: &CMarketingMessages_GetMarketingMessagesForUser_Request| { &m.operating_system },
            |m: &mut CMarketingMessages_GetMarketingMessagesForUser_Request| { &mut m.operating_system },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_package_version",
            |m: &CMarketingMessages_GetMarketingMessagesForUser_Request| { &m.client_package_version },
            |m: &mut CMarketingMessages_GetMarketingMessagesForUser_Request| { &mut m.client_package_version },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_storebrowse_steamclient::StoreBrowseContext>(
            "context",
            |m: &CMarketingMessages_GetMarketingMessagesForUser_Request| { &m.context },
            |m: &mut CMarketingMessages_GetMarketingMessagesForUser_Request| { &mut m.context },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest>(
            "data_request",
            |m: &CMarketingMessages_GetMarketingMessagesForUser_Request| { &m.data_request },
            |m: &mut CMarketingMessages_GetMarketingMessagesForUser_Request| { &mut m.data_request },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetMarketingMessagesForUser_Request>(
            "CMarketingMessages_GetMarketingMessagesForUser_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetMarketingMessagesForUser_Request {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessagesForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.include_seen_messages = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.operating_system = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.client_package_version = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                58 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.data_request)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.include_seen_messages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.elanguage {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.operating_system {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.client_package_version {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.include_seen_messages {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.elanguage {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.operating_system {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.client_package_version {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.context.as_ref() {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.data_request.as_ref() {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessagesForUser_Request {
        CMarketingMessages_GetMarketingMessagesForUser_Request::new()
    }

    fn clear(&mut self) {
        self.include_seen_messages = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.elanguage = ::std::option::Option::None;
        self.operating_system = ::std::option::Option::None;
        self.client_package_version = ::std::option::Option::None;
        self.context.clear();
        self.data_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessagesForUser_Request {
        static instance: CMarketingMessages_GetMarketingMessagesForUser_Request = CMarketingMessages_GetMarketingMessagesForUser_Request {
            include_seen_messages: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            elanguage: ::std::option::Option::None,
            operating_system: ::std::option::Option::None,
            client_package_version: ::std::option::Option::None,
            context: crate::MessageField::none(),
            data_request: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetMarketingMessagesForUser_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetMarketingMessagesForUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetMarketingMessagesForUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetMarketingMessagesForUser_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDisplayMarketingMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDisplayMarketingMessage {
    // message fields
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<EMarketingMessageType>>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.associated_item_id)
    pub associated_item_id: crate::MessageField<super::steammessages_storebrowse_steamclient::StoreItemID>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.associated_item)
    pub associated_item: crate::MessageField<super::steammessages_storebrowse_steamclient::StoreItem>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.associated_name)
    pub associated_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.template_type)
    pub template_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDisplayMarketingMessage.template_vars_json)
    pub template_vars_json: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CDisplayMarketingMessage.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDisplayMarketingMessage {
    fn default() -> &'a CDisplayMarketingMessage {
        <CDisplayMarketingMessage as crate::Message>::default_instance()
    }
}

impl CDisplayMarketingMessage {
    pub fn new() -> CDisplayMarketingMessage {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EMarketingMessageType type = 3;

    pub fn type_(&self) -> EMarketingMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(EMarketingMessageType::k_EMarketingMessageInvalid),
            None => EMarketingMessageType::k_EMarketingMessageInvalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EMarketingMessageType) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .StoreItemID associated_item_id = 4;

    pub fn associated_item_id(&self) -> &super::steammessages_storebrowse_steamclient::StoreItemID {
        self.associated_item_id.as_ref().unwrap_or_else(|| <super::steammessages_storebrowse_steamclient::StoreItemID as crate::Message>::default_instance())
    }

    pub fn clear_associated_item_id(&mut self) {
        self.associated_item_id.clear();
    }

    pub fn has_associated_item_id(&self) -> bool {
        self.associated_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_item_id(&mut self, v: super::steammessages_storebrowse_steamclient::StoreItemID) {
        self.associated_item_id = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_associated_item_id(&mut self) -> &mut super::steammessages_storebrowse_steamclient::StoreItemID {
        self.associated_item_id.mut_or_insert_default()
    }

    // Take field
    pub fn take_associated_item_id(&mut self) -> super::steammessages_storebrowse_steamclient::StoreItemID {
        self.associated_item_id.take().unwrap_or_else(|| super::steammessages_storebrowse_steamclient::StoreItemID::new())
    }

    // optional .StoreItem associated_item = 5;

    pub fn associated_item(&self) -> &super::steammessages_storebrowse_steamclient::StoreItem {
        self.associated_item.as_ref().unwrap_or_else(|| <super::steammessages_storebrowse_steamclient::StoreItem as crate::Message>::default_instance())
    }

    pub fn clear_associated_item(&mut self) {
        self.associated_item.clear();
    }

    pub fn has_associated_item(&self) -> bool {
        self.associated_item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_item(&mut self, v: super::steammessages_storebrowse_steamclient::StoreItem) {
        self.associated_item = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_associated_item(&mut self) -> &mut super::steammessages_storebrowse_steamclient::StoreItem {
        self.associated_item.mut_or_insert_default()
    }

    // Take field
    pub fn take_associated_item(&mut self) -> super::steammessages_storebrowse_steamclient::StoreItem {
        self.associated_item.take().unwrap_or_else(|| super::steammessages_storebrowse_steamclient::StoreItem::new())
    }

    // optional string associated_name = 6;

    pub fn associated_name(&self) -> &str {
        match self.associated_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_associated_name(&mut self) {
        self.associated_name = ::std::option::Option::None;
    }

    pub fn has_associated_name(&self) -> bool {
        self.associated_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_name(&mut self, v: ::std::string::String) {
        self.associated_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_associated_name(&mut self) -> &mut ::std::string::String {
        if self.associated_name.is_none() {
            self.associated_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.associated_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_associated_name(&mut self) -> ::std::string::String {
        self.associated_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_type = 10;

    pub fn template_type(&self) -> &str {
        match self.template_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: ::std::string::String) {
        self.template_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_type(&mut self) -> &mut ::std::string::String {
        if self.template_type.is_none() {
            self.template_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_type(&mut self) -> ::std::string::String {
        self.template_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string template_vars_json = 11;

    pub fn template_vars_json(&self) -> &str {
        match self.template_vars_json.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_template_vars_json(&mut self) {
        self.template_vars_json = ::std::option::Option::None;
    }

    pub fn has_template_vars_json(&self) -> bool {
        self.template_vars_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_vars_json(&mut self, v: ::std::string::String) {
        self.template_vars_json = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template_vars_json(&mut self) -> &mut ::std::string::String {
        if self.template_vars_json.is_none() {
            self.template_vars_json = ::std::option::Option::Some(::std::string::String::new());
        }
        self.template_vars_json.as_mut().unwrap()
    }

    // Take field
    pub fn take_template_vars_json(&mut self) -> ::std::string::String {
        self.template_vars_json.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CDisplayMarketingMessage| { &m.gid },
            |m: &mut CDisplayMarketingMessage| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CDisplayMarketingMessage| { &m.title },
            |m: &mut CDisplayMarketingMessage| { &mut m.title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CDisplayMarketingMessage| { &m.type_ },
            |m: &mut CDisplayMarketingMessage| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_storebrowse_steamclient::StoreItemID>(
            "associated_item_id",
            |m: &CDisplayMarketingMessage| { &m.associated_item_id },
            |m: &mut CDisplayMarketingMessage| { &mut m.associated_item_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_storebrowse_steamclient::StoreItem>(
            "associated_item",
            |m: &CDisplayMarketingMessage| { &m.associated_item },
            |m: &mut CDisplayMarketingMessage| { &mut m.associated_item },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "associated_name",
            |m: &CDisplayMarketingMessage| { &m.associated_name },
            |m: &mut CDisplayMarketingMessage| { &mut m.associated_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "template_type",
            |m: &CDisplayMarketingMessage| { &m.template_type },
            |m: &mut CDisplayMarketingMessage| { &mut m.template_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "template_vars_json",
            |m: &CDisplayMarketingMessage| { &m.template_vars_json },
            |m: &mut CDisplayMarketingMessage| { &mut m.template_vars_json },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CDisplayMarketingMessage>(
            "CDisplayMarketingMessage",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CDisplayMarketingMessage {
    const NAME: &'static str = "CDisplayMarketingMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.associated_item_id)?;
                },
                42 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.associated_item)?;
                },
                50 => {
                    self.associated_name = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.template_type = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.template_vars_json = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.associated_item_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.associated_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.associated_name.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.template_type.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        if let Some(v) = self.template_vars_json.as_ref() {
            my_size += crate::rt::string_size(11, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.associated_item_id.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.associated_item.as_ref() {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.associated_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.template_type.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.template_vars_json.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDisplayMarketingMessage {
        CDisplayMarketingMessage::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.associated_item_id.clear();
        self.associated_item.clear();
        self.associated_name = ::std::option::Option::None;
        self.template_type = ::std::option::Option::None;
        self.template_vars_json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDisplayMarketingMessage {
        static instance: CDisplayMarketingMessage = CDisplayMarketingMessage {
            gid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            associated_item_id: crate::MessageField::none(),
            associated_item: crate::MessageField::none(),
            associated_name: ::std::option::Option::None,
            template_type: ::std::option::Option::None,
            template_vars_json: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CDisplayMarketingMessage {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDisplayMarketingMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDisplayMarketingMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CDisplayMarketingMessage {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessagesForUser_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Response.messages)
    pub messages: ::std::vec::Vec<cmarketing_messages_get_marketing_messages_for_user_response::MarketingMessageForUser>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesForUser_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessagesForUser_Response {
    fn default() -> &'a CMarketingMessages_GetMarketingMessagesForUser_Response {
        <CMarketingMessages_GetMarketingMessagesForUser_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessagesForUser_Response {
    pub fn new() -> CMarketingMessages_GetMarketingMessagesForUser_Response {
        ::std::default::Default::default()
    }

    // repeated .CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser messages = 1;

    pub fn messages(&self) -> &[cmarketing_messages_get_marketing_messages_for_user_response::MarketingMessageForUser] {
        &self.messages
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<cmarketing_messages_get_marketing_messages_for_user_response::MarketingMessageForUser>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<cmarketing_messages_get_marketing_messages_for_user_response::MarketingMessageForUser> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<cmarketing_messages_get_marketing_messages_for_user_response::MarketingMessageForUser> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CMarketingMessages_GetMarketingMessagesForUser_Response| { &m.messages },
            |m: &mut CMarketingMessages_GetMarketingMessagesForUser_Response| { &mut m.messages },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetMarketingMessagesForUser_Response>(
            "CMarketingMessages_GetMarketingMessagesForUser_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetMarketingMessagesForUser_Response {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessagesForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.messages {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessagesForUser_Response {
        CMarketingMessages_GetMarketingMessagesForUser_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessagesForUser_Response {
        static instance: CMarketingMessages_GetMarketingMessagesForUser_Response = CMarketingMessages_GetMarketingMessagesForUser_Response {
            messages: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetMarketingMessagesForUser_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetMarketingMessagesForUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetMarketingMessagesForUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetMarketingMessagesForUser_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMarketingMessages_GetMarketingMessagesForUser_Response`
pub mod cmarketing_messages_get_marketing_messages_for_user_response {
    // @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MarketingMessageForUser {
        // message fields
        // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser.already_seen)
        pub already_seen: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser.message)
        pub message: crate::MessageField<super::CDisplayMarketingMessage>,
        // special fields
        // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MarketingMessageForUser {
        fn default() -> &'a MarketingMessageForUser {
            <MarketingMessageForUser as crate::Message>::default_instance()
        }
    }

    impl MarketingMessageForUser {
        pub fn new() -> MarketingMessageForUser {
            ::std::default::Default::default()
        }

        // optional bool already_seen = 1;

        pub fn already_seen(&self) -> bool {
            self.already_seen.unwrap_or(false)
        }

        pub fn clear_already_seen(&mut self) {
            self.already_seen = ::std::option::Option::None;
        }

        pub fn has_already_seen(&self) -> bool {
            self.already_seen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_already_seen(&mut self, v: bool) {
            self.already_seen = ::std::option::Option::Some(v);
        }

        // optional .CDisplayMarketingMessage message = 2;

        pub fn message(&self) -> &super::CDisplayMarketingMessage {
            self.message.as_ref().unwrap_or_else(|| <super::CDisplayMarketingMessage as crate::Message>::default_instance())
        }

        pub fn clear_message(&mut self) {
            self.message.clear();
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: super::CDisplayMarketingMessage) {
            self.message = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut super::CDisplayMarketingMessage {
            self.message.mut_or_insert_default()
        }

        // Take field
        pub fn take_message(&mut self) -> super::CDisplayMarketingMessage {
            self.message.take().unwrap_or_else(|| super::CDisplayMarketingMessage::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "already_seen",
                |m: &MarketingMessageForUser| { &m.already_seen },
                |m: &mut MarketingMessageForUser| { &mut m.already_seen },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::CDisplayMarketingMessage>(
                "message",
                |m: &MarketingMessageForUser| { &m.message },
                |m: &mut MarketingMessageForUser| { &mut m.message },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<MarketingMessageForUser>(
                "CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for MarketingMessageForUser {
        const NAME: &'static str = "MarketingMessageForUser";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.already_seen = ::std::option::Option::Some(is.read_bool()?);
                    },
                    18 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.message)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.already_seen {
                my_size += 1 + 1;
            }
            if let Some(v) = self.message.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.already_seen {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                crate::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MarketingMessageForUser {
            MarketingMessageForUser::new()
        }

        fn clear(&mut self) {
            self.already_seen = ::std::option::Option::None;
            self.message.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MarketingMessageForUser {
            static instance: MarketingMessageForUser = MarketingMessageForUser {
                already_seen: ::std::option::Option::None,
                message: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for MarketingMessageForUser {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMarketingMessages_GetMarketingMessagesForUser_Response.MarketingMessageForUser").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MarketingMessageForUser {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for MarketingMessageForUser {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.elanguage)
    pub elanguage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.operating_system)
    pub operating_system: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.client_package_version)
    pub client_package_version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    fn default() -> &'a CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
        <CMarketingMessages_DoesUserHavePendingMarketingMessages_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    pub fn new() -> CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
        ::std::default::Default::default()
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 elanguage = 3;

    pub fn elanguage(&self) -> i32 {
        self.elanguage.unwrap_or(0)
    }

    pub fn clear_elanguage(&mut self) {
        self.elanguage = ::std::option::Option::None;
    }

    pub fn has_elanguage(&self) -> bool {
        self.elanguage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elanguage(&mut self, v: i32) {
        self.elanguage = ::std::option::Option::Some(v);
    }

    // optional int32 operating_system = 4;

    pub fn operating_system(&self) -> i32 {
        self.operating_system.unwrap_or(0)
    }

    pub fn clear_operating_system(&mut self) {
        self.operating_system = ::std::option::Option::None;
    }

    pub fn has_operating_system(&self) -> bool {
        self.operating_system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operating_system(&mut self, v: i32) {
        self.operating_system = ::std::option::Option::Some(v);
    }

    // optional int32 client_package_version = 5;

    pub fn client_package_version(&self) -> i32 {
        self.client_package_version.unwrap_or(0)
    }

    pub fn clear_client_package_version(&mut self) {
        self.client_package_version = ::std::option::Option::None;
    }

    pub fn has_client_package_version(&self) -> bool {
        self.client_package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_package_version(&mut self, v: i32) {
        self.client_package_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &CMarketingMessages_DoesUserHavePendingMarketingMessages_Request| { &m.country_code },
            |m: &mut CMarketingMessages_DoesUserHavePendingMarketingMessages_Request| { &mut m.country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "elanguage",
            |m: &CMarketingMessages_DoesUserHavePendingMarketingMessages_Request| { &m.elanguage },
            |m: &mut CMarketingMessages_DoesUserHavePendingMarketingMessages_Request| { &mut m.elanguage },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "operating_system",
            |m: &CMarketingMessages_DoesUserHavePendingMarketingMessages_Request| { &m.operating_system },
            |m: &mut CMarketingMessages_DoesUserHavePendingMarketingMessages_Request| { &mut m.operating_system },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_package_version",
            |m: &CMarketingMessages_DoesUserHavePendingMarketingMessages_Request| { &m.client_package_version },
            |m: &mut CMarketingMessages_DoesUserHavePendingMarketingMessages_Request| { &mut m.client_package_version },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_DoesUserHavePendingMarketingMessages_Request>(
            "CMarketingMessages_DoesUserHavePendingMarketingMessages_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    const NAME: &'static str = "CMarketingMessages_DoesUserHavePendingMarketingMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.operating_system = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.client_package_version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country_code.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.elanguage {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.operating_system {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.client_package_version {
            my_size += crate::rt::int32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.elanguage {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.operating_system {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.client_package_version {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
        CMarketingMessages_DoesUserHavePendingMarketingMessages_Request::new()
    }

    fn clear(&mut self) {
        self.country_code = ::std::option::Option::None;
        self.elanguage = ::std::option::Option::None;
        self.operating_system = ::std::option::Option::None;
        self.client_package_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
        static instance: CMarketingMessages_DoesUserHavePendingMarketingMessages_Request = CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
            country_code: ::std::option::Option::None,
            elanguage: ::std::option::Option::None,
            operating_system: ::std::option::Option::None,
            client_package_version: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_DoesUserHavePendingMarketingMessages_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_DoesUserHavePendingMarketingMessages_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_DoesUserHavePendingMarketingMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Response.has_pending_messages)
    pub has_pending_messages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Response.pending_message_count)
    pub pending_message_count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_DoesUserHavePendingMarketingMessages_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    fn default() -> &'a CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
        <CMarketingMessages_DoesUserHavePendingMarketingMessages_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    pub fn new() -> CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
        ::std::default::Default::default()
    }

    // optional bool has_pending_messages = 1;

    pub fn has_pending_messages(&self) -> bool {
        self.has_pending_messages.unwrap_or(false)
    }

    pub fn clear_has_pending_messages(&mut self) {
        self.has_pending_messages = ::std::option::Option::None;
    }

    pub fn has_has_pending_messages(&self) -> bool {
        self.has_pending_messages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_pending_messages(&mut self, v: bool) {
        self.has_pending_messages = ::std::option::Option::Some(v);
    }

    // optional int32 pending_message_count = 2;

    pub fn pending_message_count(&self) -> i32 {
        self.pending_message_count.unwrap_or(0)
    }

    pub fn clear_pending_message_count(&mut self) {
        self.pending_message_count = ::std::option::Option::None;
    }

    pub fn has_pending_message_count(&self) -> bool {
        self.pending_message_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_message_count(&mut self, v: i32) {
        self.pending_message_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_pending_messages",
            |m: &CMarketingMessages_DoesUserHavePendingMarketingMessages_Response| { &m.has_pending_messages },
            |m: &mut CMarketingMessages_DoesUserHavePendingMarketingMessages_Response| { &mut m.has_pending_messages },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pending_message_count",
            |m: &CMarketingMessages_DoesUserHavePendingMarketingMessages_Response| { &m.pending_message_count },
            |m: &mut CMarketingMessages_DoesUserHavePendingMarketingMessages_Response| { &mut m.pending_message_count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_DoesUserHavePendingMarketingMessages_Response>(
            "CMarketingMessages_DoesUserHavePendingMarketingMessages_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    const NAME: &'static str = "CMarketingMessages_DoesUserHavePendingMarketingMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.has_pending_messages = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.pending_message_count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.has_pending_messages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pending_message_count {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.has_pending_messages {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.pending_message_count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
        CMarketingMessages_DoesUserHavePendingMarketingMessages_Response::new()
    }

    fn clear(&mut self) {
        self.has_pending_messages = ::std::option::Option::None;
        self.pending_message_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
        static instance: CMarketingMessages_DoesUserHavePendingMarketingMessages_Response = CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
            has_pending_messages: ::std::option::Option::None,
            pending_message_count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_DoesUserHavePendingMarketingMessages_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_DoesUserHavePendingMarketingMessages_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetDisplayMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetDisplayMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetDisplayMarketingMessage_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetDisplayMarketingMessage_Request.context)
    pub context: crate::MessageField<super::steammessages_storebrowse_steamclient::StoreBrowseContext>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetDisplayMarketingMessage_Request.data_request)
    pub data_request: crate::MessageField<super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetDisplayMarketingMessage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetDisplayMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_GetDisplayMarketingMessage_Request {
        <CMarketingMessages_GetDisplayMarketingMessage_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetDisplayMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_GetDisplayMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional .StoreBrowseContext context = 2;

    pub fn context(&self) -> &super::steammessages_storebrowse_steamclient::StoreBrowseContext {
        self.context.as_ref().unwrap_or_else(|| <super::steammessages_storebrowse_steamclient::StoreBrowseContext as crate::Message>::default_instance())
    }

    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: super::steammessages_storebrowse_steamclient::StoreBrowseContext) {
        self.context = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut super::steammessages_storebrowse_steamclient::StoreBrowseContext {
        self.context.mut_or_insert_default()
    }

    // Take field
    pub fn take_context(&mut self) -> super::steammessages_storebrowse_steamclient::StoreBrowseContext {
        self.context.take().unwrap_or_else(|| super::steammessages_storebrowse_steamclient::StoreBrowseContext::new())
    }

    // optional .StoreBrowseItemDataRequest data_request = 3;

    pub fn data_request(&self) -> &super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest {
        self.data_request.as_ref().unwrap_or_else(|| <super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest as crate::Message>::default_instance())
    }

    pub fn clear_data_request(&mut self) {
        self.data_request.clear();
    }

    pub fn has_data_request(&self) -> bool {
        self.data_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_request(&mut self, v: super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest) {
        self.data_request = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_request(&mut self) -> &mut super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest {
        self.data_request.mut_or_insert_default()
    }

    // Take field
    pub fn take_data_request(&mut self) -> super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest {
        self.data_request.take().unwrap_or_else(|| super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_GetDisplayMarketingMessage_Request| { &m.gid },
            |m: &mut CMarketingMessages_GetDisplayMarketingMessage_Request| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_storebrowse_steamclient::StoreBrowseContext>(
            "context",
            |m: &CMarketingMessages_GetDisplayMarketingMessage_Request| { &m.context },
            |m: &mut CMarketingMessages_GetDisplayMarketingMessage_Request| { &mut m.context },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::steammessages_storebrowse_steamclient::StoreBrowseItemDataRequest>(
            "data_request",
            |m: &CMarketingMessages_GetDisplayMarketingMessage_Request| { &m.data_request },
            |m: &mut CMarketingMessages_GetDisplayMarketingMessage_Request| { &mut m.data_request },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetDisplayMarketingMessage_Request>(
            "CMarketingMessages_GetDisplayMarketingMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetDisplayMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_GetDisplayMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.data_request)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.context.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.data_request.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetDisplayMarketingMessage_Request {
        CMarketingMessages_GetDisplayMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.context.clear();
        self.data_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetDisplayMarketingMessage_Request {
        static instance: CMarketingMessages_GetDisplayMarketingMessage_Request = CMarketingMessages_GetDisplayMarketingMessage_Request {
            gid: ::std::option::Option::None,
            context: crate::MessageField::none(),
            data_request: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetDisplayMarketingMessage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetDisplayMarketingMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetDisplayMarketingMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetDisplayMarketingMessage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetDisplayMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetDisplayMarketingMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetDisplayMarketingMessage_Response.message)
    pub message: crate::MessageField<CDisplayMarketingMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetDisplayMarketingMessage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetDisplayMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_GetDisplayMarketingMessage_Response {
        <CMarketingMessages_GetDisplayMarketingMessage_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetDisplayMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_GetDisplayMarketingMessage_Response {
        ::std::default::Default::default()
    }

    // optional .CDisplayMarketingMessage message = 1;

    pub fn message(&self) -> &CDisplayMarketingMessage {
        self.message.as_ref().unwrap_or_else(|| <CDisplayMarketingMessage as crate::Message>::default_instance())
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: CDisplayMarketingMessage) {
        self.message = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut CDisplayMarketingMessage {
        self.message.mut_or_insert_default()
    }

    // Take field
    pub fn take_message(&mut self) -> CDisplayMarketingMessage {
        self.message.take().unwrap_or_else(|| CDisplayMarketingMessage::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CDisplayMarketingMessage>(
            "message",
            |m: &CMarketingMessages_GetDisplayMarketingMessage_Response| { &m.message },
            |m: &mut CMarketingMessages_GetDisplayMarketingMessage_Response| { &mut m.message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetDisplayMarketingMessage_Response>(
            "CMarketingMessages_GetDisplayMarketingMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetDisplayMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_GetDisplayMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.message.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetDisplayMarketingMessage_Response {
        CMarketingMessages_GetDisplayMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetDisplayMarketingMessage_Response {
        static instance: CMarketingMessages_GetDisplayMarketingMessage_Response = CMarketingMessages_GetDisplayMarketingMessage_Response {
            message: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetDisplayMarketingMessage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetDisplayMarketingMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetDisplayMarketingMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetDisplayMarketingMessage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_MarkMessageSeen_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_MarkMessageSeen_Notification {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_MarkMessageSeen_Notification.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_MarkMessageSeen_Notification.display_index)
    pub display_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessages_MarkMessageSeen_Notification.template_type)
    pub template_type: ::std::option::Option<crate::EnumOrUnknown<EMarketingMessageTemplateType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_MarkMessageSeen_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_MarkMessageSeen_Notification {
    fn default() -> &'a CMarketingMessages_MarkMessageSeen_Notification {
        <CMarketingMessages_MarkMessageSeen_Notification as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_MarkMessageSeen_Notification {
    pub fn new() -> CMarketingMessages_MarkMessageSeen_Notification {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 display_index = 2;

    pub fn display_index(&self) -> u32 {
        self.display_index.unwrap_or(0u32)
    }

    pub fn clear_display_index(&mut self) {
        self.display_index = ::std::option::Option::None;
    }

    pub fn has_display_index(&self) -> bool {
        self.display_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_index(&mut self, v: u32) {
        self.display_index = ::std::option::Option::Some(v);
    }

    // optional .EMarketingMessageTemplateType template_type = 3;

    pub fn template_type(&self) -> EMarketingMessageTemplateType {
        match self.template_type {
            Some(e) => e.enum_value_or(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown),
            None => EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown,
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: EMarketingMessageTemplateType) {
        self.template_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_MarkMessageSeen_Notification| { &m.gid },
            |m: &mut CMarketingMessages_MarkMessageSeen_Notification| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_index",
            |m: &CMarketingMessages_MarkMessageSeen_Notification| { &m.display_index },
            |m: &mut CMarketingMessages_MarkMessageSeen_Notification| { &mut m.display_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "template_type",
            |m: &CMarketingMessages_MarkMessageSeen_Notification| { &m.template_type },
            |m: &mut CMarketingMessages_MarkMessageSeen_Notification| { &mut m.template_type },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_MarkMessageSeen_Notification>(
            "CMarketingMessages_MarkMessageSeen_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_MarkMessageSeen_Notification {
    const NAME: &'static str = "CMarketingMessages_MarkMessageSeen_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.display_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.template_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.display_index {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.template_type {
            my_size += crate::rt::int32_size(3, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.display_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.template_type {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_MarkMessageSeen_Notification {
        CMarketingMessages_MarkMessageSeen_Notification::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.display_index = ::std::option::Option::None;
        self.template_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_MarkMessageSeen_Notification {
        static instance: CMarketingMessages_MarkMessageSeen_Notification = CMarketingMessages_MarkMessageSeen_Notification {
            gid: ::std::option::Option::None,
            display_index: ::std::option::Option::None,
            template_type: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_MarkMessageSeen_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_MarkMessageSeen_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_MarkMessageSeen_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_MarkMessageSeen_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessage_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_GetMarketingMessage_Request {
        <CMarketingMessages_GetMarketingMessage_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_GetMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_GetMarketingMessage_Request| { &m.gid },
            |m: &mut CMarketingMessages_GetMarketingMessage_Request| { &mut m.gid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetMarketingMessage_Request>(
            "CMarketingMessages_GetMarketingMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessage_Request {
        CMarketingMessages_GetMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessage_Request {
        static instance: CMarketingMessages_GetMarketingMessage_Request = CMarketingMessages_GetMarketingMessage_Request {
            gid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetMarketingMessage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetMarketingMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetMarketingMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetMarketingMessage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessage_Response.message)
    pub message: crate::MessageField<CMarketingMessageProto>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_GetMarketingMessage_Response {
        <CMarketingMessages_GetMarketingMessage_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_GetMarketingMessage_Response {
        ::std::default::Default::default()
    }

    // optional .CMarketingMessageProto message = 1;

    pub fn message(&self) -> &CMarketingMessageProto {
        self.message.as_ref().unwrap_or_else(|| <CMarketingMessageProto as crate::Message>::default_instance())
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: CMarketingMessageProto) {
        self.message = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut CMarketingMessageProto {
        self.message.mut_or_insert_default()
    }

    // Take field
    pub fn take_message(&mut self) -> CMarketingMessageProto {
        self.message.take().unwrap_or_else(|| CMarketingMessageProto::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMarketingMessageProto>(
            "message",
            |m: &CMarketingMessages_GetMarketingMessage_Response| { &m.message },
            |m: &mut CMarketingMessages_GetMarketingMessage_Response| { &mut m.message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetMarketingMessage_Response>(
            "CMarketingMessages_GetMarketingMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.message.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessage_Response {
        CMarketingMessages_GetMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessage_Response {
        static instance: CMarketingMessages_GetMarketingMessage_Response = CMarketingMessages_GetMarketingMessage_Response {
            message: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetMarketingMessage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetMarketingMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetMarketingMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetMarketingMessage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_CreateMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_CreateMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_CreateMarketingMessage_Request.message)
    pub message: crate::MessageField<CMarketingMessageProto>,
    // @@protoc_insertion_point(field:CMarketingMessages_CreateMarketingMessage_Request.from_json)
    pub from_json: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_CreateMarketingMessage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_CreateMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_CreateMarketingMessage_Request {
        <CMarketingMessages_CreateMarketingMessage_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_CreateMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_CreateMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional .CMarketingMessageProto message = 1;

    pub fn message(&self) -> &CMarketingMessageProto {
        self.message.as_ref().unwrap_or_else(|| <CMarketingMessageProto as crate::Message>::default_instance())
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: CMarketingMessageProto) {
        self.message = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut CMarketingMessageProto {
        self.message.mut_or_insert_default()
    }

    // Take field
    pub fn take_message(&mut self) -> CMarketingMessageProto {
        self.message.take().unwrap_or_else(|| CMarketingMessageProto::new())
    }

    // optional bool from_json = 2;

    pub fn from_json(&self) -> bool {
        self.from_json.unwrap_or(false)
    }

    pub fn clear_from_json(&mut self) {
        self.from_json = ::std::option::Option::None;
    }

    pub fn has_from_json(&self) -> bool {
        self.from_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_json(&mut self, v: bool) {
        self.from_json = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMarketingMessageProto>(
            "message",
            |m: &CMarketingMessages_CreateMarketingMessage_Request| { &m.message },
            |m: &mut CMarketingMessages_CreateMarketingMessage_Request| { &mut m.message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_json",
            |m: &CMarketingMessages_CreateMarketingMessage_Request| { &m.from_json },
            |m: &mut CMarketingMessages_CreateMarketingMessage_Request| { &mut m.from_json },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_CreateMarketingMessage_Request>(
            "CMarketingMessages_CreateMarketingMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_CreateMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_CreateMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                16 => {
                    self.from_json = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.from_json {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.message.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.from_json {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_CreateMarketingMessage_Request {
        CMarketingMessages_CreateMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.from_json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_CreateMarketingMessage_Request {
        static instance: CMarketingMessages_CreateMarketingMessage_Request = CMarketingMessages_CreateMarketingMessage_Request {
            message: crate::MessageField::none(),
            from_json: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_CreateMarketingMessage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_CreateMarketingMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_CreateMarketingMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_CreateMarketingMessage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_CreateMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_CreateMarketingMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_CreateMarketingMessage_Response.gid)
    pub gid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_CreateMarketingMessage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_CreateMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_CreateMarketingMessage_Response {
        <CMarketingMessages_CreateMarketingMessage_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_CreateMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_CreateMarketingMessage_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_CreateMarketingMessage_Response| { &m.gid },
            |m: &mut CMarketingMessages_CreateMarketingMessage_Response| { &mut m.gid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_CreateMarketingMessage_Response>(
            "CMarketingMessages_CreateMarketingMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_CreateMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_CreateMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_CreateMarketingMessage_Response {
        CMarketingMessages_CreateMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_CreateMarketingMessage_Response {
        static instance: CMarketingMessages_CreateMarketingMessage_Response = CMarketingMessages_CreateMarketingMessage_Response {
            gid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_CreateMarketingMessage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_CreateMarketingMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_CreateMarketingMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_CreateMarketingMessage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_UpdateMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_UpdateMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_UpdateMarketingMessage_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_UpdateMarketingMessage_Request.message)
    pub message: crate::MessageField<CMarketingMessageProto>,
    // @@protoc_insertion_point(field:CMarketingMessages_UpdateMarketingMessage_Request.from_json)
    pub from_json: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_UpdateMarketingMessage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_UpdateMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_UpdateMarketingMessage_Request {
        <CMarketingMessages_UpdateMarketingMessage_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_UpdateMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_UpdateMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional .CMarketingMessageProto message = 2;

    pub fn message(&self) -> &CMarketingMessageProto {
        self.message.as_ref().unwrap_or_else(|| <CMarketingMessageProto as crate::Message>::default_instance())
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: CMarketingMessageProto) {
        self.message = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut CMarketingMessageProto {
        self.message.mut_or_insert_default()
    }

    // Take field
    pub fn take_message(&mut self) -> CMarketingMessageProto {
        self.message.take().unwrap_or_else(|| CMarketingMessageProto::new())
    }

    // optional bool from_json = 3;

    pub fn from_json(&self) -> bool {
        self.from_json.unwrap_or(false)
    }

    pub fn clear_from_json(&mut self) {
        self.from_json = ::std::option::Option::None;
    }

    pub fn has_from_json(&self) -> bool {
        self.from_json.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_json(&mut self, v: bool) {
        self.from_json = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_UpdateMarketingMessage_Request| { &m.gid },
            |m: &mut CMarketingMessages_UpdateMarketingMessage_Request| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMarketingMessageProto>(
            "message",
            |m: &CMarketingMessages_UpdateMarketingMessage_Request| { &m.message },
            |m: &mut CMarketingMessages_UpdateMarketingMessage_Request| { &mut m.message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_json",
            |m: &CMarketingMessages_UpdateMarketingMessage_Request| { &m.from_json },
            |m: &mut CMarketingMessages_UpdateMarketingMessage_Request| { &mut m.from_json },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_UpdateMarketingMessage_Request>(
            "CMarketingMessages_UpdateMarketingMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_UpdateMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_UpdateMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                24 => {
                    self.from_json = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.from_json {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.from_json {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_UpdateMarketingMessage_Request {
        CMarketingMessages_UpdateMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.message.clear();
        self.from_json = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_UpdateMarketingMessage_Request {
        static instance: CMarketingMessages_UpdateMarketingMessage_Request = CMarketingMessages_UpdateMarketingMessage_Request {
            gid: ::std::option::Option::None,
            message: crate::MessageField::none(),
            from_json: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_UpdateMarketingMessage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_UpdateMarketingMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_UpdateMarketingMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_UpdateMarketingMessage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_UpdateMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_UpdateMarketingMessage_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_UpdateMarketingMessage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_UpdateMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_UpdateMarketingMessage_Response {
        <CMarketingMessages_UpdateMarketingMessage_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_UpdateMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_UpdateMarketingMessage_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_UpdateMarketingMessage_Response>(
            "CMarketingMessages_UpdateMarketingMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_UpdateMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_UpdateMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_UpdateMarketingMessage_Response {
        CMarketingMessages_UpdateMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_UpdateMarketingMessage_Response {
        static instance: CMarketingMessages_UpdateMarketingMessage_Response = CMarketingMessages_UpdateMarketingMessage_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_UpdateMarketingMessage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_UpdateMarketingMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_UpdateMarketingMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_UpdateMarketingMessage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_DeleteMarketingMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_DeleteMarketingMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_DeleteMarketingMessage_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_DeleteMarketingMessage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_DeleteMarketingMessage_Request {
    fn default() -> &'a CMarketingMessages_DeleteMarketingMessage_Request {
        <CMarketingMessages_DeleteMarketingMessage_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_DeleteMarketingMessage_Request {
    pub fn new() -> CMarketingMessages_DeleteMarketingMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_DeleteMarketingMessage_Request| { &m.gid },
            |m: &mut CMarketingMessages_DeleteMarketingMessage_Request| { &mut m.gid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_DeleteMarketingMessage_Request>(
            "CMarketingMessages_DeleteMarketingMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_DeleteMarketingMessage_Request {
    const NAME: &'static str = "CMarketingMessages_DeleteMarketingMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_DeleteMarketingMessage_Request {
        CMarketingMessages_DeleteMarketingMessage_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_DeleteMarketingMessage_Request {
        static instance: CMarketingMessages_DeleteMarketingMessage_Request = CMarketingMessages_DeleteMarketingMessage_Request {
            gid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_DeleteMarketingMessage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_DeleteMarketingMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_DeleteMarketingMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_DeleteMarketingMessage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_DeleteMarketingMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_DeleteMarketingMessage_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_DeleteMarketingMessage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_DeleteMarketingMessage_Response {
    fn default() -> &'a CMarketingMessages_DeleteMarketingMessage_Response {
        <CMarketingMessages_DeleteMarketingMessage_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_DeleteMarketingMessage_Response {
    pub fn new() -> CMarketingMessages_DeleteMarketingMessage_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_DeleteMarketingMessage_Response>(
            "CMarketingMessages_DeleteMarketingMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_DeleteMarketingMessage_Response {
    const NAME: &'static str = "CMarketingMessages_DeleteMarketingMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_DeleteMarketingMessage_Response {
        CMarketingMessages_DeleteMarketingMessage_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_DeleteMarketingMessage_Response {
        static instance: CMarketingMessages_DeleteMarketingMessage_Response = CMarketingMessages_DeleteMarketingMessage_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_DeleteMarketingMessage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_DeleteMarketingMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_DeleteMarketingMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_DeleteMarketingMessage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_FindMarketingMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_FindMarketingMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.lookup_type)
    pub lookup_type: ::std::option::Option<crate::EnumOrUnknown<EMarketingMessageLookupType>>,
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.message_type)
    pub message_type: ::std::option::Option<crate::EnumOrUnknown<EMarketingMessageType>>,
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.gidlist)
    pub gidlist: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Request.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_FindMarketingMessages_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_FindMarketingMessages_Request {
    fn default() -> &'a CMarketingMessages_FindMarketingMessages_Request {
        <CMarketingMessages_FindMarketingMessages_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_FindMarketingMessages_Request {
    pub fn new() -> CMarketingMessages_FindMarketingMessages_Request {
        ::std::default::Default::default()
    }

    // optional .EMarketingMessageLookupType lookup_type = 1;

    pub fn lookup_type(&self) -> EMarketingMessageLookupType {
        match self.lookup_type {
            Some(e) => e.enum_value_or(EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid),
            None => EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid,
        }
    }

    pub fn clear_lookup_type(&mut self) {
        self.lookup_type = ::std::option::Option::None;
    }

    pub fn has_lookup_type(&self) -> bool {
        self.lookup_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lookup_type(&mut self, v: EMarketingMessageLookupType) {
        self.lookup_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional fixed64 gid = 2;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional .EMarketingMessageType message_type = 3;

    pub fn message_type(&self) -> EMarketingMessageType {
        match self.message_type {
            Some(e) => e.enum_value_or(EMarketingMessageType::k_EMarketingMessageInvalid),
            None => EMarketingMessageType::k_EMarketingMessageInvalid,
        }
    }

    pub fn clear_message_type(&mut self) {
        self.message_type = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        self.message_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: EMarketingMessageType) {
        self.message_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // repeated fixed64 gidlist = 4;

    pub fn gidlist(&self) -> &[u64] {
        &self.gidlist
    }

    pub fn clear_gidlist(&mut self) {
        self.gidlist.clear();
    }

    // Param is passed by value, moved
    pub fn set_gidlist(&mut self, v: ::std::vec::Vec<u64>) {
        self.gidlist = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gidlist(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.gidlist
    }

    // Take field
    pub fn take_gidlist(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.gidlist, ::std::vec::Vec::new())
    }

    // optional string title = 5;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lookup_type",
            |m: &CMarketingMessages_FindMarketingMessages_Request| { &m.lookup_type },
            |m: &mut CMarketingMessages_FindMarketingMessages_Request| { &mut m.lookup_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_FindMarketingMessages_Request| { &m.gid },
            |m: &mut CMarketingMessages_FindMarketingMessages_Request| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_type",
            |m: &CMarketingMessages_FindMarketingMessages_Request| { &m.message_type },
            |m: &mut CMarketingMessages_FindMarketingMessages_Request| { &mut m.message_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gidlist",
            |m: &CMarketingMessages_FindMarketingMessages_Request| { &m.gidlist },
            |m: &mut CMarketingMessages_FindMarketingMessages_Request| { &mut m.gidlist },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CMarketingMessages_FindMarketingMessages_Request| { &m.title },
            |m: &mut CMarketingMessages_FindMarketingMessages_Request| { &mut m.title },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_FindMarketingMessages_Request>(
            "CMarketingMessages_FindMarketingMessages_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_FindMarketingMessages_Request {
    const NAME: &'static str = "CMarketingMessages_FindMarketingMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lookup_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.message_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.gidlist)?;
                },
                33 => {
                    self.gidlist.push(is.read_fixed64()?);
                },
                42 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lookup_type {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.message_type {
            my_size += crate::rt::int32_size(3, v.value());
        }
        my_size += 9 * self.gidlist.len() as u64;
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.lookup_type {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.message_type {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        for v in &self.gidlist {
            os.write_fixed64(4, *v)?;
        };
        if let Some(v) = self.title.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_FindMarketingMessages_Request {
        CMarketingMessages_FindMarketingMessages_Request::new()
    }

    fn clear(&mut self) {
        self.lookup_type = ::std::option::Option::None;
        self.gid = ::std::option::Option::None;
        self.message_type = ::std::option::Option::None;
        self.gidlist.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_FindMarketingMessages_Request {
        static instance: CMarketingMessages_FindMarketingMessages_Request = CMarketingMessages_FindMarketingMessages_Request {
            lookup_type: ::std::option::Option::None,
            gid: ::std::option::Option::None,
            message_type: ::std::option::Option::None,
            gidlist: ::std::vec::Vec::new(),
            title: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_FindMarketingMessages_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_FindMarketingMessages_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_FindMarketingMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_FindMarketingMessages_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_FindMarketingMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_FindMarketingMessages_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_FindMarketingMessages_Response.messages)
    pub messages: ::std::vec::Vec<CMarketingMessageProto>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_FindMarketingMessages_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_FindMarketingMessages_Response {
    fn default() -> &'a CMarketingMessages_FindMarketingMessages_Response {
        <CMarketingMessages_FindMarketingMessages_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_FindMarketingMessages_Response {
    pub fn new() -> CMarketingMessages_FindMarketingMessages_Response {
        ::std::default::Default::default()
    }

    // repeated .CMarketingMessageProto messages = 1;

    pub fn messages(&self) -> &[CMarketingMessageProto] {
        &self.messages
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<CMarketingMessageProto>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<CMarketingMessageProto> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<CMarketingMessageProto> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CMarketingMessages_FindMarketingMessages_Response| { &m.messages },
            |m: &mut CMarketingMessages_FindMarketingMessages_Response| { &mut m.messages },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_FindMarketingMessages_Response>(
            "CMarketingMessages_FindMarketingMessages_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_FindMarketingMessages_Response {
    const NAME: &'static str = "CMarketingMessages_FindMarketingMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.messages {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_FindMarketingMessages_Response {
        CMarketingMessages_FindMarketingMessages_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_FindMarketingMessages_Response {
        static instance: CMarketingMessages_FindMarketingMessages_Response = CMarketingMessages_FindMarketingMessages_Response {
            messages: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_FindMarketingMessages_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_FindMarketingMessages_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_FindMarketingMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_FindMarketingMessages_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessageViewerStats_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessageViewerStats_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessageViewerStats_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessageViewerStats_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessageViewerStats_Request {
    fn default() -> &'a CMarketingMessages_GetMarketingMessageViewerStats_Request {
        <CMarketingMessages_GetMarketingMessageViewerStats_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessageViewerStats_Request {
    pub fn new() -> CMarketingMessages_GetMarketingMessageViewerStats_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_GetMarketingMessageViewerStats_Request| { &m.gid },
            |m: &mut CMarketingMessages_GetMarketingMessageViewerStats_Request| { &mut m.gid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetMarketingMessageViewerStats_Request>(
            "CMarketingMessages_GetMarketingMessageViewerStats_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetMarketingMessageViewerStats_Request {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessageViewerStats_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessageViewerStats_Request {
        CMarketingMessages_GetMarketingMessageViewerStats_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessageViewerStats_Request {
        static instance: CMarketingMessages_GetMarketingMessageViewerStats_Request = CMarketingMessages_GetMarketingMessageViewerStats_Request {
            gid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetMarketingMessageViewerStats_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetMarketingMessageViewerStats_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetMarketingMessageViewerStats_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetMarketingMessageViewerStats_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessageHourlyStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessageHourlyStats {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessageHourlyStats.rt_time_hour)
    pub rt_time_hour: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageHourlyStats.seen_count)
    pub seen_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessageHourlyStats.template_type)
    pub template_type: ::std::option::Option<crate::EnumOrUnknown<EMarketingMessageTemplateType>>,
    // @@protoc_insertion_point(field:CMarketingMessageHourlyStats.display_index)
    pub display_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessageHourlyStats.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessageHourlyStats {
    fn default() -> &'a CMarketingMessageHourlyStats {
        <CMarketingMessageHourlyStats as crate::Message>::default_instance()
    }
}

impl CMarketingMessageHourlyStats {
    pub fn new() -> CMarketingMessageHourlyStats {
        ::std::default::Default::default()
    }

    // optional uint32 rt_time_hour = 1;

    pub fn rt_time_hour(&self) -> u32 {
        self.rt_time_hour.unwrap_or(0)
    }

    pub fn clear_rt_time_hour(&mut self) {
        self.rt_time_hour = ::std::option::Option::None;
    }

    pub fn has_rt_time_hour(&self) -> bool {
        self.rt_time_hour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt_time_hour(&mut self, v: u32) {
        self.rt_time_hour = ::std::option::Option::Some(v);
    }

    // optional uint32 seen_count = 2;

    pub fn seen_count(&self) -> u32 {
        self.seen_count.unwrap_or(0)
    }

    pub fn clear_seen_count(&mut self) {
        self.seen_count = ::std::option::Option::None;
    }

    pub fn has_seen_count(&self) -> bool {
        self.seen_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seen_count(&mut self, v: u32) {
        self.seen_count = ::std::option::Option::Some(v);
    }

    // optional .EMarketingMessageTemplateType template_type = 3;

    pub fn template_type(&self) -> EMarketingMessageTemplateType {
        match self.template_type {
            Some(e) => e.enum_value_or(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown),
            None => EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown,
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: EMarketingMessageTemplateType) {
        self.template_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 display_index = 4;

    pub fn display_index(&self) -> u32 {
        self.display_index.unwrap_or(0)
    }

    pub fn clear_display_index(&mut self) {
        self.display_index = ::std::option::Option::None;
    }

    pub fn has_display_index(&self) -> bool {
        self.display_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_index(&mut self, v: u32) {
        self.display_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rt_time_hour",
            |m: &CMarketingMessageHourlyStats| { &m.rt_time_hour },
            |m: &mut CMarketingMessageHourlyStats| { &mut m.rt_time_hour },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "seen_count",
            |m: &CMarketingMessageHourlyStats| { &m.seen_count },
            |m: &mut CMarketingMessageHourlyStats| { &mut m.seen_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "template_type",
            |m: &CMarketingMessageHourlyStats| { &m.template_type },
            |m: &mut CMarketingMessageHourlyStats| { &mut m.template_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_index",
            |m: &CMarketingMessageHourlyStats| { &m.display_index },
            |m: &mut CMarketingMessageHourlyStats| { &mut m.display_index },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessageHourlyStats>(
            "CMarketingMessageHourlyStats",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessageHourlyStats {
    const NAME: &'static str = "CMarketingMessageHourlyStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rt_time_hour = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.seen_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.template_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.display_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rt_time_hour {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.seen_count {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.template_type {
            my_size += crate::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.display_index {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.rt_time_hour {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.seen_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.template_type {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.display_index {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessageHourlyStats {
        CMarketingMessageHourlyStats::new()
    }

    fn clear(&mut self) {
        self.rt_time_hour = ::std::option::Option::None;
        self.seen_count = ::std::option::Option::None;
        self.template_type = ::std::option::Option::None;
        self.display_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessageHourlyStats {
        static instance: CMarketingMessageHourlyStats = CMarketingMessageHourlyStats {
            rt_time_hour: ::std::option::Option::None,
            seen_count: ::std::option::Option::None,
            template_type: ::std::option::Option::None,
            display_index: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessageHourlyStats {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessageHourlyStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessageHourlyStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessageHourlyStats {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessageViewerStats_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessageViewerStats_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessageViewerStats_Response.stats)
    pub stats: ::std::vec::Vec<CMarketingMessageHourlyStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessageViewerStats_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessageViewerStats_Response {
    fn default() -> &'a CMarketingMessages_GetMarketingMessageViewerStats_Response {
        <CMarketingMessages_GetMarketingMessageViewerStats_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessageViewerStats_Response {
    pub fn new() -> CMarketingMessages_GetMarketingMessageViewerStats_Response {
        ::std::default::Default::default()
    }

    // repeated .CMarketingMessageHourlyStats stats = 1;

    pub fn stats(&self) -> &[CMarketingMessageHourlyStats] {
        &self.stats
    }

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::vec::Vec<CMarketingMessageHourlyStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::vec::Vec<CMarketingMessageHourlyStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::vec::Vec<CMarketingMessageHourlyStats> {
        ::std::mem::replace(&mut self.stats, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CMarketingMessages_GetMarketingMessageViewerStats_Response| { &m.stats },
            |m: &mut CMarketingMessages_GetMarketingMessageViewerStats_Response| { &mut m.stats },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetMarketingMessageViewerStats_Response>(
            "CMarketingMessages_GetMarketingMessageViewerStats_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetMarketingMessageViewerStats_Response {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessageViewerStats_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.stats {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessageViewerStats_Response {
        CMarketingMessages_GetMarketingMessageViewerStats_Response::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessageViewerStats_Response {
        static instance: CMarketingMessages_GetMarketingMessageViewerStats_Response = CMarketingMessages_GetMarketingMessageViewerStats_Response {
            stats: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetMarketingMessageViewerStats_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetMarketingMessageViewerStats_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetMarketingMessageViewerStats_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetMarketingMessageViewerStats_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request.rt_start_time)
    pub rt_start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request.rt_end_time)
    pub rt_end_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    fn default() -> &'a CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
        <CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    pub fn new() -> CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
        ::std::default::Default::default()
    }

    // optional uint32 rt_start_time = 1;

    pub fn rt_start_time(&self) -> u32 {
        self.rt_start_time.unwrap_or(0)
    }

    pub fn clear_rt_start_time(&mut self) {
        self.rt_start_time = ::std::option::Option::None;
    }

    pub fn has_rt_start_time(&self) -> bool {
        self.rt_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt_start_time(&mut self, v: u32) {
        self.rt_start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 rt_end_time = 2;

    pub fn rt_end_time(&self) -> u32 {
        self.rt_end_time.unwrap_or(0)
    }

    pub fn clear_rt_end_time(&mut self) {
        self.rt_end_time = ::std::option::Option::None;
    }

    pub fn has_rt_end_time(&self) -> bool {
        self.rt_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rt_end_time(&mut self, v: u32) {
        self.rt_end_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rt_start_time",
            |m: &CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request| { &m.rt_start_time },
            |m: &mut CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request| { &mut m.rt_start_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rt_end_time",
            |m: &CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request| { &m.rt_end_time },
            |m: &mut CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request| { &mut m.rt_end_time },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request>(
            "CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rt_start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rt_end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rt_start_time {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rt_end_time {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.rt_start_time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rt_end_time {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
        CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request::new()
    }

    fn clear(&mut self) {
        self.rt_start_time = ::std::option::Option::None;
        self.rt_end_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
        static instance: CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request = CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
            rt_start_time: ::std::option::Option::None,
            rt_end_time: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response.stats)
    pub stats: ::std::vec::Vec<CMarketingMessageHourlyStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    fn default() -> &'a CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
        <CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    pub fn new() -> CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
        ::std::default::Default::default()
    }

    // repeated .CMarketingMessageHourlyStats stats = 1;

    pub fn stats(&self) -> &[CMarketingMessageHourlyStats] {
        &self.stats
    }

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::vec::Vec<CMarketingMessageHourlyStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::vec::Vec<CMarketingMessageHourlyStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::vec::Vec<CMarketingMessageHourlyStats> {
        ::std::mem::replace(&mut self.stats, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response| { &m.stats },
            |m: &mut CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response| { &mut m.stats },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response>(
            "CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    const NAME: &'static str = "CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.stats {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
        CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
        static instance: CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response = CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
            stats: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetPartnerReadyToPublishMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetPartnerReadyToPublishMessages_Request.partnerid)
    pub partnerid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetPartnerReadyToPublishMessages_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
    fn default() -> &'a CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
        <CMarketingMessages_GetPartnerReadyToPublishMessages_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
    pub fn new() -> CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
        ::std::default::Default::default()
    }

    // optional uint32 partnerid = 1;

    pub fn partnerid(&self) -> u32 {
        self.partnerid.unwrap_or(0)
    }

    pub fn clear_partnerid(&mut self) {
        self.partnerid = ::std::option::Option::None;
    }

    pub fn has_partnerid(&self) -> bool {
        self.partnerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partnerid(&mut self, v: u32) {
        self.partnerid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "partnerid",
            |m: &CMarketingMessages_GetPartnerReadyToPublishMessages_Request| { &m.partnerid },
            |m: &mut CMarketingMessages_GetPartnerReadyToPublishMessages_Request| { &mut m.partnerid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetPartnerReadyToPublishMessages_Request>(
            "CMarketingMessages_GetPartnerReadyToPublishMessages_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
    const NAME: &'static str = "CMarketingMessages_GetPartnerReadyToPublishMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.partnerid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.partnerid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.partnerid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
        CMarketingMessages_GetPartnerReadyToPublishMessages_Request::new()
    }

    fn clear(&mut self) {
        self.partnerid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
        static instance: CMarketingMessages_GetPartnerReadyToPublishMessages_Request = CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
            partnerid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetPartnerReadyToPublishMessages_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetPartnerReadyToPublishMessages_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetPartnerReadyToPublishMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetPartnerReadyToPublishMessages_Response.messages)
    pub messages: ::std::vec::Vec<CDisplayMarketingMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetPartnerReadyToPublishMessages_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
    fn default() -> &'a CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
        <CMarketingMessages_GetPartnerReadyToPublishMessages_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
    pub fn new() -> CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
        ::std::default::Default::default()
    }

    // repeated .CDisplayMarketingMessage messages = 1;

    pub fn messages(&self) -> &[CDisplayMarketingMessage] {
        &self.messages
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<CDisplayMarketingMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<CDisplayMarketingMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<CDisplayMarketingMessage> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CMarketingMessages_GetPartnerReadyToPublishMessages_Response| { &m.messages },
            |m: &mut CMarketingMessages_GetPartnerReadyToPublishMessages_Response| { &mut m.messages },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetPartnerReadyToPublishMessages_Response>(
            "CMarketingMessages_GetPartnerReadyToPublishMessages_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
    const NAME: &'static str = "CMarketingMessages_GetPartnerReadyToPublishMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.messages {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
        CMarketingMessages_GetPartnerReadyToPublishMessages_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
        static instance: CMarketingMessages_GetPartnerReadyToPublishMessages_Response = CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
            messages: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetPartnerReadyToPublishMessages_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetPartnerReadyToPublishMessages_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_PartnerPublishMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_PartnerPublishMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_PartnerPublishMessage_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_PartnerPublishMessage_Request.partnerid)
    pub partnerid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_PartnerPublishMessage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_PartnerPublishMessage_Request {
    fn default() -> &'a CMarketingMessages_PartnerPublishMessage_Request {
        <CMarketingMessages_PartnerPublishMessage_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_PartnerPublishMessage_Request {
    pub fn new() -> CMarketingMessages_PartnerPublishMessage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 partnerid = 2;

    pub fn partnerid(&self) -> u32 {
        self.partnerid.unwrap_or(0)
    }

    pub fn clear_partnerid(&mut self) {
        self.partnerid = ::std::option::Option::None;
    }

    pub fn has_partnerid(&self) -> bool {
        self.partnerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partnerid(&mut self, v: u32) {
        self.partnerid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_PartnerPublishMessage_Request| { &m.gid },
            |m: &mut CMarketingMessages_PartnerPublishMessage_Request| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "partnerid",
            |m: &CMarketingMessages_PartnerPublishMessage_Request| { &m.partnerid },
            |m: &mut CMarketingMessages_PartnerPublishMessage_Request| { &mut m.partnerid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_PartnerPublishMessage_Request>(
            "CMarketingMessages_PartnerPublishMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_PartnerPublishMessage_Request {
    const NAME: &'static str = "CMarketingMessages_PartnerPublishMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.partnerid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.partnerid {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.partnerid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_PartnerPublishMessage_Request {
        CMarketingMessages_PartnerPublishMessage_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.partnerid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_PartnerPublishMessage_Request {
        static instance: CMarketingMessages_PartnerPublishMessage_Request = CMarketingMessages_PartnerPublishMessage_Request {
            gid: ::std::option::Option::None,
            partnerid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_PartnerPublishMessage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_PartnerPublishMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_PartnerPublishMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_PartnerPublishMessage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_PartnerPublishMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_PartnerPublishMessage_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_PartnerPublishMessage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_PartnerPublishMessage_Response {
    fn default() -> &'a CMarketingMessages_PartnerPublishMessage_Response {
        <CMarketingMessages_PartnerPublishMessage_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_PartnerPublishMessage_Response {
    pub fn new() -> CMarketingMessages_PartnerPublishMessage_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_PartnerPublishMessage_Response>(
            "CMarketingMessages_PartnerPublishMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_PartnerPublishMessage_Response {
    const NAME: &'static str = "CMarketingMessages_PartnerPublishMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_PartnerPublishMessage_Response {
        CMarketingMessages_PartnerPublishMessage_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_PartnerPublishMessage_Response {
        static instance: CMarketingMessages_PartnerPublishMessage_Response = CMarketingMessages_PartnerPublishMessage_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_PartnerPublishMessage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_PartnerPublishMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_PartnerPublishMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_PartnerPublishMessage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetPartnerMessagePreview_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetPartnerMessagePreview_Request {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetPartnerMessagePreview_Request.gid)
    pub gid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMarketingMessages_GetPartnerMessagePreview_Request.partnerid)
    pub partnerid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetPartnerMessagePreview_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetPartnerMessagePreview_Request {
    fn default() -> &'a CMarketingMessages_GetPartnerMessagePreview_Request {
        <CMarketingMessages_GetPartnerMessagePreview_Request as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetPartnerMessagePreview_Request {
    pub fn new() -> CMarketingMessages_GetPartnerMessagePreview_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint32 partnerid = 2;

    pub fn partnerid(&self) -> u32 {
        self.partnerid.unwrap_or(0)
    }

    pub fn clear_partnerid(&mut self) {
        self.partnerid = ::std::option::Option::None;
    }

    pub fn has_partnerid(&self) -> bool {
        self.partnerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partnerid(&mut self, v: u32) {
        self.partnerid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gid",
            |m: &CMarketingMessages_GetPartnerMessagePreview_Request| { &m.gid },
            |m: &mut CMarketingMessages_GetPartnerMessagePreview_Request| { &mut m.gid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "partnerid",
            |m: &CMarketingMessages_GetPartnerMessagePreview_Request| { &m.partnerid },
            |m: &mut CMarketingMessages_GetPartnerMessagePreview_Request| { &mut m.partnerid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetPartnerMessagePreview_Request>(
            "CMarketingMessages_GetPartnerMessagePreview_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetPartnerMessagePreview_Request {
    const NAME: &'static str = "CMarketingMessages_GetPartnerMessagePreview_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.gid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.partnerid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.partnerid {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.partnerid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetPartnerMessagePreview_Request {
        CMarketingMessages_GetPartnerMessagePreview_Request::new()
    }

    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.partnerid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetPartnerMessagePreview_Request {
        static instance: CMarketingMessages_GetPartnerMessagePreview_Request = CMarketingMessages_GetPartnerMessagePreview_Request {
            gid: ::std::option::Option::None,
            partnerid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetPartnerMessagePreview_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetPartnerMessagePreview_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetPartnerMessagePreview_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetPartnerMessagePreview_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMarketingMessages_GetPartnerMessagePreview_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMarketingMessages_GetPartnerMessagePreview_Response {
    // message fields
    // @@protoc_insertion_point(field:CMarketingMessages_GetPartnerMessagePreview_Response.message)
    pub message: crate::MessageField<CMarketingMessageProto>,
    // special fields
    // @@protoc_insertion_point(special_field:CMarketingMessages_GetPartnerMessagePreview_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMarketingMessages_GetPartnerMessagePreview_Response {
    fn default() -> &'a CMarketingMessages_GetPartnerMessagePreview_Response {
        <CMarketingMessages_GetPartnerMessagePreview_Response as crate::Message>::default_instance()
    }
}

impl CMarketingMessages_GetPartnerMessagePreview_Response {
    pub fn new() -> CMarketingMessages_GetPartnerMessagePreview_Response {
        ::std::default::Default::default()
    }

    // optional .CMarketingMessageProto message = 1;

    pub fn message(&self) -> &CMarketingMessageProto {
        self.message.as_ref().unwrap_or_else(|| <CMarketingMessageProto as crate::Message>::default_instance())
    }

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: CMarketingMessageProto) {
        self.message = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut CMarketingMessageProto {
        self.message.mut_or_insert_default()
    }

    // Take field
    pub fn take_message(&mut self) -> CMarketingMessageProto {
        self.message.take().unwrap_or_else(|| CMarketingMessageProto::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CMarketingMessageProto>(
            "message",
            |m: &CMarketingMessages_GetPartnerMessagePreview_Response| { &m.message },
            |m: &mut CMarketingMessages_GetPartnerMessagePreview_Response| { &mut m.message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMarketingMessages_GetPartnerMessagePreview_Response>(
            "CMarketingMessages_GetPartnerMessagePreview_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMarketingMessages_GetPartnerMessagePreview_Response {
    const NAME: &'static str = "CMarketingMessages_GetPartnerMessagePreview_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.message)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.message.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMarketingMessages_GetPartnerMessagePreview_Response {
        CMarketingMessages_GetPartnerMessagePreview_Response::new()
    }

    fn clear(&mut self) {
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMarketingMessages_GetPartnerMessagePreview_Response {
        static instance: CMarketingMessages_GetPartnerMessagePreview_Response = CMarketingMessages_GetPartnerMessagePreview_Response {
            message: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMarketingMessages_GetPartnerMessagePreview_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMarketingMessages_GetPartnerMessagePreview_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMarketingMessages_GetPartnerMessagePreview_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMarketingMessages_GetPartnerMessagePreview_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageType)
pub enum EMarketingMessageType {
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageInvalid)
    k_EMarketingMessageInvalid = 0,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageNowAvailable)
    k_EMarketingMessageNowAvailable = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageWeekendDeal)
    k_EMarketingMessageWeekendDeal = 2,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessagePrePurchase)
    k_EMarketingMessagePrePurchase = 3,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessagePlayNow)
    k_EMarketingMessagePlayNow = 4,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessagePreloadNow)
    k_EMarketingMessagePreloadNow = 5,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageGeneral)
    k_EMarketingMessageGeneral = 6,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageDemoQuit)
    k_EMarketingMessageDemoQuit = 7,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageGifting)
    k_EMarketingMessageGifting = 8,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageEJsKorner)
    k_EMarketingMessageEJsKorner = 9,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageUpdate)
    k_EMarketingMessageUpdate = 10,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageMidweekDeal)
    k_EMarketingMessageMidweekDeal = 11,
    // @@protoc_insertion_point(enum_value:EMarketingMessageType.k_EMarketingMessageDailyDeal)
    k_EMarketingMessageDailyDeal = 12,
}

impl crate::Enum for EMarketingMessageType {
    const NAME: &'static str = "EMarketingMessageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageType> {
        match value {
            0 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageInvalid),
            1 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageNowAvailable),
            2 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageWeekendDeal),
            3 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePrePurchase),
            4 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePlayNow),
            5 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePreloadNow),
            6 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageGeneral),
            7 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageDemoQuit),
            8 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageGifting),
            9 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageEJsKorner),
            10 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageUpdate),
            11 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageMidweekDeal),
            12 => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageDailyDeal),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageType> {
        match str {
            "k_EMarketingMessageInvalid" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageInvalid),
            "k_EMarketingMessageNowAvailable" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageNowAvailable),
            "k_EMarketingMessageWeekendDeal" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageWeekendDeal),
            "k_EMarketingMessagePrePurchase" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePrePurchase),
            "k_EMarketingMessagePlayNow" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePlayNow),
            "k_EMarketingMessagePreloadNow" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessagePreloadNow),
            "k_EMarketingMessageGeneral" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageGeneral),
            "k_EMarketingMessageDemoQuit" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageDemoQuit),
            "k_EMarketingMessageGifting" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageGifting),
            "k_EMarketingMessageEJsKorner" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageEJsKorner),
            "k_EMarketingMessageUpdate" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageUpdate),
            "k_EMarketingMessageMidweekDeal" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageMidweekDeal),
            "k_EMarketingMessageDailyDeal" => ::std::option::Option::Some(EMarketingMessageType::k_EMarketingMessageDailyDeal),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageType] = &[
        EMarketingMessageType::k_EMarketingMessageInvalid,
        EMarketingMessageType::k_EMarketingMessageNowAvailable,
        EMarketingMessageType::k_EMarketingMessageWeekendDeal,
        EMarketingMessageType::k_EMarketingMessagePrePurchase,
        EMarketingMessageType::k_EMarketingMessagePlayNow,
        EMarketingMessageType::k_EMarketingMessagePreloadNow,
        EMarketingMessageType::k_EMarketingMessageGeneral,
        EMarketingMessageType::k_EMarketingMessageDemoQuit,
        EMarketingMessageType::k_EMarketingMessageGifting,
        EMarketingMessageType::k_EMarketingMessageEJsKorner,
        EMarketingMessageType::k_EMarketingMessageUpdate,
        EMarketingMessageType::k_EMarketingMessageMidweekDeal,
        EMarketingMessageType::k_EMarketingMessageDailyDeal,
    ];
}

impl crate::EnumFull for EMarketingMessageType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EMarketingMessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EMarketingMessageType {
    fn default() -> Self {
        EMarketingMessageType::k_EMarketingMessageInvalid
    }
}

impl EMarketingMessageType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EMarketingMessageType>("EMarketingMessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageVisibility)
pub enum EMarketingMessageVisibility {
    // @@protoc_insertion_point(enum_value:EMarketingMessageVisibility.k_EMarketingMessageVisibleBeta)
    k_EMarketingMessageVisibleBeta = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageVisibility.k_EMarketingMessageVisiblePublic)
    k_EMarketingMessageVisiblePublic = 2,
    // @@protoc_insertion_point(enum_value:EMarketingMessageVisibility.k_EMarketingMessageVisibleApprovedForPublish)
    k_EMarketingMessageVisibleApprovedForPublish = 3,
}

impl crate::Enum for EMarketingMessageVisibility {
    const NAME: &'static str = "EMarketingMessageVisibility";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageVisibility> {
        match value {
            1 => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta),
            2 => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisiblePublic),
            3 => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisibleApprovedForPublish),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageVisibility> {
        match str {
            "k_EMarketingMessageVisibleBeta" => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta),
            "k_EMarketingMessageVisiblePublic" => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisiblePublic),
            "k_EMarketingMessageVisibleApprovedForPublish" => ::std::option::Option::Some(EMarketingMessageVisibility::k_EMarketingMessageVisibleApprovedForPublish),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageVisibility] = &[
        EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta,
        EMarketingMessageVisibility::k_EMarketingMessageVisiblePublic,
        EMarketingMessageVisibility::k_EMarketingMessageVisibleApprovedForPublish,
    ];
}

impl crate::EnumFull for EMarketingMessageVisibility {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EMarketingMessageVisibility").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta => 0,
            EMarketingMessageVisibility::k_EMarketingMessageVisiblePublic => 1,
            EMarketingMessageVisibility::k_EMarketingMessageVisibleApprovedForPublish => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EMarketingMessageVisibility {
    fn default() -> Self {
        EMarketingMessageVisibility::k_EMarketingMessageVisibleBeta
    }
}

impl EMarketingMessageVisibility {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EMarketingMessageVisibility>("EMarketingMessageVisibility")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageAssociationType)
pub enum EMarketingMessageAssociationType {
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageNoAssociation)
    k_EMarketingMessageNoAssociation = 0,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageAppAssociation)
    k_EMarketingMessageAppAssociation = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageSubscriptionAssociation)
    k_EMarketingMessageSubscriptionAssociation = 2,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessagePublisherAssociation)
    k_EMarketingMessagePublisherAssociation = 3,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageGenreAssociation)
    k_EMarketingMessageGenreAssociation = 4,
    // @@protoc_insertion_point(enum_value:EMarketingMessageAssociationType.k_EMarketingMessageBundleAssociation)
    k_EMarketingMessageBundleAssociation = 5,
}

impl crate::Enum for EMarketingMessageAssociationType {
    const NAME: &'static str = "EMarketingMessageAssociationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageAssociationType> {
        match value {
            0 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation),
            1 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageAppAssociation),
            2 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageSubscriptionAssociation),
            3 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessagePublisherAssociation),
            4 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageGenreAssociation),
            5 => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageBundleAssociation),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageAssociationType> {
        match str {
            "k_EMarketingMessageNoAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation),
            "k_EMarketingMessageAppAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageAppAssociation),
            "k_EMarketingMessageSubscriptionAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageSubscriptionAssociation),
            "k_EMarketingMessagePublisherAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessagePublisherAssociation),
            "k_EMarketingMessageGenreAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageGenreAssociation),
            "k_EMarketingMessageBundleAssociation" => ::std::option::Option::Some(EMarketingMessageAssociationType::k_EMarketingMessageBundleAssociation),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageAssociationType] = &[
        EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessageAppAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessageSubscriptionAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessagePublisherAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessageGenreAssociation,
        EMarketingMessageAssociationType::k_EMarketingMessageBundleAssociation,
    ];
}

impl crate::EnumFull for EMarketingMessageAssociationType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EMarketingMessageAssociationType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EMarketingMessageAssociationType {
    fn default() -> Self {
        EMarketingMessageAssociationType::k_EMarketingMessageNoAssociation
    }
}

impl EMarketingMessageAssociationType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EMarketingMessageAssociationType>("EMarketingMessageAssociationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageTemplateType)
pub enum EMarketingMessageTemplateType {
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Unknown)
    k_EMarketingMessageTemplate_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Image)
    k_EMarketingMessageTemplate_Image = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Animated)
    k_EMarketingMessageTemplate_Animated = 2,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Featured_Video)
    k_EMarketingMessageTemplate_Featured_Video = 3,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_DLC_Override)
    k_EMarketingMessageTemplate_DLC_Override = 4,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_Replay)
    k_EMarketingMessageTemplate_Replay = 5,
    // @@protoc_insertion_point(enum_value:EMarketingMessageTemplateType.k_EMarketingMessageTemplate_MAX)
    k_EMarketingMessageTemplate_MAX = 6,
}

impl crate::Enum for EMarketingMessageTemplateType {
    const NAME: &'static str = "EMarketingMessageTemplateType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageTemplateType> {
        match value {
            0 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown),
            1 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Image),
            2 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Animated),
            3 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Featured_Video),
            4 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_DLC_Override),
            5 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Replay),
            6 => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageTemplateType> {
        match str {
            "k_EMarketingMessageTemplate_Unknown" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown),
            "k_EMarketingMessageTemplate_Image" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Image),
            "k_EMarketingMessageTemplate_Animated" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Animated),
            "k_EMarketingMessageTemplate_Featured_Video" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Featured_Video),
            "k_EMarketingMessageTemplate_DLC_Override" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_DLC_Override),
            "k_EMarketingMessageTemplate_Replay" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Replay),
            "k_EMarketingMessageTemplate_MAX" => ::std::option::Option::Some(EMarketingMessageTemplateType::k_EMarketingMessageTemplate_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageTemplateType] = &[
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Image,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Animated,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Featured_Video,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_DLC_Override,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Replay,
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_MAX,
    ];
}

impl crate::EnumFull for EMarketingMessageTemplateType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EMarketingMessageTemplateType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EMarketingMessageTemplateType {
    fn default() -> Self {
        EMarketingMessageTemplateType::k_EMarketingMessageTemplate_Unknown
    }
}

impl EMarketingMessageTemplateType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EMarketingMessageTemplateType>("EMarketingMessageTemplateType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EMarketingMessageLookupType)
pub enum EMarketingMessageLookupType {
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupInvalid)
    k_EMarketingMessageLookupInvalid = 0,
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupByGID)
    k_EMarketingMessageLookupByGID = 1,
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupActive)
    k_EMarketingMessageLookupActive = 2,
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupByTitleWithType)
    k_EMarketingMessageLookupByTitleWithType = 3,
    // @@protoc_insertion_point(enum_value:EMarketingMessageLookupType.k_EMarketingMessageLookupByGIDList)
    k_EMarketingMessageLookupByGIDList = 4,
}

impl crate::Enum for EMarketingMessageLookupType {
    const NAME: &'static str = "EMarketingMessageLookupType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EMarketingMessageLookupType> {
        match value {
            0 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid),
            1 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByGID),
            2 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupActive),
            3 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByTitleWithType),
            4 => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByGIDList),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EMarketingMessageLookupType> {
        match str {
            "k_EMarketingMessageLookupInvalid" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid),
            "k_EMarketingMessageLookupByGID" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByGID),
            "k_EMarketingMessageLookupActive" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupActive),
            "k_EMarketingMessageLookupByTitleWithType" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByTitleWithType),
            "k_EMarketingMessageLookupByGIDList" => ::std::option::Option::Some(EMarketingMessageLookupType::k_EMarketingMessageLookupByGIDList),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EMarketingMessageLookupType] = &[
        EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid,
        EMarketingMessageLookupType::k_EMarketingMessageLookupByGID,
        EMarketingMessageLookupType::k_EMarketingMessageLookupActive,
        EMarketingMessageLookupType::k_EMarketingMessageLookupByTitleWithType,
        EMarketingMessageLookupType::k_EMarketingMessageLookupByGIDList,
    ];
}

impl crate::EnumFull for EMarketingMessageLookupType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EMarketingMessageLookupType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EMarketingMessageLookupType {
    fn default() -> Self {
        EMarketingMessageLookupType::k_EMarketingMessageLookupInvalid
    }
}

impl EMarketingMessageLookupType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EMarketingMessageLookupType>("EMarketingMessageLookupType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n1steammessages_marketingmessages.steamclient.proto\x1a\x18steammessage\
    s_base.proto\x1a,steammessages_unified_base.steamclient.proto\x1a+steamm\
    essages_storebrowse.steamclient.proto\"x\n5CMarketingMessages_GetActiveM\
    arketingMessages_Request\x12\x18\n\x07country\x18\x01\x20\x01(\tR\x07cou\
    ntry\x12%\n\x0eanonymous_user\x18\x02\x20\x01(\x08R\ranonymousUser\"\xa9\
    \t\n\x16CMarketingMessageProto\x12\x10\n\x03gid\x18\x01\x20\x01(\x06R\
    \x03gid\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12F\n\x04type\
    \x18\x03\x20\x01(\x0e2\x16.EMarketingMessageType:\x1ak_EMarketingMessage\
    InvalidR\x04type\x12\\\n\nvisibility\x18\x04\x20\x01(\x0e2\x1c.EMarketin\
    gMessageVisibility:\x1ek_EMarketingMessageVisibleBetaR\nvisibility\x12\
    \x1a\n\x08priority\x18\x05\x20\x01(\rR\x08priority\x12n\n\x10association\
    _type\x18\x06\x20\x01(\x0e2!.EMarketingMessageAssociationType:\x20k_EMar\
    ketingMessageNoAssociationR\x0fassociationType\x12#\n\rassociated_id\x18\
    \x07\x20\x01(\rR\x0cassociatedId\x12'\n\x0fassociated_name\x18\x08\x20\
    \x01(\tR\x0eassociatedName\x12\x1d\n\nstart_date\x18\t\x20\x01(\rR\tstar\
    tDate\x12\x19\n\x08end_date\x18\n\x20\x01(\rR\x07endDate\x12#\n\rcountry\
    _allow\x18\x0b\x20\x01(\tR\x0ccountryAllow\x12!\n\x0ccountry_deny\x18\
    \x0c\x20\x01(\tR\x0bcountryDeny\x12J\n!ownership_restrictions_overridden\
    \x18\r\x20\x01(\x08R\x1fownershipRestrictionsOverridden\x12$\n\x0emust_o\
    wn_appid\x18\x0e\x20\x01(\rR\x0cmustOwnAppid\x12+\n\x12must_not_own_appi\
    d\x18\x0f\x20\x01(\rR\x0fmustNotOwnAppid\x12,\n\x12must_own_packageid\
    \x18\x10\x20\x01(\rR\x10mustOwnPackageid\x123\n\x16must_not_own_packagei\
    d\x18\x11\x20\x01(\rR\x13mustNotOwnPackageid\x127\n\x18must_have_launche\
    d_appid\x18\x12\x20\x01(\rR\x15mustHaveLaunchedAppid\x127\n\x17additiona\
    l_restrictions\x18\x13\x20\x01(\tR\x16additionalRestrictions\x12#\n\rtem\
    plate_type\x18\x14\x20\x01(\tR\x0ctemplateType\x12#\n\rtemplate_vars\x18\
    \x15\x20\x01(\tR\x0ctemplateVars\x12\x14\n\x05flags\x18\x16\x20\x01(\rR\
    \x05flags\x12!\n\x0ccreator_name\x18\x17\x20\x01(\tR\x0bcreatorName\x12,\
    \n\x12template_vars_json\x18\x18\x20\x01(\tR\x10templateVarsJson\x12@\n\
    \x1cadditional_restrictions_json\x18\x19\x20\x01(\tR\x1aadditionalRestri\
    ctionsJson\"\xa0\x01\n6CMarketingMessages_GetActiveMarketingMessages_Res\
    ponse\x123\n\x08messages\x18\x01\x20\x03(\x0b2\x17.CMarketingMessageProt\
    oR\x08messages\x121\n\x15time_next_message_age\x18\x02\x20\x01(\rR\x12ti\
    meNextMessageAge\"\xfd\x02\n6CMarketingMessages_GetMarketingMessagesForU\
    ser_Request\x122\n\x15include_seen_messages\x18\x01\x20\x01(\x08R\x13inc\
    ludeSeenMessages\x12!\n\x0ccountry_code\x18\x02\x20\x01(\tR\x0bcountryCo\
    de\x12\x1c\n\telanguage\x18\x03\x20\x01(\x05R\telanguage\x12)\n\x10opera\
    ting_system\x18\x04\x20\x01(\x05R\x0foperatingSystem\x124\n\x16client_pa\
    ckage_version\x18\x05\x20\x01(\x05R\x14clientPackageVersion\x12-\n\x07co\
    ntext\x18\x06\x20\x01(\x0b2\x13.StoreBrowseContextR\x07context\x12>\n\
    \x0cdata_request\x18\x07\x20\x01(\x0b2\x1b.StoreBrowseItemDataRequestR\
    \x0bdataRequest\"\xf7\x02\n\x18CDisplayMarketingMessage\x12\x10\n\x03gid\
    \x18\x01\x20\x01(\x06R\x03gid\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05\
    title\x12F\n\x04type\x18\x03\x20\x01(\x0e2\x16.EMarketingMessageType:\
    \x1ak_EMarketingMessageInvalidR\x04type\x12:\n\x12associated_item_id\x18\
    \x04\x20\x01(\x0b2\x0c.StoreItemIDR\x10associatedItemId\x123\n\x0fassoci\
    ated_item\x18\x05\x20\x01(\x0b2\n.StoreItemR\x0eassociatedItem\x12'\n\
    \x0fassociated_name\x18\x06\x20\x01(\tR\x0eassociatedName\x12#\n\rtempla\
    te_type\x18\n\x20\x01(\tR\x0ctemplateType\x12,\n\x12template_vars_json\
    \x18\x0b\x20\x01(\tR\x10templateVarsJson\"\x9a\x02\n7CMarketingMessages_\
    GetMarketingMessagesForUser_Response\x12l\n\x08messages\x18\x01\x20\x03(\
    \x0b2P.CMarketingMessages_GetMarketingMessagesForUser_Response.Marketing\
    MessageForUserR\x08messages\x1aq\n\x17MarketingMessageForUser\x12!\n\x0c\
    already_seen\x18\x01\x20\x01(\x08R\x0balreadySeen\x123\n\x07message\x18\
    \x02\x20\x01(\x0b2\x19.CDisplayMarketingMessageR\x07message\"\xe3\x01\n?\
    CMarketingMessages_DoesUserHavePendingMarketingMessages_Request\x12!\n\
    \x0ccountry_code\x18\x02\x20\x01(\tR\x0bcountryCode\x12\x1c\n\telanguage\
    \x18\x03\x20\x01(\x05R\telanguage\x12)\n\x10operating_system\x18\x04\x20\
    \x01(\x05R\x0foperatingSystem\x124\n\x16client_package_version\x18\x05\
    \x20\x01(\x05R\x14clientPackageVersion\"\xa8\x01\n@CMarketingMessages_Do\
    esUserHavePendingMarketingMessages_Response\x120\n\x14has_pending_messag\
    es\x18\x01\x20\x01(\x08R\x12hasPendingMessages\x122\n\x15pending_message\
    _count\x18\x02\x20\x01(\x05R\x13pendingMessageCount\"\xb8\x01\n5CMarketi\
    ngMessages_GetDisplayMarketingMessage_Request\x12\x10\n\x03gid\x18\x01\
    \x20\x01(\x06R\x03gid\x12-\n\x07context\x18\x02\x20\x01(\x0b2\x13.StoreB\
    rowseContextR\x07context\x12>\n\x0cdata_request\x18\x03\x20\x01(\x0b2\
    \x1b.StoreBrowseItemDataRequestR\x0bdataRequest\"m\n6CMarketingMessages_\
    GetDisplayMarketingMessage_Response\x123\n\x07message\x18\x01\x20\x01(\
    \x0b2\x19.CDisplayMarketingMessageR\x07message\"\xd5\x01\n/CMarketingMes\
    sages_MarkMessageSeen_Notification\x12\x10\n\x03gid\x18\x01\x20\x01(\x06\
    R\x03gid\x12&\n\rdisplay_index\x18\x02\x20\x01(\r:\x010R\x0cdisplayIndex\
    \x12h\n\rtemplate_type\x18\x03\x20\x01(\x0e2\x1e.EMarketingMessageTempla\
    teType:#k_EMarketingMessageTemplate_UnknownR\x0ctemplateType\"B\n.CMarke\
    tingMessages_GetMarketingMessage_Request\x12\x10\n\x03gid\x18\x01\x20\
    \x01(\x06R\x03gid\"d\n/CMarketingMessages_GetMarketingMessage_Response\
    \x121\n\x07message\x18\x01\x20\x01(\x0b2\x17.CMarketingMessageProtoR\x07\
    message\"\x83\x01\n1CMarketingMessages_CreateMarketingMessage_Request\
    \x121\n\x07message\x18\x01\x20\x01(\x0b2\x17.CMarketingMessageProtoR\x07\
    message\x12\x1b\n\tfrom_json\x18\x02\x20\x01(\x08R\x08fromJson\"F\n2CMar\
    ketingMessages_CreateMarketingMessage_Response\x12\x10\n\x03gid\x18\x01\
    \x20\x01(\x06R\x03gid\"\x95\x01\n1CMarketingMessages_UpdateMarketingMess\
    age_Request\x12\x10\n\x03gid\x18\x01\x20\x01(\x06R\x03gid\x121\n\x07mess\
    age\x18\x02\x20\x01(\x0b2\x17.CMarketingMessageProtoR\x07message\x12\x1b\
    \n\tfrom_json\x18\x03\x20\x01(\x08R\x08fromJson\"4\n2CMarketingMessages_\
    UpdateMarketingMessage_Response\"E\n1CMarketingMessages_DeleteMarketingM\
    essage_Request\x12\x10\n\x03gid\x18\x01\x20\x01(\x06R\x03gid\"4\n2CMarke\
    tingMessages_DeleteMarketingMessage_Response\"\xac\x02\n0CMarketingMessa\
    ges_FindMarketingMessages_Request\x12_\n\x0blookup_type\x18\x01\x20\x01(\
    \x0e2\x1c.EMarketingMessageLookupType:\x20k_EMarketingMessageLookupInval\
    idR\nlookupType\x12\x10\n\x03gid\x18\x02\x20\x01(\x06R\x03gid\x12U\n\x0c\
    message_type\x18\x03\x20\x01(\x0e2\x16.EMarketingMessageType:\x1ak_EMark\
    etingMessageInvalidR\x0bmessageType\x12\x18\n\x07gidlist\x18\x04\x20\x03\
    (\x06R\x07gidlist\x12\x14\n\x05title\x18\x05\x20\x01(\tR\x05title\"h\n1C\
    MarketingMessages_FindMarketingMessages_Response\x123\n\x08messages\x18\
    \x01\x20\x03(\x0b2\x17.CMarketingMessageProtoR\x08messages\"M\n9CMarketi\
    ngMessages_GetMarketingMessageViewerStats_Request\x12\x10\n\x03gid\x18\
    \x01\x20\x01(\x06R\x03gid\"\xee\x01\n\x1cCMarketingMessageHourlyStats\
    \x12\x20\n\x0crt_time_hour\x18\x01\x20\x01(\rR\nrtTimeHour\x12\x1d\n\nse\
    en_count\x18\x02\x20\x01(\rR\tseenCount\x12h\n\rtemplate_type\x18\x03\
    \x20\x01(\x0e2\x1e.EMarketingMessageTemplateType:#k_EMarketingMessageTem\
    plate_UnknownR\x0ctemplateType\x12#\n\rdisplay_index\x18\x04\x20\x01(\rR\
    \x0cdisplayIndex\"q\n:CMarketingMessages_GetMarketingMessageViewerStats_\
    Response\x123\n\x05stats\x18\x01\x20\x03(\x0b2\x1d.CMarketingMessageHour\
    lyStatsR\x05stats\"\x85\x01\n?CMarketingMessages_GetMarketingMessagesVie\
    werRangeStats_Request\x12\"\n\rrt_start_time\x18\x01\x20\x01(\rR\x0brtSt\
    artTime\x12\x1e\n\x0brt_end_time\x18\x02\x20\x01(\rR\trtEndTime\"w\n@CMa\
    rketingMessages_GetMarketingMessagesViewerRangeStats_Response\x123\n\x05\
    stats\x18\x01\x20\x03(\x0b2\x1d.CMarketingMessageHourlyStatsR\x05stats\"\
    [\n;CMarketingMessages_GetPartnerReadyToPublishMessages_Request\x12\x1c\
    \n\tpartnerid\x18\x01\x20\x01(\rR\tpartnerid\"u\n<CMarketingMessages_Get\
    PartnerReadyToPublishMessages_Response\x125\n\x08messages\x18\x01\x20\
    \x03(\x0b2\x19.CDisplayMarketingMessageR\x08messages\"b\n0CMarketingMess\
    ages_PartnerPublishMessage_Request\x12\x10\n\x03gid\x18\x01\x20\x01(\x06\
    R\x03gid\x12\x1c\n\tpartnerid\x18\x02\x20\x01(\rR\tpartnerid\"3\n1CMarke\
    tingMessages_PartnerPublishMessage_Response\"e\n3CMarketingMessages_GetP\
    artnerMessagePreview_Request\x12\x10\n\x03gid\x18\x01\x20\x01(\x06R\x03g\
    id\x12\x1c\n\tpartnerid\x18\x02\x20\x01(\rR\tpartnerid\"i\n4CMarketingMe\
    ssages_GetPartnerMessagePreview_Response\x121\n\x07message\x18\x01\x20\
    \x01(\x0b2\x17.CMarketingMessageProtoR\x07message*\xcf\x03\n\x15EMarketi\
    ngMessageType\x12\x1e\n\x1ak_EMarketingMessageInvalid\x10\0\x12#\n\x1fk_\
    EMarketingMessageNowAvailable\x10\x01\x12\"\n\x1ek_EMarketingMessageWeek\
    endDeal\x10\x02\x12\"\n\x1ek_EMarketingMessagePrePurchase\x10\x03\x12\
    \x1e\n\x1ak_EMarketingMessagePlayNow\x10\x04\x12!\n\x1dk_EMarketingMessa\
    gePreloadNow\x10\x05\x12\x1e\n\x1ak_EMarketingMessageGeneral\x10\x06\x12\
    \x1f\n\x1bk_EMarketingMessageDemoQuit\x10\x07\x12\x1e\n\x1ak_EMarketingM\
    essageGifting\x10\x08\x12\x20\n\x1ck_EMarketingMessageEJsKorner\x10\t\
    \x12\x1d\n\x19k_EMarketingMessageUpdate\x10\n\x12\"\n\x1ek_EMarketingMes\
    sageMidweekDeal\x10\x0b\x12\x20\n\x1ck_EMarketingMessageDailyDeal\x10\
    \x0c*\x99\x01\n\x1bEMarketingMessageVisibility\x12\"\n\x1ek_EMarketingMe\
    ssageVisibleBeta\x10\x01\x12$\n\x20k_EMarketingMessageVisiblePublic\x10\
    \x02\x120\n,k_EMarketingMessageVisibleApprovedForPublish\x10\x03*\x9f\
    \x02\n\x20EMarketingMessageAssociationType\x12$\n\x20k_EMarketingMessage\
    NoAssociation\x10\0\x12%\n!k_EMarketingMessageAppAssociation\x10\x01\x12\
    .\n*k_EMarketingMessageSubscriptionAssociation\x10\x02\x12+\n'k_EMarketi\
    ngMessagePublisherAssociation\x10\x03\x12'\n#k_EMarketingMessageGenreAss\
    ociation\x10\x04\x12(\n$k_EMarketingMessageBundleAssociation\x10\x05*\
    \xc4\x02\n\x1dEMarketingMessageTemplateType\x12'\n#k_EMarketingMessageTe\
    mplate_Unknown\x10\0\x12%\n!k_EMarketingMessageTemplate_Image\x10\x01\
    \x12(\n$k_EMarketingMessageTemplate_Animated\x10\x02\x12.\n*k_EMarketing\
    MessageTemplate_Featured_Video\x10\x03\x12,\n(k_EMarketingMessageTemplat\
    e_DLC_Override\x10\x04\x12&\n\"k_EMarketingMessageTemplate_Replay\x10\
    \x05\x12#\n\x1fk_EMarketingMessageTemplate_MAX\x10\x06*\xe2\x01\n\x1bEMa\
    rketingMessageLookupType\x12$\n\x20k_EMarketingMessageLookupInvalid\x10\
    \0\x12\"\n\x1ek_EMarketingMessageLookupByGID\x10\x01\x12#\n\x1fk_EMarket\
    ingMessageLookupActive\x10\x02\x12,\n(k_EMarketingMessageLookupByTitleWi\
    thType\x10\x03\x12&\n\"k_EMarketingMessageLookupByGIDList\x10\x042\xee\
    \x12\n\x11MarketingMessages\x12\x8d\x01\n\x1aGetActiveMarketingMessages\
    \x126.CMarketingMessages_GetActiveMarketingMessages_Request\x1a7.CMarket\
    ingMessages_GetActiveMarketingMessages_Response\x12\x90\x01\n\x1bGetMark\
    etingMessagesForUser\x127.CMarketingMessages_GetMarketingMessagesForUser\
    _Request\x1a8.CMarketingMessages_GetMarketingMessagesForUser_Response\
    \x12\xab\x01\n$DoesUserHavePendingMarketingMessages\x12@.CMarketingMessa\
    ges_DoesUserHavePendingMarketingMessages_Request\x1aA.CMarketingMessages\
    _DoesUserHavePendingMarketingMessages_Response\x12\x8d\x01\n\x1aGetDispl\
    ayMarketingMessage\x126.CMarketingMessages_GetDisplayMarketingMessage_Re\
    quest\x1a7.CMarketingMessages_GetDisplayMarketingMessage_Response\x12\
    \x94\x01\n!GetDisplayMarketingMessageForUser\x126.CMarketingMessages_Get\
    DisplayMarketingMessage_Request\x1a7.CMarketingMessages_GetDisplayMarket\
    ingMessage_Response\x12\x92\x01\n\x1fGetDisplayMarketingMessageAdmin\x12\
    6.CMarketingMessages_GetDisplayMarketingMessage_Request\x1a7.CMarketingM\
    essages_GetDisplayMarketingMessage_Response\x12P\n\x0fMarkMessageSeen\
    \x120.CMarketingMessages_MarkMessageSeen_Notification\x1a\x0b.NoResponse\
    \x12x\n\x13GetMarketingMessage\x12/.CMarketingMessages_GetMarketingMessa\
    ge_Request\x1a0.CMarketingMessages_GetMarketingMessage_Response\x12\x81\
    \x01\n\x16CreateMarketingMessage\x122.CMarketingMessages_CreateMarketing\
    Message_Request\x1a3.CMarketingMessages_CreateMarketingMessage_Response\
    \x12\x81\x01\n\x16UpdateMarketingMessage\x122.CMarketingMessages_UpdateM\
    arketingMessage_Request\x1a3.CMarketingMessages_UpdateMarketingMessage_R\
    esponse\x12\x81\x01\n\x16DeleteMarketingMessage\x122.CMarketingMessages_\
    DeleteMarketingMessage_Request\x1a3.CMarketingMessages_DeleteMarketingMe\
    ssage_Response\x12~\n\x15FindMarketingMessages\x121.CMarketingMessages_F\
    indMarketingMessages_Request\x1a2.CMarketingMessages_FindMarketingMessag\
    es_Response\x12\x99\x01\n\x1eGetMarketingMessageViewerStats\x12:.CMarket\
    ingMessages_GetMarketingMessageViewerStats_Request\x1a;.CMarketingMessag\
    es_GetMarketingMessageViewerStats_Response\x12\xab\x01\n$GetMarketingMes\
    sagesViewerRangeStats\x12@.CMarketingMessages_GetMarketingMessagesViewer\
    RangeStats_Request\x1aA.CMarketingMessages_GetMarketingMessagesViewerRan\
    geStats_Response\x12\x9f\x01\n\x20GetPartnerReadyToPublishMessages\x12<.\
    CMarketingMessages_GetPartnerReadyToPublishMessages_Request\x1a=.CMarket\
    ingMessages_GetPartnerReadyToPublishMessages_Response\x12~\n\x15PublishP\
    artnerMessage\x121.CMarketingMessages_PartnerPublishMessage_Request\x1a2\
    .CMarketingMessages_PartnerPublishMessage_Response\x12\x87\x01\n\x18GetP\
    artnerMessagePreview\x124.CMarketingMessages_GetPartnerMessagePreview_Re\
    quest\x1a5.CMarketingMessages_GetPartnerMessagePreview_ResponseB\x03\x80\
    \x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::steammessages_base::file_descriptor().clone());
            deps.push(super::steammessages_unified_base_steamclient::file_descriptor().clone());
            deps.push(super::steammessages_storebrowse_steamclient::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(33);
            messages.push(CMarketingMessages_GetActiveMarketingMessages_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessageProto::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetActiveMarketingMessages_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetMarketingMessagesForUser_Request::generated_message_descriptor_data());
            messages.push(CDisplayMarketingMessage::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetMarketingMessagesForUser_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_DoesUserHavePendingMarketingMessages_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_DoesUserHavePendingMarketingMessages_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetDisplayMarketingMessage_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetDisplayMarketingMessage_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_MarkMessageSeen_Notification::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetMarketingMessage_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetMarketingMessage_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_CreateMarketingMessage_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_CreateMarketingMessage_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_UpdateMarketingMessage_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_UpdateMarketingMessage_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_DeleteMarketingMessage_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_DeleteMarketingMessage_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_FindMarketingMessages_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_FindMarketingMessages_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetMarketingMessageViewerStats_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessageHourlyStats::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetMarketingMessageViewerStats_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetMarketingMessagesViewerRangeStats_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetMarketingMessagesViewerRangeStats_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetPartnerReadyToPublishMessages_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetPartnerReadyToPublishMessages_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_PartnerPublishMessage_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_PartnerPublishMessage_Response::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetPartnerMessagePreview_Request::generated_message_descriptor_data());
            messages.push(CMarketingMessages_GetPartnerMessagePreview_Response::generated_message_descriptor_data());
            messages.push(cmarketing_messages_get_marketing_messages_for_user_response::MarketingMessageForUser::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(5);
            enums.push(EMarketingMessageType::generated_enum_descriptor_data());
            enums.push(EMarketingMessageVisibility::generated_enum_descriptor_data());
            enums.push(EMarketingMessageAssociationType::generated_enum_descriptor_data());
            enums.push(EMarketingMessageTemplateType::generated_enum_descriptor_data());
            enums.push(EMarketingMessageLookupType::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
