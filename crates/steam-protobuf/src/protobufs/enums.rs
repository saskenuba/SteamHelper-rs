// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `enums.proto`

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileQueryType)
pub enum EPublishedFileQueryType {
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByVote)
    k_PublishedFileQueryType_RankedByVote = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByPublicationDate)
    k_PublishedFileQueryType_RankedByPublicationDate = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate)
    k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate = 2,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTrend)
    k_PublishedFileQueryType_RankedByTrend = 3,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate)
    k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate = 4,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate)
    k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate = 5,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByNumTimesReported)
    k_PublishedFileQueryType_RankedByNumTimesReported = 6,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate)
    k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate = 7,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_NotYetRated)
    k_PublishedFileQueryType_NotYetRated = 8,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions)
    k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions = 9,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTotalVotesAsc)
    k_PublishedFileQueryType_RankedByTotalVotesAsc = 10,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByVotesUp)
    k_PublishedFileQueryType_RankedByVotesUp = 11,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTextSearch)
    k_PublishedFileQueryType_RankedByTextSearch = 12,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByPlaytimeTrend)
    k_PublishedFileQueryType_RankedByPlaytimeTrend = 13,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByTotalPlaytime)
    k_PublishedFileQueryType_RankedByTotalPlaytime = 14,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByAveragePlaytimeTrend)
    k_PublishedFileQueryType_RankedByAveragePlaytimeTrend = 15,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime)
    k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime = 16,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend)
    k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend = 17,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions)
    k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions = 18,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByInappropriateContentRating)
    k_PublishedFileQueryType_RankedByInappropriateContentRating = 19,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByBanContentCheck)
    k_PublishedFileQueryType_RankedByBanContentCheck = 20,
    // @@protoc_insertion_point(enum_value:EPublishedFileQueryType.k_PublishedFileQueryType_RankedByLastUpdatedDate)
    k_PublishedFileQueryType_RankedByLastUpdatedDate = 21,
}

impl crate::Enum for EPublishedFileQueryType {
    const NAME: &'static str = "EPublishedFileQueryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileQueryType> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote),
            1 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate),
            2 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate),
            3 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend),
            4 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate),
            5 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate),
            6 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported),
            7 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate),
            8 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated),
            9 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions),
            10 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc),
            11 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp),
            12 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch),
            13 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend),
            14 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime),
            15 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend),
            16 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime),
            17 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend),
            18 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions),
            19 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating),
            20 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByBanContentCheck),
            21 => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLastUpdatedDate),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileQueryType> {
        match str {
            "k_PublishedFileQueryType_RankedByVote" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote),
            "k_PublishedFileQueryType_RankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate),
            "k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate),
            "k_PublishedFileQueryType_RankedByTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend),
            "k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate),
            "k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate),
            "k_PublishedFileQueryType_RankedByNumTimesReported" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported),
            "k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate),
            "k_PublishedFileQueryType_NotYetRated" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated),
            "k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions),
            "k_PublishedFileQueryType_RankedByTotalVotesAsc" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc),
            "k_PublishedFileQueryType_RankedByVotesUp" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp),
            "k_PublishedFileQueryType_RankedByTextSearch" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch),
            "k_PublishedFileQueryType_RankedByPlaytimeTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend),
            "k_PublishedFileQueryType_RankedByTotalPlaytime" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime),
            "k_PublishedFileQueryType_RankedByAveragePlaytimeTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend),
            "k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime),
            "k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend),
            "k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions),
            "k_PublishedFileQueryType_RankedByInappropriateContentRating" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating),
            "k_PublishedFileQueryType_RankedByBanContentCheck" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByBanContentCheck),
            "k_PublishedFileQueryType_RankedByLastUpdatedDate" => ::std::option::Option::Some(EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLastUpdatedDate),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileQueryType] = &[
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByNumTimesReported,
        EPublishedFileQueryType::k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate,
        EPublishedFileQueryType::k_PublishedFileQueryType_NotYetRated,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalVotesAsc,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVotesUp,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTextSearch,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByTotalPlaytime,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByAveragePlaytimeTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByInappropriateContentRating,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByBanContentCheck,
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByLastUpdatedDate,
    ];
}

impl crate::EnumFull for EPublishedFileQueryType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPublishedFileQueryType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPublishedFileQueryType {
    fn default() -> Self {
        EPublishedFileQueryType::k_PublishedFileQueryType_RankedByVote
    }
}

impl EPublishedFileQueryType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EPublishedFileQueryType>("EPublishedFileQueryType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileInappropriateProvider)
pub enum EPublishedFileInappropriateProvider {
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateProvider.k_EPublishedFileInappropriateProvider_Invalid)
    k_EPublishedFileInappropriateProvider_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateProvider.k_EPublishedFileInappropriateProvider_Google)
    k_EPublishedFileInappropriateProvider_Google = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateProvider.k_EPublishedFileInappropriateProvider_Amazon)
    k_EPublishedFileInappropriateProvider_Amazon = 2,
}

impl crate::Enum for EPublishedFileInappropriateProvider {
    const NAME: &'static str = "EPublishedFileInappropriateProvider";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileInappropriateProvider> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid),
            1 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google),
            2 => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileInappropriateProvider> {
        match str {
            "k_EPublishedFileInappropriateProvider_Invalid" => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid),
            "k_EPublishedFileInappropriateProvider_Google" => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google),
            "k_EPublishedFileInappropriateProvider_Amazon" => ::std::option::Option::Some(EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileInappropriateProvider] = &[
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid,
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Google,
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Amazon,
    ];
}

impl crate::EnumFull for EPublishedFileInappropriateProvider {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPublishedFileInappropriateProvider").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPublishedFileInappropriateProvider {
    fn default() -> Self {
        EPublishedFileInappropriateProvider::k_EPublishedFileInappropriateProvider_Invalid
    }
}

impl EPublishedFileInappropriateProvider {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EPublishedFileInappropriateProvider>("EPublishedFileInappropriateProvider")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileInappropriateResult)
pub enum EPublishedFileInappropriateResult {
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_NotScanned)
    k_EPublishedFileInappropriateResult_NotScanned = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_VeryUnlikely)
    k_EPublishedFileInappropriateResult_VeryUnlikely = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_Unlikely)
    k_EPublishedFileInappropriateResult_Unlikely = 30,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_Possible)
    k_EPublishedFileInappropriateResult_Possible = 50,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_Likely)
    k_EPublishedFileInappropriateResult_Likely = 75,
    // @@protoc_insertion_point(enum_value:EPublishedFileInappropriateResult.k_EPublishedFileInappropriateResult_VeryLikely)
    k_EPublishedFileInappropriateResult_VeryLikely = 100,
}

impl crate::Enum for EPublishedFileInappropriateResult {
    const NAME: &'static str = "EPublishedFileInappropriateResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileInappropriateResult> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned),
            1 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely),
            30 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely),
            50 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible),
            75 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely),
            100 => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileInappropriateResult> {
        match str {
            "k_EPublishedFileInappropriateResult_NotScanned" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned),
            "k_EPublishedFileInappropriateResult_VeryUnlikely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely),
            "k_EPublishedFileInappropriateResult_Unlikely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely),
            "k_EPublishedFileInappropriateResult_Possible" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible),
            "k_EPublishedFileInappropriateResult_Likely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely),
            "k_EPublishedFileInappropriateResult_VeryLikely" => ::std::option::Option::Some(EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileInappropriateResult] = &[
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely,
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely,
    ];
}

impl crate::EnumFull for EPublishedFileInappropriateResult {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPublishedFileInappropriateResult").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned => 0,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryUnlikely => 1,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Unlikely => 2,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Possible => 3,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_Likely => 4,
            EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_VeryLikely => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPublishedFileInappropriateResult {
    fn default() -> Self {
        EPublishedFileInappropriateResult::k_EPublishedFileInappropriateResult_NotScanned
    }
}

impl EPublishedFileInappropriateResult {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EPublishedFileInappropriateResult>("EPublishedFileInappropriateResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPersonaStateFlag)
pub enum EPersonaStateFlag {
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_HasRichPresence)
    k_EPersonaStateFlag_HasRichPresence = 1,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_InJoinableGame)
    k_EPersonaStateFlag_InJoinableGame = 2,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_Golden)
    k_EPersonaStateFlag_Golden = 4,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_RemotePlayTogether)
    k_EPersonaStateFlag_RemotePlayTogether = 8,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeWeb)
    k_EPersonaStateFlag_ClientTypeWeb = 256,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeMobile)
    k_EPersonaStateFlag_ClientTypeMobile = 512,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeTenfoot)
    k_EPersonaStateFlag_ClientTypeTenfoot = 1024,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_ClientTypeVR)
    k_EPersonaStateFlag_ClientTypeVR = 2048,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_LaunchTypeGamepad)
    k_EPersonaStateFlag_LaunchTypeGamepad = 4096,
    // @@protoc_insertion_point(enum_value:EPersonaStateFlag.k_EPersonaStateFlag_LaunchTypeCompatTool)
    k_EPersonaStateFlag_LaunchTypeCompatTool = 8192,
}

impl crate::Enum for EPersonaStateFlag {
    const NAME: &'static str = "EPersonaStateFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPersonaStateFlag> {
        match value {
            1 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence),
            2 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame),
            4 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_Golden),
            8 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether),
            256 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb),
            512 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile),
            1024 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot),
            2048 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR),
            4096 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad),
            8192 => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPersonaStateFlag> {
        match str {
            "k_EPersonaStateFlag_HasRichPresence" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence),
            "k_EPersonaStateFlag_InJoinableGame" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame),
            "k_EPersonaStateFlag_Golden" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_Golden),
            "k_EPersonaStateFlag_RemotePlayTogether" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether),
            "k_EPersonaStateFlag_ClientTypeWeb" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb),
            "k_EPersonaStateFlag_ClientTypeMobile" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile),
            "k_EPersonaStateFlag_ClientTypeTenfoot" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot),
            "k_EPersonaStateFlag_ClientTypeVR" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR),
            "k_EPersonaStateFlag_LaunchTypeGamepad" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad),
            "k_EPersonaStateFlag_LaunchTypeCompatTool" => ::std::option::Option::Some(EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPersonaStateFlag] = &[
        EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence,
        EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame,
        EPersonaStateFlag::k_EPersonaStateFlag_Golden,
        EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot,
        EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR,
        EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad,
        EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool,
    ];
}

impl crate::EnumFull for EPersonaStateFlag {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPersonaStateFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence => 0,
            EPersonaStateFlag::k_EPersonaStateFlag_InJoinableGame => 1,
            EPersonaStateFlag::k_EPersonaStateFlag_Golden => 2,
            EPersonaStateFlag::k_EPersonaStateFlag_RemotePlayTogether => 3,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeWeb => 4,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeMobile => 5,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeTenfoot => 6,
            EPersonaStateFlag::k_EPersonaStateFlag_ClientTypeVR => 7,
            EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeGamepad => 8,
            EPersonaStateFlag::k_EPersonaStateFlag_LaunchTypeCompatTool => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EPersonaStateFlag {
    fn default() -> Self {
        EPersonaStateFlag::k_EPersonaStateFlag_HasRichPresence
    }
}

impl EPersonaStateFlag {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EPersonaStateFlag>("EPersonaStateFlag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EContentCheckProvider)
pub enum EContentCheckProvider {
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Invalid)
    k_EContentCheckProvider_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Google_DEPRECATED)
    k_EContentCheckProvider_Google_DEPRECATED = 1,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Amazon)
    k_EContentCheckProvider_Amazon = 2,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_Local)
    k_EContentCheckProvider_Local = 3,
    // @@protoc_insertion_point(enum_value:EContentCheckProvider.k_EContentCheckProvider_GoogleVertexAI)
    k_EContentCheckProvider_GoogleVertexAI = 4,
}

impl crate::Enum for EContentCheckProvider {
    const NAME: &'static str = "EContentCheckProvider";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EContentCheckProvider> {
        match value {
            0 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Invalid),
            1 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Google_DEPRECATED),
            2 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Amazon),
            3 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Local),
            4 => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_GoogleVertexAI),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EContentCheckProvider> {
        match str {
            "k_EContentCheckProvider_Invalid" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Invalid),
            "k_EContentCheckProvider_Google_DEPRECATED" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Google_DEPRECATED),
            "k_EContentCheckProvider_Amazon" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Amazon),
            "k_EContentCheckProvider_Local" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_Local),
            "k_EContentCheckProvider_GoogleVertexAI" => ::std::option::Option::Some(EContentCheckProvider::k_EContentCheckProvider_GoogleVertexAI),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EContentCheckProvider] = &[
        EContentCheckProvider::k_EContentCheckProvider_Invalid,
        EContentCheckProvider::k_EContentCheckProvider_Google_DEPRECATED,
        EContentCheckProvider::k_EContentCheckProvider_Amazon,
        EContentCheckProvider::k_EContentCheckProvider_Local,
        EContentCheckProvider::k_EContentCheckProvider_GoogleVertexAI,
    ];
}

impl crate::EnumFull for EContentCheckProvider {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EContentCheckProvider").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EContentCheckProvider {
    fn default() -> Self {
        EContentCheckProvider::k_EContentCheckProvider_Invalid
    }
}

impl EContentCheckProvider {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EContentCheckProvider>("EContentCheckProvider")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProfileCustomizationType)
pub enum EProfileCustomizationType {
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeInvalid)
    k_EProfileCustomizationTypeInvalid = 0,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeRareAchievementShowcase)
    k_EProfileCustomizationTypeRareAchievementShowcase = 1,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeGameCollector)
    k_EProfileCustomizationTypeGameCollector = 2,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeItemShowcase)
    k_EProfileCustomizationTypeItemShowcase = 3,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeTradeShowcase)
    k_EProfileCustomizationTypeTradeShowcase = 4,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeBadges)
    k_EProfileCustomizationTypeBadges = 5,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeFavoriteGame)
    k_EProfileCustomizationTypeFavoriteGame = 6,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeScreenshotShowcase)
    k_EProfileCustomizationTypeScreenshotShowcase = 7,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeCustomText)
    k_EProfileCustomizationTypeCustomText = 8,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeFavoriteGroup)
    k_EProfileCustomizationTypeFavoriteGroup = 9,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeRecommendation)
    k_EProfileCustomizationTypeRecommendation = 10,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeWorkshopItem)
    k_EProfileCustomizationTypeWorkshopItem = 11,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeMyWorkshop)
    k_EProfileCustomizationTypeMyWorkshop = 12,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeArtworkShowcase)
    k_EProfileCustomizationTypeArtworkShowcase = 13,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeVideoShowcase)
    k_EProfileCustomizationTypeVideoShowcase = 14,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeGuides)
    k_EProfileCustomizationTypeGuides = 15,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeMyGuides)
    k_EProfileCustomizationTypeMyGuides = 16,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeAchievements)
    k_EProfileCustomizationTypeAchievements = 17,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeGreenlight)
    k_EProfileCustomizationTypeGreenlight = 18,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeMyGreenlight)
    k_EProfileCustomizationTypeMyGreenlight = 19,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeSalien)
    k_EProfileCustomizationTypeSalien = 20,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeLoyaltyRewardReactions)
    k_EProfileCustomizationTypeLoyaltyRewardReactions = 21,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeSingleArtworkShowcase)
    k_EProfileCustomizationTypeSingleArtworkShowcase = 22,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeAchievementsCompletionist)
    k_EProfileCustomizationTypeAchievementsCompletionist = 23,
    // @@protoc_insertion_point(enum_value:EProfileCustomizationType.k_EProfileCustomizationTypeReplay)
    k_EProfileCustomizationTypeReplay = 24,
}

impl crate::Enum for EProfileCustomizationType {
    const NAME: &'static str = "EProfileCustomizationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProfileCustomizationType> {
        match value {
            0 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeInvalid),
            1 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase),
            2 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector),
            3 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase),
            4 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase),
            5 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeBadges),
            6 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame),
            7 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase),
            8 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeCustomText),
            9 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup),
            10 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation),
            11 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem),
            12 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop),
            13 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase),
            14 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase),
            15 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGuides),
            16 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides),
            17 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievements),
            18 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight),
            19 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight),
            20 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSalien),
            21 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeLoyaltyRewardReactions),
            22 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSingleArtworkShowcase),
            23 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievementsCompletionist),
            24 => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeReplay),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProfileCustomizationType> {
        match str {
            "k_EProfileCustomizationTypeInvalid" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeInvalid),
            "k_EProfileCustomizationTypeRareAchievementShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase),
            "k_EProfileCustomizationTypeGameCollector" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector),
            "k_EProfileCustomizationTypeItemShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase),
            "k_EProfileCustomizationTypeTradeShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase),
            "k_EProfileCustomizationTypeBadges" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeBadges),
            "k_EProfileCustomizationTypeFavoriteGame" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame),
            "k_EProfileCustomizationTypeScreenshotShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase),
            "k_EProfileCustomizationTypeCustomText" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeCustomText),
            "k_EProfileCustomizationTypeFavoriteGroup" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup),
            "k_EProfileCustomizationTypeRecommendation" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation),
            "k_EProfileCustomizationTypeWorkshopItem" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem),
            "k_EProfileCustomizationTypeMyWorkshop" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop),
            "k_EProfileCustomizationTypeArtworkShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase),
            "k_EProfileCustomizationTypeVideoShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase),
            "k_EProfileCustomizationTypeGuides" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGuides),
            "k_EProfileCustomizationTypeMyGuides" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides),
            "k_EProfileCustomizationTypeAchievements" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievements),
            "k_EProfileCustomizationTypeGreenlight" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight),
            "k_EProfileCustomizationTypeMyGreenlight" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight),
            "k_EProfileCustomizationTypeSalien" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSalien),
            "k_EProfileCustomizationTypeLoyaltyRewardReactions" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeLoyaltyRewardReactions),
            "k_EProfileCustomizationTypeSingleArtworkShowcase" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeSingleArtworkShowcase),
            "k_EProfileCustomizationTypeAchievementsCompletionist" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeAchievementsCompletionist),
            "k_EProfileCustomizationTypeReplay" => ::std::option::Option::Some(EProfileCustomizationType::k_EProfileCustomizationTypeReplay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProfileCustomizationType] = &[
        EProfileCustomizationType::k_EProfileCustomizationTypeInvalid,
        EProfileCustomizationType::k_EProfileCustomizationTypeRareAchievementShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeGameCollector,
        EProfileCustomizationType::k_EProfileCustomizationTypeItemShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeTradeShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeBadges,
        EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGame,
        EProfileCustomizationType::k_EProfileCustomizationTypeScreenshotShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeCustomText,
        EProfileCustomizationType::k_EProfileCustomizationTypeFavoriteGroup,
        EProfileCustomizationType::k_EProfileCustomizationTypeRecommendation,
        EProfileCustomizationType::k_EProfileCustomizationTypeWorkshopItem,
        EProfileCustomizationType::k_EProfileCustomizationTypeMyWorkshop,
        EProfileCustomizationType::k_EProfileCustomizationTypeArtworkShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeVideoShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeGuides,
        EProfileCustomizationType::k_EProfileCustomizationTypeMyGuides,
        EProfileCustomizationType::k_EProfileCustomizationTypeAchievements,
        EProfileCustomizationType::k_EProfileCustomizationTypeGreenlight,
        EProfileCustomizationType::k_EProfileCustomizationTypeMyGreenlight,
        EProfileCustomizationType::k_EProfileCustomizationTypeSalien,
        EProfileCustomizationType::k_EProfileCustomizationTypeLoyaltyRewardReactions,
        EProfileCustomizationType::k_EProfileCustomizationTypeSingleArtworkShowcase,
        EProfileCustomizationType::k_EProfileCustomizationTypeAchievementsCompletionist,
        EProfileCustomizationType::k_EProfileCustomizationTypeReplay,
    ];
}

impl crate::EnumFull for EProfileCustomizationType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EProfileCustomizationType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EProfileCustomizationType {
    fn default() -> Self {
        EProfileCustomizationType::k_EProfileCustomizationTypeInvalid
    }
}

impl EProfileCustomizationType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EProfileCustomizationType>("EProfileCustomizationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPublishedFileStorageSystem)
pub enum EPublishedFileStorageSystem {
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemInvalid)
    k_EPublishedFileStorageSystemInvalid = 0,
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemLegacyCloud)
    k_EPublishedFileStorageSystemLegacyCloud = 1,
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemDepot)
    k_EPublishedFileStorageSystemDepot = 2,
    // @@protoc_insertion_point(enum_value:EPublishedFileStorageSystem.k_EPublishedFileStorageSystemUGCCloud)
    k_EPublishedFileStorageSystemUGCCloud = 3,
}

impl crate::Enum for EPublishedFileStorageSystem {
    const NAME: &'static str = "EPublishedFileStorageSystem";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPublishedFileStorageSystem> {
        match value {
            0 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid),
            1 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemLegacyCloud),
            2 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemDepot),
            3 => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemUGCCloud),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPublishedFileStorageSystem> {
        match str {
            "k_EPublishedFileStorageSystemInvalid" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid),
            "k_EPublishedFileStorageSystemLegacyCloud" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemLegacyCloud),
            "k_EPublishedFileStorageSystemDepot" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemDepot),
            "k_EPublishedFileStorageSystemUGCCloud" => ::std::option::Option::Some(EPublishedFileStorageSystem::k_EPublishedFileStorageSystemUGCCloud),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPublishedFileStorageSystem] = &[
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid,
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemLegacyCloud,
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemDepot,
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemUGCCloud,
    ];
}

impl crate::EnumFull for EPublishedFileStorageSystem {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EPublishedFileStorageSystem").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EPublishedFileStorageSystem {
    fn default() -> Self {
        EPublishedFileStorageSystem::k_EPublishedFileStorageSystemInvalid
    }
}

impl EPublishedFileStorageSystem {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EPublishedFileStorageSystem>("EPublishedFileStorageSystem")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECloudStoragePersistState)
pub enum ECloudStoragePersistState {
    // @@protoc_insertion_point(enum_value:ECloudStoragePersistState.k_ECloudStoragePersistStatePersisted)
    k_ECloudStoragePersistStatePersisted = 0,
    // @@protoc_insertion_point(enum_value:ECloudStoragePersistState.k_ECloudStoragePersistStateForgotten)
    k_ECloudStoragePersistStateForgotten = 1,
    // @@protoc_insertion_point(enum_value:ECloudStoragePersistState.k_ECloudStoragePersistStateDeleted)
    k_ECloudStoragePersistStateDeleted = 2,
}

impl crate::Enum for ECloudStoragePersistState {
    const NAME: &'static str = "ECloudStoragePersistState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECloudStoragePersistState> {
        match value {
            0 => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted),
            1 => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateForgotten),
            2 => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateDeleted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECloudStoragePersistState> {
        match str {
            "k_ECloudStoragePersistStatePersisted" => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted),
            "k_ECloudStoragePersistStateForgotten" => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateForgotten),
            "k_ECloudStoragePersistStateDeleted" => ::std::option::Option::Some(ECloudStoragePersistState::k_ECloudStoragePersistStateDeleted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECloudStoragePersistState] = &[
        ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted,
        ECloudStoragePersistState::k_ECloudStoragePersistStateForgotten,
        ECloudStoragePersistState::k_ECloudStoragePersistStateDeleted,
    ];
}

impl crate::EnumFull for ECloudStoragePersistState {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECloudStoragePersistState").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECloudStoragePersistState {
    fn default() -> Self {
        ECloudStoragePersistState::k_ECloudStoragePersistStatePersisted
    }
}

impl ECloudStoragePersistState {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ECloudStoragePersistState>("ECloudStoragePersistState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESDCardFormatStage)
pub enum ESDCardFormatStage {
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Invalid)
    k_ESDCardFormatStage_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Starting)
    k_ESDCardFormatStage_Starting = 1,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Testing)
    k_ESDCardFormatStage_Testing = 2,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Rescuing)
    k_ESDCardFormatStage_Rescuing = 3,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Formatting)
    k_ESDCardFormatStage_Formatting = 4,
    // @@protoc_insertion_point(enum_value:ESDCardFormatStage.k_ESDCardFormatStage_Finalizing)
    k_ESDCardFormatStage_Finalizing = 5,
}

impl crate::Enum for ESDCardFormatStage {
    const NAME: &'static str = "ESDCardFormatStage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESDCardFormatStage> {
        match value {
            0 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Invalid),
            1 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Starting),
            2 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Testing),
            3 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Rescuing),
            4 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Formatting),
            5 => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESDCardFormatStage> {
        match str {
            "k_ESDCardFormatStage_Invalid" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Invalid),
            "k_ESDCardFormatStage_Starting" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Starting),
            "k_ESDCardFormatStage_Testing" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Testing),
            "k_ESDCardFormatStage_Rescuing" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Rescuing),
            "k_ESDCardFormatStage_Formatting" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Formatting),
            "k_ESDCardFormatStage_Finalizing" => ::std::option::Option::Some(ESDCardFormatStage::k_ESDCardFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESDCardFormatStage] = &[
        ESDCardFormatStage::k_ESDCardFormatStage_Invalid,
        ESDCardFormatStage::k_ESDCardFormatStage_Starting,
        ESDCardFormatStage::k_ESDCardFormatStage_Testing,
        ESDCardFormatStage::k_ESDCardFormatStage_Rescuing,
        ESDCardFormatStage::k_ESDCardFormatStage_Formatting,
        ESDCardFormatStage::k_ESDCardFormatStage_Finalizing,
    ];
}

impl crate::EnumFull for ESDCardFormatStage {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESDCardFormatStage").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESDCardFormatStage {
    fn default() -> Self {
        ESDCardFormatStage::k_ESDCardFormatStage_Invalid
    }
}

impl ESDCardFormatStage {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESDCardFormatStage>("ESDCardFormatStage")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageFormatStage)
pub enum EStorageFormatStage {
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Invalid)
    k_EStorageFormatStage_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_NotRunning)
    k_EStorageFormatStage_NotRunning = 1,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Starting)
    k_EStorageFormatStage_Starting = 2,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Testing)
    k_EStorageFormatStage_Testing = 3,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Rescuing)
    k_EStorageFormatStage_Rescuing = 4,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Formatting)
    k_EStorageFormatStage_Formatting = 5,
    // @@protoc_insertion_point(enum_value:EStorageFormatStage.k_EStorageFormatStage_Finalizing)
    k_EStorageFormatStage_Finalizing = 6,
}

impl crate::Enum for EStorageFormatStage {
    const NAME: &'static str = "EStorageFormatStage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageFormatStage> {
        match value {
            0 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Invalid),
            1 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_NotRunning),
            2 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Starting),
            3 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Testing),
            4 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Rescuing),
            5 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Formatting),
            6 => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageFormatStage> {
        match str {
            "k_EStorageFormatStage_Invalid" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Invalid),
            "k_EStorageFormatStage_NotRunning" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_NotRunning),
            "k_EStorageFormatStage_Starting" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Starting),
            "k_EStorageFormatStage_Testing" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Testing),
            "k_EStorageFormatStage_Rescuing" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Rescuing),
            "k_EStorageFormatStage_Formatting" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Formatting),
            "k_EStorageFormatStage_Finalizing" => ::std::option::Option::Some(EStorageFormatStage::k_EStorageFormatStage_Finalizing),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageFormatStage] = &[
        EStorageFormatStage::k_EStorageFormatStage_Invalid,
        EStorageFormatStage::k_EStorageFormatStage_NotRunning,
        EStorageFormatStage::k_EStorageFormatStage_Starting,
        EStorageFormatStage::k_EStorageFormatStage_Testing,
        EStorageFormatStage::k_EStorageFormatStage_Rescuing,
        EStorageFormatStage::k_EStorageFormatStage_Formatting,
        EStorageFormatStage::k_EStorageFormatStage_Finalizing,
    ];
}

impl crate::EnumFull for EStorageFormatStage {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStorageFormatStage").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStorageFormatStage {
    fn default() -> Self {
        EStorageFormatStage::k_EStorageFormatStage_Invalid
    }
}

impl EStorageFormatStage {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStorageFormatStage>("EStorageFormatStage")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemFanControlMode)
pub enum ESystemFanControlMode {
    // @@protoc_insertion_point(enum_value:ESystemFanControlMode.k_SystemFanControlMode_Invalid)
    k_SystemFanControlMode_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemFanControlMode.k_SystemFanControlMode_Disabled)
    k_SystemFanControlMode_Disabled = 1,
    // @@protoc_insertion_point(enum_value:ESystemFanControlMode.k_SystemFanControlMode_Default)
    k_SystemFanControlMode_Default = 2,
}

impl crate::Enum for ESystemFanControlMode {
    const NAME: &'static str = "ESystemFanControlMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemFanControlMode> {
        match value {
            0 => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Invalid),
            1 => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Disabled),
            2 => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Default),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemFanControlMode> {
        match str {
            "k_SystemFanControlMode_Invalid" => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Invalid),
            "k_SystemFanControlMode_Disabled" => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Disabled),
            "k_SystemFanControlMode_Default" => ::std::option::Option::Some(ESystemFanControlMode::k_SystemFanControlMode_Default),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemFanControlMode] = &[
        ESystemFanControlMode::k_SystemFanControlMode_Invalid,
        ESystemFanControlMode::k_SystemFanControlMode_Disabled,
        ESystemFanControlMode::k_SystemFanControlMode_Default,
    ];
}

impl crate::EnumFull for ESystemFanControlMode {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemFanControlMode").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemFanControlMode {
    fn default() -> Self {
        ESystemFanControlMode::k_SystemFanControlMode_Invalid
    }
}

impl ESystemFanControlMode {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESystemFanControlMode>("ESystemFanControlMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStartupMovieVariant)
pub enum EStartupMovieVariant {
    // @@protoc_insertion_point(enum_value:EStartupMovieVariant.k_EStartupMovieVariant_Invalid)
    k_EStartupMovieVariant_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStartupMovieVariant.k_EStartupMovieVariant_Default)
    k_EStartupMovieVariant_Default = 1,
    // @@protoc_insertion_point(enum_value:EStartupMovieVariant.k_EStartupMovieVariant_Orange)
    k_EStartupMovieVariant_Orange = 2,
}

impl crate::Enum for EStartupMovieVariant {
    const NAME: &'static str = "EStartupMovieVariant";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStartupMovieVariant> {
        match value {
            0 => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Invalid),
            1 => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Default),
            2 => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Orange),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStartupMovieVariant> {
        match str {
            "k_EStartupMovieVariant_Invalid" => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Invalid),
            "k_EStartupMovieVariant_Default" => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Default),
            "k_EStartupMovieVariant_Orange" => ::std::option::Option::Some(EStartupMovieVariant::k_EStartupMovieVariant_Orange),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStartupMovieVariant] = &[
        EStartupMovieVariant::k_EStartupMovieVariant_Invalid,
        EStartupMovieVariant::k_EStartupMovieVariant_Default,
        EStartupMovieVariant::k_EStartupMovieVariant_Orange,
    ];
}

impl crate::EnumFull for EStartupMovieVariant {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStartupMovieVariant").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStartupMovieVariant {
    fn default() -> Self {
        EStartupMovieVariant::k_EStartupMovieVariant_Invalid
    }
}

impl EStartupMovieVariant {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStartupMovieVariant>("EStartupMovieVariant")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EColorGamutLabelSet)
pub enum EColorGamutLabelSet {
    // @@protoc_insertion_point(enum_value:EColorGamutLabelSet.k_ColorGamutLabelSet_Default)
    k_ColorGamutLabelSet_Default = 0,
    // @@protoc_insertion_point(enum_value:EColorGamutLabelSet.k_ColorGamutLabelSet_sRGB_Native)
    k_ColorGamutLabelSet_sRGB_Native = 1,
    // @@protoc_insertion_point(enum_value:EColorGamutLabelSet.k_ColorGamutLabelSet_Native_sRGB_Boosted)
    k_ColorGamutLabelSet_Native_sRGB_Boosted = 2,
}

impl crate::Enum for EColorGamutLabelSet {
    const NAME: &'static str = "EColorGamutLabelSet";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EColorGamutLabelSet> {
        match value {
            0 => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_Default),
            1 => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_sRGB_Native),
            2 => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_Native_sRGB_Boosted),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EColorGamutLabelSet> {
        match str {
            "k_ColorGamutLabelSet_Default" => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_Default),
            "k_ColorGamutLabelSet_sRGB_Native" => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_sRGB_Native),
            "k_ColorGamutLabelSet_Native_sRGB_Boosted" => ::std::option::Option::Some(EColorGamutLabelSet::k_ColorGamutLabelSet_Native_sRGB_Boosted),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EColorGamutLabelSet] = &[
        EColorGamutLabelSet::k_ColorGamutLabelSet_Default,
        EColorGamutLabelSet::k_ColorGamutLabelSet_sRGB_Native,
        EColorGamutLabelSet::k_ColorGamutLabelSet_Native_sRGB_Boosted,
    ];
}

impl crate::EnumFull for EColorGamutLabelSet {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EColorGamutLabelSet").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EColorGamutLabelSet {
    fn default() -> Self {
        EColorGamutLabelSet::k_ColorGamutLabelSet_Default
    }
}

impl EColorGamutLabelSet {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EColorGamutLabelSet>("EColorGamutLabelSet")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBluetoothDeviceType)
pub enum EBluetoothDeviceType {
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Invalid)
    k_BluetoothDeviceType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Unknown)
    k_BluetoothDeviceType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Phone)
    k_BluetoothDeviceType_Phone = 2,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Computer)
    k_BluetoothDeviceType_Computer = 3,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Headset)
    k_BluetoothDeviceType_Headset = 4,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Headphones)
    k_BluetoothDeviceType_Headphones = 5,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Speakers)
    k_BluetoothDeviceType_Speakers = 6,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_OtherAudio)
    k_BluetoothDeviceType_OtherAudio = 7,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Mouse)
    k_BluetoothDeviceType_Mouse = 8,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Joystick)
    k_BluetoothDeviceType_Joystick = 9,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Gamepad)
    k_BluetoothDeviceType_Gamepad = 10,
    // @@protoc_insertion_point(enum_value:EBluetoothDeviceType.k_BluetoothDeviceType_Keyboard)
    k_BluetoothDeviceType_Keyboard = 11,
}

impl crate::Enum for EBluetoothDeviceType {
    const NAME: &'static str = "EBluetoothDeviceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBluetoothDeviceType> {
        match value {
            0 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
            1 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Unknown),
            2 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Phone),
            3 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Computer),
            4 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headset),
            5 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headphones),
            6 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Speakers),
            7 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_OtherAudio),
            8 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Mouse),
            9 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Joystick),
            10 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Gamepad),
            11 => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Keyboard),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBluetoothDeviceType> {
        match str {
            "k_BluetoothDeviceType_Invalid" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Invalid),
            "k_BluetoothDeviceType_Unknown" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Unknown),
            "k_BluetoothDeviceType_Phone" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Phone),
            "k_BluetoothDeviceType_Computer" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Computer),
            "k_BluetoothDeviceType_Headset" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headset),
            "k_BluetoothDeviceType_Headphones" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Headphones),
            "k_BluetoothDeviceType_Speakers" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Speakers),
            "k_BluetoothDeviceType_OtherAudio" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_OtherAudio),
            "k_BluetoothDeviceType_Mouse" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Mouse),
            "k_BluetoothDeviceType_Joystick" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Joystick),
            "k_BluetoothDeviceType_Gamepad" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Gamepad),
            "k_BluetoothDeviceType_Keyboard" => ::std::option::Option::Some(EBluetoothDeviceType::k_BluetoothDeviceType_Keyboard),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBluetoothDeviceType] = &[
        EBluetoothDeviceType::k_BluetoothDeviceType_Invalid,
        EBluetoothDeviceType::k_BluetoothDeviceType_Unknown,
        EBluetoothDeviceType::k_BluetoothDeviceType_Phone,
        EBluetoothDeviceType::k_BluetoothDeviceType_Computer,
        EBluetoothDeviceType::k_BluetoothDeviceType_Headset,
        EBluetoothDeviceType::k_BluetoothDeviceType_Headphones,
        EBluetoothDeviceType::k_BluetoothDeviceType_Speakers,
        EBluetoothDeviceType::k_BluetoothDeviceType_OtherAudio,
        EBluetoothDeviceType::k_BluetoothDeviceType_Mouse,
        EBluetoothDeviceType::k_BluetoothDeviceType_Joystick,
        EBluetoothDeviceType::k_BluetoothDeviceType_Gamepad,
        EBluetoothDeviceType::k_BluetoothDeviceType_Keyboard,
    ];
}

impl crate::EnumFull for EBluetoothDeviceType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBluetoothDeviceType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EBluetoothDeviceType {
    fn default() -> Self {
        EBluetoothDeviceType::k_BluetoothDeviceType_Invalid
    }
}

impl EBluetoothDeviceType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EBluetoothDeviceType>("EBluetoothDeviceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioDirection)
pub enum ESystemAudioDirection {
    // @@protoc_insertion_point(enum_value:ESystemAudioDirection.k_SystemAudioDirection_Invalid)
    k_SystemAudioDirection_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioDirection.k_SystemAudioDirection_Input)
    k_SystemAudioDirection_Input = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioDirection.k_SystemAudioDirection_Output)
    k_SystemAudioDirection_Output = 2,
}

impl crate::Enum for ESystemAudioDirection {
    const NAME: &'static str = "ESystemAudioDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioDirection> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Input),
            2 => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioDirection> {
        match str {
            "k_SystemAudioDirection_Invalid" => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Invalid),
            "k_SystemAudioDirection_Input" => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Input),
            "k_SystemAudioDirection_Output" => ::std::option::Option::Some(ESystemAudioDirection::k_SystemAudioDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioDirection] = &[
        ESystemAudioDirection::k_SystemAudioDirection_Invalid,
        ESystemAudioDirection::k_SystemAudioDirection_Input,
        ESystemAudioDirection::k_SystemAudioDirection_Output,
    ];
}

impl crate::EnumFull for ESystemAudioDirection {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemAudioDirection").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemAudioDirection {
    fn default() -> Self {
        ESystemAudioDirection::k_SystemAudioDirection_Invalid
    }
}

impl ESystemAudioDirection {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESystemAudioDirection>("ESystemAudioDirection")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioChannel)
pub enum ESystemAudioChannel {
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Invalid)
    k_SystemAudioChannel_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Aggregated)
    k_SystemAudioChannel_Aggregated = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_FrontLeft)
    k_SystemAudioChannel_FrontLeft = 2,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_FrontRight)
    k_SystemAudioChannel_FrontRight = 3,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_LFE)
    k_SystemAudioChannel_LFE = 4,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_BackLeft)
    k_SystemAudioChannel_BackLeft = 5,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_BackRight)
    k_SystemAudioChannel_BackRight = 6,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_FrontCenter)
    k_SystemAudioChannel_FrontCenter = 7,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Unknown)
    k_SystemAudioChannel_Unknown = 8,
    // @@protoc_insertion_point(enum_value:ESystemAudioChannel.k_SystemAudioChannel_Mono)
    k_SystemAudioChannel_Mono = 9,
}

impl crate::Enum for ESystemAudioChannel {
    const NAME: &'static str = "ESystemAudioChannel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioChannel> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Aggregated),
            2 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontLeft),
            3 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontRight),
            4 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_LFE),
            5 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackLeft),
            6 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackRight),
            7 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontCenter),
            8 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Unknown),
            9 => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Mono),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioChannel> {
        match str {
            "k_SystemAudioChannel_Invalid" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Invalid),
            "k_SystemAudioChannel_Aggregated" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Aggregated),
            "k_SystemAudioChannel_FrontLeft" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontLeft),
            "k_SystemAudioChannel_FrontRight" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontRight),
            "k_SystemAudioChannel_LFE" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_LFE),
            "k_SystemAudioChannel_BackLeft" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackLeft),
            "k_SystemAudioChannel_BackRight" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_BackRight),
            "k_SystemAudioChannel_FrontCenter" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_FrontCenter),
            "k_SystemAudioChannel_Unknown" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Unknown),
            "k_SystemAudioChannel_Mono" => ::std::option::Option::Some(ESystemAudioChannel::k_SystemAudioChannel_Mono),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioChannel] = &[
        ESystemAudioChannel::k_SystemAudioChannel_Invalid,
        ESystemAudioChannel::k_SystemAudioChannel_Aggregated,
        ESystemAudioChannel::k_SystemAudioChannel_FrontLeft,
        ESystemAudioChannel::k_SystemAudioChannel_FrontRight,
        ESystemAudioChannel::k_SystemAudioChannel_LFE,
        ESystemAudioChannel::k_SystemAudioChannel_BackLeft,
        ESystemAudioChannel::k_SystemAudioChannel_BackRight,
        ESystemAudioChannel::k_SystemAudioChannel_FrontCenter,
        ESystemAudioChannel::k_SystemAudioChannel_Unknown,
        ESystemAudioChannel::k_SystemAudioChannel_Mono,
    ];
}

impl crate::EnumFull for ESystemAudioChannel {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemAudioChannel").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemAudioChannel {
    fn default() -> Self {
        ESystemAudioChannel::k_SystemAudioChannel_Invalid
    }
}

impl ESystemAudioChannel {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESystemAudioChannel>("ESystemAudioChannel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioPortType)
pub enum ESystemAudioPortType {
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Invalid)
    k_SystemAudioPortType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Unknown)
    k_SystemAudioPortType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Audio32f)
    k_SystemAudioPortType_Audio32f = 2,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Midi8b)
    k_SystemAudioPortType_Midi8b = 3,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortType.k_SystemAudioPortType_Video32RGBA)
    k_SystemAudioPortType_Video32RGBA = 4,
}

impl crate::Enum for ESystemAudioPortType {
    const NAME: &'static str = "ESystemAudioPortType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioPortType> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Unknown),
            2 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Audio32f),
            3 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Midi8b),
            4 => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Video32RGBA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioPortType> {
        match str {
            "k_SystemAudioPortType_Invalid" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Invalid),
            "k_SystemAudioPortType_Unknown" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Unknown),
            "k_SystemAudioPortType_Audio32f" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Audio32f),
            "k_SystemAudioPortType_Midi8b" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Midi8b),
            "k_SystemAudioPortType_Video32RGBA" => ::std::option::Option::Some(ESystemAudioPortType::k_SystemAudioPortType_Video32RGBA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioPortType] = &[
        ESystemAudioPortType::k_SystemAudioPortType_Invalid,
        ESystemAudioPortType::k_SystemAudioPortType_Unknown,
        ESystemAudioPortType::k_SystemAudioPortType_Audio32f,
        ESystemAudioPortType::k_SystemAudioPortType_Midi8b,
        ESystemAudioPortType::k_SystemAudioPortType_Video32RGBA,
    ];
}

impl crate::EnumFull for ESystemAudioPortType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemAudioPortType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemAudioPortType {
    fn default() -> Self {
        ESystemAudioPortType::k_SystemAudioPortType_Invalid
    }
}

impl ESystemAudioPortType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESystemAudioPortType>("ESystemAudioPortType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemAudioPortDirection)
pub enum ESystemAudioPortDirection {
    // @@protoc_insertion_point(enum_value:ESystemAudioPortDirection.k_SystemAudioPortDirection_Invalid)
    k_SystemAudioPortDirection_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortDirection.k_SystemAudioPortDirection_Input)
    k_SystemAudioPortDirection_Input = 1,
    // @@protoc_insertion_point(enum_value:ESystemAudioPortDirection.k_SystemAudioPortDirection_Output)
    k_SystemAudioPortDirection_Output = 2,
}

impl crate::Enum for ESystemAudioPortDirection {
    const NAME: &'static str = "ESystemAudioPortDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemAudioPortDirection> {
        match value {
            0 => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid),
            1 => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Input),
            2 => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemAudioPortDirection> {
        match str {
            "k_SystemAudioPortDirection_Invalid" => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid),
            "k_SystemAudioPortDirection_Input" => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Input),
            "k_SystemAudioPortDirection_Output" => ::std::option::Option::Some(ESystemAudioPortDirection::k_SystemAudioPortDirection_Output),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemAudioPortDirection] = &[
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid,
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Input,
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Output,
    ];
}

impl crate::EnumFull for ESystemAudioPortDirection {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemAudioPortDirection").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemAudioPortDirection {
    fn default() -> Self {
        ESystemAudioPortDirection::k_SystemAudioPortDirection_Invalid
    }
}

impl ESystemAudioPortDirection {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESystemAudioPortDirection>("ESystemAudioPortDirection")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemServiceState)
pub enum ESystemServiceState {
    // @@protoc_insertion_point(enum_value:ESystemServiceState.k_ESystemServiceState_Unavailable)
    k_ESystemServiceState_Unavailable = 0,
    // @@protoc_insertion_point(enum_value:ESystemServiceState.k_ESystemServiceState_Disabled)
    k_ESystemServiceState_Disabled = 1,
    // @@protoc_insertion_point(enum_value:ESystemServiceState.k_ESystemServiceState_Enabled)
    k_ESystemServiceState_Enabled = 2,
}

impl crate::Enum for ESystemServiceState {
    const NAME: &'static str = "ESystemServiceState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemServiceState> {
        match value {
            0 => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Unavailable),
            1 => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Disabled),
            2 => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Enabled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemServiceState> {
        match str {
            "k_ESystemServiceState_Unavailable" => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Unavailable),
            "k_ESystemServiceState_Disabled" => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Disabled),
            "k_ESystemServiceState_Enabled" => ::std::option::Option::Some(ESystemServiceState::k_ESystemServiceState_Enabled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemServiceState] = &[
        ESystemServiceState::k_ESystemServiceState_Unavailable,
        ESystemServiceState::k_ESystemServiceState_Disabled,
        ESystemServiceState::k_ESystemServiceState_Enabled,
    ];
}

impl crate::EnumFull for ESystemServiceState {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemServiceState").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemServiceState {
    fn default() -> Self {
        ESystemServiceState::k_ESystemServiceState_Unavailable
    }
}

impl ESystemServiceState {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESystemServiceState>("ESystemServiceState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGraphicsPerfOverlayLevel)
pub enum EGraphicsPerfOverlayLevel {
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Hidden)
    k_EGraphicsPerfOverlayLevel_Hidden = 0,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Basic)
    k_EGraphicsPerfOverlayLevel_Basic = 1,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Medium)
    k_EGraphicsPerfOverlayLevel_Medium = 2,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Full)
    k_EGraphicsPerfOverlayLevel_Full = 3,
    // @@protoc_insertion_point(enum_value:EGraphicsPerfOverlayLevel.k_EGraphicsPerfOverlayLevel_Minimal)
    k_EGraphicsPerfOverlayLevel_Minimal = 4,
}

impl crate::Enum for EGraphicsPerfOverlayLevel {
    const NAME: &'static str = "EGraphicsPerfOverlayLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGraphicsPerfOverlayLevel> {
        match value {
            0 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            1 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Basic),
            2 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Medium),
            3 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Full),
            4 => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Minimal),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGraphicsPerfOverlayLevel> {
        match str {
            "k_EGraphicsPerfOverlayLevel_Hidden" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden),
            "k_EGraphicsPerfOverlayLevel_Basic" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Basic),
            "k_EGraphicsPerfOverlayLevel_Medium" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Medium),
            "k_EGraphicsPerfOverlayLevel_Full" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Full),
            "k_EGraphicsPerfOverlayLevel_Minimal" => ::std::option::Option::Some(EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Minimal),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGraphicsPerfOverlayLevel] = &[
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Basic,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Medium,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Full,
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Minimal,
    ];
}

impl crate::EnumFull for EGraphicsPerfOverlayLevel {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGraphicsPerfOverlayLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGraphicsPerfOverlayLevel {
    fn default() -> Self {
        EGraphicsPerfOverlayLevel::k_EGraphicsPerfOverlayLevel_Hidden
    }
}

impl EGraphicsPerfOverlayLevel {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EGraphicsPerfOverlayLevel>("EGraphicsPerfOverlayLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGPUPerformanceLevel)
pub enum EGPUPerformanceLevel {
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Invalid)
    k_EGPUPerformanceLevel_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Auto)
    k_EGPUPerformanceLevel_Auto = 1,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Manual)
    k_EGPUPerformanceLevel_Manual = 2,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Low)
    k_EGPUPerformanceLevel_Low = 3,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_High)
    k_EGPUPerformanceLevel_High = 4,
    // @@protoc_insertion_point(enum_value:EGPUPerformanceLevel.k_EGPUPerformanceLevel_Profiling)
    k_EGPUPerformanceLevel_Profiling = 5,
}

impl crate::Enum for EGPUPerformanceLevel {
    const NAME: &'static str = "EGPUPerformanceLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGPUPerformanceLevel> {
        match value {
            0 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            1 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Auto),
            2 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Manual),
            3 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Low),
            4 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_High),
            5 => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Profiling),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGPUPerformanceLevel> {
        match str {
            "k_EGPUPerformanceLevel_Invalid" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid),
            "k_EGPUPerformanceLevel_Auto" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Auto),
            "k_EGPUPerformanceLevel_Manual" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Manual),
            "k_EGPUPerformanceLevel_Low" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Low),
            "k_EGPUPerformanceLevel_High" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_High),
            "k_EGPUPerformanceLevel_Profiling" => ::std::option::Option::Some(EGPUPerformanceLevel::k_EGPUPerformanceLevel_Profiling),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGPUPerformanceLevel] = &[
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Auto,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Manual,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Low,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_High,
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Profiling,
    ];
}

impl crate::EnumFull for EGPUPerformanceLevel {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGPUPerformanceLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGPUPerformanceLevel {
    fn default() -> Self {
        EGPUPerformanceLevel::k_EGPUPerformanceLevel_Invalid
    }
}

impl EGPUPerformanceLevel {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EGPUPerformanceLevel>("EGPUPerformanceLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EScalingFilter)
pub enum EScalingFilter {
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Invalid)
    k_EScalingFilter_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_FSR)
    k_EScalingFilter_FSR = 1,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Nearest)
    k_EScalingFilter_Nearest = 2,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Integer)
    k_EScalingFilter_Integer = 3,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_Linear)
    k_EScalingFilter_Linear = 4,
    // @@protoc_insertion_point(enum_value:EScalingFilter.k_EScalingFilter_NIS)
    k_EScalingFilter_NIS = 5,
}

impl crate::Enum for EScalingFilter {
    const NAME: &'static str = "EScalingFilter";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EScalingFilter> {
        match value {
            0 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Invalid),
            1 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_FSR),
            2 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Nearest),
            3 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Integer),
            4 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Linear),
            5 => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EScalingFilter> {
        match str {
            "k_EScalingFilter_Invalid" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Invalid),
            "k_EScalingFilter_FSR" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_FSR),
            "k_EScalingFilter_Nearest" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Nearest),
            "k_EScalingFilter_Integer" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Integer),
            "k_EScalingFilter_Linear" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_Linear),
            "k_EScalingFilter_NIS" => ::std::option::Option::Some(EScalingFilter::k_EScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EScalingFilter] = &[
        EScalingFilter::k_EScalingFilter_Invalid,
        EScalingFilter::k_EScalingFilter_FSR,
        EScalingFilter::k_EScalingFilter_Nearest,
        EScalingFilter::k_EScalingFilter_Integer,
        EScalingFilter::k_EScalingFilter_Linear,
        EScalingFilter::k_EScalingFilter_NIS,
    ];
}

impl crate::EnumFull for EScalingFilter {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EScalingFilter").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EScalingFilter {
    fn default() -> Self {
        EScalingFilter::k_EScalingFilter_Invalid
    }
}

impl EScalingFilter {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EScalingFilter>("EScalingFilter")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESplitScalingFilter)
pub enum ESplitScalingFilter {
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_Invalid)
    k_ESplitScalingFilter_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_Linear)
    k_ESplitScalingFilter_Linear = 1,
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_Nearest)
    k_ESplitScalingFilter_Nearest = 2,
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_FSR)
    k_ESplitScalingFilter_FSR = 3,
    // @@protoc_insertion_point(enum_value:ESplitScalingFilter.k_ESplitScalingFilter_NIS)
    k_ESplitScalingFilter_NIS = 4,
}

impl crate::Enum for ESplitScalingFilter {
    const NAME: &'static str = "ESplitScalingFilter";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESplitScalingFilter> {
        match value {
            0 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Invalid),
            1 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Linear),
            2 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Nearest),
            3 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_FSR),
            4 => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESplitScalingFilter> {
        match str {
            "k_ESplitScalingFilter_Invalid" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Invalid),
            "k_ESplitScalingFilter_Linear" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Linear),
            "k_ESplitScalingFilter_Nearest" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_Nearest),
            "k_ESplitScalingFilter_FSR" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_FSR),
            "k_ESplitScalingFilter_NIS" => ::std::option::Option::Some(ESplitScalingFilter::k_ESplitScalingFilter_NIS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESplitScalingFilter] = &[
        ESplitScalingFilter::k_ESplitScalingFilter_Invalid,
        ESplitScalingFilter::k_ESplitScalingFilter_Linear,
        ESplitScalingFilter::k_ESplitScalingFilter_Nearest,
        ESplitScalingFilter::k_ESplitScalingFilter_FSR,
        ESplitScalingFilter::k_ESplitScalingFilter_NIS,
    ];
}

impl crate::EnumFull for ESplitScalingFilter {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESplitScalingFilter").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESplitScalingFilter {
    fn default() -> Self {
        ESplitScalingFilter::k_ESplitScalingFilter_Invalid
    }
}

impl ESplitScalingFilter {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESplitScalingFilter>("ESplitScalingFilter")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESplitScalingScaler)
pub enum ESplitScalingScaler {
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Invalid)
    k_ESplitScalingScaler_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Auto)
    k_ESplitScalingScaler_Auto = 1,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Integer)
    k_ESplitScalingScaler_Integer = 2,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Fit)
    k_ESplitScalingScaler_Fit = 3,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Fill)
    k_ESplitScalingScaler_Fill = 4,
    // @@protoc_insertion_point(enum_value:ESplitScalingScaler.k_ESplitScalingScaler_Stretch)
    k_ESplitScalingScaler_Stretch = 5,
}

impl crate::Enum for ESplitScalingScaler {
    const NAME: &'static str = "ESplitScalingScaler";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESplitScalingScaler> {
        match value {
            0 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Invalid),
            1 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Auto),
            2 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Integer),
            3 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Fit),
            4 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Fill),
            5 => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Stretch),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESplitScalingScaler> {
        match str {
            "k_ESplitScalingScaler_Invalid" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Invalid),
            "k_ESplitScalingScaler_Auto" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Auto),
            "k_ESplitScalingScaler_Integer" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Integer),
            "k_ESplitScalingScaler_Fit" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Fit),
            "k_ESplitScalingScaler_Fill" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Fill),
            "k_ESplitScalingScaler_Stretch" => ::std::option::Option::Some(ESplitScalingScaler::k_ESplitScalingScaler_Stretch),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESplitScalingScaler] = &[
        ESplitScalingScaler::k_ESplitScalingScaler_Invalid,
        ESplitScalingScaler::k_ESplitScalingScaler_Auto,
        ESplitScalingScaler::k_ESplitScalingScaler_Integer,
        ESplitScalingScaler::k_ESplitScalingScaler_Fit,
        ESplitScalingScaler::k_ESplitScalingScaler_Fill,
        ESplitScalingScaler::k_ESplitScalingScaler_Stretch,
    ];
}

impl crate::EnumFull for ESplitScalingScaler {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESplitScalingScaler").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESplitScalingScaler {
    fn default() -> Self {
        ESplitScalingScaler::k_ESplitScalingScaler_Invalid
    }
}

impl ESplitScalingScaler {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESplitScalingScaler>("ESplitScalingScaler")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGamescopeBlurMode)
pub enum EGamescopeBlurMode {
    // @@protoc_insertion_point(enum_value:EGamescopeBlurMode.k_EGamescopeBlurMode_Disabled)
    k_EGamescopeBlurMode_Disabled = 0,
    // @@protoc_insertion_point(enum_value:EGamescopeBlurMode.k_EGamescopeBlurMode_IfOccluded)
    k_EGamescopeBlurMode_IfOccluded = 1,
    // @@protoc_insertion_point(enum_value:EGamescopeBlurMode.k_EGamescopeBlurMode_Always)
    k_EGamescopeBlurMode_Always = 2,
}

impl crate::Enum for EGamescopeBlurMode {
    const NAME: &'static str = "EGamescopeBlurMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGamescopeBlurMode> {
        match value {
            0 => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_Disabled),
            1 => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_IfOccluded),
            2 => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_Always),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGamescopeBlurMode> {
        match str {
            "k_EGamescopeBlurMode_Disabled" => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_Disabled),
            "k_EGamescopeBlurMode_IfOccluded" => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_IfOccluded),
            "k_EGamescopeBlurMode_Always" => ::std::option::Option::Some(EGamescopeBlurMode::k_EGamescopeBlurMode_Always),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGamescopeBlurMode] = &[
        EGamescopeBlurMode::k_EGamescopeBlurMode_Disabled,
        EGamescopeBlurMode::k_EGamescopeBlurMode_IfOccluded,
        EGamescopeBlurMode::k_EGamescopeBlurMode_Always,
    ];
}

impl crate::EnumFull for EGamescopeBlurMode {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGamescopeBlurMode").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EGamescopeBlurMode {
    fn default() -> Self {
        EGamescopeBlurMode::k_EGamescopeBlurMode_Disabled
    }
}

impl EGamescopeBlurMode {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EGamescopeBlurMode>("EGamescopeBlurMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESLSHelper)
pub enum ESLSHelper {
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Invalid)
    k_ESLSHelper_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Minidump)
    k_ESLSHelper_Minidump = 1,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Kdump)
    k_ESLSHelper_Kdump = 2,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Journal)
    k_ESLSHelper_Journal = 3,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_Gpu)
    k_ESLSHelper_Gpu = 4,
    // @@protoc_insertion_point(enum_value:ESLSHelper.k_ESLSHelper_SystemInfo)
    k_ESLSHelper_SystemInfo = 5,
}

impl crate::Enum for ESLSHelper {
    const NAME: &'static str = "ESLSHelper";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESLSHelper> {
        match value {
            0 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Invalid),
            1 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Minidump),
            2 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Kdump),
            3 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Journal),
            4 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Gpu),
            5 => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_SystemInfo),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESLSHelper> {
        match str {
            "k_ESLSHelper_Invalid" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Invalid),
            "k_ESLSHelper_Minidump" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Minidump),
            "k_ESLSHelper_Kdump" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Kdump),
            "k_ESLSHelper_Journal" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Journal),
            "k_ESLSHelper_Gpu" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_Gpu),
            "k_ESLSHelper_SystemInfo" => ::std::option::Option::Some(ESLSHelper::k_ESLSHelper_SystemInfo),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESLSHelper] = &[
        ESLSHelper::k_ESLSHelper_Invalid,
        ESLSHelper::k_ESLSHelper_Minidump,
        ESLSHelper::k_ESLSHelper_Kdump,
        ESLSHelper::k_ESLSHelper_Journal,
        ESLSHelper::k_ESLSHelper_Gpu,
        ESLSHelper::k_ESLSHelper_SystemInfo,
    ];
}

impl crate::EnumFull for ESLSHelper {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESLSHelper").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESLSHelper {
    fn default() -> Self {
        ESLSHelper::k_ESLSHelper_Invalid
    }
}

impl ESLSHelper {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESLSHelper>("ESLSHelper")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHDRVisualization)
pub enum EHDRVisualization {
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_None)
    k_EHDRVisualization_None = 0,
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_Heatmap)
    k_EHDRVisualization_Heatmap = 1,
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_Analysis)
    k_EHDRVisualization_Analysis = 2,
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_HeatmapExtended)
    k_EHDRVisualization_HeatmapExtended = 3,
    // @@protoc_insertion_point(enum_value:EHDRVisualization.k_EHDRVisualization_HeatmapClassic)
    k_EHDRVisualization_HeatmapClassic = 4,
}

impl crate::Enum for EHDRVisualization {
    const NAME: &'static str = "EHDRVisualization";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHDRVisualization> {
        match value {
            0 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_None),
            1 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_Heatmap),
            2 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_Analysis),
            3 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_HeatmapExtended),
            4 => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_HeatmapClassic),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHDRVisualization> {
        match str {
            "k_EHDRVisualization_None" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_None),
            "k_EHDRVisualization_Heatmap" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_Heatmap),
            "k_EHDRVisualization_Analysis" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_Analysis),
            "k_EHDRVisualization_HeatmapExtended" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_HeatmapExtended),
            "k_EHDRVisualization_HeatmapClassic" => ::std::option::Option::Some(EHDRVisualization::k_EHDRVisualization_HeatmapClassic),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHDRVisualization] = &[
        EHDRVisualization::k_EHDRVisualization_None,
        EHDRVisualization::k_EHDRVisualization_Heatmap,
        EHDRVisualization::k_EHDRVisualization_Analysis,
        EHDRVisualization::k_EHDRVisualization_HeatmapExtended,
        EHDRVisualization::k_EHDRVisualization_HeatmapClassic,
    ];
}

impl crate::EnumFull for EHDRVisualization {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EHDRVisualization").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EHDRVisualization {
    fn default() -> Self {
        EHDRVisualization::k_EHDRVisualization_None
    }
}

impl EHDRVisualization {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EHDRVisualization>("EHDRVisualization")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHDRToneMapOperator)
pub enum EHDRToneMapOperator {
    // @@protoc_insertion_point(enum_value:EHDRToneMapOperator.k_EHDRToneMapOperator_Invalid)
    k_EHDRToneMapOperator_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EHDRToneMapOperator.k_EHDRToneMapOperator_Uncharted)
    k_EHDRToneMapOperator_Uncharted = 1,
    // @@protoc_insertion_point(enum_value:EHDRToneMapOperator.k_EHDRToneMapOperator_Reinhard)
    k_EHDRToneMapOperator_Reinhard = 2,
}

impl crate::Enum for EHDRToneMapOperator {
    const NAME: &'static str = "EHDRToneMapOperator";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHDRToneMapOperator> {
        match value {
            0 => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid),
            1 => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Uncharted),
            2 => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Reinhard),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHDRToneMapOperator> {
        match str {
            "k_EHDRToneMapOperator_Invalid" => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid),
            "k_EHDRToneMapOperator_Uncharted" => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Uncharted),
            "k_EHDRToneMapOperator_Reinhard" => ::std::option::Option::Some(EHDRToneMapOperator::k_EHDRToneMapOperator_Reinhard),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHDRToneMapOperator] = &[
        EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid,
        EHDRToneMapOperator::k_EHDRToneMapOperator_Uncharted,
        EHDRToneMapOperator::k_EHDRToneMapOperator_Reinhard,
    ];
}

impl crate::EnumFull for EHDRToneMapOperator {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EHDRToneMapOperator").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EHDRToneMapOperator {
    fn default() -> Self {
        EHDRToneMapOperator::k_EHDRToneMapOperator_Invalid
    }
}

impl EHDRToneMapOperator {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EHDRToneMapOperator>("EHDRToneMapOperator")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECPUGovernor)
pub enum ECPUGovernor {
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Invalid)
    k_ECPUGovernor_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Perf)
    k_ECPUGovernor_Perf = 1,
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Powersave)
    k_ECPUGovernor_Powersave = 2,
    // @@protoc_insertion_point(enum_value:ECPUGovernor.k_ECPUGovernor_Manual)
    k_ECPUGovernor_Manual = 3,
}

impl crate::Enum for ECPUGovernor {
    const NAME: &'static str = "ECPUGovernor";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECPUGovernor> {
        match value {
            0 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Invalid),
            1 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Perf),
            2 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Powersave),
            3 => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Manual),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECPUGovernor> {
        match str {
            "k_ECPUGovernor_Invalid" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Invalid),
            "k_ECPUGovernor_Perf" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Perf),
            "k_ECPUGovernor_Powersave" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Powersave),
            "k_ECPUGovernor_Manual" => ::std::option::Option::Some(ECPUGovernor::k_ECPUGovernor_Manual),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECPUGovernor] = &[
        ECPUGovernor::k_ECPUGovernor_Invalid,
        ECPUGovernor::k_ECPUGovernor_Perf,
        ECPUGovernor::k_ECPUGovernor_Powersave,
        ECPUGovernor::k_ECPUGovernor_Manual,
    ];
}

impl crate::EnumFull for ECPUGovernor {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECPUGovernor").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECPUGovernor {
    fn default() -> Self {
        ECPUGovernor::k_ECPUGovernor_Invalid
    }
}

impl ECPUGovernor {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ECPUGovernor>("ECPUGovernor")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUpdaterType)
pub enum EUpdaterType {
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Invalid)
    k_EUpdaterType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Client)
    k_EUpdaterType_Client = 1,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_OS)
    k_EUpdaterType_OS = 2,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_BIOS)
    k_EUpdaterType_BIOS = 3,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Aggregated)
    k_EUpdaterType_Aggregated = 4,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Test1)
    k_EUpdaterType_Test1 = 5,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Test2)
    k_EUpdaterType_Test2 = 6,
    // @@protoc_insertion_point(enum_value:EUpdaterType.k_EUpdaterType_Dummy)
    k_EUpdaterType_Dummy = 7,
}

impl crate::Enum for EUpdaterType {
    const NAME: &'static str = "EUpdaterType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUpdaterType> {
        match value {
            0 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Invalid),
            1 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Client),
            2 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_OS),
            3 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_BIOS),
            4 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Aggregated),
            5 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test1),
            6 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test2),
            7 => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Dummy),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUpdaterType> {
        match str {
            "k_EUpdaterType_Invalid" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Invalid),
            "k_EUpdaterType_Client" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Client),
            "k_EUpdaterType_OS" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_OS),
            "k_EUpdaterType_BIOS" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_BIOS),
            "k_EUpdaterType_Aggregated" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Aggregated),
            "k_EUpdaterType_Test1" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test1),
            "k_EUpdaterType_Test2" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Test2),
            "k_EUpdaterType_Dummy" => ::std::option::Option::Some(EUpdaterType::k_EUpdaterType_Dummy),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUpdaterType] = &[
        EUpdaterType::k_EUpdaterType_Invalid,
        EUpdaterType::k_EUpdaterType_Client,
        EUpdaterType::k_EUpdaterType_OS,
        EUpdaterType::k_EUpdaterType_BIOS,
        EUpdaterType::k_EUpdaterType_Aggregated,
        EUpdaterType::k_EUpdaterType_Test1,
        EUpdaterType::k_EUpdaterType_Test2,
        EUpdaterType::k_EUpdaterType_Dummy,
    ];
}

impl crate::EnumFull for EUpdaterType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EUpdaterType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EUpdaterType {
    fn default() -> Self {
        EUpdaterType::k_EUpdaterType_Invalid
    }
}

impl EUpdaterType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EUpdaterType>("EUpdaterType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUpdaterState)
pub enum EUpdaterState {
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Invalid)
    k_EUpdaterState_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_UpToDate)
    k_EUpdaterState_UpToDate = 2,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Checking)
    k_EUpdaterState_Checking = 3,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Available)
    k_EUpdaterState_Available = 4,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_Applying)
    k_EUpdaterState_Applying = 5,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_ClientRestartPending)
    k_EUpdaterState_ClientRestartPending = 6,
    // @@protoc_insertion_point(enum_value:EUpdaterState.k_EUpdaterState_SystemRestartPending)
    k_EUpdaterState_SystemRestartPending = 7,
}

impl crate::Enum for EUpdaterState {
    const NAME: &'static str = "EUpdaterState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUpdaterState> {
        match value {
            0 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Invalid),
            2 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_UpToDate),
            3 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Checking),
            4 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Available),
            5 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Applying),
            6 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_ClientRestartPending),
            7 => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_SystemRestartPending),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUpdaterState> {
        match str {
            "k_EUpdaterState_Invalid" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Invalid),
            "k_EUpdaterState_UpToDate" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_UpToDate),
            "k_EUpdaterState_Checking" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Checking),
            "k_EUpdaterState_Available" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Available),
            "k_EUpdaterState_Applying" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_Applying),
            "k_EUpdaterState_ClientRestartPending" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_ClientRestartPending),
            "k_EUpdaterState_SystemRestartPending" => ::std::option::Option::Some(EUpdaterState::k_EUpdaterState_SystemRestartPending),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUpdaterState] = &[
        EUpdaterState::k_EUpdaterState_Invalid,
        EUpdaterState::k_EUpdaterState_UpToDate,
        EUpdaterState::k_EUpdaterState_Checking,
        EUpdaterState::k_EUpdaterState_Available,
        EUpdaterState::k_EUpdaterState_Applying,
        EUpdaterState::k_EUpdaterState_ClientRestartPending,
        EUpdaterState::k_EUpdaterState_SystemRestartPending,
    ];
}

impl crate::EnumFull for EUpdaterState {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EUpdaterState").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EUpdaterState::k_EUpdaterState_Invalid => 0,
            EUpdaterState::k_EUpdaterState_UpToDate => 1,
            EUpdaterState::k_EUpdaterState_Checking => 2,
            EUpdaterState::k_EUpdaterState_Available => 3,
            EUpdaterState::k_EUpdaterState_Applying => 4,
            EUpdaterState::k_EUpdaterState_ClientRestartPending => 5,
            EUpdaterState::k_EUpdaterState_SystemRestartPending => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EUpdaterState {
    fn default() -> Self {
        EUpdaterState::k_EUpdaterState_Invalid
    }
}

impl EUpdaterState {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EUpdaterState>("EUpdaterState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageBlockContentType)
pub enum EStorageBlockContentType {
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Invalid)
    k_EStorageBlockContentType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Unknown)
    k_EStorageBlockContentType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_FileSystem)
    k_EStorageBlockContentType_FileSystem = 2,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Crypto)
    k_EStorageBlockContentType_Crypto = 3,
    // @@protoc_insertion_point(enum_value:EStorageBlockContentType.k_EStorageBlockContentType_Raid)
    k_EStorageBlockContentType_Raid = 4,
}

impl crate::Enum for EStorageBlockContentType {
    const NAME: &'static str = "EStorageBlockContentType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageBlockContentType> {
        match value {
            0 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
            1 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Unknown),
            2 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_FileSystem),
            3 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Crypto),
            4 => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Raid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageBlockContentType> {
        match str {
            "k_EStorageBlockContentType_Invalid" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Invalid),
            "k_EStorageBlockContentType_Unknown" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Unknown),
            "k_EStorageBlockContentType_FileSystem" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_FileSystem),
            "k_EStorageBlockContentType_Crypto" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Crypto),
            "k_EStorageBlockContentType_Raid" => ::std::option::Option::Some(EStorageBlockContentType::k_EStorageBlockContentType_Raid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageBlockContentType] = &[
        EStorageBlockContentType::k_EStorageBlockContentType_Invalid,
        EStorageBlockContentType::k_EStorageBlockContentType_Unknown,
        EStorageBlockContentType::k_EStorageBlockContentType_FileSystem,
        EStorageBlockContentType::k_EStorageBlockContentType_Crypto,
        EStorageBlockContentType::k_EStorageBlockContentType_Raid,
    ];
}

impl crate::EnumFull for EStorageBlockContentType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStorageBlockContentType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStorageBlockContentType {
    fn default() -> Self {
        EStorageBlockContentType::k_EStorageBlockContentType_Invalid
    }
}

impl EStorageBlockContentType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStorageBlockContentType>("EStorageBlockContentType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageBlockFileSystemType)
pub enum EStorageBlockFileSystemType {
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_Invalid)
    k_EStorageBlockFileSystemType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_Unknown)
    k_EStorageBlockFileSystemType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_VFat)
    k_EStorageBlockFileSystemType_VFat = 2,
    // @@protoc_insertion_point(enum_value:EStorageBlockFileSystemType.k_EStorageBlockFileSystemType_Ext4)
    k_EStorageBlockFileSystemType_Ext4 = 3,
}

impl crate::Enum for EStorageBlockFileSystemType {
    const NAME: &'static str = "EStorageBlockFileSystemType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageBlockFileSystemType> {
        match value {
            0 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
            1 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Unknown),
            2 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_VFat),
            3 => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Ext4),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageBlockFileSystemType> {
        match str {
            "k_EStorageBlockFileSystemType_Invalid" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid),
            "k_EStorageBlockFileSystemType_Unknown" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Unknown),
            "k_EStorageBlockFileSystemType_VFat" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_VFat),
            "k_EStorageBlockFileSystemType_Ext4" => ::std::option::Option::Some(EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Ext4),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageBlockFileSystemType] = &[
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid,
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Unknown,
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_VFat,
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Ext4,
    ];
}

impl crate::EnumFull for EStorageBlockFileSystemType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStorageBlockFileSystemType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStorageBlockFileSystemType {
    fn default() -> Self {
        EStorageBlockFileSystemType::k_EStorageBlockFileSystemType_Invalid
    }
}

impl EStorageBlockFileSystemType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStorageBlockFileSystemType>("EStorageBlockFileSystemType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStorageDriveMediaType)
pub enum EStorageDriveMediaType {
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_Invalid)
    k_EStorageDriveMediaType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_Unknown)
    k_EStorageDriveMediaType_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_HDD)
    k_EStorageDriveMediaType_HDD = 2,
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_SSD)
    k_EStorageDriveMediaType_SSD = 3,
    // @@protoc_insertion_point(enum_value:EStorageDriveMediaType.k_EStorageDriveMediaType_Removable)
    k_EStorageDriveMediaType_Removable = 4,
}

impl crate::Enum for EStorageDriveMediaType {
    const NAME: &'static str = "EStorageDriveMediaType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStorageDriveMediaType> {
        match value {
            0 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid),
            1 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Unknown),
            2 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_HDD),
            3 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_SSD),
            4 => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Removable),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStorageDriveMediaType> {
        match str {
            "k_EStorageDriveMediaType_Invalid" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid),
            "k_EStorageDriveMediaType_Unknown" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Unknown),
            "k_EStorageDriveMediaType_HDD" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_HDD),
            "k_EStorageDriveMediaType_SSD" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_SSD),
            "k_EStorageDriveMediaType_Removable" => ::std::option::Option::Some(EStorageDriveMediaType::k_EStorageDriveMediaType_Removable),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStorageDriveMediaType] = &[
        EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid,
        EStorageDriveMediaType::k_EStorageDriveMediaType_Unknown,
        EStorageDriveMediaType::k_EStorageDriveMediaType_HDD,
        EStorageDriveMediaType::k_EStorageDriveMediaType_SSD,
        EStorageDriveMediaType::k_EStorageDriveMediaType_Removable,
    ];
}

impl crate::EnumFull for EStorageDriveMediaType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStorageDriveMediaType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStorageDriveMediaType {
    fn default() -> Self {
        EStorageDriveMediaType::k_EStorageDriveMediaType_Invalid
    }
}

impl EStorageDriveMediaType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStorageDriveMediaType>("EStorageDriveMediaType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESystemDisplayCompatibilityMode)
pub enum ESystemDisplayCompatibilityMode {
    // @@protoc_insertion_point(enum_value:ESystemDisplayCompatibilityMode.k_ESystemDisplayCompatibilityMode_Invalid)
    k_ESystemDisplayCompatibilityMode_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESystemDisplayCompatibilityMode.k_ESystemDisplayCompatibilityMode_None)
    k_ESystemDisplayCompatibilityMode_None = 1,
    // @@protoc_insertion_point(enum_value:ESystemDisplayCompatibilityMode.k_ESystemDisplayCompatibilityMode_MinimalBandwith)
    k_ESystemDisplayCompatibilityMode_MinimalBandwith = 2,
}

impl crate::Enum for ESystemDisplayCompatibilityMode {
    const NAME: &'static str = "ESystemDisplayCompatibilityMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESystemDisplayCompatibilityMode> {
        match value {
            0 => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid),
            1 => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_None),
            2 => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_MinimalBandwith),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESystemDisplayCompatibilityMode> {
        match str {
            "k_ESystemDisplayCompatibilityMode_Invalid" => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid),
            "k_ESystemDisplayCompatibilityMode_None" => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_None),
            "k_ESystemDisplayCompatibilityMode_MinimalBandwith" => ::std::option::Option::Some(ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_MinimalBandwith),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESystemDisplayCompatibilityMode] = &[
        ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid,
        ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_None,
        ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_MinimalBandwith,
    ];
}

impl crate::EnumFull for ESystemDisplayCompatibilityMode {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESystemDisplayCompatibilityMode").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESystemDisplayCompatibilityMode {
    fn default() -> Self {
        ESystemDisplayCompatibilityMode::k_ESystemDisplayCompatibilityMode_Invalid
    }
}

impl ESystemDisplayCompatibilityMode {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESystemDisplayCompatibilityMode>("ESystemDisplayCompatibilityMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityCategory)
pub enum ESteamDeckCompatibilityCategory {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Unknown)
    k_ESteamDeckCompatibilityCategory_Unknown = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Unsupported)
    k_ESteamDeckCompatibilityCategory_Unsupported = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Playable)
    k_ESteamDeckCompatibilityCategory_Playable = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityCategory.k_ESteamDeckCompatibilityCategory_Verified)
    k_ESteamDeckCompatibilityCategory_Verified = 3,
}

impl crate::Enum for ESteamDeckCompatibilityCategory {
    const NAME: &'static str = "ESteamDeckCompatibilityCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityCategory> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unsupported),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Playable),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Verified),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityCategory> {
        match str {
            "k_ESteamDeckCompatibilityCategory_Unknown" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown),
            "k_ESteamDeckCompatibilityCategory_Unsupported" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unsupported),
            "k_ESteamDeckCompatibilityCategory_Playable" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Playable),
            "k_ESteamDeckCompatibilityCategory_Verified" => ::std::option::Option::Some(ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Verified),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityCategory] = &[
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown,
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unsupported,
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Playable,
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Verified,
    ];
}

impl crate::EnumFull for ESteamDeckCompatibilityCategory {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamDeckCompatibilityCategory").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamDeckCompatibilityCategory {
    fn default() -> Self {
        ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown
    }
}

impl ESteamDeckCompatibilityCategory {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESteamDeckCompatibilityCategory>("ESteamDeckCompatibilityCategory")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityResultDisplayType)
pub enum ESteamDeckCompatibilityResultDisplayType {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Invisible)
    k_ESteamDeckCompatibilityResultDisplayType_Invisible = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Informational)
    k_ESteamDeckCompatibilityResultDisplayType_Informational = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Unsupported)
    k_ESteamDeckCompatibilityResultDisplayType_Unsupported = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Playable)
    k_ESteamDeckCompatibilityResultDisplayType_Playable = 3,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityResultDisplayType.k_ESteamDeckCompatibilityResultDisplayType_Verified)
    k_ESteamDeckCompatibilityResultDisplayType_Verified = 4,
}

impl crate::Enum for ESteamDeckCompatibilityResultDisplayType {
    const NAME: &'static str = "ESteamDeckCompatibilityResultDisplayType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityResultDisplayType> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Informational),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Unsupported),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Playable),
            4 => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Verified),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityResultDisplayType> {
        match str {
            "k_ESteamDeckCompatibilityResultDisplayType_Invisible" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible),
            "k_ESteamDeckCompatibilityResultDisplayType_Informational" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Informational),
            "k_ESteamDeckCompatibilityResultDisplayType_Unsupported" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Unsupported),
            "k_ESteamDeckCompatibilityResultDisplayType_Playable" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Playable),
            "k_ESteamDeckCompatibilityResultDisplayType_Verified" => ::std::option::Option::Some(ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Verified),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityResultDisplayType] = &[
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Informational,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Unsupported,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Playable,
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Verified,
    ];
}

impl crate::EnumFull for ESteamDeckCompatibilityResultDisplayType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamDeckCompatibilityResultDisplayType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamDeckCompatibilityResultDisplayType {
    fn default() -> Self {
        ESteamDeckCompatibilityResultDisplayType::k_ESteamDeckCompatibilityResultDisplayType_Invisible
    }
}

impl ESteamDeckCompatibilityResultDisplayType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESteamDeckCompatibilityResultDisplayType>("ESteamDeckCompatibilityResultDisplayType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EACState)
pub enum EACState {
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_Unknown)
    k_EACState_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_Disconnected)
    k_EACState_Disconnected = 1,
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_Connected)
    k_EACState_Connected = 2,
    // @@protoc_insertion_point(enum_value:EACState.k_EACState_ConnectedSlow)
    k_EACState_ConnectedSlow = 3,
}

impl crate::Enum for EACState {
    const NAME: &'static str = "EACState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EACState> {
        match value {
            0 => ::std::option::Option::Some(EACState::k_EACState_Unknown),
            1 => ::std::option::Option::Some(EACState::k_EACState_Disconnected),
            2 => ::std::option::Option::Some(EACState::k_EACState_Connected),
            3 => ::std::option::Option::Some(EACState::k_EACState_ConnectedSlow),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EACState> {
        match str {
            "k_EACState_Unknown" => ::std::option::Option::Some(EACState::k_EACState_Unknown),
            "k_EACState_Disconnected" => ::std::option::Option::Some(EACState::k_EACState_Disconnected),
            "k_EACState_Connected" => ::std::option::Option::Some(EACState::k_EACState_Connected),
            "k_EACState_ConnectedSlow" => ::std::option::Option::Some(EACState::k_EACState_ConnectedSlow),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EACState] = &[
        EACState::k_EACState_Unknown,
        EACState::k_EACState_Disconnected,
        EACState::k_EACState_Connected,
        EACState::k_EACState_ConnectedSlow,
    ];
}

impl crate::EnumFull for EACState {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EACState").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EACState {
    fn default() -> Self {
        EACState::k_EACState_Unknown
    }
}

impl EACState {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EACState>("EACState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBatteryState)
pub enum EBatteryState {
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Unknown)
    k_EBatteryState_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Discharging)
    k_EBatteryState_Discharging = 1,
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Charging)
    k_EBatteryState_Charging = 2,
    // @@protoc_insertion_point(enum_value:EBatteryState.k_EBatteryState_Full)
    k_EBatteryState_Full = 3,
}

impl crate::Enum for EBatteryState {
    const NAME: &'static str = "EBatteryState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBatteryState> {
        match value {
            0 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Unknown),
            1 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Discharging),
            2 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Charging),
            3 => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Full),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBatteryState> {
        match str {
            "k_EBatteryState_Unknown" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Unknown),
            "k_EBatteryState_Discharging" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Discharging),
            "k_EBatteryState_Charging" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Charging),
            "k_EBatteryState_Full" => ::std::option::Option::Some(EBatteryState::k_EBatteryState_Full),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBatteryState] = &[
        EBatteryState::k_EBatteryState_Unknown,
        EBatteryState::k_EBatteryState_Discharging,
        EBatteryState::k_EBatteryState_Charging,
        EBatteryState::k_EBatteryState_Full,
    ];
}

impl crate::EnumFull for EBatteryState {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBatteryState").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EBatteryState {
    fn default() -> Self {
        EBatteryState::k_EBatteryState_Unknown
    }
}

impl EBatteryState {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EBatteryState>("EBatteryState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EOSBranch)
pub enum EOSBranch {
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Unknown)
    k_EOSBranch_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Release)
    k_EOSBranch_Release = 1,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_ReleaseCandidate)
    k_EOSBranch_ReleaseCandidate = 2,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Beta)
    k_EOSBranch_Beta = 3,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_BetaCandidate)
    k_EOSBranch_BetaCandidate = 4,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Main)
    k_EOSBranch_Main = 5,
    // @@protoc_insertion_point(enum_value:EOSBranch.k_EOSBranch_Staging)
    k_EOSBranch_Staging = 6,
}

impl crate::Enum for EOSBranch {
    const NAME: &'static str = "EOSBranch";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EOSBranch> {
        match value {
            0 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Unknown),
            1 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Release),
            2 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_ReleaseCandidate),
            3 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Beta),
            4 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_BetaCandidate),
            5 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Main),
            6 => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Staging),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EOSBranch> {
        match str {
            "k_EOSBranch_Unknown" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Unknown),
            "k_EOSBranch_Release" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Release),
            "k_EOSBranch_ReleaseCandidate" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_ReleaseCandidate),
            "k_EOSBranch_Beta" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Beta),
            "k_EOSBranch_BetaCandidate" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_BetaCandidate),
            "k_EOSBranch_Main" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Main),
            "k_EOSBranch_Staging" => ::std::option::Option::Some(EOSBranch::k_EOSBranch_Staging),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EOSBranch] = &[
        EOSBranch::k_EOSBranch_Unknown,
        EOSBranch::k_EOSBranch_Release,
        EOSBranch::k_EOSBranch_ReleaseCandidate,
        EOSBranch::k_EOSBranch_Beta,
        EOSBranch::k_EOSBranch_BetaCandidate,
        EOSBranch::k_EOSBranch_Main,
        EOSBranch::k_EOSBranch_Staging,
    ];
}

impl crate::EnumFull for EOSBranch {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EOSBranch").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EOSBranch {
    fn default() -> Self {
        EOSBranch::k_EOSBranch_Unknown
    }
}

impl EOSBranch {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EOSBranch>("EOSBranch")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECommunityItemClass)
pub enum ECommunityItemClass {
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Invalid)
    k_ECommunityItemClass_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Badge)
    k_ECommunityItemClass_Badge = 1,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_GameCard)
    k_ECommunityItemClass_GameCard = 2,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_ProfileBackground)
    k_ECommunityItemClass_ProfileBackground = 3,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Emoticon)
    k_ECommunityItemClass_Emoticon = 4,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_BoosterPack)
    k_ECommunityItemClass_BoosterPack = 5,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Consumable)
    k_ECommunityItemClass_Consumable = 6,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_GameGoo)
    k_ECommunityItemClass_GameGoo = 7,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_ProfileModifier)
    k_ECommunityItemClass_ProfileModifier = 8,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Scene)
    k_ECommunityItemClass_Scene = 9,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_SalienItem)
    k_ECommunityItemClass_SalienItem = 10,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_Sticker)
    k_ECommunityItemClass_Sticker = 11,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_ChatEffect)
    k_ECommunityItemClass_ChatEffect = 12,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_MiniProfileBackground)
    k_ECommunityItemClass_MiniProfileBackground = 13,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_AvatarFrame)
    k_ECommunityItemClass_AvatarFrame = 14,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_AnimatedAvatar)
    k_ECommunityItemClass_AnimatedAvatar = 15,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_SteamDeckKeyboardSkin)
    k_ECommunityItemClass_SteamDeckKeyboardSkin = 16,
    // @@protoc_insertion_point(enum_value:ECommunityItemClass.k_ECommunityItemClass_SteamDeckStartupMovie)
    k_ECommunityItemClass_SteamDeckStartupMovie = 17,
}

impl crate::Enum for ECommunityItemClass {
    const NAME: &'static str = "ECommunityItemClass";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECommunityItemClass> {
        match value {
            0 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Invalid),
            1 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Badge),
            2 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameCard),
            3 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileBackground),
            4 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Emoticon),
            5 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_BoosterPack),
            6 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Consumable),
            7 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameGoo),
            8 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileModifier),
            9 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Scene),
            10 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SalienItem),
            11 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Sticker),
            12 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ChatEffect),
            13 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_MiniProfileBackground),
            14 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AvatarFrame),
            15 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AnimatedAvatar),
            16 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckKeyboardSkin),
            17 => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckStartupMovie),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECommunityItemClass> {
        match str {
            "k_ECommunityItemClass_Invalid" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Invalid),
            "k_ECommunityItemClass_Badge" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Badge),
            "k_ECommunityItemClass_GameCard" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameCard),
            "k_ECommunityItemClass_ProfileBackground" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileBackground),
            "k_ECommunityItemClass_Emoticon" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Emoticon),
            "k_ECommunityItemClass_BoosterPack" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_BoosterPack),
            "k_ECommunityItemClass_Consumable" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Consumable),
            "k_ECommunityItemClass_GameGoo" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_GameGoo),
            "k_ECommunityItemClass_ProfileModifier" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ProfileModifier),
            "k_ECommunityItemClass_Scene" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Scene),
            "k_ECommunityItemClass_SalienItem" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SalienItem),
            "k_ECommunityItemClass_Sticker" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_Sticker),
            "k_ECommunityItemClass_ChatEffect" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_ChatEffect),
            "k_ECommunityItemClass_MiniProfileBackground" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_MiniProfileBackground),
            "k_ECommunityItemClass_AvatarFrame" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AvatarFrame),
            "k_ECommunityItemClass_AnimatedAvatar" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_AnimatedAvatar),
            "k_ECommunityItemClass_SteamDeckKeyboardSkin" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckKeyboardSkin),
            "k_ECommunityItemClass_SteamDeckStartupMovie" => ::std::option::Option::Some(ECommunityItemClass::k_ECommunityItemClass_SteamDeckStartupMovie),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECommunityItemClass] = &[
        ECommunityItemClass::k_ECommunityItemClass_Invalid,
        ECommunityItemClass::k_ECommunityItemClass_Badge,
        ECommunityItemClass::k_ECommunityItemClass_GameCard,
        ECommunityItemClass::k_ECommunityItemClass_ProfileBackground,
        ECommunityItemClass::k_ECommunityItemClass_Emoticon,
        ECommunityItemClass::k_ECommunityItemClass_BoosterPack,
        ECommunityItemClass::k_ECommunityItemClass_Consumable,
        ECommunityItemClass::k_ECommunityItemClass_GameGoo,
        ECommunityItemClass::k_ECommunityItemClass_ProfileModifier,
        ECommunityItemClass::k_ECommunityItemClass_Scene,
        ECommunityItemClass::k_ECommunityItemClass_SalienItem,
        ECommunityItemClass::k_ECommunityItemClass_Sticker,
        ECommunityItemClass::k_ECommunityItemClass_ChatEffect,
        ECommunityItemClass::k_ECommunityItemClass_MiniProfileBackground,
        ECommunityItemClass::k_ECommunityItemClass_AvatarFrame,
        ECommunityItemClass::k_ECommunityItemClass_AnimatedAvatar,
        ECommunityItemClass::k_ECommunityItemClass_SteamDeckKeyboardSkin,
        ECommunityItemClass::k_ECommunityItemClass_SteamDeckStartupMovie,
    ];
}

impl crate::EnumFull for ECommunityItemClass {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECommunityItemClass").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECommunityItemClass {
    fn default() -> Self {
        ECommunityItemClass::k_ECommunityItemClass_Invalid
    }
}

impl ECommunityItemClass {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ECommunityItemClass>("ECommunityItemClass")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamDeckCompatibilityFeedback)
pub enum ESteamDeckCompatibilityFeedback {
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Unset)
    k_ESteamDeckCompatibilityFeedback_Unset = 0,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Agree)
    k_ESteamDeckCompatibilityFeedback_Agree = 1,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Disagree)
    k_ESteamDeckCompatibilityFeedback_Disagree = 2,
    // @@protoc_insertion_point(enum_value:ESteamDeckCompatibilityFeedback.k_ESteamDeckCompatibilityFeedback_Ignore)
    k_ESteamDeckCompatibilityFeedback_Ignore = 3,
}

impl crate::Enum for ESteamDeckCompatibilityFeedback {
    const NAME: &'static str = "ESteamDeckCompatibilityFeedback";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamDeckCompatibilityFeedback> {
        match value {
            0 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            1 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Agree),
            2 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Disagree),
            3 => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Ignore),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamDeckCompatibilityFeedback> {
        match str {
            "k_ESteamDeckCompatibilityFeedback_Unset" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset),
            "k_ESteamDeckCompatibilityFeedback_Agree" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Agree),
            "k_ESteamDeckCompatibilityFeedback_Disagree" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Disagree),
            "k_ESteamDeckCompatibilityFeedback_Ignore" => ::std::option::Option::Some(ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Ignore),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamDeckCompatibilityFeedback] = &[
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset,
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Agree,
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Disagree,
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Ignore,
    ];
}

impl crate::EnumFull for ESteamDeckCompatibilityFeedback {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamDeckCompatibilityFeedback").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamDeckCompatibilityFeedback {
    fn default() -> Self {
        ESteamDeckCompatibilityFeedback::k_ESteamDeckCompatibilityFeedback_Unset
    }
}

impl ESteamDeckCompatibilityFeedback {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESteamDeckCompatibilityFeedback>("ESteamDeckCompatibilityFeedback")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EProvideDeckFeedbackPreference)
pub enum EProvideDeckFeedbackPreference {
    // @@protoc_insertion_point(enum_value:EProvideDeckFeedbackPreference.k_EProvideDeckFeedbackPreference_Unset)
    k_EProvideDeckFeedbackPreference_Unset = 0,
    // @@protoc_insertion_point(enum_value:EProvideDeckFeedbackPreference.k_EProvideDeckFeedbackPreference_Yes)
    k_EProvideDeckFeedbackPreference_Yes = 1,
    // @@protoc_insertion_point(enum_value:EProvideDeckFeedbackPreference.k_EProvideDeckFeedbackPreference_No)
    k_EProvideDeckFeedbackPreference_No = 2,
}

impl crate::Enum for EProvideDeckFeedbackPreference {
    const NAME: &'static str = "EProvideDeckFeedbackPreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProvideDeckFeedbackPreference> {
        match value {
            0 => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset),
            1 => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Yes),
            2 => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_No),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EProvideDeckFeedbackPreference> {
        match str {
            "k_EProvideDeckFeedbackPreference_Unset" => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset),
            "k_EProvideDeckFeedbackPreference_Yes" => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Yes),
            "k_EProvideDeckFeedbackPreference_No" => ::std::option::Option::Some(EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_No),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EProvideDeckFeedbackPreference] = &[
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset,
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Yes,
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_No,
    ];
}

impl crate::EnumFull for EProvideDeckFeedbackPreference {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EProvideDeckFeedbackPreference").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EProvideDeckFeedbackPreference {
    fn default() -> Self {
        EProvideDeckFeedbackPreference::k_EProvideDeckFeedbackPreference_Unset
    }
}

impl EProvideDeckFeedbackPreference {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EProvideDeckFeedbackPreference>("EProvideDeckFeedbackPreference")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETouchGesture)
pub enum ETouchGesture {
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureNone)
    k_ETouchGestureNone = 0,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTouch)
    k_ETouchGestureTouch = 1,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTap)
    k_ETouchGestureTap = 2,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureDoubleTap)
    k_ETouchGestureDoubleTap = 3,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureShortPress)
    k_ETouchGestureShortPress = 4,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureLongPress)
    k_ETouchGestureLongPress = 5,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureLongTap)
    k_ETouchGestureLongTap = 6,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTwoFingerTap)
    k_ETouchGestureTwoFingerTap = 7,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureTapCancelled)
    k_ETouchGestureTapCancelled = 8,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGesturePinchBegin)
    k_ETouchGesturePinchBegin = 9,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGesturePinchUpdate)
    k_ETouchGesturePinchUpdate = 10,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGesturePinchEnd)
    k_ETouchGesturePinchEnd = 11,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureFlingStart)
    k_ETouchGestureFlingStart = 12,
    // @@protoc_insertion_point(enum_value:ETouchGesture.k_ETouchGestureFlingCancelled)
    k_ETouchGestureFlingCancelled = 13,
}

impl crate::Enum for ETouchGesture {
    const NAME: &'static str = "ETouchGesture";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETouchGesture> {
        match value {
            0 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureNone),
            1 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTouch),
            2 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTap),
            3 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureDoubleTap),
            4 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureShortPress),
            5 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongPress),
            6 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongTap),
            7 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTwoFingerTap),
            8 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTapCancelled),
            9 => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchBegin),
            10 => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchUpdate),
            11 => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchEnd),
            12 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingStart),
            13 => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingCancelled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETouchGesture> {
        match str {
            "k_ETouchGestureNone" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureNone),
            "k_ETouchGestureTouch" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTouch),
            "k_ETouchGestureTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTap),
            "k_ETouchGestureDoubleTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureDoubleTap),
            "k_ETouchGestureShortPress" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureShortPress),
            "k_ETouchGestureLongPress" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongPress),
            "k_ETouchGestureLongTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureLongTap),
            "k_ETouchGestureTwoFingerTap" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTwoFingerTap),
            "k_ETouchGestureTapCancelled" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureTapCancelled),
            "k_ETouchGesturePinchBegin" => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchBegin),
            "k_ETouchGesturePinchUpdate" => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchUpdate),
            "k_ETouchGesturePinchEnd" => ::std::option::Option::Some(ETouchGesture::k_ETouchGesturePinchEnd),
            "k_ETouchGestureFlingStart" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingStart),
            "k_ETouchGestureFlingCancelled" => ::std::option::Option::Some(ETouchGesture::k_ETouchGestureFlingCancelled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETouchGesture] = &[
        ETouchGesture::k_ETouchGestureNone,
        ETouchGesture::k_ETouchGestureTouch,
        ETouchGesture::k_ETouchGestureTap,
        ETouchGesture::k_ETouchGestureDoubleTap,
        ETouchGesture::k_ETouchGestureShortPress,
        ETouchGesture::k_ETouchGestureLongPress,
        ETouchGesture::k_ETouchGestureLongTap,
        ETouchGesture::k_ETouchGestureTwoFingerTap,
        ETouchGesture::k_ETouchGestureTapCancelled,
        ETouchGesture::k_ETouchGesturePinchBegin,
        ETouchGesture::k_ETouchGesturePinchUpdate,
        ETouchGesture::k_ETouchGesturePinchEnd,
        ETouchGesture::k_ETouchGestureFlingStart,
        ETouchGesture::k_ETouchGestureFlingCancelled,
    ];
}

impl crate::EnumFull for ETouchGesture {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ETouchGesture").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ETouchGesture {
    fn default() -> Self {
        ETouchGesture::k_ETouchGestureNone
    }
}

impl ETouchGesture {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ETouchGesture>("ETouchGesture")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESessionPersistence)
pub enum ESessionPersistence {
    // @@protoc_insertion_point(enum_value:ESessionPersistence.k_ESessionPersistence_Invalid)
    k_ESessionPersistence_Invalid = -1,
    // @@protoc_insertion_point(enum_value:ESessionPersistence.k_ESessionPersistence_Ephemeral)
    k_ESessionPersistence_Ephemeral = 0,
    // @@protoc_insertion_point(enum_value:ESessionPersistence.k_ESessionPersistence_Persistent)
    k_ESessionPersistence_Persistent = 1,
}

impl crate::Enum for ESessionPersistence {
    const NAME: &'static str = "ESessionPersistence";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESessionPersistence> {
        match value {
            -1 => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Invalid),
            0 => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Ephemeral),
            1 => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Persistent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESessionPersistence> {
        match str {
            "k_ESessionPersistence_Invalid" => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Invalid),
            "k_ESessionPersistence_Ephemeral" => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Ephemeral),
            "k_ESessionPersistence_Persistent" => ::std::option::Option::Some(ESessionPersistence::k_ESessionPersistence_Persistent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESessionPersistence] = &[
        ESessionPersistence::k_ESessionPersistence_Invalid,
        ESessionPersistence::k_ESessionPersistence_Ephemeral,
        ESessionPersistence::k_ESessionPersistence_Persistent,
    ];
}

impl crate::EnumFull for ESessionPersistence {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESessionPersistence").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            ESessionPersistence::k_ESessionPersistence_Invalid => 0,
            ESessionPersistence::k_ESessionPersistence_Ephemeral => 1,
            ESessionPersistence::k_ESessionPersistence_Persistent => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ESessionPersistence {
    fn default() -> Self {
        ESessionPersistence::k_ESessionPersistence_Invalid
    }
}

impl ESessionPersistence {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESessionPersistence>("ESessionPersistence")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ENewSteamAnnouncementState)
pub enum ENewSteamAnnouncementState {
    // @@protoc_insertion_point(enum_value:ENewSteamAnnouncementState.k_ENewSteamAnnouncementState_Invalid)
    k_ENewSteamAnnouncementState_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ENewSteamAnnouncementState.k_ENewSteamAnnouncementState_AllRead)
    k_ENewSteamAnnouncementState_AllRead = 1,
    // @@protoc_insertion_point(enum_value:ENewSteamAnnouncementState.k_ENewSteamAnnouncementState_NewAnnouncement)
    k_ENewSteamAnnouncementState_NewAnnouncement = 2,
    // @@protoc_insertion_point(enum_value:ENewSteamAnnouncementState.k_ENewSteamAnnouncementState_FeaturedAnnouncement)
    k_ENewSteamAnnouncementState_FeaturedAnnouncement = 3,
}

impl crate::Enum for ENewSteamAnnouncementState {
    const NAME: &'static str = "ENewSteamAnnouncementState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ENewSteamAnnouncementState> {
        match value {
            0 => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_Invalid),
            1 => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_AllRead),
            2 => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_NewAnnouncement),
            3 => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_FeaturedAnnouncement),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ENewSteamAnnouncementState> {
        match str {
            "k_ENewSteamAnnouncementState_Invalid" => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_Invalid),
            "k_ENewSteamAnnouncementState_AllRead" => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_AllRead),
            "k_ENewSteamAnnouncementState_NewAnnouncement" => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_NewAnnouncement),
            "k_ENewSteamAnnouncementState_FeaturedAnnouncement" => ::std::option::Option::Some(ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_FeaturedAnnouncement),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ENewSteamAnnouncementState] = &[
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_Invalid,
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_AllRead,
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_NewAnnouncement,
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_FeaturedAnnouncement,
    ];
}

impl crate::EnumFull for ENewSteamAnnouncementState {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ENewSteamAnnouncementState").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ENewSteamAnnouncementState {
    fn default() -> Self {
        ENewSteamAnnouncementState::k_ENewSteamAnnouncementState_Invalid
    }
}

impl ENewSteamAnnouncementState {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ENewSteamAnnouncementState>("ENewSteamAnnouncementState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECommentThreadType)
pub enum ECommentThreadType {
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeInvalid)
    k_ECommentThreadTypeInvalid = 0,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeScreenshot_Deprecated)
    k_ECommentThreadTypeScreenshot_Deprecated = 1,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeWorkshopAccount_Developer)
    k_ECommentThreadTypeWorkshopAccount_Developer = 2,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeWorkshopAccount_Public)
    k_ECommentThreadTypeWorkshopAccount_Public = 3,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypePublishedFile_Developer)
    k_ECommentThreadTypePublishedFile_Developer = 4,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypePublishedFile_Public)
    k_ECommentThreadTypePublishedFile_Public = 5,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeTest)
    k_ECommentThreadTypeTest = 6,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeForumTopic)
    k_ECommentThreadTypeForumTopic = 7,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeRecommendation)
    k_ECommentThreadTypeRecommendation = 8,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeVideo_Deprecated)
    k_ECommentThreadTypeVideo_Deprecated = 9,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeProfile)
    k_ECommentThreadTypeProfile = 10,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeNewsPost)
    k_ECommentThreadTypeNewsPost = 11,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeClan)
    k_ECommentThreadTypeClan = 12,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeClanAnnouncement)
    k_ECommentThreadTypeClanAnnouncement = 13,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeClanEvent)
    k_ECommentThreadTypeClanEvent = 14,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeUserStatusPublished)
    k_ECommentThreadTypeUserStatusPublished = 15,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeUserReceivedNewGame)
    k_ECommentThreadTypeUserReceivedNewGame = 16,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypePublishedFile_Announcement)
    k_ECommentThreadTypePublishedFile_Announcement = 17,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeModeratorMessage)
    k_ECommentThreadTypeModeratorMessage = 18,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeClanCuratedApp)
    k_ECommentThreadTypeClanCuratedApp = 19,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeQAndASession)
    k_ECommentThreadTypeQAndASession = 20,
    // @@protoc_insertion_point(enum_value:ECommentThreadType.k_ECommentThreadTypeMax)
    k_ECommentThreadTypeMax = 21,
}

impl crate::Enum for ECommentThreadType {
    const NAME: &'static str = "ECommentThreadType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECommentThreadType> {
        match value {
            0 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeInvalid),
            1 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeScreenshot_Deprecated),
            2 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Developer),
            3 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Public),
            4 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Developer),
            5 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Public),
            6 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeTest),
            7 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeForumTopic),
            8 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeRecommendation),
            9 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeVideo_Deprecated),
            10 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeProfile),
            11 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeNewsPost),
            12 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClan),
            13 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanAnnouncement),
            14 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanEvent),
            15 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeUserStatusPublished),
            16 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeUserReceivedNewGame),
            17 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Announcement),
            18 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeModeratorMessage),
            19 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanCuratedApp),
            20 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeQAndASession),
            21 => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeMax),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECommentThreadType> {
        match str {
            "k_ECommentThreadTypeInvalid" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeInvalid),
            "k_ECommentThreadTypeScreenshot_Deprecated" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeScreenshot_Deprecated),
            "k_ECommentThreadTypeWorkshopAccount_Developer" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Developer),
            "k_ECommentThreadTypeWorkshopAccount_Public" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Public),
            "k_ECommentThreadTypePublishedFile_Developer" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Developer),
            "k_ECommentThreadTypePublishedFile_Public" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Public),
            "k_ECommentThreadTypeTest" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeTest),
            "k_ECommentThreadTypeForumTopic" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeForumTopic),
            "k_ECommentThreadTypeRecommendation" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeRecommendation),
            "k_ECommentThreadTypeVideo_Deprecated" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeVideo_Deprecated),
            "k_ECommentThreadTypeProfile" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeProfile),
            "k_ECommentThreadTypeNewsPost" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeNewsPost),
            "k_ECommentThreadTypeClan" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClan),
            "k_ECommentThreadTypeClanAnnouncement" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanAnnouncement),
            "k_ECommentThreadTypeClanEvent" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanEvent),
            "k_ECommentThreadTypeUserStatusPublished" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeUserStatusPublished),
            "k_ECommentThreadTypeUserReceivedNewGame" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeUserReceivedNewGame),
            "k_ECommentThreadTypePublishedFile_Announcement" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypePublishedFile_Announcement),
            "k_ECommentThreadTypeModeratorMessage" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeModeratorMessage),
            "k_ECommentThreadTypeClanCuratedApp" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeClanCuratedApp),
            "k_ECommentThreadTypeQAndASession" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeQAndASession),
            "k_ECommentThreadTypeMax" => ::std::option::Option::Some(ECommentThreadType::k_ECommentThreadTypeMax),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECommentThreadType] = &[
        ECommentThreadType::k_ECommentThreadTypeInvalid,
        ECommentThreadType::k_ECommentThreadTypeScreenshot_Deprecated,
        ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Developer,
        ECommentThreadType::k_ECommentThreadTypeWorkshopAccount_Public,
        ECommentThreadType::k_ECommentThreadTypePublishedFile_Developer,
        ECommentThreadType::k_ECommentThreadTypePublishedFile_Public,
        ECommentThreadType::k_ECommentThreadTypeTest,
        ECommentThreadType::k_ECommentThreadTypeForumTopic,
        ECommentThreadType::k_ECommentThreadTypeRecommendation,
        ECommentThreadType::k_ECommentThreadTypeVideo_Deprecated,
        ECommentThreadType::k_ECommentThreadTypeProfile,
        ECommentThreadType::k_ECommentThreadTypeNewsPost,
        ECommentThreadType::k_ECommentThreadTypeClan,
        ECommentThreadType::k_ECommentThreadTypeClanAnnouncement,
        ECommentThreadType::k_ECommentThreadTypeClanEvent,
        ECommentThreadType::k_ECommentThreadTypeUserStatusPublished,
        ECommentThreadType::k_ECommentThreadTypeUserReceivedNewGame,
        ECommentThreadType::k_ECommentThreadTypePublishedFile_Announcement,
        ECommentThreadType::k_ECommentThreadTypeModeratorMessage,
        ECommentThreadType::k_ECommentThreadTypeClanCuratedApp,
        ECommentThreadType::k_ECommentThreadTypeQAndASession,
        ECommentThreadType::k_ECommentThreadTypeMax,
    ];
}

impl crate::EnumFull for ECommentThreadType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECommentThreadType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECommentThreadType {
    fn default() -> Self {
        ECommentThreadType::k_ECommentThreadTypeInvalid
    }
}

impl ECommentThreadType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ECommentThreadType>("ECommentThreadType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBroadcastPermission)
pub enum EBroadcastPermission {
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionDisabled)
    k_EBroadcastPermissionDisabled = 0,
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionFriendsApprove)
    k_EBroadcastPermissionFriendsApprove = 1,
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionFriendsAllowed)
    k_EBroadcastPermissionFriendsAllowed = 2,
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionPublic)
    k_EBroadcastPermissionPublic = 3,
    // @@protoc_insertion_point(enum_value:EBroadcastPermission.k_EBroadcastPermissionSubscribers)
    k_EBroadcastPermissionSubscribers = 4,
}

impl crate::Enum for EBroadcastPermission {
    const NAME: &'static str = "EBroadcastPermission";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastPermission> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionDisabled),
            1 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionFriendsApprove),
            2 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionFriendsAllowed),
            3 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionPublic),
            4 => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionSubscribers),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastPermission> {
        match str {
            "k_EBroadcastPermissionDisabled" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionDisabled),
            "k_EBroadcastPermissionFriendsApprove" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionFriendsApprove),
            "k_EBroadcastPermissionFriendsAllowed" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionFriendsAllowed),
            "k_EBroadcastPermissionPublic" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionPublic),
            "k_EBroadcastPermissionSubscribers" => ::std::option::Option::Some(EBroadcastPermission::k_EBroadcastPermissionSubscribers),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastPermission] = &[
        EBroadcastPermission::k_EBroadcastPermissionDisabled,
        EBroadcastPermission::k_EBroadcastPermissionFriendsApprove,
        EBroadcastPermission::k_EBroadcastPermissionFriendsAllowed,
        EBroadcastPermission::k_EBroadcastPermissionPublic,
        EBroadcastPermission::k_EBroadcastPermissionSubscribers,
    ];
}

impl crate::EnumFull for EBroadcastPermission {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBroadcastPermission").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EBroadcastPermission {
    fn default() -> Self {
        EBroadcastPermission::k_EBroadcastPermissionDisabled
    }
}

impl EBroadcastPermission {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EBroadcastPermission>("EBroadcastPermission")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBroadcastEncoderSetting)
pub enum EBroadcastEncoderSetting {
    // @@protoc_insertion_point(enum_value:EBroadcastEncoderSetting.k_EBroadcastEncoderBestQuality)
    k_EBroadcastEncoderBestQuality = 0,
    // @@protoc_insertion_point(enum_value:EBroadcastEncoderSetting.k_EBroadcastEncoderBestPerformance)
    k_EBroadcastEncoderBestPerformance = 1,
}

impl crate::Enum for EBroadcastEncoderSetting {
    const NAME: &'static str = "EBroadcastEncoderSetting";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastEncoderSetting> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality),
            1 => ::std::option::Option::Some(EBroadcastEncoderSetting::k_EBroadcastEncoderBestPerformance),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastEncoderSetting> {
        match str {
            "k_EBroadcastEncoderBestQuality" => ::std::option::Option::Some(EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality),
            "k_EBroadcastEncoderBestPerformance" => ::std::option::Option::Some(EBroadcastEncoderSetting::k_EBroadcastEncoderBestPerformance),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastEncoderSetting] = &[
        EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality,
        EBroadcastEncoderSetting::k_EBroadcastEncoderBestPerformance,
    ];
}

impl crate::EnumFull for EBroadcastEncoderSetting {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBroadcastEncoderSetting").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EBroadcastEncoderSetting {
    fn default() -> Self {
        EBroadcastEncoderSetting::k_EBroadcastEncoderBestQuality
    }
}

impl EBroadcastEncoderSetting {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EBroadcastEncoderSetting>("EBroadcastEncoderSetting")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECloudGamingPlatform)
pub enum ECloudGamingPlatform {
    // @@protoc_insertion_point(enum_value:ECloudGamingPlatform.k_ECloudGamingPlatformNone)
    k_ECloudGamingPlatformNone = 0,
    // @@protoc_insertion_point(enum_value:ECloudGamingPlatform.k_ECloudGamingPlatformValve)
    k_ECloudGamingPlatformValve = 1,
    // @@protoc_insertion_point(enum_value:ECloudGamingPlatform.k_ECloudGamingPlatformNVIDIA)
    k_ECloudGamingPlatformNVIDIA = 2,
}

impl crate::Enum for ECloudGamingPlatform {
    const NAME: &'static str = "ECloudGamingPlatform";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECloudGamingPlatform> {
        match value {
            0 => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformNone),
            1 => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformValve),
            2 => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformNVIDIA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECloudGamingPlatform> {
        match str {
            "k_ECloudGamingPlatformNone" => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformNone),
            "k_ECloudGamingPlatformValve" => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformValve),
            "k_ECloudGamingPlatformNVIDIA" => ::std::option::Option::Some(ECloudGamingPlatform::k_ECloudGamingPlatformNVIDIA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECloudGamingPlatform] = &[
        ECloudGamingPlatform::k_ECloudGamingPlatformNone,
        ECloudGamingPlatform::k_ECloudGamingPlatformValve,
        ECloudGamingPlatform::k_ECloudGamingPlatformNVIDIA,
    ];
}

impl crate::EnumFull for ECloudGamingPlatform {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECloudGamingPlatform").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECloudGamingPlatform {
    fn default() -> Self {
        ECloudGamingPlatform::k_ECloudGamingPlatformNone
    }
}

impl ECloudGamingPlatform {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ECloudGamingPlatform>("ECloudGamingPlatform")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0benums.proto\x1a\x18steammessages_base.proto*\x80\n\n\x17EPublished\
    FileQueryType\x12)\n%k_PublishedFileQueryType_RankedByVote\x10\0\x124\n0\
    k_PublishedFileQueryType_RankedByPublicationDate\x10\x01\x12B\n>k_Publis\
    hedFileQueryType_AcceptedForGameRankedByAcceptanceDate\x10\x02\x12*\n&k_\
    PublishedFileQueryType_RankedByTrend\x10\x03\x12F\nBk_PublishedFileQuery\
    Type_FavoritedByFriendsRankedByPublicationDate\x10\x04\x12D\n@k_Publishe\
    dFileQueryType_CreatedByFriendsRankedByPublicationDate\x10\x05\x125\n1k_\
    PublishedFileQueryType_RankedByNumTimesReported\x10\x06\x12J\nFk_Publish\
    edFileQueryType_CreatedByFollowedUsersRankedByPublicationDate\x10\x07\
    \x12(\n$k_PublishedFileQueryType_NotYetRated\x10\x08\x12=\n9k_PublishedF\
    ileQueryType_RankedByTotalUniqueSubscriptions\x10\t\x122\n.k_PublishedFi\
    leQueryType_RankedByTotalVotesAsc\x10\n\x12,\n(k_PublishedFileQueryType_\
    RankedByVotesUp\x10\x0b\x12/\n+k_PublishedFileQueryType_RankedByTextSear\
    ch\x10\x0c\x122\n.k_PublishedFileQueryType_RankedByPlaytimeTrend\x10\r\
    \x122\n.k_PublishedFileQueryType_RankedByTotalPlaytime\x10\x0e\x129\n5k_\
    PublishedFileQueryType_RankedByAveragePlaytimeTrend\x10\x0f\x12<\n8k_Pub\
    lishedFileQueryType_RankedByLifetimeAveragePlaytime\x10\x10\x12:\n6k_Pub\
    lishedFileQueryType_RankedByPlaytimeSessionsTrend\x10\x11\x12=\n9k_Publi\
    shedFileQueryType_RankedByLifetimePlaytimeSessions\x10\x12\x12?\n;k_Publ\
    ishedFileQueryType_RankedByInappropriateContentRating\x10\x13\x124\n0k_P\
    ublishedFileQueryType_RankedByBanContentCheck\x10\x14\x124\n0k_Published\
    FileQueryType_RankedByLastUpdatedDate\x10\x15*\xbc\x01\n#EPublishedFileI\
    nappropriateProvider\x121\n-k_EPublishedFileInappropriateProvider_Invali\
    d\x10\0\x120\n,k_EPublishedFileInappropriateProvider_Google\x10\x01\x120\
    \n,k_EPublishedFileInappropriateProvider_Amazon\x10\x02*\xd5\x02\n!EPubl\
    ishedFileInappropriateResult\x122\n.k_EPublishedFileInappropriateResult_\
    NotScanned\x10\0\x124\n0k_EPublishedFileInappropriateResult_VeryUnlikely\
    \x10\x01\x120\n,k_EPublishedFileInappropriateResult_Unlikely\x10\x1e\x12\
    0\n,k_EPublishedFileInappropriateResult_Possible\x102\x12.\n*k_EPublishe\
    dFileInappropriateResult_Likely\x10K\x122\n.k_EPublishedFileInappropriat\
    eResult_VeryLikely\x10d*\xb1\x03\n\x11EPersonaStateFlag\x12'\n#k_EPerson\
    aStateFlag_HasRichPresence\x10\x01\x12&\n\"k_EPersonaStateFlag_InJoinabl\
    eGame\x10\x02\x12\x1e\n\x1ak_EPersonaStateFlag_Golden\x10\x04\x12*\n&k_E\
    PersonaStateFlag_RemotePlayTogether\x10\x08\x12&\n!k_EPersonaStateFlag_C\
    lientTypeWeb\x10\x80\x02\x12)\n$k_EPersonaStateFlag_ClientTypeMobile\x10\
    \x80\x04\x12*\n%k_EPersonaStateFlag_ClientTypeTenfoot\x10\x80\x08\x12%\n\
    \x20k_EPersonaStateFlag_ClientTypeVR\x10\x80\x10\x12*\n%k_EPersonaStateF\
    lag_LaunchTypeGamepad\x10\x80\x20\x12-\n(k_EPersonaStateFlag_LaunchTypeC\
    ompatTool\x10\x80@*\xde\x01\n\x15EContentCheckProvider\x12#\n\x1fk_ECont\
    entCheckProvider_Invalid\x10\0\x12-\n)k_EContentCheckProvider_Google_DEP\
    RECATED\x10\x01\x12\"\n\x1ek_EContentCheckProvider_Amazon\x10\x02\x12!\n\
    \x1dk_EContentCheckProvider_Local\x10\x03\x12*\n&k_EContentCheckProvider\
    _GoogleVertexAI\x10\x04*\x93\t\n\x19EProfileCustomizationType\x12&\n\"k_\
    EProfileCustomizationTypeInvalid\x10\0\x126\n2k_EProfileCustomizationTyp\
    eRareAchievementShowcase\x10\x01\x12,\n(k_EProfileCustomizationTypeGameC\
    ollector\x10\x02\x12+\n'k_EProfileCustomizationTypeItemShowcase\x10\x03\
    \x12,\n(k_EProfileCustomizationTypeTradeShowcase\x10\x04\x12%\n!k_EProfi\
    leCustomizationTypeBadges\x10\x05\x12+\n'k_EProfileCustomizationTypeFavo\
    riteGame\x10\x06\x121\n-k_EProfileCustomizationTypeScreenshotShowcase\
    \x10\x07\x12)\n%k_EProfileCustomizationTypeCustomText\x10\x08\x12,\n(k_E\
    ProfileCustomizationTypeFavoriteGroup\x10\t\x12-\n)k_EProfileCustomizati\
    onTypeRecommendation\x10\n\x12+\n'k_EProfileCustomizationTypeWorkshopIte\
    m\x10\x0b\x12)\n%k_EProfileCustomizationTypeMyWorkshop\x10\x0c\x12.\n*k_\
    EProfileCustomizationTypeArtworkShowcase\x10\r\x12,\n(k_EProfileCustomiz\
    ationTypeVideoShowcase\x10\x0e\x12%\n!k_EProfileCustomizationTypeGuides\
    \x10\x0f\x12'\n#k_EProfileCustomizationTypeMyGuides\x10\x10\x12+\n'k_EPr\
    ofileCustomizationTypeAchievements\x10\x11\x12)\n%k_EProfileCustomizatio\
    nTypeGreenlight\x10\x12\x12+\n'k_EProfileCustomizationTypeMyGreenlight\
    \x10\x13\x12%\n!k_EProfileCustomizationTypeSalien\x10\x14\x125\n1k_EProf\
    ileCustomizationTypeLoyaltyRewardReactions\x10\x15\x124\n0k_EProfileCust\
    omizationTypeSingleArtworkShowcase\x10\x16\x128\n4k_EProfileCustomizatio\
    nTypeAchievementsCompletionist\x10\x17\x12%\n!k_EProfileCustomizationTyp\
    eReplay\x10\x18*\xc8\x01\n\x1bEPublishedFileStorageSystem\x12(\n$k_EPubl\
    ishedFileStorageSystemInvalid\x10\0\x12,\n(k_EPublishedFileStorageSystem\
    LegacyCloud\x10\x01\x12&\n\"k_EPublishedFileStorageSystemDepot\x10\x02\
    \x12)\n%k_EPublishedFileStorageSystemUGCCloud\x10\x03*\x97\x01\n\x19EClo\
    udStoragePersistState\x12(\n$k_ECloudStoragePersistStatePersisted\x10\0\
    \x12(\n$k_ECloudStoragePersistStateForgotten\x10\x01\x12&\n\"k_ECloudSto\
    ragePersistStateDeleted\x10\x02*\xe8\x01\n\x12ESDCardFormatStage\x12\x20\
    \n\x1ck_ESDCardFormatStage_Invalid\x10\0\x12!\n\x1dk_ESDCardFormatStage_\
    Starting\x10\x01\x12\x20\n\x1ck_ESDCardFormatStage_Testing\x10\x02\x12!\
    \n\x1dk_ESDCardFormatStage_Rescuing\x10\x03\x12#\n\x1fk_ESDCardFormatSta\
    ge_Formatting\x10\x04\x12#\n\x1fk_ESDCardFormatStage_Finalizing\x10\x05*\
    \x95\x02\n\x13EStorageFormatStage\x12!\n\x1dk_EStorageFormatStage_Invali\
    d\x10\0\x12$\n\x20k_EStorageFormatStage_NotRunning\x10\x01\x12\"\n\x1ek_\
    EStorageFormatStage_Starting\x10\x02\x12!\n\x1dk_EStorageFormatStage_Tes\
    ting\x10\x03\x12\"\n\x1ek_EStorageFormatStage_Rescuing\x10\x04\x12$\n\
    \x20k_EStorageFormatStage_Formatting\x10\x05\x12$\n\x20k_EStorageFormatS\
    tage_Finalizing\x10\x06*\x84\x01\n\x15ESystemFanControlMode\x12\"\n\x1ek\
    _SystemFanControlMode_Invalid\x10\0\x12#\n\x1fk_SystemFanControlMode_Dis\
    abled\x10\x01\x12\"\n\x1ek_SystemFanControlMode_Default\x10\x02*\x81\x01\
    \n\x14EStartupMovieVariant\x12\"\n\x1ek_EStartupMovieVariant_Invalid\x10\
    \0\x12\"\n\x1ek_EStartupMovieVariant_Default\x10\x01\x12!\n\x1dk_EStartu\
    pMovieVariant_Orange\x10\x02*\x8b\x01\n\x13EColorGamutLabelSet\x12\x20\n\
    \x1ck_ColorGamutLabelSet_Default\x10\0\x12$\n\x20k_ColorGamutLabelSet_sR\
    GB_Native\x10\x01\x12,\n(k_ColorGamutLabelSet_Native_sRGB_Boosted\x10\
    \x02*\xc0\x03\n\x14EBluetoothDeviceType\x12!\n\x1dk_BluetoothDeviceType_\
    Invalid\x10\0\x12!\n\x1dk_BluetoothDeviceType_Unknown\x10\x01\x12\x1f\n\
    \x1bk_BluetoothDeviceType_Phone\x10\x02\x12\"\n\x1ek_BluetoothDeviceType\
    _Computer\x10\x03\x12!\n\x1dk_BluetoothDeviceType_Headset\x10\x04\x12$\n\
    \x20k_BluetoothDeviceType_Headphones\x10\x05\x12\"\n\x1ek_BluetoothDevic\
    eType_Speakers\x10\x06\x12$\n\x20k_BluetoothDeviceType_OtherAudio\x10\
    \x07\x12\x1f\n\x1bk_BluetoothDeviceType_Mouse\x10\x08\x12\"\n\x1ek_Bluet\
    oothDeviceType_Joystick\x10\t\x12!\n\x1dk_BluetoothDeviceType_Gamepad\
    \x10\n\x12\"\n\x1ek_BluetoothDeviceType_Keyboard\x10\x0b*\x80\x01\n\x15E\
    SystemAudioDirection\x12\"\n\x1ek_SystemAudioDirection_Invalid\x10\0\x12\
    \x20\n\x1ck_SystemAudioDirection_Input\x10\x01\x12!\n\x1dk_SystemAudioDi\
    rection_Output\x10\x02*\xf1\x02\n\x13ESystemAudioChannel\x12\x20\n\x1ck_\
    SystemAudioChannel_Invalid\x10\0\x12#\n\x1fk_SystemAudioChannel_Aggregat\
    ed\x10\x01\x12\"\n\x1ek_SystemAudioChannel_FrontLeft\x10\x02\x12#\n\x1fk\
    _SystemAudioChannel_FrontRight\x10\x03\x12\x1c\n\x18k_SystemAudioChannel\
    _LFE\x10\x04\x12!\n\x1dk_SystemAudioChannel_BackLeft\x10\x05\x12\"\n\x1e\
    k_SystemAudioChannel_BackRight\x10\x06\x12$\n\x20k_SystemAudioChannel_Fr\
    ontCenter\x10\x07\x12\x20\n\x1ck_SystemAudioChannel_Unknown\x10\x08\x12\
    \x1d\n\x19k_SystemAudioChannel_Mono\x10\t*\xc9\x01\n\x14ESystemAudioPort\
    Type\x12!\n\x1dk_SystemAudioPortType_Invalid\x10\0\x12!\n\x1dk_SystemAud\
    ioPortType_Unknown\x10\x01\x12\"\n\x1ek_SystemAudioPortType_Audio32f\x10\
    \x02\x12\x20\n\x1ck_SystemAudioPortType_Midi8b\x10\x03\x12%\n!k_SystemAu\
    dioPortType_Video32RGBA\x10\x04*\x90\x01\n\x19ESystemAudioPortDirection\
    \x12&\n\"k_SystemAudioPortDirection_Invalid\x10\0\x12$\n\x20k_SystemAudi\
    oPortDirection_Input\x10\x01\x12%\n!k_SystemAudioPortDirection_Output\
    \x10\x02*\x83\x01\n\x13ESystemServiceState\x12%\n!k_ESystemServiceState_\
    Unavailable\x10\0\x12\"\n\x1ek_ESystemServiceState_Disabled\x10\x01\x12!\
    \n\x1dk_ESystemServiceState_Enabled\x10\x02*\xe1\x01\n\x19EGraphicsPerfO\
    verlayLevel\x12&\n\"k_EGraphicsPerfOverlayLevel_Hidden\x10\0\x12%\n!k_EG\
    raphicsPerfOverlayLevel_Basic\x10\x01\x12&\n\"k_EGraphicsPerfOverlayLeve\
    l_Medium\x10\x02\x12$\n\x20k_EGraphicsPerfOverlayLevel_Full\x10\x03\x12'\
    \n#k_EGraphicsPerfOverlayLevel_Minimal\x10\x04*\xe5\x01\n\x14EGPUPerform\
    anceLevel\x12\"\n\x1ek_EGPUPerformanceLevel_Invalid\x10\0\x12\x1f\n\x1bk\
    _EGPUPerformanceLevel_Auto\x10\x01\x12!\n\x1dk_EGPUPerformanceLevel_Manu\
    al\x10\x02\x12\x1e\n\x1ak_EGPUPerformanceLevel_Low\x10\x03\x12\x1f\n\x1b\
    k_EGPUPerformanceLevel_High\x10\x04\x12$\n\x20k_EGPUPerformanceLevel_Pro\
    filing\x10\x05*\xbb\x01\n\x0eEScalingFilter\x12\x1c\n\x18k_EScalingFilte\
    r_Invalid\x10\0\x12\x18\n\x14k_EScalingFilter_FSR\x10\x01\x12\x1c\n\x18k\
    _EScalingFilter_Nearest\x10\x02\x12\x1c\n\x18k_EScalingFilter_Integer\
    \x10\x03\x12\x1b\n\x17k_EScalingFilter_Linear\x10\x04\x12\x18\n\x14k_ESc\
    alingFilter_NIS\x10\x05*\xbb\x01\n\x13ESplitScalingFilter\x12!\n\x1dk_ES\
    plitScalingFilter_Invalid\x10\0\x12\x20\n\x1ck_ESplitScalingFilter_Linea\
    r\x10\x01\x12!\n\x1dk_ESplitScalingFilter_Nearest\x10\x02\x12\x1d\n\x19k\
    _ESplitScalingFilter_FSR\x10\x03\x12\x1d\n\x19k_ESplitScalingFilter_NIS\
    \x10\x04*\xdd\x01\n\x13ESplitScalingScaler\x12!\n\x1dk_ESplitScalingScal\
    er_Invalid\x10\0\x12\x1e\n\x1ak_ESplitScalingScaler_Auto\x10\x01\x12!\n\
    \x1dk_ESplitScalingScaler_Integer\x10\x02\x12\x1d\n\x19k_ESplitScalingSc\
    aler_Fit\x10\x03\x12\x1e\n\x1ak_ESplitScalingScaler_Fill\x10\x04\x12!\n\
    \x1dk_ESplitScalingScaler_Stretch\x10\x05*}\n\x12EGamescopeBlurMode\x12!\
    \n\x1dk_EGamescopeBlurMode_Disabled\x10\0\x12#\n\x1fk_EGamescopeBlurMode\
    _IfOccluded\x10\x01\x12\x1f\n\x1bk_EGamescopeBlurMode_Always\x10\x02*\
    \xa6\x01\n\nESLSHelper\x12\x18\n\x14k_ESLSHelper_Invalid\x10\0\x12\x19\n\
    \x15k_ESLSHelper_Minidump\x10\x01\x12\x16\n\x12k_ESLSHelper_Kdump\x10\
    \x02\x12\x18\n\x14k_ESLSHelper_Journal\x10\x03\x12\x14\n\x10k_ESLSHelper\
    _Gpu\x10\x04\x12\x1b\n\x17k_ESLSHelper_SystemInfo\x10\x05*\xc5\x01\n\x11\
    EHDRVisualization\x12\x1c\n\x18k_EHDRVisualization_None\x10\0\x12\x1f\n\
    \x1bk_EHDRVisualization_Heatmap\x10\x01\x12\x20\n\x1ck_EHDRVisualization\
    _Analysis\x10\x02\x12'\n#k_EHDRVisualization_HeatmapExtended\x10\x03\x12\
    &\n\"k_EHDRVisualization_HeatmapClassic\x10\x04*\x81\x01\n\x13EHDRToneMa\
    pOperator\x12!\n\x1dk_EHDRToneMapOperator_Invalid\x10\0\x12#\n\x1fk_EHDR\
    ToneMapOperator_Uncharted\x10\x01\x12\"\n\x1ek_EHDRToneMapOperator_Reinh\
    ard\x10\x02*|\n\x0cECPUGovernor\x12\x1a\n\x16k_ECPUGovernor_Invalid\x10\
    \0\x12\x17\n\x13k_ECPUGovernor_Perf\x10\x01\x12\x1c\n\x18k_ECPUGovernor_\
    Powersave\x10\x02\x12\x19\n\x15k_ECPUGovernor_Manual\x10\x03*\xe2\x01\n\
    \x0cEUpdaterType\x12\x1a\n\x16k_EUpdaterType_Invalid\x10\0\x12\x19\n\x15\
    k_EUpdaterType_Client\x10\x01\x12\x15\n\x11k_EUpdaterType_OS\x10\x02\x12\
    \x17\n\x13k_EUpdaterType_BIOS\x10\x03\x12\x1d\n\x19k_EUpdaterType_Aggreg\
    ated\x10\x04\x12\x18\n\x14k_EUpdaterType_Test1\x10\x05\x12\x18\n\x14k_EU\
    pdaterType_Test2\x10\x06\x12\x18\n\x14k_EUpdaterType_Dummy\x10\x07*\xf9\
    \x01\n\rEUpdaterState\x12\x1b\n\x17k_EUpdaterState_Invalid\x10\0\x12\x1c\
    \n\x18k_EUpdaterState_UpToDate\x10\x02\x12\x1c\n\x18k_EUpdaterState_Chec\
    king\x10\x03\x12\x1d\n\x19k_EUpdaterState_Available\x10\x04\x12\x1c\n\
    \x18k_EUpdaterState_Applying\x10\x05\x12(\n$k_EUpdaterState_ClientRestar\
    tPending\x10\x06\x12(\n$k_EUpdaterState_SystemRestartPending\x10\x07*\
    \xe1\x01\n\x18EStorageBlockContentType\x12&\n\"k_EStorageBlockContentTyp\
    e_Invalid\x10\0\x12&\n\"k_EStorageBlockContentType_Unknown\x10\x01\x12)\
    \n%k_EStorageBlockContentType_FileSystem\x10\x02\x12%\n!k_EStorageBlockC\
    ontentType_Crypto\x10\x03\x12#\n\x1fk_EStorageBlockContentType_Raid\x10\
    \x04*\xc3\x01\n\x1bEStorageBlockFileSystemType\x12)\n%k_EStorageBlockFil\
    eSystemType_Invalid\x10\0\x12)\n%k_EStorageBlockFileSystemType_Unknown\
    \x10\x01\x12&\n\"k_EStorageBlockFileSystemType_VFat\x10\x02\x12&\n\"k_ES\
    torageBlockFileSystemType_Ext4\x10\x03*\xd0\x01\n\x16EStorageDriveMediaT\
    ype\x12$\n\x20k_EStorageDriveMediaType_Invalid\x10\0\x12$\n\x20k_EStorag\
    eDriveMediaType_Unknown\x10\x01\x12\x20\n\x1ck_EStorageDriveMediaType_HD\
    D\x10\x02\x12\x20\n\x1ck_EStorageDriveMediaType_SSD\x10\x03\x12&\n\"k_ES\
    torageDriveMediaType_Removable\x10\x04*\xb3\x01\n\x1fESystemDisplayCompa\
    tibilityMode\x12-\n)k_ESystemDisplayCompatibilityMode_Invalid\x10\0\x12*\
    \n&k_ESystemDisplayCompatibilityMode_None\x10\x01\x125\n1k_ESystemDispla\
    yCompatibilityMode_MinimalBandwith\x10\x02*\xe3\x01\n\x1fESteamDeckCompa\
    tibilityCategory\x12-\n)k_ESteamDeckCompatibilityCategory_Unknown\x10\0\
    \x121\n-k_ESteamDeckCompatibilityCategory_Unsupported\x10\x01\x12.\n*k_E\
    SteamDeckCompatibilityCategory_Playable\x10\x02\x12.\n*k_ESteamDeckCompa\
    tibilityCategory_Verified\x10\x03*\xd0\x02\n(ESteamDeckCompatibilityResu\
    ltDisplayType\x128\n4k_ESteamDeckCompatibilityResultDisplayType_Invisibl\
    e\x10\0\x12<\n8k_ESteamDeckCompatibilityResultDisplayType_Informational\
    \x10\x01\x12:\n6k_ESteamDeckCompatibilityResultDisplayType_Unsupported\
    \x10\x02\x127\n3k_ESteamDeckCompatibilityResultDisplayType_Playable\x10\
    \x03\x127\n3k_ESteamDeckCompatibilityResultDisplayType_Verified\x10\x04*\
    w\n\x08EACState\x12\x16\n\x12k_EACState_Unknown\x10\0\x12\x1b\n\x17k_EAC\
    State_Disconnected\x10\x01\x12\x18\n\x14k_EACState_Connected\x10\x02\x12\
    \x1c\n\x18k_EACState_ConnectedSlow\x10\x03*\x85\x01\n\rEBatteryState\x12\
    \x1b\n\x17k_EBatteryState_Unknown\x10\0\x12\x1f\n\x1bk_EBatteryState_Dis\
    charging\x10\x01\x12\x1c\n\x18k_EBatteryState_Charging\x10\x02\x12\x18\n\
    \x14k_EBatteryState_Full\x10\x03*\xc3\x01\n\tEOSBranch\x12\x17\n\x13k_EO\
    SBranch_Unknown\x10\0\x12\x17\n\x13k_EOSBranch_Release\x10\x01\x12\x20\n\
    \x1ck_EOSBranch_ReleaseCandidate\x10\x02\x12\x14\n\x10k_EOSBranch_Beta\
    \x10\x03\x12\x1d\n\x19k_EOSBranch_BetaCandidate\x10\x04\x12\x14\n\x10k_E\
    OSBranch_Main\x10\x05\x12\x17\n\x13k_EOSBranch_Staging\x10\x06*\xdd\x05\
    \n\x13ECommunityItemClass\x12!\n\x1dk_ECommunityItemClass_Invalid\x10\0\
    \x12\x1f\n\x1bk_ECommunityItemClass_Badge\x10\x01\x12\"\n\x1ek_ECommunit\
    yItemClass_GameCard\x10\x02\x12+\n'k_ECommunityItemClass_ProfileBackgrou\
    nd\x10\x03\x12\"\n\x1ek_ECommunityItemClass_Emoticon\x10\x04\x12%\n!k_EC\
    ommunityItemClass_BoosterPack\x10\x05\x12$\n\x20k_ECommunityItemClass_Co\
    nsumable\x10\x06\x12!\n\x1dk_ECommunityItemClass_GameGoo\x10\x07\x12)\n%\
    k_ECommunityItemClass_ProfileModifier\x10\x08\x12\x1f\n\x1bk_ECommunityI\
    temClass_Scene\x10\t\x12$\n\x20k_ECommunityItemClass_SalienItem\x10\n\
    \x12!\n\x1dk_ECommunityItemClass_Sticker\x10\x0b\x12$\n\x20k_ECommunityI\
    temClass_ChatEffect\x10\x0c\x12/\n+k_ECommunityItemClass_MiniProfileBack\
    ground\x10\r\x12%\n!k_ECommunityItemClass_AvatarFrame\x10\x0e\x12(\n$k_E\
    CommunityItemClass_AnimatedAvatar\x10\x0f\x12/\n+k_ECommunityItemClass_S\
    teamDeckKeyboardSkin\x10\x10\x12/\n+k_ECommunityItemClass_SteamDeckStart\
    upMovie\x10\x11*\xd9\x01\n\x1fESteamDeckCompatibilityFeedback\x12+\n'k_E\
    SteamDeckCompatibilityFeedback_Unset\x10\0\x12+\n'k_ESteamDeckCompatibil\
    ityFeedback_Agree\x10\x01\x12.\n*k_ESteamDeckCompatibilityFeedback_Disag\
    ree\x10\x02\x12,\n(k_ESteamDeckCompatibilityFeedback_Ignore\x10\x03*\x9f\
    \x01\n\x1eEProvideDeckFeedbackPreference\x12*\n&k_EProvideDeckFeedbackPr\
    eference_Unset\x10\0\x12(\n$k_EProvideDeckFeedbackPreference_Yes\x10\x01\
    \x12'\n#k_EProvideDeckFeedbackPreference_No\x10\x02*\xb1\x03\n\rETouchGe\
    sture\x12\x17\n\x13k_ETouchGestureNone\x10\0\x12\x18\n\x14k_ETouchGestur\
    eTouch\x10\x01\x12\x16\n\x12k_ETouchGestureTap\x10\x02\x12\x1c\n\x18k_ET\
    ouchGestureDoubleTap\x10\x03\x12\x1d\n\x19k_ETouchGestureShortPress\x10\
    \x04\x12\x1c\n\x18k_ETouchGestureLongPress\x10\x05\x12\x1a\n\x16k_ETouch\
    GestureLongTap\x10\x06\x12\x1f\n\x1bk_ETouchGestureTwoFingerTap\x10\x07\
    \x12\x1f\n\x1bk_ETouchGestureTapCancelled\x10\x08\x12\x1d\n\x19k_ETouchG\
    esturePinchBegin\x10\t\x12\x1e\n\x1ak_ETouchGesturePinchUpdate\x10\n\x12\
    \x1b\n\x17k_ETouchGesturePinchEnd\x10\x0b\x12\x1d\n\x19k_ETouchGestureFl\
    ingStart\x10\x0c\x12!\n\x1dk_ETouchGestureFlingCancelled\x10\r*\x8c\x01\
    \n\x13ESessionPersistence\x12*\n\x1dk_ESessionPersistence_Invalid\x10\
    \xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12#\n\x1fk_ESessionPersistence\
    _Ephemeral\x10\0\x12$\n\x20k_ESessionPersistence_Persistent\x10\x01*\xd9\
    \x01\n\x1aENewSteamAnnouncementState\x12(\n$k_ENewSteamAnnouncementState\
    _Invalid\x10\0\x12(\n$k_ENewSteamAnnouncementState_AllRead\x10\x01\x120\
    \n,k_ENewSteamAnnouncementState_NewAnnouncement\x10\x02\x125\n1k_ENewSte\
    amAnnouncementState_FeaturedAnnouncement\x10\x03*\x8b\x07\n\x12ECommentT\
    hreadType\x12\x1f\n\x1bk_ECommentThreadTypeInvalid\x10\0\x12-\n)k_EComme\
    ntThreadTypeScreenshot_Deprecated\x10\x01\x121\n-k_ECommentThreadTypeWor\
    kshopAccount_Developer\x10\x02\x12.\n*k_ECommentThreadTypeWorkshopAccoun\
    t_Public\x10\x03\x12/\n+k_ECommentThreadTypePublishedFile_Developer\x10\
    \x04\x12,\n(k_ECommentThreadTypePublishedFile_Public\x10\x05\x12\x1c\n\
    \x18k_ECommentThreadTypeTest\x10\x06\x12\"\n\x1ek_ECommentThreadTypeForu\
    mTopic\x10\x07\x12&\n\"k_ECommentThreadTypeRecommendation\x10\x08\x12(\n\
    $k_ECommentThreadTypeVideo_Deprecated\x10\t\x12\x1f\n\x1bk_ECommentThrea\
    dTypeProfile\x10\n\x12\x20\n\x1ck_ECommentThreadTypeNewsPost\x10\x0b\x12\
    \x1c\n\x18k_ECommentThreadTypeClan\x10\x0c\x12(\n$k_ECommentThreadTypeCl\
    anAnnouncement\x10\r\x12!\n\x1dk_ECommentThreadTypeClanEvent\x10\x0e\x12\
    +\n'k_ECommentThreadTypeUserStatusPublished\x10\x0f\x12+\n'k_ECommentThr\
    eadTypeUserReceivedNewGame\x10\x10\x122\n.k_ECommentThreadTypePublishedF\
    ile_Announcement\x10\x11\x12(\n$k_ECommentThreadTypeModeratorMessage\x10\
    \x12\x12&\n\"k_ECommentThreadTypeClanCuratedApp\x10\x13\x12$\n\x20k_ECom\
    mentThreadTypeQAndASession\x10\x14\x12\x1b\n\x17k_ECommentThreadTypeMax\
    \x10\x15*\xd7\x01\n\x14EBroadcastPermission\x12\"\n\x1ek_EBroadcastPermi\
    ssionDisabled\x10\0\x12(\n$k_EBroadcastPermissionFriendsApprove\x10\x01\
    \x12(\n$k_EBroadcastPermissionFriendsAllowed\x10\x02\x12\x20\n\x1ck_EBro\
    adcastPermissionPublic\x10\x03\x12%\n!k_EBroadcastPermissionSubscribers\
    \x10\x04*f\n\x18EBroadcastEncoderSetting\x12\"\n\x1ek_EBroadcastEncoderB\
    estQuality\x10\0\x12&\n\"k_EBroadcastEncoderBestPerformance\x10\x01*y\n\
    \x14ECloudGamingPlatform\x12\x1e\n\x1ak_ECloudGamingPlatformNone\x10\0\
    \x12\x1f\n\x1bk_ECloudGamingPlatformValve\x10\x01\x12\x20\n\x1ck_ECloudG\
    amingPlatformNVIDIA\x10\x02B\tH\x01\x80\x01\x01\x80\xb5\x18\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages_base::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(0);
            let mut enums = ::std::vec::Vec::with_capacity(50);
            enums.push(EPublishedFileQueryType::generated_enum_descriptor_data());
            enums.push(EPublishedFileInappropriateProvider::generated_enum_descriptor_data());
            enums.push(EPublishedFileInappropriateResult::generated_enum_descriptor_data());
            enums.push(EPersonaStateFlag::generated_enum_descriptor_data());
            enums.push(EContentCheckProvider::generated_enum_descriptor_data());
            enums.push(EProfileCustomizationType::generated_enum_descriptor_data());
            enums.push(EPublishedFileStorageSystem::generated_enum_descriptor_data());
            enums.push(ECloudStoragePersistState::generated_enum_descriptor_data());
            enums.push(ESDCardFormatStage::generated_enum_descriptor_data());
            enums.push(EStorageFormatStage::generated_enum_descriptor_data());
            enums.push(ESystemFanControlMode::generated_enum_descriptor_data());
            enums.push(EStartupMovieVariant::generated_enum_descriptor_data());
            enums.push(EColorGamutLabelSet::generated_enum_descriptor_data());
            enums.push(EBluetoothDeviceType::generated_enum_descriptor_data());
            enums.push(ESystemAudioDirection::generated_enum_descriptor_data());
            enums.push(ESystemAudioChannel::generated_enum_descriptor_data());
            enums.push(ESystemAudioPortType::generated_enum_descriptor_data());
            enums.push(ESystemAudioPortDirection::generated_enum_descriptor_data());
            enums.push(ESystemServiceState::generated_enum_descriptor_data());
            enums.push(EGraphicsPerfOverlayLevel::generated_enum_descriptor_data());
            enums.push(EGPUPerformanceLevel::generated_enum_descriptor_data());
            enums.push(EScalingFilter::generated_enum_descriptor_data());
            enums.push(ESplitScalingFilter::generated_enum_descriptor_data());
            enums.push(ESplitScalingScaler::generated_enum_descriptor_data());
            enums.push(EGamescopeBlurMode::generated_enum_descriptor_data());
            enums.push(ESLSHelper::generated_enum_descriptor_data());
            enums.push(EHDRVisualization::generated_enum_descriptor_data());
            enums.push(EHDRToneMapOperator::generated_enum_descriptor_data());
            enums.push(ECPUGovernor::generated_enum_descriptor_data());
            enums.push(EUpdaterType::generated_enum_descriptor_data());
            enums.push(EUpdaterState::generated_enum_descriptor_data());
            enums.push(EStorageBlockContentType::generated_enum_descriptor_data());
            enums.push(EStorageBlockFileSystemType::generated_enum_descriptor_data());
            enums.push(EStorageDriveMediaType::generated_enum_descriptor_data());
            enums.push(ESystemDisplayCompatibilityMode::generated_enum_descriptor_data());
            enums.push(ESteamDeckCompatibilityCategory::generated_enum_descriptor_data());
            enums.push(ESteamDeckCompatibilityResultDisplayType::generated_enum_descriptor_data());
            enums.push(EACState::generated_enum_descriptor_data());
            enums.push(EBatteryState::generated_enum_descriptor_data());
            enums.push(EOSBranch::generated_enum_descriptor_data());
            enums.push(ECommunityItemClass::generated_enum_descriptor_data());
            enums.push(ESteamDeckCompatibilityFeedback::generated_enum_descriptor_data());
            enums.push(EProvideDeckFeedbackPreference::generated_enum_descriptor_data());
            enums.push(ETouchGesture::generated_enum_descriptor_data());
            enums.push(ESessionPersistence::generated_enum_descriptor_data());
            enums.push(ENewSteamAnnouncementState::generated_enum_descriptor_data());
            enums.push(ECommentThreadType::generated_enum_descriptor_data());
            enums.push(EBroadcastPermission::generated_enum_descriptor_data());
            enums.push(EBroadcastEncoderSetting::generated_enum_descriptor_data());
            enums.push(ECloudGamingPlatform::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
