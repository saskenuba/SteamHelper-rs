// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_remoteplay.proto`

// @@protoc_insertion_point(message:CDiscoveryPingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDiscoveryPingRequest {
    // message fields
    // @@protoc_insertion_point(field:CDiscoveryPingRequest.sequence)
    pub sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDiscoveryPingRequest.packet_size_requested)
    pub packet_size_requested: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDiscoveryPingRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDiscoveryPingRequest {
    fn default() -> &'a CDiscoveryPingRequest {
        <CDiscoveryPingRequest as crate::Message>::default_instance()
    }
}

impl CDiscoveryPingRequest {
    pub fn new() -> CDiscoveryPingRequest {
        ::std::default::Default::default()
    }

    // optional uint32 sequence = 1;

    pub fn sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    // optional uint32 packet_size_requested = 2;

    pub fn packet_size_requested(&self) -> u32 {
        self.packet_size_requested.unwrap_or(0)
    }

    pub fn clear_packet_size_requested(&mut self) {
        self.packet_size_requested = ::std::option::Option::None;
    }

    pub fn has_packet_size_requested(&self) -> bool {
        self.packet_size_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_requested(&mut self, v: u32) {
        self.packet_size_requested = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence",
            |m: &CDiscoveryPingRequest| { &m.sequence },
            |m: &mut CDiscoveryPingRequest| { &mut m.sequence },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "packet_size_requested",
            |m: &CDiscoveryPingRequest| { &m.packet_size_requested },
            |m: &mut CDiscoveryPingRequest| { &mut m.packet_size_requested },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CDiscoveryPingRequest>(
            "CDiscoveryPingRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CDiscoveryPingRequest {
    const NAME: &'static str = "CDiscoveryPingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.packet_size_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.packet_size_requested {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packet_size_requested {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDiscoveryPingRequest {
        CDiscoveryPingRequest::new()
    }

    fn clear(&mut self) {
        self.sequence = ::std::option::Option::None;
        self.packet_size_requested = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDiscoveryPingRequest {
        static instance: CDiscoveryPingRequest = CDiscoveryPingRequest {
            sequence: ::std::option::Option::None,
            packet_size_requested: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CDiscoveryPingRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDiscoveryPingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDiscoveryPingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CDiscoveryPingRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDiscoveryPingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDiscoveryPingResponse {
    // message fields
    // @@protoc_insertion_point(field:CDiscoveryPingResponse.sequence)
    pub sequence: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDiscoveryPingResponse.packet_size_received)
    pub packet_size_received: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CDiscoveryPingResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDiscoveryPingResponse {
    fn default() -> &'a CDiscoveryPingResponse {
        <CDiscoveryPingResponse as crate::Message>::default_instance()
    }
}

impl CDiscoveryPingResponse {
    pub fn new() -> CDiscoveryPingResponse {
        ::std::default::Default::default()
    }

    // optional uint32 sequence = 1;

    pub fn sequence(&self) -> u32 {
        self.sequence.unwrap_or(0)
    }

    pub fn clear_sequence(&mut self) {
        self.sequence = ::std::option::Option::None;
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: u32) {
        self.sequence = ::std::option::Option::Some(v);
    }

    // optional uint32 packet_size_received = 2;

    pub fn packet_size_received(&self) -> u32 {
        self.packet_size_received.unwrap_or(0)
    }

    pub fn clear_packet_size_received(&mut self) {
        self.packet_size_received = ::std::option::Option::None;
    }

    pub fn has_packet_size_received(&self) -> bool {
        self.packet_size_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_size_received(&mut self, v: u32) {
        self.packet_size_received = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence",
            |m: &CDiscoveryPingResponse| { &m.sequence },
            |m: &mut CDiscoveryPingResponse| { &mut m.sequence },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "packet_size_received",
            |m: &CDiscoveryPingResponse| { &m.packet_size_received },
            |m: &mut CDiscoveryPingResponse| { &mut m.packet_size_received },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CDiscoveryPingResponse>(
            "CDiscoveryPingResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CDiscoveryPingResponse {
    const NAME: &'static str = "CDiscoveryPingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sequence = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.packet_size_received = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sequence {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.packet_size_received {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.sequence {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packet_size_received {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDiscoveryPingResponse {
        CDiscoveryPingResponse::new()
    }

    fn clear(&mut self) {
        self.sequence = ::std::option::Option::None;
        self.packet_size_received = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDiscoveryPingResponse {
        static instance: CDiscoveryPingResponse = CDiscoveryPingResponse {
            sequence: ::std::option::Option::None,
            packet_size_received: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CDiscoveryPingResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDiscoveryPingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDiscoveryPingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CDiscoveryPingResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamingClientHandshakeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingClientHandshakeInfo {
    // message fields
    // @@protoc_insertion_point(field:CStreamingClientHandshakeInfo.network_test)
    pub network_test: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingClientHandshakeInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingClientHandshakeInfo {
    fn default() -> &'a CStreamingClientHandshakeInfo {
        <CStreamingClientHandshakeInfo as crate::Message>::default_instance()
    }
}

impl CStreamingClientHandshakeInfo {
    pub fn new() -> CStreamingClientHandshakeInfo {
        ::std::default::Default::default()
    }

    // optional int32 network_test = 2;

    pub fn network_test(&self) -> i32 {
        self.network_test.unwrap_or(0)
    }

    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: i32) {
        self.network_test = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_test",
            |m: &CStreamingClientHandshakeInfo| { &m.network_test },
            |m: &mut CStreamingClientHandshakeInfo| { &mut m.network_test },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamingClientHandshakeInfo>(
            "CStreamingClientHandshakeInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamingClientHandshakeInfo {
    const NAME: &'static str = "CStreamingClientHandshakeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.network_test = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.network_test {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.network_test {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingClientHandshakeInfo {
        CStreamingClientHandshakeInfo::new()
    }

    fn clear(&mut self) {
        self.network_test = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingClientHandshakeInfo {
        static instance: CStreamingClientHandshakeInfo = CStreamingClientHandshakeInfo {
            network_test: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamingClientHandshakeInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamingClientHandshakeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamingClientHandshakeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamingClientHandshakeInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClientHandshakeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClientHandshakeMsg {
    // message fields
    // @@protoc_insertion_point(field:CClientHandshakeMsg.info)
    pub info: crate::MessageField<CStreamingClientHandshakeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientHandshakeMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientHandshakeMsg {
    fn default() -> &'a CClientHandshakeMsg {
        <CClientHandshakeMsg as crate::Message>::default_instance()
    }
}

impl CClientHandshakeMsg {
    pub fn new() -> CClientHandshakeMsg {
        ::std::default::Default::default()
    }

    // required .CStreamingClientHandshakeInfo info = 1;

    pub fn info(&self) -> &CStreamingClientHandshakeInfo {
        self.info.as_ref().unwrap_or_else(|| <CStreamingClientHandshakeInfo as crate::Message>::default_instance())
    }

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CStreamingClientHandshakeInfo) {
        self.info = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CStreamingClientHandshakeInfo {
        self.info.mut_or_insert_default()
    }

    // Take field
    pub fn take_info(&mut self) -> CStreamingClientHandshakeInfo {
        self.info.take().unwrap_or_else(|| CStreamingClientHandshakeInfo::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamingClientHandshakeInfo>(
            "info",
            |m: &CClientHandshakeMsg| { &m.info },
            |m: &mut CClientHandshakeMsg| { &mut m.info },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClientHandshakeMsg>(
            "CClientHandshakeMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClientHandshakeMsg {
    const NAME: &'static str = "CClientHandshakeMsg";

    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.info.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientHandshakeMsg {
        CClientHandshakeMsg::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientHandshakeMsg {
        static instance: CClientHandshakeMsg = CClientHandshakeMsg {
            info: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClientHandshakeMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientHandshakeMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientHandshakeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClientHandshakeMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamingServerHandshakeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingServerHandshakeInfo {
    // message fields
    // @@protoc_insertion_point(field:CStreamingServerHandshakeInfo.mtu)
    pub mtu: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingServerHandshakeInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingServerHandshakeInfo {
    fn default() -> &'a CStreamingServerHandshakeInfo {
        <CStreamingServerHandshakeInfo as crate::Message>::default_instance()
    }
}

impl CStreamingServerHandshakeInfo {
    pub fn new() -> CStreamingServerHandshakeInfo {
        ::std::default::Default::default()
    }

    // optional int32 mtu = 1;

    pub fn mtu(&self) -> i32 {
        self.mtu.unwrap_or(0)
    }

    pub fn clear_mtu(&mut self) {
        self.mtu = ::std::option::Option::None;
    }

    pub fn has_mtu(&self) -> bool {
        self.mtu.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mtu(&mut self, v: i32) {
        self.mtu = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mtu",
            |m: &CStreamingServerHandshakeInfo| { &m.mtu },
            |m: &mut CStreamingServerHandshakeInfo| { &mut m.mtu },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamingServerHandshakeInfo>(
            "CStreamingServerHandshakeInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamingServerHandshakeInfo {
    const NAME: &'static str = "CStreamingServerHandshakeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mtu = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mtu {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.mtu {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingServerHandshakeInfo {
        CStreamingServerHandshakeInfo::new()
    }

    fn clear(&mut self) {
        self.mtu = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingServerHandshakeInfo {
        static instance: CStreamingServerHandshakeInfo = CStreamingServerHandshakeInfo {
            mtu: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamingServerHandshakeInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamingServerHandshakeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamingServerHandshakeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamingServerHandshakeInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CServerHandshakeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CServerHandshakeMsg {
    // message fields
    // @@protoc_insertion_point(field:CServerHandshakeMsg.info)
    pub info: crate::MessageField<CStreamingServerHandshakeInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CServerHandshakeMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CServerHandshakeMsg {
    fn default() -> &'a CServerHandshakeMsg {
        <CServerHandshakeMsg as crate::Message>::default_instance()
    }
}

impl CServerHandshakeMsg {
    pub fn new() -> CServerHandshakeMsg {
        ::std::default::Default::default()
    }

    // required .CStreamingServerHandshakeInfo info = 1;

    pub fn info(&self) -> &CStreamingServerHandshakeInfo {
        self.info.as_ref().unwrap_or_else(|| <CStreamingServerHandshakeInfo as crate::Message>::default_instance())
    }

    pub fn clear_info(&mut self) {
        self.info.clear();
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: CStreamingServerHandshakeInfo) {
        self.info = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut CStreamingServerHandshakeInfo {
        self.info.mut_or_insert_default()
    }

    // Take field
    pub fn take_info(&mut self) -> CStreamingServerHandshakeInfo {
        self.info.take().unwrap_or_else(|| CStreamingServerHandshakeInfo::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamingServerHandshakeInfo>(
            "info",
            |m: &CServerHandshakeMsg| { &m.info },
            |m: &mut CServerHandshakeMsg| { &mut m.info },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CServerHandshakeMsg>(
            "CServerHandshakeMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CServerHandshakeMsg {
    const NAME: &'static str = "CServerHandshakeMsg";

    fn is_initialized(&self) -> bool {
        if self.info.is_none() {
            return false;
        }
        for v in &self.info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.info.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CServerHandshakeMsg {
        CServerHandshakeMsg::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CServerHandshakeMsg {
        static instance: CServerHandshakeMsg = CServerHandshakeMsg {
            info: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CServerHandshakeMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CServerHandshakeMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CServerHandshakeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CServerHandshakeMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CAuthenticationRequestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAuthenticationRequestMsg {
    // message fields
    // @@protoc_insertion_point(field:CAuthenticationRequestMsg.token)
    pub token: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CAuthenticationRequestMsg.version)
    pub version: ::std::option::Option<crate::EnumOrUnknown<EStreamVersion>>,
    // @@protoc_insertion_point(field:CAuthenticationRequestMsg.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CAuthenticationRequestMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAuthenticationRequestMsg {
    fn default() -> &'a CAuthenticationRequestMsg {
        <CAuthenticationRequestMsg as crate::Message>::default_instance()
    }
}

impl CAuthenticationRequestMsg {
    pub fn new() -> CAuthenticationRequestMsg {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::bytes::Bytes) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::bytes::Bytes {
        self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional .EStreamVersion version = 2;

    pub fn version(&self) -> EStreamVersion {
        match self.version {
            Some(e) => e.enum_value_or(EStreamVersion::k_EStreamVersionNone),
            None => EStreamVersion::k_EStreamVersionNone,
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CAuthenticationRequestMsg| { &m.token },
            |m: &mut CAuthenticationRequestMsg| { &mut m.token },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CAuthenticationRequestMsg| { &m.version },
            |m: &mut CAuthenticationRequestMsg| { &mut m.version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CAuthenticationRequestMsg| { &m.steamid },
            |m: &mut CAuthenticationRequestMsg| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CAuthenticationRequestMsg>(
            "CAuthenticationRequestMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CAuthenticationRequestMsg {
    const NAME: &'static str = "CAuthenticationRequestMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.version {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.steamid {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.version {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.steamid {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAuthenticationRequestMsg {
        CAuthenticationRequestMsg::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAuthenticationRequestMsg {
        static instance: CAuthenticationRequestMsg = CAuthenticationRequestMsg {
            token: ::std::option::Option::None,
            version: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CAuthenticationRequestMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAuthenticationRequestMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAuthenticationRequestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CAuthenticationRequestMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CAuthenticationResponseMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAuthenticationResponseMsg {
    // message fields
    // @@protoc_insertion_point(field:CAuthenticationResponseMsg.result)
    pub result: ::std::option::Option<crate::EnumOrUnknown<cauthentication_response_msg::AuthenticationResult>>,
    // @@protoc_insertion_point(field:CAuthenticationResponseMsg.version)
    pub version: ::std::option::Option<crate::EnumOrUnknown<EStreamVersion>>,
    // special fields
    // @@protoc_insertion_point(special_field:CAuthenticationResponseMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAuthenticationResponseMsg {
    fn default() -> &'a CAuthenticationResponseMsg {
        <CAuthenticationResponseMsg as crate::Message>::default_instance()
    }
}

impl CAuthenticationResponseMsg {
    pub fn new() -> CAuthenticationResponseMsg {
        ::std::default::Default::default()
    }

    // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1;

    pub fn result(&self) -> cauthentication_response_msg::AuthenticationResult {
        match self.result {
            Some(e) => e.enum_value_or(cauthentication_response_msg::AuthenticationResult::SUCCEEDED),
            None => cauthentication_response_msg::AuthenticationResult::SUCCEEDED,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cauthentication_response_msg::AuthenticationResult) {
        self.result = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EStreamVersion version = 2;

    pub fn version(&self) -> EStreamVersion {
        match self.version {
            Some(e) => e.enum_value_or(EStreamVersion::k_EStreamVersionNone),
            None => EStreamVersion::k_EStreamVersionNone,
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: EStreamVersion) {
        self.version = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CAuthenticationResponseMsg| { &m.result },
            |m: &mut CAuthenticationResponseMsg| { &mut m.result },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CAuthenticationResponseMsg| { &m.version },
            |m: &mut CAuthenticationResponseMsg| { &mut m.version },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CAuthenticationResponseMsg>(
            "CAuthenticationResponseMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CAuthenticationResponseMsg {
    const NAME: &'static str = "CAuthenticationResponseMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.version = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.version {
            my_size += crate::rt::int32_size(2, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.version {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAuthenticationResponseMsg {
        CAuthenticationResponseMsg::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAuthenticationResponseMsg {
        static instance: CAuthenticationResponseMsg = CAuthenticationResponseMsg {
            result: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CAuthenticationResponseMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAuthenticationResponseMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAuthenticationResponseMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CAuthenticationResponseMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CAuthenticationResponseMsg`
pub mod cauthentication_response_msg {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CAuthenticationResponseMsg.AuthenticationResult)
    pub enum AuthenticationResult {
        // @@protoc_insertion_point(enum_value:CAuthenticationResponseMsg.AuthenticationResult.SUCCEEDED)
        SUCCEEDED = 0,
        // @@protoc_insertion_point(enum_value:CAuthenticationResponseMsg.AuthenticationResult.FAILED)
        FAILED = 1,
    }

    impl crate::Enum for AuthenticationResult {
        const NAME: &'static str = "AuthenticationResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<AuthenticationResult> {
            match value {
                0 => ::std::option::Option::Some(AuthenticationResult::SUCCEEDED),
                1 => ::std::option::Option::Some(AuthenticationResult::FAILED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<AuthenticationResult> {
            match str {
                "SUCCEEDED" => ::std::option::Option::Some(AuthenticationResult::SUCCEEDED),
                "FAILED" => ::std::option::Option::Some(AuthenticationResult::FAILED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [AuthenticationResult] = &[
            AuthenticationResult::SUCCEEDED,
            AuthenticationResult::FAILED,
        ];
    }

    impl crate::EnumFull for AuthenticationResult {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CAuthenticationResponseMsg.AuthenticationResult").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for AuthenticationResult {
        fn default() -> Self {
            AuthenticationResult::SUCCEEDED
        }
    }

    impl AuthenticationResult {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<AuthenticationResult>("CAuthenticationResponseMsg.AuthenticationResult")
        }
    }
}

// @@protoc_insertion_point(message:CKeepAliveMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CKeepAliveMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CKeepAliveMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CKeepAliveMsg {
    fn default() -> &'a CKeepAliveMsg {
        <CKeepAliveMsg as crate::Message>::default_instance()
    }
}

impl CKeepAliveMsg {
    pub fn new() -> CKeepAliveMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CKeepAliveMsg>(
            "CKeepAliveMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CKeepAliveMsg {
    const NAME: &'static str = "CKeepAliveMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CKeepAliveMsg {
        CKeepAliveMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CKeepAliveMsg {
        static instance: CKeepAliveMsg = CKeepAliveMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CKeepAliveMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CKeepAliveMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CKeepAliveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CKeepAliveMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStartNetworkTestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStartNetworkTestMsg {
    // message fields
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.frames)
    pub frames: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.framerate)
    pub framerate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.bitrate_kbps)
    pub bitrate_kbps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.burst_bitrate_kbps)
    pub burst_bitrate_kbps: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartNetworkTestMsg.bandwidth_test)
    pub bandwidth_test: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CStartNetworkTestMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStartNetworkTestMsg {
    fn default() -> &'a CStartNetworkTestMsg {
        <CStartNetworkTestMsg as crate::Message>::default_instance()
    }
}

impl CStartNetworkTestMsg {
    pub fn new() -> CStartNetworkTestMsg {
        ::std::default::Default::default()
    }

    // optional uint32 frames = 1;

    pub fn frames(&self) -> u32 {
        self.frames.unwrap_or(0)
    }

    pub fn clear_frames(&mut self) {
        self.frames = ::std::option::Option::None;
    }

    pub fn has_frames(&self) -> bool {
        self.frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frames(&mut self, v: u32) {
        self.frames = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate = 2;

    pub fn framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 bitrate_kbps = 3;

    pub fn bitrate_kbps(&self) -> u32 {
        self.bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_bitrate_kbps(&mut self) {
        self.bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_bitrate_kbps(&self) -> bool {
        self.bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate_kbps(&mut self, v: u32) {
        self.bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional uint32 burst_bitrate_kbps = 4;

    pub fn burst_bitrate_kbps(&self) -> u32 {
        self.burst_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_burst_bitrate_kbps(&mut self) {
        self.burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_burst_bitrate_kbps(&self) -> bool {
        self.burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_burst_bitrate_kbps(&mut self, v: u32) {
        self.burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool bandwidth_test = 5;

    pub fn bandwidth_test(&self) -> bool {
        self.bandwidth_test.unwrap_or(false)
    }

    pub fn clear_bandwidth_test(&mut self) {
        self.bandwidth_test = ::std::option::Option::None;
    }

    pub fn has_bandwidth_test(&self) -> bool {
        self.bandwidth_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bandwidth_test(&mut self, v: bool) {
        self.bandwidth_test = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "frames",
            |m: &CStartNetworkTestMsg| { &m.frames },
            |m: &mut CStartNetworkTestMsg| { &mut m.frames },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "framerate",
            |m: &CStartNetworkTestMsg| { &m.framerate },
            |m: &mut CStartNetworkTestMsg| { &mut m.framerate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bitrate_kbps",
            |m: &CStartNetworkTestMsg| { &m.bitrate_kbps },
            |m: &mut CStartNetworkTestMsg| { &mut m.bitrate_kbps },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "burst_bitrate_kbps",
            |m: &CStartNetworkTestMsg| { &m.burst_bitrate_kbps },
            |m: &mut CStartNetworkTestMsg| { &mut m.burst_bitrate_kbps },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bandwidth_test",
            |m: &CStartNetworkTestMsg| { &m.bandwidth_test },
            |m: &mut CStartNetworkTestMsg| { &mut m.bandwidth_test },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStartNetworkTestMsg>(
            "CStartNetworkTestMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStartNetworkTestMsg {
    const NAME: &'static str = "CStartNetworkTestMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.frames = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bitrate_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.burst_bitrate_kbps = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.bandwidth_test = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frames {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.framerate {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bitrate_kbps {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.burst_bitrate_kbps {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.bandwidth_test {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.frames {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.framerate {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bitrate_kbps {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.burst_bitrate_kbps {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bandwidth_test {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStartNetworkTestMsg {
        CStartNetworkTestMsg::new()
    }

    fn clear(&mut self) {
        self.frames = ::std::option::Option::None;
        self.framerate = ::std::option::Option::None;
        self.bitrate_kbps = ::std::option::Option::None;
        self.burst_bitrate_kbps = ::std::option::Option::None;
        self.bandwidth_test = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStartNetworkTestMsg {
        static instance: CStartNetworkTestMsg = CStartNetworkTestMsg {
            frames: ::std::option::Option::None,
            framerate: ::std::option::Option::None,
            bitrate_kbps: ::std::option::Option::None,
            burst_bitrate_kbps: ::std::option::Option::None,
            bandwidth_test: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStartNetworkTestMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStartNetworkTestMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStartNetworkTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStartNetworkTestMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamVideoMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamVideoMode {
    // message fields
    // @@protoc_insertion_point(field:CStreamVideoMode.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamVideoMode.height)
    pub height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamVideoMode.refresh_rate)
    pub refresh_rate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamVideoMode.refresh_rate_numerator)
    pub refresh_rate_numerator: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamVideoMode.refresh_rate_denominator)
    pub refresh_rate_denominator: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamVideoMode.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamVideoMode {
    fn default() -> &'a CStreamVideoMode {
        <CStreamVideoMode as crate::Message>::default_instance()
    }
}

impl CStreamVideoMode {
    pub fn new() -> CStreamVideoMode {
        ::std::default::Default::default()
    }

    // required uint32 width = 1;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // required uint32 height = 2;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate = 3;

    pub fn refresh_rate(&self) -> u32 {
        self.refresh_rate.unwrap_or(0)
    }

    pub fn clear_refresh_rate(&mut self) {
        self.refresh_rate = ::std::option::Option::None;
    }

    pub fn has_refresh_rate(&self) -> bool {
        self.refresh_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate(&mut self, v: u32) {
        self.refresh_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate_numerator = 4;

    pub fn refresh_rate_numerator(&self) -> u32 {
        self.refresh_rate_numerator.unwrap_or(0)
    }

    pub fn clear_refresh_rate_numerator(&mut self) {
        self.refresh_rate_numerator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_numerator(&self) -> bool {
        self.refresh_rate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_numerator(&mut self, v: u32) {
        self.refresh_rate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 refresh_rate_denominator = 5;

    pub fn refresh_rate_denominator(&self) -> u32 {
        self.refresh_rate_denominator.unwrap_or(0)
    }

    pub fn clear_refresh_rate_denominator(&mut self) {
        self.refresh_rate_denominator = ::std::option::Option::None;
    }

    pub fn has_refresh_rate_denominator(&self) -> bool {
        self.refresh_rate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refresh_rate_denominator(&mut self, v: u32) {
        self.refresh_rate_denominator = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CStreamVideoMode| { &m.width },
            |m: &mut CStreamVideoMode| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CStreamVideoMode| { &m.height },
            |m: &mut CStreamVideoMode| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "refresh_rate",
            |m: &CStreamVideoMode| { &m.refresh_rate },
            |m: &mut CStreamVideoMode| { &mut m.refresh_rate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "refresh_rate_numerator",
            |m: &CStreamVideoMode| { &m.refresh_rate_numerator },
            |m: &mut CStreamVideoMode| { &mut m.refresh_rate_numerator },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "refresh_rate_denominator",
            |m: &CStreamVideoMode| { &m.refresh_rate_denominator },
            |m: &mut CStreamVideoMode| { &mut m.refresh_rate_denominator },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamVideoMode>(
            "CStreamVideoMode",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamVideoMode {
    const NAME: &'static str = "CStreamVideoMode";

    fn is_initialized(&self) -> bool {
        if self.width.is_none() {
            return false;
        }
        if self.height.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.refresh_rate = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.refresh_rate_numerator = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.refresh_rate_denominator = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.refresh_rate {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.refresh_rate_numerator {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.refresh_rate_denominator {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.width {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.refresh_rate {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.refresh_rate_numerator {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.refresh_rate_denominator {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamVideoMode {
        CStreamVideoMode::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.refresh_rate = ::std::option::Option::None;
        self.refresh_rate_numerator = ::std::option::Option::None;
        self.refresh_rate_denominator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamVideoMode {
        static instance: CStreamVideoMode = CStreamVideoMode {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            refresh_rate: ::std::option::Option::None,
            refresh_rate_numerator: ::std::option::Option::None,
            refresh_rate_denominator: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamVideoMode {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamVideoMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamVideoMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamVideoMode {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamVideoLimit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamVideoLimit {
    // message fields
    // @@protoc_insertion_point(field:CStreamVideoLimit.codec)
    pub codec: ::std::option::Option<crate::EnumOrUnknown<EStreamVideoCodec>>,
    // @@protoc_insertion_point(field:CStreamVideoLimit.mode)
    pub mode: crate::MessageField<CStreamVideoMode>,
    // @@protoc_insertion_point(field:CStreamVideoLimit.bitrate_kbps)
    pub bitrate_kbps: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamVideoLimit.burst_bitrate_kbps)
    pub burst_bitrate_kbps: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamVideoLimit.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamVideoLimit {
    fn default() -> &'a CStreamVideoLimit {
        <CStreamVideoLimit as crate::Message>::default_instance()
    }
}

impl CStreamVideoLimit {
    pub fn new() -> CStreamVideoLimit {
        ::std::default::Default::default()
    }

    // optional .EStreamVideoCodec codec = 1;

    pub fn codec(&self) -> EStreamVideoCodec {
        match self.codec {
            Some(e) => e.enum_value_or(EStreamVideoCodec::k_EStreamVideoCodecNone),
            None => EStreamVideoCodec::k_EStreamVideoCodecNone,
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamVideoCodec) {
        self.codec = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .CStreamVideoMode mode = 2;

    pub fn mode(&self) -> &CStreamVideoMode {
        self.mode.as_ref().unwrap_or_else(|| <CStreamVideoMode as crate::Message>::default_instance())
    }

    pub fn clear_mode(&mut self) {
        self.mode.clear();
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: CStreamVideoMode) {
        self.mode = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode(&mut self) -> &mut CStreamVideoMode {
        self.mode.mut_or_insert_default()
    }

    // Take field
    pub fn take_mode(&mut self) -> CStreamVideoMode {
        self.mode.take().unwrap_or_else(|| CStreamVideoMode::new())
    }

    // optional int32 bitrate_kbps = 3;

    pub fn bitrate_kbps(&self) -> i32 {
        self.bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_bitrate_kbps(&mut self) {
        self.bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_bitrate_kbps(&self) -> bool {
        self.bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate_kbps(&mut self, v: i32) {
        self.bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional int32 burst_bitrate_kbps = 4;

    pub fn burst_bitrate_kbps(&self) -> i32 {
        self.burst_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_burst_bitrate_kbps(&mut self) {
        self.burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_burst_bitrate_kbps(&self) -> bool {
        self.burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_burst_bitrate_kbps(&mut self, v: i32) {
        self.burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "codec",
            |m: &CStreamVideoLimit| { &m.codec },
            |m: &mut CStreamVideoLimit| { &mut m.codec },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamVideoMode>(
            "mode",
            |m: &CStreamVideoLimit| { &m.mode },
            |m: &mut CStreamVideoLimit| { &mut m.mode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bitrate_kbps",
            |m: &CStreamVideoLimit| { &m.bitrate_kbps },
            |m: &mut CStreamVideoLimit| { &mut m.bitrate_kbps },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "burst_bitrate_kbps",
            |m: &CStreamVideoLimit| { &m.burst_bitrate_kbps },
            |m: &mut CStreamVideoLimit| { &mut m.burst_bitrate_kbps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamVideoLimit>(
            "CStreamVideoLimit",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamVideoLimit {
    const NAME: &'static str = "CStreamVideoLimit";

    fn is_initialized(&self) -> bool {
        for v in &self.mode {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.mode)?;
                },
                24 => {
                    self.bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.burst_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.codec {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.mode.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bitrate_kbps {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.burst_bitrate_kbps {
            my_size += crate::rt::int32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.codec {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mode.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.bitrate_kbps {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.burst_bitrate_kbps {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamVideoLimit {
        CStreamVideoLimit::new()
    }

    fn clear(&mut self) {
        self.codec = ::std::option::Option::None;
        self.mode.clear();
        self.bitrate_kbps = ::std::option::Option::None;
        self.burst_bitrate_kbps = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamVideoLimit {
        static instance: CStreamVideoLimit = CStreamVideoLimit {
            codec: ::std::option::Option::None,
            mode: crate::MessageField::none(),
            bitrate_kbps: ::std::option::Option::None,
            burst_bitrate_kbps: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamVideoLimit {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamVideoLimit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamVideoLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamVideoLimit {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamingClientCaps)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingClientCaps {
    // message fields
    // @@protoc_insertion_point(field:CStreamingClientCaps.system_info)
    pub system_info: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.system_can_suspend)
    pub system_can_suspend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.maximum_decode_bitrate_kbps)
    pub maximum_decode_bitrate_kbps: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.maximum_burst_bitrate_kbps)
    pub maximum_burst_bitrate_kbps: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.supports_video_hevc)
    pub supports_video_hevc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_steam_store)
    pub disable_steam_store: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_client_cursor)
    pub disable_client_cursor: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_intel_hardware_encoding)
    pub disable_intel_hardware_encoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_amd_hardware_encoding)
    pub disable_amd_hardware_encoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.disable_nvidia_hardware_encoding)
    pub disable_nvidia_hardware_encoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.form_factor)
    pub form_factor: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.has_on_screen_keyboard)
    pub has_on_screen_keyboard: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientCaps.supported_colorspaces)
    pub supported_colorspaces: ::std::vec::Vec<crate::EnumOrUnknown<EStreamColorspace>>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingClientCaps.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingClientCaps {
    fn default() -> &'a CStreamingClientCaps {
        <CStreamingClientCaps as crate::Message>::default_instance()
    }
}

impl CStreamingClientCaps {
    pub fn new() -> CStreamingClientCaps {
        ::std::default::Default::default()
    }

    // optional string system_info = 1;

    pub fn system_info(&self) -> &str {
        match self.system_info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_system_info(&mut self) {
        self.system_info = ::std::option::Option::None;
    }

    pub fn has_system_info(&self) -> bool {
        self.system_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_info(&mut self, v: ::std::string::String) {
        self.system_info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_info(&mut self) -> &mut ::std::string::String {
        if self.system_info.is_none() {
            self.system_info = ::std::option::Option::Some(::std::string::String::new());
        }
        self.system_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_system_info(&mut self) -> ::std::string::String {
        self.system_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool system_can_suspend = 2;

    pub fn system_can_suspend(&self) -> bool {
        self.system_can_suspend.unwrap_or(false)
    }

    pub fn clear_system_can_suspend(&mut self) {
        self.system_can_suspend = ::std::option::Option::None;
    }

    pub fn has_system_can_suspend(&self) -> bool {
        self.system_can_suspend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system_can_suspend(&mut self, v: bool) {
        self.system_can_suspend = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_decode_bitrate_kbps = 3;

    pub fn maximum_decode_bitrate_kbps(&self) -> i32 {
        self.maximum_decode_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_maximum_decode_bitrate_kbps(&mut self) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_decode_bitrate_kbps(&self) -> bool {
        self.maximum_decode_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_decode_bitrate_kbps(&mut self, v: i32) {
        self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_burst_bitrate_kbps = 4;

    pub fn maximum_burst_bitrate_kbps(&self) -> i32 {
        self.maximum_burst_bitrate_kbps.unwrap_or(0)
    }

    pub fn clear_maximum_burst_bitrate_kbps(&mut self) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_maximum_burst_bitrate_kbps(&self) -> bool {
        self.maximum_burst_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_burst_bitrate_kbps(&mut self, v: i32) {
        self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool supports_video_hevc = 5;

    pub fn supports_video_hevc(&self) -> bool {
        self.supports_video_hevc.unwrap_or(false)
    }

    pub fn clear_supports_video_hevc(&mut self) {
        self.supports_video_hevc = ::std::option::Option::None;
    }

    pub fn has_supports_video_hevc(&self) -> bool {
        self.supports_video_hevc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_video_hevc(&mut self, v: bool) {
        self.supports_video_hevc = ::std::option::Option::Some(v);
    }

    // optional bool disable_steam_store = 6;

    pub fn disable_steam_store(&self) -> bool {
        self.disable_steam_store.unwrap_or(false)
    }

    pub fn clear_disable_steam_store(&mut self) {
        self.disable_steam_store = ::std::option::Option::None;
    }

    pub fn has_disable_steam_store(&self) -> bool {
        self.disable_steam_store.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_steam_store(&mut self, v: bool) {
        self.disable_steam_store = ::std::option::Option::Some(v);
    }

    // optional bool disable_client_cursor = 7;

    pub fn disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.unwrap_or(false)
    }

    pub fn clear_disable_client_cursor(&mut self) {
        self.disable_client_cursor = ::std::option::Option::None;
    }

    pub fn has_disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_client_cursor(&mut self, v: bool) {
        self.disable_client_cursor = ::std::option::Option::Some(v);
    }

    // optional bool disable_intel_hardware_encoding = 8;

    pub fn disable_intel_hardware_encoding(&self) -> bool {
        self.disable_intel_hardware_encoding.unwrap_or(false)
    }

    pub fn clear_disable_intel_hardware_encoding(&mut self) {
        self.disable_intel_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_intel_hardware_encoding(&self) -> bool {
        self.disable_intel_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_intel_hardware_encoding(&mut self, v: bool) {
        self.disable_intel_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional bool disable_amd_hardware_encoding = 9;

    pub fn disable_amd_hardware_encoding(&self) -> bool {
        self.disable_amd_hardware_encoding.unwrap_or(false)
    }

    pub fn clear_disable_amd_hardware_encoding(&mut self) {
        self.disable_amd_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_amd_hardware_encoding(&self) -> bool {
        self.disable_amd_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_amd_hardware_encoding(&mut self, v: bool) {
        self.disable_amd_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional bool disable_nvidia_hardware_encoding = 10;

    pub fn disable_nvidia_hardware_encoding(&self) -> bool {
        self.disable_nvidia_hardware_encoding.unwrap_or(false)
    }

    pub fn clear_disable_nvidia_hardware_encoding(&mut self) {
        self.disable_nvidia_hardware_encoding = ::std::option::Option::None;
    }

    pub fn has_disable_nvidia_hardware_encoding(&self) -> bool {
        self.disable_nvidia_hardware_encoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_nvidia_hardware_encoding(&mut self, v: bool) {
        self.disable_nvidia_hardware_encoding = ::std::option::Option::Some(v);
    }

    // optional int32 form_factor = 11;

    pub fn form_factor(&self) -> i32 {
        self.form_factor.unwrap_or(0)
    }

    pub fn clear_form_factor(&mut self) {
        self.form_factor = ::std::option::Option::None;
    }

    pub fn has_form_factor(&self) -> bool {
        self.form_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_form_factor(&mut self, v: i32) {
        self.form_factor = ::std::option::Option::Some(v);
    }

    // optional bool has_on_screen_keyboard = 12;

    pub fn has_on_screen_keyboard(&self) -> bool {
        self.has_on_screen_keyboard.unwrap_or(false)
    }

    pub fn clear_has_on_screen_keyboard(&mut self) {
        self.has_on_screen_keyboard = ::std::option::Option::None;
    }

    pub fn has_has_on_screen_keyboard(&self) -> bool {
        self.has_on_screen_keyboard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_on_screen_keyboard(&mut self, v: bool) {
        self.has_on_screen_keyboard = ::std::option::Option::Some(v);
    }

    // repeated .EStreamColorspace supported_colorspaces = 13;

    pub fn supported_colorspaces(&self) -> &[crate::EnumOrUnknown<EStreamColorspace>] {
        &self.supported_colorspaces
    }

    pub fn clear_supported_colorspaces(&mut self) {
        self.supported_colorspaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_colorspaces(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<EStreamColorspace>>) {
        self.supported_colorspaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_colorspaces(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<EStreamColorspace>> {
        &mut self.supported_colorspaces
    }

    // Take field
    pub fn take_supported_colorspaces(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<EStreamColorspace>> {
        ::std::mem::replace(&mut self.supported_colorspaces, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "system_info",
            |m: &CStreamingClientCaps| { &m.system_info },
            |m: &mut CStreamingClientCaps| { &mut m.system_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "system_can_suspend",
            |m: &CStreamingClientCaps| { &m.system_can_suspend },
            |m: &mut CStreamingClientCaps| { &mut m.system_can_suspend },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum_decode_bitrate_kbps",
            |m: &CStreamingClientCaps| { &m.maximum_decode_bitrate_kbps },
            |m: &mut CStreamingClientCaps| { &mut m.maximum_decode_bitrate_kbps },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum_burst_bitrate_kbps",
            |m: &CStreamingClientCaps| { &m.maximum_burst_bitrate_kbps },
            |m: &mut CStreamingClientCaps| { &mut m.maximum_burst_bitrate_kbps },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "supports_video_hevc",
            |m: &CStreamingClientCaps| { &m.supports_video_hevc },
            |m: &mut CStreamingClientCaps| { &mut m.supports_video_hevc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_steam_store",
            |m: &CStreamingClientCaps| { &m.disable_steam_store },
            |m: &mut CStreamingClientCaps| { &mut m.disable_steam_store },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_client_cursor",
            |m: &CStreamingClientCaps| { &m.disable_client_cursor },
            |m: &mut CStreamingClientCaps| { &mut m.disable_client_cursor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_intel_hardware_encoding",
            |m: &CStreamingClientCaps| { &m.disable_intel_hardware_encoding },
            |m: &mut CStreamingClientCaps| { &mut m.disable_intel_hardware_encoding },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_amd_hardware_encoding",
            |m: &CStreamingClientCaps| { &m.disable_amd_hardware_encoding },
            |m: &mut CStreamingClientCaps| { &mut m.disable_amd_hardware_encoding },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_nvidia_hardware_encoding",
            |m: &CStreamingClientCaps| { &m.disable_nvidia_hardware_encoding },
            |m: &mut CStreamingClientCaps| { &mut m.disable_nvidia_hardware_encoding },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "form_factor",
            |m: &CStreamingClientCaps| { &m.form_factor },
            |m: &mut CStreamingClientCaps| { &mut m.form_factor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "has_on_screen_keyboard",
            |m: &CStreamingClientCaps| { &m.has_on_screen_keyboard },
            |m: &mut CStreamingClientCaps| { &mut m.has_on_screen_keyboard },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_colorspaces",
            |m: &CStreamingClientCaps| { &m.supported_colorspaces },
            |m: &mut CStreamingClientCaps| { &mut m.supported_colorspaces },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamingClientCaps>(
            "CStreamingClientCaps",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamingClientCaps {
    const NAME: &'static str = "CStreamingClientCaps";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.system_info = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.system_can_suspend = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.maximum_decode_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.maximum_burst_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.supports_video_hevc = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.disable_steam_store = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.disable_client_cursor = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.disable_intel_hardware_encoding = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.disable_amd_hardware_encoding = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.disable_nvidia_hardware_encoding = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.form_factor = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.has_on_screen_keyboard = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.supported_colorspaces.push(is.read_enum_or_unknown()?);
                },
                106 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_colorspaces)?
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.system_info.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.system_can_suspend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.supports_video_hevc {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_steam_store {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_client_cursor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_intel_hardware_encoding {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_amd_hardware_encoding {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_nvidia_hardware_encoding {
            my_size += 1 + 1;
        }
        if let Some(v) = self.form_factor {
            my_size += crate::rt::int32_size(11, v);
        }
        if let Some(v) = self.has_on_screen_keyboard {
            my_size += 1 + 1;
        }
        for value in &self.supported_colorspaces {
            my_size += crate::rt::int32_size(13, value.value());
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.system_info.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.system_can_suspend {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.maximum_decode_bitrate_kbps {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.maximum_burst_bitrate_kbps {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.supports_video_hevc {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.disable_steam_store {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.disable_client_cursor {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.disable_intel_hardware_encoding {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.disable_amd_hardware_encoding {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.disable_nvidia_hardware_encoding {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.form_factor {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.has_on_screen_keyboard {
            os.write_bool(12, v)?;
        }
        for v in &self.supported_colorspaces {
            os.write_enum(13, crate::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingClientCaps {
        CStreamingClientCaps::new()
    }

    fn clear(&mut self) {
        self.system_info = ::std::option::Option::None;
        self.system_can_suspend = ::std::option::Option::None;
        self.maximum_decode_bitrate_kbps = ::std::option::Option::None;
        self.maximum_burst_bitrate_kbps = ::std::option::Option::None;
        self.supports_video_hevc = ::std::option::Option::None;
        self.disable_steam_store = ::std::option::Option::None;
        self.disable_client_cursor = ::std::option::Option::None;
        self.disable_intel_hardware_encoding = ::std::option::Option::None;
        self.disable_amd_hardware_encoding = ::std::option::Option::None;
        self.disable_nvidia_hardware_encoding = ::std::option::Option::None;
        self.form_factor = ::std::option::Option::None;
        self.has_on_screen_keyboard = ::std::option::Option::None;
        self.supported_colorspaces.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingClientCaps {
        static instance: CStreamingClientCaps = CStreamingClientCaps {
            system_info: ::std::option::Option::None,
            system_can_suspend: ::std::option::Option::None,
            maximum_decode_bitrate_kbps: ::std::option::Option::None,
            maximum_burst_bitrate_kbps: ::std::option::Option::None,
            supports_video_hevc: ::std::option::Option::None,
            disable_steam_store: ::std::option::Option::None,
            disable_client_cursor: ::std::option::Option::None,
            disable_intel_hardware_encoding: ::std::option::Option::None,
            disable_amd_hardware_encoding: ::std::option::Option::None,
            disable_nvidia_hardware_encoding: ::std::option::Option::None,
            form_factor: ::std::option::Option::None,
            has_on_screen_keyboard: ::std::option::Option::None,
            supported_colorspaces: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamingClientCaps {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamingClientCaps").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamingClientCaps {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamingClientCaps {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamingClientConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingClientConfig {
    // message fields
    // @@protoc_insertion_point(field:CStreamingClientConfig.quality)
    pub quality: ::std::option::Option<crate::EnumOrUnknown<EStreamQualityPreference>>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.desired_resolution_x)
    pub desired_resolution_x: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.desired_resolution_y)
    pub desired_resolution_y: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.desired_framerate_numerator)
    pub desired_framerate_numerator: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.desired_framerate_denominator)
    pub desired_framerate_denominator: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.desired_bitrate_kbps)
    pub desired_bitrate_kbps: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_hardware_decoding)
    pub enable_hardware_decoding: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_performance_overlay)
    pub enable_performance_overlay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_video_streaming)
    pub enable_video_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_audio_streaming)
    pub enable_audio_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_input_streaming)
    pub enable_input_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.audio_channels)
    pub audio_channels: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_video_hevc)
    pub enable_video_hevc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_performance_icons)
    pub enable_performance_icons: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_microphone_streaming)
    pub enable_microphone_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.controller_overlay_hotkey)
    pub controller_overlay_hotkey: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_touch_controller_OBSOLETE)
    pub enable_touch_controller_OBSOLETE: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.p2p_scope)
    pub p2p_scope: ::std::option::Option<crate::EnumOrUnknown<EStreamP2PScope>>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_audio_uncompressed)
    pub enable_audio_uncompressed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.display_limit)
    pub display_limit: crate::MessageField<CStreamVideoLimit>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.quality_limit)
    pub quality_limit: crate::MessageField<CStreamVideoLimit>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.runtime_limit)
    pub runtime_limit: crate::MessageField<CStreamVideoLimit>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.decoder_limit)
    pub decoder_limit: ::std::vec::Vec<CStreamVideoLimit>,
    // @@protoc_insertion_point(field:CStreamingClientConfig.enable_unreliable_fec)
    pub enable_unreliable_fec: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingClientConfig.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingClientConfig {
    fn default() -> &'a CStreamingClientConfig {
        <CStreamingClientConfig as crate::Message>::default_instance()
    }
}

impl CStreamingClientConfig {
    pub fn new() -> CStreamingClientConfig {
        ::std::default::Default::default()
    }

    // optional .EStreamQualityPreference quality = 1;

    pub fn quality(&self) -> EStreamQualityPreference {
        match self.quality {
            Some(e) => e.enum_value_or(EStreamQualityPreference::k_EStreamQualityBalanced),
            None => EStreamQualityPreference::k_EStreamQualityBalanced,
        }
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: EStreamQualityPreference) {
        self.quality = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 desired_resolution_x = 2;

    pub fn desired_resolution_x(&self) -> u32 {
        self.desired_resolution_x.unwrap_or(0)
    }

    pub fn clear_desired_resolution_x(&mut self) {
        self.desired_resolution_x = ::std::option::Option::None;
    }

    pub fn has_desired_resolution_x(&self) -> bool {
        self.desired_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_resolution_x(&mut self, v: u32) {
        self.desired_resolution_x = ::std::option::Option::Some(v);
    }

    // optional uint32 desired_resolution_y = 3;

    pub fn desired_resolution_y(&self) -> u32 {
        self.desired_resolution_y.unwrap_or(0)
    }

    pub fn clear_desired_resolution_y(&mut self) {
        self.desired_resolution_y = ::std::option::Option::None;
    }

    pub fn has_desired_resolution_y(&self) -> bool {
        self.desired_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_resolution_y(&mut self, v: u32) {
        self.desired_resolution_y = ::std::option::Option::Some(v);
    }

    // optional uint32 desired_framerate_numerator = 4;

    pub fn desired_framerate_numerator(&self) -> u32 {
        self.desired_framerate_numerator.unwrap_or(0)
    }

    pub fn clear_desired_framerate_numerator(&mut self) {
        self.desired_framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_desired_framerate_numerator(&self) -> bool {
        self.desired_framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_framerate_numerator(&mut self, v: u32) {
        self.desired_framerate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 desired_framerate_denominator = 5;

    pub fn desired_framerate_denominator(&self) -> u32 {
        self.desired_framerate_denominator.unwrap_or(0)
    }

    pub fn clear_desired_framerate_denominator(&mut self) {
        self.desired_framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_desired_framerate_denominator(&self) -> bool {
        self.desired_framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_framerate_denominator(&mut self, v: u32) {
        self.desired_framerate_denominator = ::std::option::Option::Some(v);
    }

    // optional int32 desired_bitrate_kbps = 6;

    pub fn desired_bitrate_kbps(&self) -> i32 {
        self.desired_bitrate_kbps.unwrap_or(-1i32)
    }

    pub fn clear_desired_bitrate_kbps(&mut self) {
        self.desired_bitrate_kbps = ::std::option::Option::None;
    }

    pub fn has_desired_bitrate_kbps(&self) -> bool {
        self.desired_bitrate_kbps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_bitrate_kbps(&mut self, v: i32) {
        self.desired_bitrate_kbps = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_decoding = 7;

    pub fn enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.unwrap_or(true)
    }

    pub fn clear_enable_hardware_decoding(&mut self) {
        self.enable_hardware_decoding = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_decoding(&self) -> bool {
        self.enable_hardware_decoding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_decoding(&mut self, v: bool) {
        self.enable_hardware_decoding = ::std::option::Option::Some(v);
    }

    // optional bool enable_performance_overlay = 8;

    pub fn enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.unwrap_or(false)
    }

    pub fn clear_enable_performance_overlay(&mut self) {
        self.enable_performance_overlay = ::std::option::Option::None;
    }

    pub fn has_enable_performance_overlay(&self) -> bool {
        self.enable_performance_overlay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_performance_overlay(&mut self, v: bool) {
        self.enable_performance_overlay = ::std::option::Option::Some(v);
    }

    // optional bool enable_video_streaming = 9;

    pub fn enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }

    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_audio_streaming = 10;

    pub fn enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }

    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_input_streaming = 11;

    pub fn enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }

    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    // optional int32 audio_channels = 12;

    pub fn audio_channels(&self) -> i32 {
        self.audio_channels.unwrap_or(2i32)
    }

    pub fn clear_audio_channels(&mut self) {
        self.audio_channels = ::std::option::Option::None;
    }

    pub fn has_audio_channels(&self) -> bool {
        self.audio_channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channels(&mut self, v: i32) {
        self.audio_channels = ::std::option::Option::Some(v);
    }

    // optional bool enable_video_hevc = 13;

    pub fn enable_video_hevc(&self) -> bool {
        self.enable_video_hevc.unwrap_or(false)
    }

    pub fn clear_enable_video_hevc(&mut self) {
        self.enable_video_hevc = ::std::option::Option::None;
    }

    pub fn has_enable_video_hevc(&self) -> bool {
        self.enable_video_hevc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_hevc(&mut self, v: bool) {
        self.enable_video_hevc = ::std::option::Option::Some(v);
    }

    // optional bool enable_performance_icons = 14;

    pub fn enable_performance_icons(&self) -> bool {
        self.enable_performance_icons.unwrap_or(true)
    }

    pub fn clear_enable_performance_icons(&mut self) {
        self.enable_performance_icons = ::std::option::Option::None;
    }

    pub fn has_enable_performance_icons(&self) -> bool {
        self.enable_performance_icons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_performance_icons(&mut self, v: bool) {
        self.enable_performance_icons = ::std::option::Option::Some(v);
    }

    // optional bool enable_microphone_streaming = 15;

    pub fn enable_microphone_streaming(&self) -> bool {
        self.enable_microphone_streaming.unwrap_or(false)
    }

    pub fn clear_enable_microphone_streaming(&mut self) {
        self.enable_microphone_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_microphone_streaming(&self) -> bool {
        self.enable_microphone_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_microphone_streaming(&mut self, v: bool) {
        self.enable_microphone_streaming = ::std::option::Option::Some(v);
    }

    // optional string controller_overlay_hotkey = 16;

    pub fn controller_overlay_hotkey(&self) -> &str {
        match self.controller_overlay_hotkey.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controller_overlay_hotkey(&mut self) {
        self.controller_overlay_hotkey = ::std::option::Option::None;
    }

    pub fn has_controller_overlay_hotkey(&self) -> bool {
        self.controller_overlay_hotkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_overlay_hotkey(&mut self, v: ::std::string::String) {
        self.controller_overlay_hotkey = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controller_overlay_hotkey(&mut self) -> &mut ::std::string::String {
        if self.controller_overlay_hotkey.is_none() {
            self.controller_overlay_hotkey = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controller_overlay_hotkey.as_mut().unwrap()
    }

    // Take field
    pub fn take_controller_overlay_hotkey(&mut self) -> ::std::string::String {
        self.controller_overlay_hotkey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool enable_touch_controller_OBSOLETE = 17;

    pub fn enable_touch_controller_OBSOLETE(&self) -> bool {
        self.enable_touch_controller_OBSOLETE.unwrap_or(false)
    }

    pub fn clear_enable_touch_controller_OBSOLETE(&mut self) {
        self.enable_touch_controller_OBSOLETE = ::std::option::Option::None;
    }

    pub fn has_enable_touch_controller_OBSOLETE(&self) -> bool {
        self.enable_touch_controller_OBSOLETE.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_touch_controller_OBSOLETE(&mut self, v: bool) {
        self.enable_touch_controller_OBSOLETE = ::std::option::Option::Some(v);
    }

    // optional .EStreamP2PScope p2p_scope = 19;

    pub fn p2p_scope(&self) -> EStreamP2PScope {
        match self.p2p_scope {
            Some(e) => e.enum_value_or(EStreamP2PScope::k_EStreamP2PScopeAutomatic),
            None => EStreamP2PScope::k_EStreamP2PScopeAutomatic,
        }
    }

    pub fn clear_p2p_scope(&mut self) {
        self.p2p_scope = ::std::option::Option::None;
    }

    pub fn has_p2p_scope(&self) -> bool {
        self.p2p_scope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_p2p_scope(&mut self, v: EStreamP2PScope) {
        self.p2p_scope = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool enable_audio_uncompressed = 20;

    pub fn enable_audio_uncompressed(&self) -> bool {
        self.enable_audio_uncompressed.unwrap_or(false)
    }

    pub fn clear_enable_audio_uncompressed(&mut self) {
        self.enable_audio_uncompressed = ::std::option::Option::None;
    }

    pub fn has_enable_audio_uncompressed(&self) -> bool {
        self.enable_audio_uncompressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_uncompressed(&mut self, v: bool) {
        self.enable_audio_uncompressed = ::std::option::Option::Some(v);
    }

    // optional .CStreamVideoLimit display_limit = 21;

    pub fn display_limit(&self) -> &CStreamVideoLimit {
        self.display_limit.as_ref().unwrap_or_else(|| <CStreamVideoLimit as crate::Message>::default_instance())
    }

    pub fn clear_display_limit(&mut self) {
        self.display_limit.clear();
    }

    pub fn has_display_limit(&self) -> bool {
        self.display_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_limit(&mut self, v: CStreamVideoLimit) {
        self.display_limit = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_limit(&mut self) -> &mut CStreamVideoLimit {
        self.display_limit.mut_or_insert_default()
    }

    // Take field
    pub fn take_display_limit(&mut self) -> CStreamVideoLimit {
        self.display_limit.take().unwrap_or_else(|| CStreamVideoLimit::new())
    }

    // optional .CStreamVideoLimit quality_limit = 22;

    pub fn quality_limit(&self) -> &CStreamVideoLimit {
        self.quality_limit.as_ref().unwrap_or_else(|| <CStreamVideoLimit as crate::Message>::default_instance())
    }

    pub fn clear_quality_limit(&mut self) {
        self.quality_limit.clear();
    }

    pub fn has_quality_limit(&self) -> bool {
        self.quality_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality_limit(&mut self, v: CStreamVideoLimit) {
        self.quality_limit = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quality_limit(&mut self) -> &mut CStreamVideoLimit {
        self.quality_limit.mut_or_insert_default()
    }

    // Take field
    pub fn take_quality_limit(&mut self) -> CStreamVideoLimit {
        self.quality_limit.take().unwrap_or_else(|| CStreamVideoLimit::new())
    }

    // optional .CStreamVideoLimit runtime_limit = 23;

    pub fn runtime_limit(&self) -> &CStreamVideoLimit {
        self.runtime_limit.as_ref().unwrap_or_else(|| <CStreamVideoLimit as crate::Message>::default_instance())
    }

    pub fn clear_runtime_limit(&mut self) {
        self.runtime_limit.clear();
    }

    pub fn has_runtime_limit(&self) -> bool {
        self.runtime_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtime_limit(&mut self, v: CStreamVideoLimit) {
        self.runtime_limit = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_limit(&mut self) -> &mut CStreamVideoLimit {
        self.runtime_limit.mut_or_insert_default()
    }

    // Take field
    pub fn take_runtime_limit(&mut self) -> CStreamVideoLimit {
        self.runtime_limit.take().unwrap_or_else(|| CStreamVideoLimit::new())
    }

    // repeated .CStreamVideoLimit decoder_limit = 24;

    pub fn decoder_limit(&self) -> &[CStreamVideoLimit] {
        &self.decoder_limit
    }

    pub fn clear_decoder_limit(&mut self) {
        self.decoder_limit.clear();
    }

    // Param is passed by value, moved
    pub fn set_decoder_limit(&mut self, v: ::std::vec::Vec<CStreamVideoLimit>) {
        self.decoder_limit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_decoder_limit(&mut self) -> &mut ::std::vec::Vec<CStreamVideoLimit> {
        &mut self.decoder_limit
    }

    // Take field
    pub fn take_decoder_limit(&mut self) -> ::std::vec::Vec<CStreamVideoLimit> {
        ::std::mem::replace(&mut self.decoder_limit, ::std::vec::Vec::new())
    }

    // optional bool enable_unreliable_fec = 25;

    pub fn enable_unreliable_fec(&self) -> bool {
        self.enable_unreliable_fec.unwrap_or(false)
    }

    pub fn clear_enable_unreliable_fec(&mut self) {
        self.enable_unreliable_fec = ::std::option::Option::None;
    }

    pub fn has_enable_unreliable_fec(&self) -> bool {
        self.enable_unreliable_fec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_unreliable_fec(&mut self, v: bool) {
        self.enable_unreliable_fec = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CStreamingClientConfig| { &m.quality },
            |m: &mut CStreamingClientConfig| { &mut m.quality },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired_resolution_x",
            |m: &CStreamingClientConfig| { &m.desired_resolution_x },
            |m: &mut CStreamingClientConfig| { &mut m.desired_resolution_x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired_resolution_y",
            |m: &CStreamingClientConfig| { &m.desired_resolution_y },
            |m: &mut CStreamingClientConfig| { &mut m.desired_resolution_y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired_framerate_numerator",
            |m: &CStreamingClientConfig| { &m.desired_framerate_numerator },
            |m: &mut CStreamingClientConfig| { &mut m.desired_framerate_numerator },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired_framerate_denominator",
            |m: &CStreamingClientConfig| { &m.desired_framerate_denominator },
            |m: &mut CStreamingClientConfig| { &mut m.desired_framerate_denominator },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired_bitrate_kbps",
            |m: &CStreamingClientConfig| { &m.desired_bitrate_kbps },
            |m: &mut CStreamingClientConfig| { &mut m.desired_bitrate_kbps },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_hardware_decoding",
            |m: &CStreamingClientConfig| { &m.enable_hardware_decoding },
            |m: &mut CStreamingClientConfig| { &mut m.enable_hardware_decoding },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_performance_overlay",
            |m: &CStreamingClientConfig| { &m.enable_performance_overlay },
            |m: &mut CStreamingClientConfig| { &mut m.enable_performance_overlay },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_video_streaming",
            |m: &CStreamingClientConfig| { &m.enable_video_streaming },
            |m: &mut CStreamingClientConfig| { &mut m.enable_video_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_audio_streaming",
            |m: &CStreamingClientConfig| { &m.enable_audio_streaming },
            |m: &mut CStreamingClientConfig| { &mut m.enable_audio_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_input_streaming",
            |m: &CStreamingClientConfig| { &m.enable_input_streaming },
            |m: &mut CStreamingClientConfig| { &mut m.enable_input_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "audio_channels",
            |m: &CStreamingClientConfig| { &m.audio_channels },
            |m: &mut CStreamingClientConfig| { &mut m.audio_channels },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_video_hevc",
            |m: &CStreamingClientConfig| { &m.enable_video_hevc },
            |m: &mut CStreamingClientConfig| { &mut m.enable_video_hevc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_performance_icons",
            |m: &CStreamingClientConfig| { &m.enable_performance_icons },
            |m: &mut CStreamingClientConfig| { &mut m.enable_performance_icons },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_microphone_streaming",
            |m: &CStreamingClientConfig| { &m.enable_microphone_streaming },
            |m: &mut CStreamingClientConfig| { &mut m.enable_microphone_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_overlay_hotkey",
            |m: &CStreamingClientConfig| { &m.controller_overlay_hotkey },
            |m: &mut CStreamingClientConfig| { &mut m.controller_overlay_hotkey },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_touch_controller_OBSOLETE",
            |m: &CStreamingClientConfig| { &m.enable_touch_controller_OBSOLETE },
            |m: &mut CStreamingClientConfig| { &mut m.enable_touch_controller_OBSOLETE },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "p2p_scope",
            |m: &CStreamingClientConfig| { &m.p2p_scope },
            |m: &mut CStreamingClientConfig| { &mut m.p2p_scope },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_audio_uncompressed",
            |m: &CStreamingClientConfig| { &m.enable_audio_uncompressed },
            |m: &mut CStreamingClientConfig| { &mut m.enable_audio_uncompressed },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamVideoLimit>(
            "display_limit",
            |m: &CStreamingClientConfig| { &m.display_limit },
            |m: &mut CStreamingClientConfig| { &mut m.display_limit },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamVideoLimit>(
            "quality_limit",
            |m: &CStreamingClientConfig| { &m.quality_limit },
            |m: &mut CStreamingClientConfig| { &mut m.quality_limit },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamVideoLimit>(
            "runtime_limit",
            |m: &CStreamingClientConfig| { &m.runtime_limit },
            |m: &mut CStreamingClientConfig| { &mut m.runtime_limit },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "decoder_limit",
            |m: &CStreamingClientConfig| { &m.decoder_limit },
            |m: &mut CStreamingClientConfig| { &mut m.decoder_limit },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_unreliable_fec",
            |m: &CStreamingClientConfig| { &m.enable_unreliable_fec },
            |m: &mut CStreamingClientConfig| { &mut m.enable_unreliable_fec },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamingClientConfig>(
            "CStreamingClientConfig",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamingClientConfig {
    const NAME: &'static str = "CStreamingClientConfig";

    fn is_initialized(&self) -> bool {
        for v in &self.display_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quality_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.runtime_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decoder_limit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quality = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.desired_resolution_x = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.desired_resolution_y = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.desired_framerate_numerator = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.desired_framerate_denominator = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.desired_bitrate_kbps = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.enable_hardware_decoding = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.enable_performance_overlay = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.enable_video_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.enable_audio_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.enable_input_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.audio_channels = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.enable_video_hevc = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.enable_performance_icons = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.enable_microphone_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                130 => {
                    self.controller_overlay_hotkey = ::std::option::Option::Some(is.read_string()?);
                },
                136 => {
                    self.enable_touch_controller_OBSOLETE = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.p2p_scope = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.enable_audio_uncompressed = ::std::option::Option::Some(is.read_bool()?);
                },
                170 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.display_limit)?;
                },
                178 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.quality_limit)?;
                },
                186 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.runtime_limit)?;
                },
                194 => {
                    self.decoder_limit.push(is.read_message()?);
                },
                200 => {
                    self.enable_unreliable_fec = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.desired_resolution_x {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.desired_resolution_y {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.desired_framerate_numerator {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.desired_framerate_denominator {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.desired_bitrate_kbps {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.enable_hardware_decoding {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_performance_overlay {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_video_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_audio_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_input_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.audio_channels {
            my_size += crate::rt::int32_size(12, v);
        }
        if let Some(v) = self.enable_video_hevc {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_performance_icons {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_microphone_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.controller_overlay_hotkey.as_ref() {
            my_size += crate::rt::string_size(16, &v);
        }
        if let Some(v) = self.enable_touch_controller_OBSOLETE {
            my_size += 2 + 1;
        }
        if let Some(v) = self.p2p_scope {
            my_size += crate::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.enable_audio_uncompressed {
            my_size += 2 + 1;
        }
        if let Some(v) = self.display_limit.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quality_limit.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.runtime_limit.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.decoder_limit {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.enable_unreliable_fec {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.quality {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.desired_resolution_x {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.desired_resolution_y {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.desired_framerate_numerator {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.desired_framerate_denominator {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.desired_bitrate_kbps {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.enable_hardware_decoding {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.enable_performance_overlay {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.audio_channels {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.enable_video_hevc {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.enable_performance_icons {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.enable_microphone_streaming {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.controller_overlay_hotkey.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.enable_touch_controller_OBSOLETE {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.p2p_scope {
            os.write_enum(19, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.enable_audio_uncompressed {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.display_limit.as_ref() {
            crate::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.quality_limit.as_ref() {
            crate::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.runtime_limit.as_ref() {
            crate::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        for v in &self.decoder_limit {
            crate::rt::write_message_field_with_cached_size(24, v, os)?;
        };
        if let Some(v) = self.enable_unreliable_fec {
            os.write_bool(25, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingClientConfig {
        CStreamingClientConfig::new()
    }

    fn clear(&mut self) {
        self.quality = ::std::option::Option::None;
        self.desired_resolution_x = ::std::option::Option::None;
        self.desired_resolution_y = ::std::option::Option::None;
        self.desired_framerate_numerator = ::std::option::Option::None;
        self.desired_framerate_denominator = ::std::option::Option::None;
        self.desired_bitrate_kbps = ::std::option::Option::None;
        self.enable_hardware_decoding = ::std::option::Option::None;
        self.enable_performance_overlay = ::std::option::Option::None;
        self.enable_video_streaming = ::std::option::Option::None;
        self.enable_audio_streaming = ::std::option::Option::None;
        self.enable_input_streaming = ::std::option::Option::None;
        self.audio_channels = ::std::option::Option::None;
        self.enable_video_hevc = ::std::option::Option::None;
        self.enable_performance_icons = ::std::option::Option::None;
        self.enable_microphone_streaming = ::std::option::Option::None;
        self.controller_overlay_hotkey = ::std::option::Option::None;
        self.enable_touch_controller_OBSOLETE = ::std::option::Option::None;
        self.p2p_scope = ::std::option::Option::None;
        self.enable_audio_uncompressed = ::std::option::Option::None;
        self.display_limit.clear();
        self.quality_limit.clear();
        self.runtime_limit.clear();
        self.decoder_limit.clear();
        self.enable_unreliable_fec = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingClientConfig {
        static instance: CStreamingClientConfig = CStreamingClientConfig {
            quality: ::std::option::Option::None,
            desired_resolution_x: ::std::option::Option::None,
            desired_resolution_y: ::std::option::Option::None,
            desired_framerate_numerator: ::std::option::Option::None,
            desired_framerate_denominator: ::std::option::Option::None,
            desired_bitrate_kbps: ::std::option::Option::None,
            enable_hardware_decoding: ::std::option::Option::None,
            enable_performance_overlay: ::std::option::Option::None,
            enable_video_streaming: ::std::option::Option::None,
            enable_audio_streaming: ::std::option::Option::None,
            enable_input_streaming: ::std::option::Option::None,
            audio_channels: ::std::option::Option::None,
            enable_video_hevc: ::std::option::Option::None,
            enable_performance_icons: ::std::option::Option::None,
            enable_microphone_streaming: ::std::option::Option::None,
            controller_overlay_hotkey: ::std::option::Option::None,
            enable_touch_controller_OBSOLETE: ::std::option::Option::None,
            p2p_scope: ::std::option::Option::None,
            enable_audio_uncompressed: ::std::option::Option::None,
            display_limit: crate::MessageField::none(),
            quality_limit: crate::MessageField::none(),
            runtime_limit: crate::MessageField::none(),
            decoder_limit: ::std::vec::Vec::new(),
            enable_unreliable_fec: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamingClientConfig {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamingClientConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamingClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamingClientConfig {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamingServerConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingServerConfig {
    // message fields
    // @@protoc_insertion_point(field:CStreamingServerConfig.change_desktop_resolution)
    pub change_desktop_resolution: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.dynamically_adjust_resolution)
    pub dynamically_adjust_resolution: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_capture_nvfbc)
    pub enable_capture_nvfbc: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_hardware_encoding_nvidia)
    pub enable_hardware_encoding_nvidia: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_hardware_encoding_amd)
    pub enable_hardware_encoding_amd: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_hardware_encoding_intel)
    pub enable_hardware_encoding_intel: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.software_encoding_threads)
    pub software_encoding_threads: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.enable_traffic_priority)
    pub enable_traffic_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CStreamingServerConfig.host_play_audio)
    pub host_play_audio: ::std::option::Option<crate::EnumOrUnknown<EStreamHostPlayAudioPreference>>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingServerConfig.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingServerConfig {
    fn default() -> &'a CStreamingServerConfig {
        <CStreamingServerConfig as crate::Message>::default_instance()
    }
}

impl CStreamingServerConfig {
    pub fn new() -> CStreamingServerConfig {
        ::std::default::Default::default()
    }

    // optional bool change_desktop_resolution = 1;

    pub fn change_desktop_resolution(&self) -> bool {
        self.change_desktop_resolution.unwrap_or(false)
    }

    pub fn clear_change_desktop_resolution(&mut self) {
        self.change_desktop_resolution = ::std::option::Option::None;
    }

    pub fn has_change_desktop_resolution(&self) -> bool {
        self.change_desktop_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_desktop_resolution(&mut self, v: bool) {
        self.change_desktop_resolution = ::std::option::Option::Some(v);
    }

    // optional bool dynamically_adjust_resolution = 2;

    pub fn dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.unwrap_or(false)
    }

    pub fn clear_dynamically_adjust_resolution(&mut self) {
        self.dynamically_adjust_resolution = ::std::option::Option::None;
    }

    pub fn has_dynamically_adjust_resolution(&self) -> bool {
        self.dynamically_adjust_resolution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamically_adjust_resolution(&mut self, v: bool) {
        self.dynamically_adjust_resolution = ::std::option::Option::Some(v);
    }

    // optional bool enable_capture_nvfbc = 3;

    pub fn enable_capture_nvfbc(&self) -> bool {
        self.enable_capture_nvfbc.unwrap_or(false)
    }

    pub fn clear_enable_capture_nvfbc(&mut self) {
        self.enable_capture_nvfbc = ::std::option::Option::None;
    }

    pub fn has_enable_capture_nvfbc(&self) -> bool {
        self.enable_capture_nvfbc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_capture_nvfbc(&mut self, v: bool) {
        self.enable_capture_nvfbc = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_nvidia = 4;

    pub fn enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.unwrap_or(false)
    }

    pub fn clear_enable_hardware_encoding_nvidia(&mut self) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_nvidia(&self) -> bool {
        self.enable_hardware_encoding_nvidia.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_nvidia(&mut self, v: bool) {
        self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_amd = 5;

    pub fn enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.unwrap_or(false)
    }

    pub fn clear_enable_hardware_encoding_amd(&mut self) {
        self.enable_hardware_encoding_amd = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_amd(&self) -> bool {
        self.enable_hardware_encoding_amd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_amd(&mut self, v: bool) {
        self.enable_hardware_encoding_amd = ::std::option::Option::Some(v);
    }

    // optional bool enable_hardware_encoding_intel = 6;

    pub fn enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.unwrap_or(false)
    }

    pub fn clear_enable_hardware_encoding_intel(&mut self) {
        self.enable_hardware_encoding_intel = ::std::option::Option::None;
    }

    pub fn has_enable_hardware_encoding_intel(&self) -> bool {
        self.enable_hardware_encoding_intel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_hardware_encoding_intel(&mut self, v: bool) {
        self.enable_hardware_encoding_intel = ::std::option::Option::Some(v);
    }

    // optional int32 software_encoding_threads = 7;

    pub fn software_encoding_threads(&self) -> i32 {
        self.software_encoding_threads.unwrap_or(0)
    }

    pub fn clear_software_encoding_threads(&mut self) {
        self.software_encoding_threads = ::std::option::Option::None;
    }

    pub fn has_software_encoding_threads(&self) -> bool {
        self.software_encoding_threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_software_encoding_threads(&mut self, v: i32) {
        self.software_encoding_threads = ::std::option::Option::Some(v);
    }

    // optional bool enable_traffic_priority = 8;

    pub fn enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.unwrap_or(false)
    }

    pub fn clear_enable_traffic_priority(&mut self) {
        self.enable_traffic_priority = ::std::option::Option::None;
    }

    pub fn has_enable_traffic_priority(&self) -> bool {
        self.enable_traffic_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_traffic_priority(&mut self, v: bool) {
        self.enable_traffic_priority = ::std::option::Option::Some(v);
    }

    // optional .EStreamHostPlayAudioPreference host_play_audio = 9;

    pub fn host_play_audio(&self) -> EStreamHostPlayAudioPreference {
        match self.host_play_audio {
            Some(e) => e.enum_value_or(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault),
            None => EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault,
        }
    }

    pub fn clear_host_play_audio(&mut self) {
        self.host_play_audio = ::std::option::Option::None;
    }

    pub fn has_host_play_audio(&self) -> bool {
        self.host_play_audio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_play_audio(&mut self, v: EStreamHostPlayAudioPreference) {
        self.host_play_audio = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "change_desktop_resolution",
            |m: &CStreamingServerConfig| { &m.change_desktop_resolution },
            |m: &mut CStreamingServerConfig| { &mut m.change_desktop_resolution },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dynamically_adjust_resolution",
            |m: &CStreamingServerConfig| { &m.dynamically_adjust_resolution },
            |m: &mut CStreamingServerConfig| { &mut m.dynamically_adjust_resolution },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_capture_nvfbc",
            |m: &CStreamingServerConfig| { &m.enable_capture_nvfbc },
            |m: &mut CStreamingServerConfig| { &mut m.enable_capture_nvfbc },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_hardware_encoding_nvidia",
            |m: &CStreamingServerConfig| { &m.enable_hardware_encoding_nvidia },
            |m: &mut CStreamingServerConfig| { &mut m.enable_hardware_encoding_nvidia },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_hardware_encoding_amd",
            |m: &CStreamingServerConfig| { &m.enable_hardware_encoding_amd },
            |m: &mut CStreamingServerConfig| { &mut m.enable_hardware_encoding_amd },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_hardware_encoding_intel",
            |m: &CStreamingServerConfig| { &m.enable_hardware_encoding_intel },
            |m: &mut CStreamingServerConfig| { &mut m.enable_hardware_encoding_intel },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "software_encoding_threads",
            |m: &CStreamingServerConfig| { &m.software_encoding_threads },
            |m: &mut CStreamingServerConfig| { &mut m.software_encoding_threads },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_traffic_priority",
            |m: &CStreamingServerConfig| { &m.enable_traffic_priority },
            |m: &mut CStreamingServerConfig| { &mut m.enable_traffic_priority },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_play_audio",
            |m: &CStreamingServerConfig| { &m.host_play_audio },
            |m: &mut CStreamingServerConfig| { &mut m.host_play_audio },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamingServerConfig>(
            "CStreamingServerConfig",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamingServerConfig {
    const NAME: &'static str = "CStreamingServerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.change_desktop_resolution = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.dynamically_adjust_resolution = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.enable_capture_nvfbc = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.enable_hardware_encoding_nvidia = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.enable_hardware_encoding_amd = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.enable_hardware_encoding_intel = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.software_encoding_threads = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.enable_traffic_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.host_play_audio = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.change_desktop_resolution {
            my_size += 1 + 1;
        }
        if let Some(v) = self.dynamically_adjust_resolution {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_capture_nvfbc {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_hardware_encoding_amd {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_hardware_encoding_intel {
            my_size += 1 + 1;
        }
        if let Some(v) = self.software_encoding_threads {
            my_size += crate::rt::int32_size(7, v);
        }
        if let Some(v) = self.enable_traffic_priority {
            my_size += 1 + 1;
        }
        if let Some(v) = self.host_play_audio {
            my_size += crate::rt::int32_size(9, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.change_desktop_resolution {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.dynamically_adjust_resolution {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.enable_capture_nvfbc {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_nvidia {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_amd {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.enable_hardware_encoding_intel {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.software_encoding_threads {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.enable_traffic_priority {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.host_play_audio {
            os.write_enum(9, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingServerConfig {
        CStreamingServerConfig::new()
    }

    fn clear(&mut self) {
        self.change_desktop_resolution = ::std::option::Option::None;
        self.dynamically_adjust_resolution = ::std::option::Option::None;
        self.enable_capture_nvfbc = ::std::option::Option::None;
        self.enable_hardware_encoding_nvidia = ::std::option::Option::None;
        self.enable_hardware_encoding_amd = ::std::option::Option::None;
        self.enable_hardware_encoding_intel = ::std::option::Option::None;
        self.software_encoding_threads = ::std::option::Option::None;
        self.enable_traffic_priority = ::std::option::Option::None;
        self.host_play_audio = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingServerConfig {
        static instance: CStreamingServerConfig = CStreamingServerConfig {
            change_desktop_resolution: ::std::option::Option::None,
            dynamically_adjust_resolution: ::std::option::Option::None,
            enable_capture_nvfbc: ::std::option::Option::None,
            enable_hardware_encoding_nvidia: ::std::option::Option::None,
            enable_hardware_encoding_amd: ::std::option::Option::None,
            enable_hardware_encoding_intel: ::std::option::Option::None,
            software_encoding_threads: ::std::option::Option::None,
            enable_traffic_priority: ::std::option::Option::None,
            host_play_audio: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamingServerConfig {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamingServerConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamingServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamingServerConfig {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNegotiatedConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNegotiatedConfig {
    // message fields
    // @@protoc_insertion_point(field:CNegotiatedConfig.reliable_data)
    pub reliable_data: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.selected_audio_codec)
    pub selected_audio_codec: ::std::option::Option<crate::EnumOrUnknown<EStreamAudioCodec>>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.selected_video_codec)
    pub selected_video_codec: ::std::option::Option<crate::EnumOrUnknown<EStreamVideoCodec>>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.available_video_modes_OBSOLETE)
    pub available_video_modes_OBSOLETE: ::std::vec::Vec<CStreamVideoMode>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.enable_remote_hid)
    pub enable_remote_hid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.enable_touch_input)
    pub enable_touch_input: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiatedConfig.disable_client_cursor)
    pub disable_client_cursor: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CNegotiatedConfig.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNegotiatedConfig {
    fn default() -> &'a CNegotiatedConfig {
        <CNegotiatedConfig as crate::Message>::default_instance()
    }
}

impl CNegotiatedConfig {
    pub fn new() -> CNegotiatedConfig {
        ::std::default::Default::default()
    }

    // optional bool reliable_data = 1;

    pub fn reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }

    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    // optional .EStreamAudioCodec selected_audio_codec = 2;

    pub fn selected_audio_codec(&self) -> EStreamAudioCodec {
        match self.selected_audio_codec {
            Some(e) => e.enum_value_or(EStreamAudioCodec::k_EStreamAudioCodecNone),
            None => EStreamAudioCodec::k_EStreamAudioCodecNone,
        }
    }

    pub fn clear_selected_audio_codec(&mut self) {
        self.selected_audio_codec = ::std::option::Option::None;
    }

    pub fn has_selected_audio_codec(&self) -> bool {
        self.selected_audio_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_audio_codec(&mut self, v: EStreamAudioCodec) {
        self.selected_audio_codec = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EStreamVideoCodec selected_video_codec = 3;

    pub fn selected_video_codec(&self) -> EStreamVideoCodec {
        match self.selected_video_codec {
            Some(e) => e.enum_value_or(EStreamVideoCodec::k_EStreamVideoCodecNone),
            None => EStreamVideoCodec::k_EStreamVideoCodecNone,
        }
    }

    pub fn clear_selected_video_codec(&mut self) {
        self.selected_video_codec = ::std::option::Option::None;
    }

    pub fn has_selected_video_codec(&self) -> bool {
        self.selected_video_codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_video_codec(&mut self, v: EStreamVideoCodec) {
        self.selected_video_codec = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // repeated .CStreamVideoMode available_video_modes_OBSOLETE = 4;

    pub fn available_video_modes_OBSOLETE(&self) -> &[CStreamVideoMode] {
        &self.available_video_modes_OBSOLETE
    }

    pub fn clear_available_video_modes_OBSOLETE(&mut self) {
        self.available_video_modes_OBSOLETE.clear();
    }

    // Param is passed by value, moved
    pub fn set_available_video_modes_OBSOLETE(&mut self, v: ::std::vec::Vec<CStreamVideoMode>) {
        self.available_video_modes_OBSOLETE = v;
    }

    // Mutable pointer to the field.
    pub fn mut_available_video_modes_OBSOLETE(&mut self) -> &mut ::std::vec::Vec<CStreamVideoMode> {
        &mut self.available_video_modes_OBSOLETE
    }

    // Take field
    pub fn take_available_video_modes_OBSOLETE(&mut self) -> ::std::vec::Vec<CStreamVideoMode> {
        ::std::mem::replace(&mut self.available_video_modes_OBSOLETE, ::std::vec::Vec::new())
    }

    // optional bool enable_remote_hid = 5;

    pub fn enable_remote_hid(&self) -> bool {
        self.enable_remote_hid.unwrap_or(false)
    }

    pub fn clear_enable_remote_hid(&mut self) {
        self.enable_remote_hid = ::std::option::Option::None;
    }

    pub fn has_enable_remote_hid(&self) -> bool {
        self.enable_remote_hid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_remote_hid(&mut self, v: bool) {
        self.enable_remote_hid = ::std::option::Option::Some(v);
    }

    // optional bool enable_touch_input = 6;

    pub fn enable_touch_input(&self) -> bool {
        self.enable_touch_input.unwrap_or(false)
    }

    pub fn clear_enable_touch_input(&mut self) {
        self.enable_touch_input = ::std::option::Option::None;
    }

    pub fn has_enable_touch_input(&self) -> bool {
        self.enable_touch_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_touch_input(&mut self, v: bool) {
        self.enable_touch_input = ::std::option::Option::Some(v);
    }

    // optional bool disable_client_cursor = 7;

    pub fn disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.unwrap_or(false)
    }

    pub fn clear_disable_client_cursor(&mut self) {
        self.disable_client_cursor = ::std::option::Option::None;
    }

    pub fn has_disable_client_cursor(&self) -> bool {
        self.disable_client_cursor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_client_cursor(&mut self, v: bool) {
        self.disable_client_cursor = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reliable_data",
            |m: &CNegotiatedConfig| { &m.reliable_data },
            |m: &mut CNegotiatedConfig| { &mut m.reliable_data },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "selected_audio_codec",
            |m: &CNegotiatedConfig| { &m.selected_audio_codec },
            |m: &mut CNegotiatedConfig| { &mut m.selected_audio_codec },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "selected_video_codec",
            |m: &CNegotiatedConfig| { &m.selected_video_codec },
            |m: &mut CNegotiatedConfig| { &mut m.selected_video_codec },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "available_video_modes_OBSOLETE",
            |m: &CNegotiatedConfig| { &m.available_video_modes_OBSOLETE },
            |m: &mut CNegotiatedConfig| { &mut m.available_video_modes_OBSOLETE },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_remote_hid",
            |m: &CNegotiatedConfig| { &m.enable_remote_hid },
            |m: &mut CNegotiatedConfig| { &mut m.enable_remote_hid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_touch_input",
            |m: &CNegotiatedConfig| { &m.enable_touch_input },
            |m: &mut CNegotiatedConfig| { &mut m.enable_touch_input },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disable_client_cursor",
            |m: &CNegotiatedConfig| { &m.disable_client_cursor },
            |m: &mut CNegotiatedConfig| { &mut m.disable_client_cursor },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CNegotiatedConfig>(
            "CNegotiatedConfig",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CNegotiatedConfig {
    const NAME: &'static str = "CNegotiatedConfig";

    fn is_initialized(&self) -> bool {
        for v in &self.available_video_modes_OBSOLETE {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable_data = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.selected_audio_codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.selected_video_codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.available_video_modes_OBSOLETE.push(is.read_message()?);
                },
                40 => {
                    self.enable_remote_hid = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.enable_touch_input = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.disable_client_cursor = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 1 + 1;
        }
        if let Some(v) = self.selected_audio_codec {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.selected_video_codec {
            my_size += crate::rt::int32_size(3, v.value());
        }
        for value in &self.available_video_modes_OBSOLETE {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.enable_remote_hid {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_touch_input {
            my_size += 1 + 1;
        }
        if let Some(v) = self.disable_client_cursor {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.selected_audio_codec {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.selected_video_codec {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        for v in &self.available_video_modes_OBSOLETE {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.enable_remote_hid {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.enable_touch_input {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.disable_client_cursor {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNegotiatedConfig {
        CNegotiatedConfig::new()
    }

    fn clear(&mut self) {
        self.reliable_data = ::std::option::Option::None;
        self.selected_audio_codec = ::std::option::Option::None;
        self.selected_video_codec = ::std::option::Option::None;
        self.available_video_modes_OBSOLETE.clear();
        self.enable_remote_hid = ::std::option::Option::None;
        self.enable_touch_input = ::std::option::Option::None;
        self.disable_client_cursor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNegotiatedConfig {
        static instance: CNegotiatedConfig = CNegotiatedConfig {
            reliable_data: ::std::option::Option::None,
            selected_audio_codec: ::std::option::Option::None,
            selected_video_codec: ::std::option::Option::None,
            available_video_modes_OBSOLETE: ::std::vec::Vec::new(),
            enable_remote_hid: ::std::option::Option::None,
            enable_touch_input: ::std::option::Option::None,
            disable_client_cursor: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CNegotiatedConfig {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNegotiatedConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNegotiatedConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CNegotiatedConfig {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNegotiationInitMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNegotiationInitMsg {
    // message fields
    // @@protoc_insertion_point(field:CNegotiationInitMsg.reliable_data)
    pub reliable_data: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiationInitMsg.supported_audio_codecs)
    pub supported_audio_codecs: ::std::vec::Vec<crate::EnumOrUnknown<EStreamAudioCodec>>,
    // @@protoc_insertion_point(field:CNegotiationInitMsg.supported_video_codecs)
    pub supported_video_codecs: ::std::vec::Vec<crate::EnumOrUnknown<EStreamVideoCodec>>,
    // @@protoc_insertion_point(field:CNegotiationInitMsg.supports_remote_hid)
    pub supports_remote_hid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNegotiationInitMsg.supports_touch_input)
    pub supports_touch_input: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CNegotiationInitMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNegotiationInitMsg {
    fn default() -> &'a CNegotiationInitMsg {
        <CNegotiationInitMsg as crate::Message>::default_instance()
    }
}

impl CNegotiationInitMsg {
    pub fn new() -> CNegotiationInitMsg {
        ::std::default::Default::default()
    }

    // optional bool reliable_data = 1;

    pub fn reliable_data(&self) -> bool {
        self.reliable_data.unwrap_or(false)
    }

    pub fn clear_reliable_data(&mut self) {
        self.reliable_data = ::std::option::Option::None;
    }

    pub fn has_reliable_data(&self) -> bool {
        self.reliable_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_data(&mut self, v: bool) {
        self.reliable_data = ::std::option::Option::Some(v);
    }

    // repeated .EStreamAudioCodec supported_audio_codecs = 2;

    pub fn supported_audio_codecs(&self) -> &[crate::EnumOrUnknown<EStreamAudioCodec>] {
        &self.supported_audio_codecs
    }

    pub fn clear_supported_audio_codecs(&mut self) {
        self.supported_audio_codecs.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_audio_codecs(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<EStreamAudioCodec>>) {
        self.supported_audio_codecs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_audio_codecs(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<EStreamAudioCodec>> {
        &mut self.supported_audio_codecs
    }

    // Take field
    pub fn take_supported_audio_codecs(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<EStreamAudioCodec>> {
        ::std::mem::replace(&mut self.supported_audio_codecs, ::std::vec::Vec::new())
    }

    // repeated .EStreamVideoCodec supported_video_codecs = 3;

    pub fn supported_video_codecs(&self) -> &[crate::EnumOrUnknown<EStreamVideoCodec>] {
        &self.supported_video_codecs
    }

    pub fn clear_supported_video_codecs(&mut self) {
        self.supported_video_codecs.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_video_codecs(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<EStreamVideoCodec>>) {
        self.supported_video_codecs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_video_codecs(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<EStreamVideoCodec>> {
        &mut self.supported_video_codecs
    }

    // Take field
    pub fn take_supported_video_codecs(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<EStreamVideoCodec>> {
        ::std::mem::replace(&mut self.supported_video_codecs, ::std::vec::Vec::new())
    }

    // optional bool supports_remote_hid = 4;

    pub fn supports_remote_hid(&self) -> bool {
        self.supports_remote_hid.unwrap_or(false)
    }

    pub fn clear_supports_remote_hid(&mut self) {
        self.supports_remote_hid = ::std::option::Option::None;
    }

    pub fn has_supports_remote_hid(&self) -> bool {
        self.supports_remote_hid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_remote_hid(&mut self, v: bool) {
        self.supports_remote_hid = ::std::option::Option::Some(v);
    }

    // optional bool supports_touch_input = 5;

    pub fn supports_touch_input(&self) -> bool {
        self.supports_touch_input.unwrap_or(false)
    }

    pub fn clear_supports_touch_input(&mut self) {
        self.supports_touch_input = ::std::option::Option::None;
    }

    pub fn has_supports_touch_input(&self) -> bool {
        self.supports_touch_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_touch_input(&mut self, v: bool) {
        self.supports_touch_input = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reliable_data",
            |m: &CNegotiationInitMsg| { &m.reliable_data },
            |m: &mut CNegotiationInitMsg| { &mut m.reliable_data },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_audio_codecs",
            |m: &CNegotiationInitMsg| { &m.supported_audio_codecs },
            |m: &mut CNegotiationInitMsg| { &mut m.supported_audio_codecs },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_video_codecs",
            |m: &CNegotiationInitMsg| { &m.supported_video_codecs },
            |m: &mut CNegotiationInitMsg| { &mut m.supported_video_codecs },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "supports_remote_hid",
            |m: &CNegotiationInitMsg| { &m.supports_remote_hid },
            |m: &mut CNegotiationInitMsg| { &mut m.supports_remote_hid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "supports_touch_input",
            |m: &CNegotiationInitMsg| { &m.supports_touch_input },
            |m: &mut CNegotiationInitMsg| { &mut m.supports_touch_input },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CNegotiationInitMsg>(
            "CNegotiationInitMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CNegotiationInitMsg {
    const NAME: &'static str = "CNegotiationInitMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable_data = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.supported_audio_codecs.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_audio_codecs)?
                },
                24 => {
                    self.supported_video_codecs.push(is.read_enum_or_unknown()?);
                },
                26 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_video_codecs)?
                },
                32 => {
                    self.supports_remote_hid = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.supports_touch_input = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_data {
            my_size += 1 + 1;
        }
        for value in &self.supported_audio_codecs {
            my_size += crate::rt::int32_size(2, value.value());
        };
        for value in &self.supported_video_codecs {
            my_size += crate::rt::int32_size(3, value.value());
        };
        if let Some(v) = self.supports_remote_hid {
            my_size += 1 + 1;
        }
        if let Some(v) = self.supports_touch_input {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.reliable_data {
            os.write_bool(1, v)?;
        }
        for v in &self.supported_audio_codecs {
            os.write_enum(2, crate::EnumOrUnknown::value(v))?;
        };
        for v in &self.supported_video_codecs {
            os.write_enum(3, crate::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.supports_remote_hid {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.supports_touch_input {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNegotiationInitMsg {
        CNegotiationInitMsg::new()
    }

    fn clear(&mut self) {
        self.reliable_data = ::std::option::Option::None;
        self.supported_audio_codecs.clear();
        self.supported_video_codecs.clear();
        self.supports_remote_hid = ::std::option::Option::None;
        self.supports_touch_input = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNegotiationInitMsg {
        static instance: CNegotiationInitMsg = CNegotiationInitMsg {
            reliable_data: ::std::option::Option::None,
            supported_audio_codecs: ::std::vec::Vec::new(),
            supported_video_codecs: ::std::vec::Vec::new(),
            supports_remote_hid: ::std::option::Option::None,
            supports_touch_input: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CNegotiationInitMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNegotiationInitMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNegotiationInitMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CNegotiationInitMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNegotiationSetConfigMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNegotiationSetConfigMsg {
    // message fields
    // @@protoc_insertion_point(field:CNegotiationSetConfigMsg.config)
    pub config: crate::MessageField<CNegotiatedConfig>,
    // @@protoc_insertion_point(field:CNegotiationSetConfigMsg.streaming_client_config)
    pub streaming_client_config: crate::MessageField<CStreamingClientConfig>,
    // @@protoc_insertion_point(field:CNegotiationSetConfigMsg.streaming_client_caps)
    pub streaming_client_caps: crate::MessageField<CStreamingClientCaps>,
    // special fields
    // @@protoc_insertion_point(special_field:CNegotiationSetConfigMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNegotiationSetConfigMsg {
    fn default() -> &'a CNegotiationSetConfigMsg {
        <CNegotiationSetConfigMsg as crate::Message>::default_instance()
    }
}

impl CNegotiationSetConfigMsg {
    pub fn new() -> CNegotiationSetConfigMsg {
        ::std::default::Default::default()
    }

    // required .CNegotiatedConfig config = 1;

    pub fn config(&self) -> &CNegotiatedConfig {
        self.config.as_ref().unwrap_or_else(|| <CNegotiatedConfig as crate::Message>::default_instance())
    }

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: CNegotiatedConfig) {
        self.config = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut CNegotiatedConfig {
        self.config.mut_or_insert_default()
    }

    // Take field
    pub fn take_config(&mut self) -> CNegotiatedConfig {
        self.config.take().unwrap_or_else(|| CNegotiatedConfig::new())
    }

    // optional .CStreamingClientConfig streaming_client_config = 2;

    pub fn streaming_client_config(&self) -> &CStreamingClientConfig {
        self.streaming_client_config.as_ref().unwrap_or_else(|| <CStreamingClientConfig as crate::Message>::default_instance())
    }

    pub fn clear_streaming_client_config(&mut self) {
        self.streaming_client_config.clear();
    }

    pub fn has_streaming_client_config(&self) -> bool {
        self.streaming_client_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streaming_client_config(&mut self, v: CStreamingClientConfig) {
        self.streaming_client_config = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streaming_client_config(&mut self) -> &mut CStreamingClientConfig {
        self.streaming_client_config.mut_or_insert_default()
    }

    // Take field
    pub fn take_streaming_client_config(&mut self) -> CStreamingClientConfig {
        self.streaming_client_config.take().unwrap_or_else(|| CStreamingClientConfig::new())
    }

    // optional .CStreamingClientCaps streaming_client_caps = 3;

    pub fn streaming_client_caps(&self) -> &CStreamingClientCaps {
        self.streaming_client_caps.as_ref().unwrap_or_else(|| <CStreamingClientCaps as crate::Message>::default_instance())
    }

    pub fn clear_streaming_client_caps(&mut self) {
        self.streaming_client_caps.clear();
    }

    pub fn has_streaming_client_caps(&self) -> bool {
        self.streaming_client_caps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streaming_client_caps(&mut self, v: CStreamingClientCaps) {
        self.streaming_client_caps = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_streaming_client_caps(&mut self) -> &mut CStreamingClientCaps {
        self.streaming_client_caps.mut_or_insert_default()
    }

    // Take field
    pub fn take_streaming_client_caps(&mut self) -> CStreamingClientCaps {
        self.streaming_client_caps.take().unwrap_or_else(|| CStreamingClientCaps::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CNegotiatedConfig>(
            "config",
            |m: &CNegotiationSetConfigMsg| { &m.config },
            |m: &mut CNegotiationSetConfigMsg| { &mut m.config },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamingClientConfig>(
            "streaming_client_config",
            |m: &CNegotiationSetConfigMsg| { &m.streaming_client_config },
            |m: &mut CNegotiationSetConfigMsg| { &mut m.streaming_client_config },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamingClientCaps>(
            "streaming_client_caps",
            |m: &CNegotiationSetConfigMsg| { &m.streaming_client_caps },
            |m: &mut CNegotiationSetConfigMsg| { &mut m.streaming_client_caps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CNegotiationSetConfigMsg>(
            "CNegotiationSetConfigMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CNegotiationSetConfigMsg {
    const NAME: &'static str = "CNegotiationSetConfigMsg";

    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        }
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streaming_client_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.streaming_client_caps {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.streaming_client_config)?;
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.streaming_client_caps)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.streaming_client_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.streaming_client_caps.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.config.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.streaming_client_config.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.streaming_client_caps.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNegotiationSetConfigMsg {
        CNegotiationSetConfigMsg::new()
    }

    fn clear(&mut self) {
        self.config.clear();
        self.streaming_client_config.clear();
        self.streaming_client_caps.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNegotiationSetConfigMsg {
        static instance: CNegotiationSetConfigMsg = CNegotiationSetConfigMsg {
            config: crate::MessageField::none(),
            streaming_client_config: crate::MessageField::none(),
            streaming_client_caps: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CNegotiationSetConfigMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNegotiationSetConfigMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNegotiationSetConfigMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CNegotiationSetConfigMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CNegotiationCompleteMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CNegotiationCompleteMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CNegotiationCompleteMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNegotiationCompleteMsg {
    fn default() -> &'a CNegotiationCompleteMsg {
        <CNegotiationCompleteMsg as crate::Message>::default_instance()
    }
}

impl CNegotiationCompleteMsg {
    pub fn new() -> CNegotiationCompleteMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CNegotiationCompleteMsg>(
            "CNegotiationCompleteMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CNegotiationCompleteMsg {
    const NAME: &'static str = "CNegotiationCompleteMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNegotiationCompleteMsg {
        CNegotiationCompleteMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNegotiationCompleteMsg {
        static instance: CNegotiationCompleteMsg = CNegotiationCompleteMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CNegotiationCompleteMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNegotiationCompleteMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNegotiationCompleteMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CNegotiationCompleteMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStartAudioDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStartAudioDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CStartAudioDataMsg.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartAudioDataMsg.codec)
    pub codec: ::std::option::Option<crate::EnumOrUnknown<EStreamAudioCodec>>,
    // @@protoc_insertion_point(field:CStartAudioDataMsg.codec_data)
    pub codec_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CStartAudioDataMsg.frequency)
    pub frequency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartAudioDataMsg.channels)
    pub channels: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStartAudioDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStartAudioDataMsg {
    fn default() -> &'a CStartAudioDataMsg {
        <CStartAudioDataMsg as crate::Message>::default_instance()
    }
}

impl CStartAudioDataMsg {
    pub fn new() -> CStartAudioDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 2;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .EStreamAudioCodec codec = 3;

    pub fn codec(&self) -> EStreamAudioCodec {
        match self.codec {
            Some(e) => e.enum_value_or(EStreamAudioCodec::k_EStreamAudioCodecNone),
            None => EStreamAudioCodec::k_EStreamAudioCodecNone,
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamAudioCodec) {
        self.codec = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bytes codec_data = 4;

    pub fn codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_codec_data(&mut self) {
        self.codec_data = ::std::option::Option::None;
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::bytes::Bytes) {
        self.codec_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::bytes::Bytes {
        if self.codec_data.is_none() {
            self.codec_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::bytes::Bytes {
        self.codec_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 frequency = 5;

    pub fn frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional uint32 channels = 6;

    pub fn channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }

    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CStartAudioDataMsg| { &m.channel },
            |m: &mut CStartAudioDataMsg| { &mut m.channel },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "codec",
            |m: &CStartAudioDataMsg| { &m.codec },
            |m: &mut CStartAudioDataMsg| { &mut m.codec },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "codec_data",
            |m: &CStartAudioDataMsg| { &m.codec_data },
            |m: &mut CStartAudioDataMsg| { &mut m.codec_data },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "frequency",
            |m: &CStartAudioDataMsg| { &m.frequency },
            |m: &mut CStartAudioDataMsg| { &mut m.frequency },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "channels",
            |m: &CStartAudioDataMsg| { &m.channels },
            |m: &mut CStartAudioDataMsg| { &mut m.channels },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStartAudioDataMsg>(
            "CStartAudioDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStartAudioDataMsg {
    const NAME: &'static str = "CStartAudioDataMsg";

    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.codec_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                40 => {
                    self.frequency = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.channels = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.codec {
            my_size += crate::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.codec_data.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.frequency {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.channels {
            my_size += crate::rt::uint32_size(6, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.codec {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.codec_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.channels {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStartAudioDataMsg {
        CStartAudioDataMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.codec_data = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.channels = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStartAudioDataMsg {
        static instance: CStartAudioDataMsg = CStartAudioDataMsg {
            channel: ::std::option::Option::None,
            codec: ::std::option::Option::None,
            codec_data: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            channels: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStartAudioDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStartAudioDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStartAudioDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStartAudioDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStopAudioDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStopAudioDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CStopAudioDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStopAudioDataMsg {
    fn default() -> &'a CStopAudioDataMsg {
        <CStopAudioDataMsg as crate::Message>::default_instance()
    }
}

impl CStopAudioDataMsg {
    pub fn new() -> CStopAudioDataMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStopAudioDataMsg>(
            "CStopAudioDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStopAudioDataMsg {
    const NAME: &'static str = "CStopAudioDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStopAudioDataMsg {
        CStopAudioDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStopAudioDataMsg {
        static instance: CStopAudioDataMsg = CStopAudioDataMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStopAudioDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStopAudioDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStopAudioDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStopAudioDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStartVideoDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStartVideoDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CStartVideoDataMsg.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartVideoDataMsg.codec)
    pub codec: ::std::option::Option<crate::EnumOrUnknown<EStreamVideoCodec>>,
    // @@protoc_insertion_point(field:CStartVideoDataMsg.codec_data)
    pub codec_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CStartVideoDataMsg.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStartVideoDataMsg.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStartVideoDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStartVideoDataMsg {
    fn default() -> &'a CStartVideoDataMsg {
        <CStartVideoDataMsg as crate::Message>::default_instance()
    }
}

impl CStartVideoDataMsg {
    pub fn new() -> CStartVideoDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional .EStreamVideoCodec codec = 2;

    pub fn codec(&self) -> EStreamVideoCodec {
        match self.codec {
            Some(e) => e.enum_value_or(EStreamVideoCodec::k_EStreamVideoCodecNone),
            None => EStreamVideoCodec::k_EStreamVideoCodecNone,
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: EStreamVideoCodec) {
        self.codec = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bytes codec_data = 3;

    pub fn codec_data(&self) -> &[u8] {
        match self.codec_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_codec_data(&mut self) {
        self.codec_data = ::std::option::Option::None;
    }

    pub fn has_codec_data(&self) -> bool {
        self.codec_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec_data(&mut self, v: ::bytes::Bytes) {
        self.codec_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec_data(&mut self) -> &mut ::bytes::Bytes {
        if self.codec_data.is_none() {
            self.codec_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.codec_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec_data(&mut self) -> ::bytes::Bytes {
        self.codec_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 width = 4;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 5;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CStartVideoDataMsg| { &m.channel },
            |m: &mut CStartVideoDataMsg| { &mut m.channel },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "codec",
            |m: &CStartVideoDataMsg| { &m.codec },
            |m: &mut CStartVideoDataMsg| { &mut m.codec },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "codec_data",
            |m: &CStartVideoDataMsg| { &m.codec_data },
            |m: &mut CStartVideoDataMsg| { &mut m.codec_data },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CStartVideoDataMsg| { &m.width },
            |m: &mut CStartVideoDataMsg| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CStartVideoDataMsg| { &m.height },
            |m: &mut CStartVideoDataMsg| { &mut m.height },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStartVideoDataMsg>(
            "CStartVideoDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStartVideoDataMsg {
    const NAME: &'static str = "CStartVideoDataMsg";

    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.codec = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.codec_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                32 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.codec {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.codec_data.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.width {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.codec {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.codec_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStartVideoDataMsg {
        CStartVideoDataMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.codec_data = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStartVideoDataMsg {
        static instance: CStartVideoDataMsg = CStartVideoDataMsg {
            channel: ::std::option::Option::None,
            codec: ::std::option::Option::None,
            codec_data: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStartVideoDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStartVideoDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStartVideoDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStartVideoDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStopVideoDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStopVideoDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CStopVideoDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStopVideoDataMsg {
    fn default() -> &'a CStopVideoDataMsg {
        <CStopVideoDataMsg as crate::Message>::default_instance()
    }
}

impl CStopVideoDataMsg {
    pub fn new() -> CStopVideoDataMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStopVideoDataMsg>(
            "CStopVideoDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStopVideoDataMsg {
    const NAME: &'static str = "CStopVideoDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStopVideoDataMsg {
        CStopVideoDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStopVideoDataMsg {
        static instance: CStopVideoDataMsg = CStopVideoDataMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStopVideoDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStopVideoDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStopVideoDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStopVideoDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStartNeptuneDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStartNeptuneDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CStartNeptuneDataMsg.channel)
    pub channel: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStartNeptuneDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStartNeptuneDataMsg {
    fn default() -> &'a CStartNeptuneDataMsg {
        <CStartNeptuneDataMsg as crate::Message>::default_instance()
    }
}

impl CStartNeptuneDataMsg {
    pub fn new() -> CStartNeptuneDataMsg {
        ::std::default::Default::default()
    }

    // required uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CStartNeptuneDataMsg| { &m.channel },
            |m: &mut CStartNeptuneDataMsg| { &mut m.channel },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStartNeptuneDataMsg>(
            "CStartNeptuneDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStartNeptuneDataMsg {
    const NAME: &'static str = "CStartNeptuneDataMsg";

    fn is_initialized(&self) -> bool {
        if self.channel.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStartNeptuneDataMsg {
        CStartNeptuneDataMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStartNeptuneDataMsg {
        static instance: CStartNeptuneDataMsg = CStartNeptuneDataMsg {
            channel: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStartNeptuneDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStartNeptuneDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStartNeptuneDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStartNeptuneDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStopNeptuneDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStopNeptuneDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CStopNeptuneDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStopNeptuneDataMsg {
    fn default() -> &'a CStopNeptuneDataMsg {
        <CStopNeptuneDataMsg as crate::Message>::default_instance()
    }
}

impl CStopNeptuneDataMsg {
    pub fn new() -> CStopNeptuneDataMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStopNeptuneDataMsg>(
            "CStopNeptuneDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStopNeptuneDataMsg {
    const NAME: &'static str = "CStopNeptuneDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStopNeptuneDataMsg {
        CStopNeptuneDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStopNeptuneDataMsg {
        static instance: CStopNeptuneDataMsg = CStopNeptuneDataMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStopNeptuneDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStopNeptuneDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStopNeptuneDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStopNeptuneDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CRecordedInput)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRecordedInput {
    // message fields
    // @@protoc_insertion_point(field:CRecordedInput.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<EStreamControlMessage>>,
    // @@protoc_insertion_point(field:CRecordedInput.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // message oneof groups
    pub data: ::std::option::Option<crecorded_input::Data>,
    // special fields
    // @@protoc_insertion_point(special_field:CRecordedInput.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRecordedInput {
    fn default() -> &'a CRecordedInput {
        <CRecordedInput as crate::Message>::default_instance()
    }
}

impl CRecordedInput {
    pub fn new() -> CRecordedInput {
        ::std::default::Default::default()
    }

    // optional .EStreamControlMessage type = 1;

    pub fn type_(&self) -> EStreamControlMessage {
        match self.type_ {
            Some(e) => e.enum_value_or(EStreamControlMessage::k_EStreamControlAuthenticationRequest),
            None => EStreamControlMessage::k_EStreamControlAuthenticationRequest,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EStreamControlMessage) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .CInputTouchFingerDownMsg finger_down = 3;

    pub fn finger_down(&self) -> &CInputTouchFingerDownMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerDown(ref v)) => v,
            _ => <CInputTouchFingerDownMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_finger_down(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_finger_down(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerDown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finger_down(&mut self, v: CInputTouchFingerDownMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::FingerDown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finger_down(&mut self) -> &mut CInputTouchFingerDownMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::FingerDown(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::FingerDown(CInputTouchFingerDownMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerDown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finger_down(&mut self) -> CInputTouchFingerDownMsg {
        if self.has_finger_down() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::FingerDown(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTouchFingerDownMsg::new()
        }
    }

    // optional .CInputTouchFingerMotionMsg finger_motion = 4;

    pub fn finger_motion(&self) -> &CInputTouchFingerMotionMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerMotion(ref v)) => v,
            _ => <CInputTouchFingerMotionMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_finger_motion(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_finger_motion(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerMotion(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finger_motion(&mut self, v: CInputTouchFingerMotionMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::FingerMotion(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finger_motion(&mut self) -> &mut CInputTouchFingerMotionMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::FingerMotion(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::FingerMotion(CInputTouchFingerMotionMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerMotion(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finger_motion(&mut self) -> CInputTouchFingerMotionMsg {
        if self.has_finger_motion() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::FingerMotion(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTouchFingerMotionMsg::new()
        }
    }

    // optional .CInputTouchFingerUpMsg finger_up = 5;

    pub fn finger_up(&self) -> &CInputTouchFingerUpMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerUp(ref v)) => v,
            _ => <CInputTouchFingerUpMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_finger_up(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_finger_up(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerUp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_finger_up(&mut self, v: CInputTouchFingerUpMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::FingerUp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_finger_up(&mut self) -> &mut CInputTouchFingerUpMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::FingerUp(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::FingerUp(CInputTouchFingerUpMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::FingerUp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_finger_up(&mut self) -> CInputTouchFingerUpMsg {
        if self.has_finger_up() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::FingerUp(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTouchFingerUpMsg::new()
        }
    }

    // optional .CInputMouseMotionMsg mouse_motion = 6;

    pub fn mouse_motion(&self) -> &CInputMouseMotionMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseMotion(ref v)) => v,
            _ => <CInputMouseMotionMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_motion(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_motion(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseMotion(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_motion(&mut self, v: CInputMouseMotionMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::MouseMotion(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_motion(&mut self) -> &mut CInputMouseMotionMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::MouseMotion(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::MouseMotion(CInputMouseMotionMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseMotion(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_motion(&mut self) -> CInputMouseMotionMsg {
        if self.has_mouse_motion() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::MouseMotion(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseMotionMsg::new()
        }
    }

    // optional .CInputMouseWheelMsg mouse_wheel = 7;

    pub fn mouse_wheel(&self) -> &CInputMouseWheelMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseWheel(ref v)) => v,
            _ => <CInputMouseWheelMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_wheel(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_wheel(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseWheel(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_wheel(&mut self, v: CInputMouseWheelMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::MouseWheel(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_wheel(&mut self) -> &mut CInputMouseWheelMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::MouseWheel(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::MouseWheel(CInputMouseWheelMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseWheel(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_wheel(&mut self) -> CInputMouseWheelMsg {
        if self.has_mouse_wheel() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::MouseWheel(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseWheelMsg::new()
        }
    }

    // optional .CInputMouseDownMsg mouse_down = 8;

    pub fn mouse_down(&self) -> &CInputMouseDownMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseDown(ref v)) => v,
            _ => <CInputMouseDownMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_down(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_down(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseDown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_down(&mut self, v: CInputMouseDownMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::MouseDown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_down(&mut self) -> &mut CInputMouseDownMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::MouseDown(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::MouseDown(CInputMouseDownMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseDown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_down(&mut self) -> CInputMouseDownMsg {
        if self.has_mouse_down() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::MouseDown(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseDownMsg::new()
        }
    }

    // optional .CInputMouseUpMsg mouse_up = 9;

    pub fn mouse_up(&self) -> &CInputMouseUpMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseUp(ref v)) => v,
            _ => <CInputMouseUpMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_mouse_up(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_mouse_up(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseUp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mouse_up(&mut self, v: CInputMouseUpMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::MouseUp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mouse_up(&mut self) -> &mut CInputMouseUpMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::MouseUp(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::MouseUp(CInputMouseUpMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::MouseUp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mouse_up(&mut self) -> CInputMouseUpMsg {
        if self.has_mouse_up() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::MouseUp(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputMouseUpMsg::new()
        }
    }

    // optional .CInputKeyDownMsg key_down = 10;

    pub fn key_down(&self) -> &CInputKeyDownMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyDown(ref v)) => v,
            _ => <CInputKeyDownMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_key_down(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_key_down(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyDown(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_down(&mut self, v: CInputKeyDownMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::KeyDown(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_down(&mut self) -> &mut CInputKeyDownMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::KeyDown(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::KeyDown(CInputKeyDownMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyDown(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_down(&mut self) -> CInputKeyDownMsg {
        if self.has_key_down() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::KeyDown(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputKeyDownMsg::new()
        }
    }

    // optional .CInputKeyUpMsg key_up = 11;

    pub fn key_up(&self) -> &CInputKeyUpMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyUp(ref v)) => v,
            _ => <CInputKeyUpMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_key_up(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_key_up(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyUp(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_key_up(&mut self, v: CInputKeyUpMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::KeyUp(v))
    }

    // Mutable pointer to the field.
    pub fn mut_key_up(&mut self) -> &mut CInputKeyUpMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::KeyUp(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::KeyUp(CInputKeyUpMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::KeyUp(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_key_up(&mut self) -> CInputKeyUpMsg {
        if self.has_key_up() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::KeyUp(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputKeyUpMsg::new()
        }
    }

    // optional .CInputTextMsg text = 12;

    pub fn text(&self) -> &CInputTextMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Text(ref v)) => v,
            _ => <CInputTextMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_text(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: CInputTextMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::Text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut CInputTextMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::Text(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::Text(CInputTextMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> CInputTextMsg {
        if self.has_text() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::Text(v)) => v,
                _ => panic!(),
            }
        } else {
            CInputTextMsg::new()
        }
    }

    // optional .CRemoteHIDMsg hid = 13;

    pub fn hid(&self) -> &CRemoteHIDMsg {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Hid(ref v)) => v,
            _ => <CRemoteHIDMsg as crate::Message>::default_instance(),
        }
    }

    pub fn clear_hid(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_hid(&self) -> bool {
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Hid(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_hid(&mut self, v: CRemoteHIDMsg) {
        self.data = ::std::option::Option::Some(crecorded_input::Data::Hid(v))
    }

    // Mutable pointer to the field.
    pub fn mut_hid(&mut self) -> &mut CRemoteHIDMsg {
        if let ::std::option::Option::Some(crecorded_input::Data::Hid(_)) = self.data {
        } else {
            self.data = ::std::option::Option::Some(crecorded_input::Data::Hid(CRemoteHIDMsg::new()));
        }
        match self.data {
            ::std::option::Option::Some(crecorded_input::Data::Hid(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_hid(&mut self) -> CRemoteHIDMsg {
        if self.has_hid() {
            match self.data.take() {
                ::std::option::Option::Some(crecorded_input::Data::Hid(v)) => v,
                _ => panic!(),
            }
        } else {
            CRemoteHIDMsg::new()
        }
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CRecordedInput| { &m.type_ },
            |m: &mut CRecordedInput| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CRecordedInput| { &m.timestamp },
            |m: &mut CRecordedInput| { &mut m.timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputTouchFingerDownMsg>(
            "finger_down",
            CRecordedInput::has_finger_down,
            CRecordedInput::finger_down,
            CRecordedInput::mut_finger_down,
            CRecordedInput::set_finger_down,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputTouchFingerMotionMsg>(
            "finger_motion",
            CRecordedInput::has_finger_motion,
            CRecordedInput::finger_motion,
            CRecordedInput::mut_finger_motion,
            CRecordedInput::set_finger_motion,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputTouchFingerUpMsg>(
            "finger_up",
            CRecordedInput::has_finger_up,
            CRecordedInput::finger_up,
            CRecordedInput::mut_finger_up,
            CRecordedInput::set_finger_up,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputMouseMotionMsg>(
            "mouse_motion",
            CRecordedInput::has_mouse_motion,
            CRecordedInput::mouse_motion,
            CRecordedInput::mut_mouse_motion,
            CRecordedInput::set_mouse_motion,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputMouseWheelMsg>(
            "mouse_wheel",
            CRecordedInput::has_mouse_wheel,
            CRecordedInput::mouse_wheel,
            CRecordedInput::mut_mouse_wheel,
            CRecordedInput::set_mouse_wheel,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputMouseDownMsg>(
            "mouse_down",
            CRecordedInput::has_mouse_down,
            CRecordedInput::mouse_down,
            CRecordedInput::mut_mouse_down,
            CRecordedInput::set_mouse_down,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputMouseUpMsg>(
            "mouse_up",
            CRecordedInput::has_mouse_up,
            CRecordedInput::mouse_up,
            CRecordedInput::mut_mouse_up,
            CRecordedInput::set_mouse_up,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputKeyDownMsg>(
            "key_down",
            CRecordedInput::has_key_down,
            CRecordedInput::key_down,
            CRecordedInput::mut_key_down,
            CRecordedInput::set_key_down,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputKeyUpMsg>(
            "key_up",
            CRecordedInput::has_key_up,
            CRecordedInput::key_up,
            CRecordedInput::mut_key_up,
            CRecordedInput::set_key_up,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CInputTextMsg>(
            "text",
            CRecordedInput::has_text,
            CRecordedInput::text,
            CRecordedInput::mut_text,
            CRecordedInput::set_text,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, CRemoteHIDMsg>(
            "hid",
            CRecordedInput::has_hid,
            CRecordedInput::hid,
            CRecordedInput::mut_hid,
            CRecordedInput::set_hid,
        ));
        oneofs.push(crecorded_input::Data::generated_oneof_descriptor_data());
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CRecordedInput>(
            "CRecordedInput",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CRecordedInput {
    const NAME: &'static str = "CRecordedInput";

    fn is_initialized(&self) -> bool {
        if let Some(crecorded_input::Data::FingerDown(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::FingerMotion(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::FingerUp(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::MouseMotion(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::MouseWheel(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::MouseDown(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::MouseUp(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::KeyDown(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::KeyUp(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::Text(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(crecorded_input::Data::Hid(ref v)) = self.data {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::FingerDown(is.read_message()?));
                },
                34 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::FingerMotion(is.read_message()?));
                },
                42 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::FingerUp(is.read_message()?));
                },
                50 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::MouseMotion(is.read_message()?));
                },
                58 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::MouseWheel(is.read_message()?));
                },
                66 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::MouseDown(is.read_message()?));
                },
                74 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::MouseUp(is.read_message()?));
                },
                82 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::KeyDown(is.read_message()?));
                },
                90 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::KeyUp(is.read_message()?));
                },
                98 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::Text(is.read_message()?));
                },
                106 => {
                    self.data = ::std::option::Option::Some(crecorded_input::Data::Hid(is.read_message()?));
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &crecorded_input::Data::FingerDown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::FingerMotion(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::FingerUp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::MouseMotion(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::MouseWheel(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::MouseDown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::MouseUp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::KeyDown(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::KeyUp(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::Text(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &crecorded_input::Data::Hid(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.data {
            match v {
                &crecorded_input::Data::FingerDown(ref v) => {
                    crate::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &crecorded_input::Data::FingerMotion(ref v) => {
                    crate::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &crecorded_input::Data::FingerUp(ref v) => {
                    crate::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &crecorded_input::Data::MouseMotion(ref v) => {
                    crate::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &crecorded_input::Data::MouseWheel(ref v) => {
                    crate::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &crecorded_input::Data::MouseDown(ref v) => {
                    crate::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &crecorded_input::Data::MouseUp(ref v) => {
                    crate::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &crecorded_input::Data::KeyDown(ref v) => {
                    crate::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &crecorded_input::Data::KeyUp(ref v) => {
                    crate::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &crecorded_input::Data::Text(ref v) => {
                    crate::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &crecorded_input::Data::Hid(ref v) => {
                    crate::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRecordedInput {
        CRecordedInput::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRecordedInput {
        static instance: CRecordedInput = CRecordedInput {
            type_: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CRecordedInput {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CRecordedInput").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CRecordedInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CRecordedInput {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CRecordedInput`
pub mod crecorded_input {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CRecordedInput.data)
    pub enum Data {
        // @@protoc_insertion_point(oneof_field:CRecordedInput.finger_down)
        FingerDown(super::CInputTouchFingerDownMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.finger_motion)
        FingerMotion(super::CInputTouchFingerMotionMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.finger_up)
        FingerUp(super::CInputTouchFingerUpMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.mouse_motion)
        MouseMotion(super::CInputMouseMotionMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.mouse_wheel)
        MouseWheel(super::CInputMouseWheelMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.mouse_down)
        MouseDown(super::CInputMouseDownMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.mouse_up)
        MouseUp(super::CInputMouseUpMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.key_down)
        KeyDown(super::CInputKeyDownMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.key_up)
        KeyUp(super::CInputKeyUpMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.text)
        Text(super::CInputTextMsg),
        // @@protoc_insertion_point(oneof_field:CRecordedInput.hid)
        Hid(super::CRemoteHIDMsg),
    }

    impl crate::Oneof for Data {
    }

    impl crate::OneofFull for Data {
        fn descriptor() -> crate::reflect::OneofDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::OneofDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| <super::CRecordedInput as crate::MessageFull>::descriptor().oneof_by_name("data").unwrap()).clone()
        }
    }

    impl Data {
        pub(in super) fn generated_oneof_descriptor_data() -> crate::reflect::GeneratedOneofDescriptorData {
            crate::reflect::GeneratedOneofDescriptorData::new::<Data>("data")
        }
    }
}

// @@protoc_insertion_point(message:CRecordedInputStream)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRecordedInputStream {
    // message fields
    // @@protoc_insertion_point(field:CRecordedInputStream.entries)
    pub entries: ::std::vec::Vec<CRecordedInput>,
    // special fields
    // @@protoc_insertion_point(special_field:CRecordedInputStream.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRecordedInputStream {
    fn default() -> &'a CRecordedInputStream {
        <CRecordedInputStream as crate::Message>::default_instance()
    }
}

impl CRecordedInputStream {
    pub fn new() -> CRecordedInputStream {
        ::std::default::Default::default()
    }

    // repeated .CRecordedInput entries = 1;

    pub fn entries(&self) -> &[CRecordedInput] {
        &self.entries
    }

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::vec::Vec<CRecordedInput>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::vec::Vec<CRecordedInput> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::vec::Vec<CRecordedInput> {
        ::std::mem::replace(&mut self.entries, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CRecordedInputStream| { &m.entries },
            |m: &mut CRecordedInputStream| { &mut m.entries },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CRecordedInputStream>(
            "CRecordedInputStream",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CRecordedInputStream {
    const NAME: &'static str = "CRecordedInputStream";

    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.entries {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRecordedInputStream {
        CRecordedInputStream::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRecordedInputStream {
        static instance: CRecordedInputStream = CRecordedInputStream {
            entries: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CRecordedInputStream {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CRecordedInputStream").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CRecordedInputStream {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CRecordedInputStream {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputLatencyTestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputLatencyTestMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputLatencyTestMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputLatencyTestMsg.color)
    pub color: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputLatencyTestMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputLatencyTestMsg {
    fn default() -> &'a CInputLatencyTestMsg {
        <CInputLatencyTestMsg as crate::Message>::default_instance()
    }
}

impl CInputLatencyTestMsg {
    pub fn new() -> CInputLatencyTestMsg {
        ::std::default::Default::default()
    }

    // required uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint32 color = 2;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputLatencyTestMsg| { &m.input_mark },
            |m: &mut CInputLatencyTestMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "color",
            |m: &CInputLatencyTestMsg| { &m.color },
            |m: &mut CInputLatencyTestMsg| { &mut m.color },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputLatencyTestMsg>(
            "CInputLatencyTestMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputLatencyTestMsg {
    const NAME: &'static str = "CInputLatencyTestMsg";

    fn is_initialized(&self) -> bool {
        if self.input_mark.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.color {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.color {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputLatencyTestMsg {
        CInputLatencyTestMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputLatencyTestMsg {
        static instance: CInputLatencyTestMsg = CInputLatencyTestMsg {
            input_mark: ::std::option::Option::None,
            color: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputLatencyTestMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputLatencyTestMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputLatencyTestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputLatencyTestMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputTouchFingerDownMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputTouchFingerDownMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputTouchFingerDownMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputTouchFingerDownMsg.fingerid)
    pub fingerid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CInputTouchFingerDownMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputTouchFingerDownMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputTouchFingerDownMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerDownMsg {
    fn default() -> &'a CInputTouchFingerDownMsg {
        <CInputTouchFingerDownMsg as crate::Message>::default_instance()
    }
}

impl CInputTouchFingerDownMsg {
    pub fn new() -> CInputTouchFingerDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;

    pub fn fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }

    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputTouchFingerDownMsg| { &m.input_mark },
            |m: &mut CInputTouchFingerDownMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fingerid",
            |m: &CInputTouchFingerDownMsg| { &m.fingerid },
            |m: &mut CInputTouchFingerDownMsg| { &mut m.fingerid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x_normalized",
            |m: &CInputTouchFingerDownMsg| { &m.x_normalized },
            |m: &mut CInputTouchFingerDownMsg| { &mut m.x_normalized },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y_normalized",
            |m: &CInputTouchFingerDownMsg| { &m.y_normalized },
            |m: &mut CInputTouchFingerDownMsg| { &mut m.y_normalized },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputTouchFingerDownMsg>(
            "CInputTouchFingerDownMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputTouchFingerDownMsg {
    const NAME: &'static str = "CInputTouchFingerDownMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fingerid = ::std::option::Option::Some(is.read_uint64()?);
                },
                29 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fingerid {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputTouchFingerDownMsg {
        CInputTouchFingerDownMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputTouchFingerDownMsg {
        static instance: CInputTouchFingerDownMsg = CInputTouchFingerDownMsg {
            input_mark: ::std::option::Option::None,
            fingerid: ::std::option::Option::None,
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputTouchFingerDownMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputTouchFingerDownMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputTouchFingerDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputTouchFingerDownMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputTouchFingerMotionMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputTouchFingerMotionMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputTouchFingerMotionMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputTouchFingerMotionMsg.fingerid)
    pub fingerid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CInputTouchFingerMotionMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputTouchFingerMotionMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputTouchFingerMotionMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerMotionMsg {
    fn default() -> &'a CInputTouchFingerMotionMsg {
        <CInputTouchFingerMotionMsg as crate::Message>::default_instance()
    }
}

impl CInputTouchFingerMotionMsg {
    pub fn new() -> CInputTouchFingerMotionMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;

    pub fn fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }

    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputTouchFingerMotionMsg| { &m.input_mark },
            |m: &mut CInputTouchFingerMotionMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fingerid",
            |m: &CInputTouchFingerMotionMsg| { &m.fingerid },
            |m: &mut CInputTouchFingerMotionMsg| { &mut m.fingerid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x_normalized",
            |m: &CInputTouchFingerMotionMsg| { &m.x_normalized },
            |m: &mut CInputTouchFingerMotionMsg| { &mut m.x_normalized },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y_normalized",
            |m: &CInputTouchFingerMotionMsg| { &m.y_normalized },
            |m: &mut CInputTouchFingerMotionMsg| { &mut m.y_normalized },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputTouchFingerMotionMsg>(
            "CInputTouchFingerMotionMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputTouchFingerMotionMsg {
    const NAME: &'static str = "CInputTouchFingerMotionMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fingerid = ::std::option::Option::Some(is.read_uint64()?);
                },
                29 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fingerid {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputTouchFingerMotionMsg {
        CInputTouchFingerMotionMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputTouchFingerMotionMsg {
        static instance: CInputTouchFingerMotionMsg = CInputTouchFingerMotionMsg {
            input_mark: ::std::option::Option::None,
            fingerid: ::std::option::Option::None,
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputTouchFingerMotionMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputTouchFingerMotionMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputTouchFingerMotionMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputTouchFingerMotionMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputTouchFingerUpMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputTouchFingerUpMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputTouchFingerUpMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputTouchFingerUpMsg.fingerid)
    pub fingerid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CInputTouchFingerUpMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputTouchFingerUpMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputTouchFingerUpMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputTouchFingerUpMsg {
    fn default() -> &'a CInputTouchFingerUpMsg {
        <CInputTouchFingerUpMsg as crate::Message>::default_instance()
    }
}

impl CInputTouchFingerUpMsg {
    pub fn new() -> CInputTouchFingerUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional uint64 fingerid = 2;

    pub fn fingerid(&self) -> u64 {
        self.fingerid.unwrap_or(0)
    }

    pub fn clear_fingerid(&mut self) {
        self.fingerid = ::std::option::Option::None;
    }

    pub fn has_fingerid(&self) -> bool {
        self.fingerid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fingerid(&mut self, v: u64) {
        self.fingerid = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 3;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 4;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputTouchFingerUpMsg| { &m.input_mark },
            |m: &mut CInputTouchFingerUpMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "fingerid",
            |m: &CInputTouchFingerUpMsg| { &m.fingerid },
            |m: &mut CInputTouchFingerUpMsg| { &mut m.fingerid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x_normalized",
            |m: &CInputTouchFingerUpMsg| { &m.x_normalized },
            |m: &mut CInputTouchFingerUpMsg| { &mut m.x_normalized },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y_normalized",
            |m: &CInputTouchFingerUpMsg| { &m.y_normalized },
            |m: &mut CInputTouchFingerUpMsg| { &mut m.y_normalized },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputTouchFingerUpMsg>(
            "CInputTouchFingerUpMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputTouchFingerUpMsg {
    const NAME: &'static str = "CInputTouchFingerUpMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fingerid = ::std::option::Option::Some(is.read_uint64()?);
                },
                29 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fingerid {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fingerid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputTouchFingerUpMsg {
        CInputTouchFingerUpMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.fingerid = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputTouchFingerUpMsg {
        static instance: CInputTouchFingerUpMsg = CInputTouchFingerUpMsg {
            input_mark: ::std::option::Option::None,
            fingerid: ::std::option::Option::None,
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputTouchFingerUpMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputTouchFingerUpMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputTouchFingerUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputTouchFingerUpMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputMouseMotionMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputMouseMotionMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.dx)
    pub dx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CInputMouseMotionMsg.dy)
    pub dy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputMouseMotionMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputMouseMotionMsg {
    fn default() -> &'a CInputMouseMotionMsg {
        <CInputMouseMotionMsg as crate::Message>::default_instance()
    }
}

impl CInputMouseMotionMsg {
    pub fn new() -> CInputMouseMotionMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // optional float x_normalized = 2;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 3;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    // optional int32 dx = 4;

    pub fn dx(&self) -> i32 {
        self.dx.unwrap_or(0)
    }

    pub fn clear_dx(&mut self) {
        self.dx = ::std::option::Option::None;
    }

    pub fn has_dx(&self) -> bool {
        self.dx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dx(&mut self, v: i32) {
        self.dx = ::std::option::Option::Some(v);
    }

    // optional int32 dy = 5;

    pub fn dy(&self) -> i32 {
        self.dy.unwrap_or(0)
    }

    pub fn clear_dy(&mut self) {
        self.dy = ::std::option::Option::None;
    }

    pub fn has_dy(&self) -> bool {
        self.dy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dy(&mut self, v: i32) {
        self.dy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputMouseMotionMsg| { &m.input_mark },
            |m: &mut CInputMouseMotionMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x_normalized",
            |m: &CInputMouseMotionMsg| { &m.x_normalized },
            |m: &mut CInputMouseMotionMsg| { &mut m.x_normalized },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y_normalized",
            |m: &CInputMouseMotionMsg| { &m.y_normalized },
            |m: &mut CInputMouseMotionMsg| { &mut m.y_normalized },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dx",
            |m: &CInputMouseMotionMsg| { &m.dx },
            |m: &mut CInputMouseMotionMsg| { &mut m.dx },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "dy",
            |m: &CInputMouseMotionMsg| { &m.dy },
            |m: &mut CInputMouseMotionMsg| { &mut m.dy },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputMouseMotionMsg>(
            "CInputMouseMotionMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputMouseMotionMsg {
    const NAME: &'static str = "CInputMouseMotionMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.dx = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.dy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.dx {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.dy {
            my_size += crate::rt::int32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x_normalized {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.dx {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.dy {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputMouseMotionMsg {
        CInputMouseMotionMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.dx = ::std::option::Option::None;
        self.dy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputMouseMotionMsg {
        static instance: CInputMouseMotionMsg = CInputMouseMotionMsg {
            input_mark: ::std::option::Option::None,
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            dx: ::std::option::Option::None,
            dy: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputMouseMotionMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputMouseMotionMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputMouseMotionMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputMouseMotionMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputMouseWheelMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputMouseWheelMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputMouseWheelMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputMouseWheelMsg.direction)
    pub direction: ::std::option::Option<crate::EnumOrUnknown<EStreamMouseWheelDirection>>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputMouseWheelMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputMouseWheelMsg {
    fn default() -> &'a CInputMouseWheelMsg {
        <CInputMouseWheelMsg as crate::Message>::default_instance()
    }
}

impl CInputMouseWheelMsg {
    pub fn new() -> CInputMouseWheelMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseWheelDirection direction = 2;

    pub fn direction(&self) -> EStreamMouseWheelDirection {
        match self.direction {
            Some(e) => e.enum_value_or(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            None => EStreamMouseWheelDirection::k_EStreamMouseWheelUp,
        }
    }

    pub fn clear_direction(&mut self) {
        self.direction = ::std::option::Option::None;
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: EStreamMouseWheelDirection) {
        self.direction = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputMouseWheelMsg| { &m.input_mark },
            |m: &mut CInputMouseWheelMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "direction",
            |m: &CInputMouseWheelMsg| { &m.direction },
            |m: &mut CInputMouseWheelMsg| { &mut m.direction },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputMouseWheelMsg>(
            "CInputMouseWheelMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputMouseWheelMsg {
    const NAME: &'static str = "CInputMouseWheelMsg";

    fn is_initialized(&self) -> bool {
        if self.direction.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.direction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.direction {
            my_size += crate::rt::int32_size(2, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.direction {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputMouseWheelMsg {
        CInputMouseWheelMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.direction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputMouseWheelMsg {
        static instance: CInputMouseWheelMsg = CInputMouseWheelMsg {
            input_mark: ::std::option::Option::None,
            direction: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputMouseWheelMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputMouseWheelMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputMouseWheelMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputMouseWheelMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputMouseDownMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputMouseDownMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputMouseDownMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputMouseDownMsg.button)
    pub button: ::std::option::Option<crate::EnumOrUnknown<EStreamMouseButton>>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputMouseDownMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputMouseDownMsg {
    fn default() -> &'a CInputMouseDownMsg {
        <CInputMouseDownMsg as crate::Message>::default_instance()
    }
}

impl CInputMouseDownMsg {
    pub fn new() -> CInputMouseDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseButton button = 2;

    pub fn button(&self) -> EStreamMouseButton {
        match self.button {
            Some(e) => e.enum_value_or(EStreamMouseButton::k_EStreamMouseButtonLeft),
            None => EStreamMouseButton::k_EStreamMouseButtonLeft,
        }
    }

    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputMouseDownMsg| { &m.input_mark },
            |m: &mut CInputMouseDownMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "button",
            |m: &CInputMouseDownMsg| { &m.button },
            |m: &mut CInputMouseDownMsg| { &mut m.button },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputMouseDownMsg>(
            "CInputMouseDownMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputMouseDownMsg {
    const NAME: &'static str = "CInputMouseDownMsg";

    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.button = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.button {
            my_size += crate::rt::int32_size(2, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.button {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputMouseDownMsg {
        CInputMouseDownMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputMouseDownMsg {
        static instance: CInputMouseDownMsg = CInputMouseDownMsg {
            input_mark: ::std::option::Option::None,
            button: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputMouseDownMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputMouseDownMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputMouseDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputMouseDownMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputMouseUpMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputMouseUpMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputMouseUpMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputMouseUpMsg.button)
    pub button: ::std::option::Option<crate::EnumOrUnknown<EStreamMouseButton>>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputMouseUpMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputMouseUpMsg {
    fn default() -> &'a CInputMouseUpMsg {
        <CInputMouseUpMsg as crate::Message>::default_instance()
    }
}

impl CInputMouseUpMsg {
    pub fn new() -> CInputMouseUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required .EStreamMouseButton button = 2;

    pub fn button(&self) -> EStreamMouseButton {
        match self.button {
            Some(e) => e.enum_value_or(EStreamMouseButton::k_EStreamMouseButtonLeft),
            None => EStreamMouseButton::k_EStreamMouseButtonLeft,
        }
    }

    pub fn clear_button(&mut self) {
        self.button = ::std::option::Option::None;
    }

    pub fn has_button(&self) -> bool {
        self.button.is_some()
    }

    // Param is passed by value, moved
    pub fn set_button(&mut self, v: EStreamMouseButton) {
        self.button = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputMouseUpMsg| { &m.input_mark },
            |m: &mut CInputMouseUpMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "button",
            |m: &CInputMouseUpMsg| { &m.button },
            |m: &mut CInputMouseUpMsg| { &mut m.button },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputMouseUpMsg>(
            "CInputMouseUpMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputMouseUpMsg {
    const NAME: &'static str = "CInputMouseUpMsg";

    fn is_initialized(&self) -> bool {
        if self.button.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.button = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.button {
            my_size += crate::rt::int32_size(2, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.button {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputMouseUpMsg {
        CInputMouseUpMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.button = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputMouseUpMsg {
        static instance: CInputMouseUpMsg = CInputMouseUpMsg {
            input_mark: ::std::option::Option::None,
            button: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputMouseUpMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputMouseUpMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputMouseUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputMouseUpMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputKeyDownMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputKeyDownMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputKeyDownMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputKeyDownMsg.scancode)
    pub scancode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputKeyDownMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputKeyDownMsg {
    fn default() -> &'a CInputKeyDownMsg {
        <CInputKeyDownMsg as crate::Message>::default_instance()
    }
}

impl CInputKeyDownMsg {
    pub fn new() -> CInputKeyDownMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required uint32 scancode = 2;

    pub fn scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputKeyDownMsg| { &m.input_mark },
            |m: &mut CInputKeyDownMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scancode",
            |m: &CInputKeyDownMsg| { &m.scancode },
            |m: &mut CInputKeyDownMsg| { &mut m.scancode },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputKeyDownMsg>(
            "CInputKeyDownMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputKeyDownMsg {
    const NAME: &'static str = "CInputKeyDownMsg";

    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scancode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scancode {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputKeyDownMsg {
        CInputKeyDownMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputKeyDownMsg {
        static instance: CInputKeyDownMsg = CInputKeyDownMsg {
            input_mark: ::std::option::Option::None,
            scancode: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputKeyDownMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputKeyDownMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputKeyDownMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputKeyDownMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputKeyUpMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputKeyUpMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputKeyUpMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputKeyUpMsg.scancode)
    pub scancode: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputKeyUpMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputKeyUpMsg {
    fn default() -> &'a CInputKeyUpMsg {
        <CInputKeyUpMsg as crate::Message>::default_instance()
    }
}

impl CInputKeyUpMsg {
    pub fn new() -> CInputKeyUpMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required uint32 scancode = 2;

    pub fn scancode(&self) -> u32 {
        self.scancode.unwrap_or(0)
    }

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: u32) {
        self.scancode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputKeyUpMsg| { &m.input_mark },
            |m: &mut CInputKeyUpMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scancode",
            |m: &CInputKeyUpMsg| { &m.scancode },
            |m: &mut CInputKeyUpMsg| { &mut m.scancode },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputKeyUpMsg>(
            "CInputKeyUpMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputKeyUpMsg {
    const NAME: &'static str = "CInputKeyUpMsg";

    fn is_initialized(&self) -> bool {
        if self.scancode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scancode = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scancode {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scancode {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputKeyUpMsg {
        CInputKeyUpMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.scancode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputKeyUpMsg {
        static instance: CInputKeyUpMsg = CInputKeyUpMsg {
            input_mark: ::std::option::Option::None,
            scancode: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputKeyUpMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputKeyUpMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputKeyUpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputKeyUpMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CInputTextMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CInputTextMsg {
    // message fields
    // @@protoc_insertion_point(field:CInputTextMsg.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CInputTextMsg.text_utf8)
    pub text_utf8: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CInputTextMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CInputTextMsg {
    fn default() -> &'a CInputTextMsg {
        <CInputTextMsg as crate::Message>::default_instance()
    }
}

impl CInputTextMsg {
    pub fn new() -> CInputTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 input_mark = 1;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // required string text_utf8 = 2;

    pub fn text_utf8(&self) -> &str {
        match self.text_utf8.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text_utf8(&mut self) {
        self.text_utf8 = ::std::option::Option::None;
    }

    pub fn has_text_utf8(&self) -> bool {
        self.text_utf8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_utf8(&mut self, v: ::std::string::String) {
        self.text_utf8 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text_utf8(&mut self) -> &mut ::std::string::String {
        if self.text_utf8.is_none() {
            self.text_utf8 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text_utf8.as_mut().unwrap()
    }

    // Take field
    pub fn take_text_utf8(&mut self) -> ::std::string::String {
        self.text_utf8.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CInputTextMsg| { &m.input_mark },
            |m: &mut CInputTextMsg| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "text_utf8",
            |m: &CInputTextMsg| { &m.text_utf8 },
            |m: &mut CInputTextMsg| { &mut m.text_utf8 },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CInputTextMsg>(
            "CInputTextMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CInputTextMsg {
    const NAME: &'static str = "CInputTextMsg";

    fn is_initialized(&self) -> bool {
        if self.text_utf8.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text_utf8 = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text_utf8.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.input_mark {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text_utf8.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CInputTextMsg {
        CInputTextMsg::new()
    }

    fn clear(&mut self) {
        self.input_mark = ::std::option::Option::None;
        self.text_utf8 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CInputTextMsg {
        static instance: CInputTextMsg = CInputTextMsg {
            input_mark: ::std::option::Option::None,
            text_utf8: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CInputTextMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CInputTextMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CInputTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CInputTextMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetTitleMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTitleMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTitleMsg.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTitleMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTitleMsg {
    fn default() -> &'a CSetTitleMsg {
        <CSetTitleMsg as crate::Message>::default_instance()
    }
}

impl CSetTitleMsg {
    pub fn new() -> CSetTitleMsg {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CSetTitleMsg| { &m.text },
            |m: &mut CSetTitleMsg| { &mut m.text },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetTitleMsg>(
            "CSetTitleMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetTitleMsg {
    const NAME: &'static str = "CSetTitleMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTitleMsg {
        CSetTitleMsg::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTitleMsg {
        static instance: CSetTitleMsg = CSetTitleMsg {
            text: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetTitleMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetTitleMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetTitleMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetTitleMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetCaptureSizeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetCaptureSizeMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetCaptureSizeMsg.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCaptureSizeMsg.height)
    pub height: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetCaptureSizeMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetCaptureSizeMsg {
    fn default() -> &'a CSetCaptureSizeMsg {
        <CSetCaptureSizeMsg as crate::Message>::default_instance()
    }
}

impl CSetCaptureSizeMsg {
    pub fn new() -> CSetCaptureSizeMsg {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CSetCaptureSizeMsg| { &m.width },
            |m: &mut CSetCaptureSizeMsg| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CSetCaptureSizeMsg| { &m.height },
            |m: &mut CSetCaptureSizeMsg| { &mut m.height },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetCaptureSizeMsg>(
            "CSetCaptureSizeMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetCaptureSizeMsg {
    const NAME: &'static str = "CSetCaptureSizeMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetCaptureSizeMsg {
        CSetCaptureSizeMsg::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetCaptureSizeMsg {
        static instance: CSetCaptureSizeMsg = CSetCaptureSizeMsg {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetCaptureSizeMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetCaptureSizeMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetCaptureSizeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetCaptureSizeMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetIconMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetIconMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetIconMsg.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetIconMsg.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetIconMsg.image)
    pub image: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetIconMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetIconMsg {
    fn default() -> &'a CSetIconMsg {
        <CSetIconMsg as crate::Message>::default_instance()
    }
}

impl CSetIconMsg {
    pub fn new() -> CSetIconMsg {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional bytes image = 3;

    pub fn image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::bytes::Bytes) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::bytes::Bytes {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::bytes::Bytes {
        self.image.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CSetIconMsg| { &m.width },
            |m: &mut CSetIconMsg| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CSetIconMsg| { &m.height },
            |m: &mut CSetIconMsg| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &CSetIconMsg| { &m.image },
            |m: &mut CSetIconMsg| { &mut m.image },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetIconMsg>(
            "CSetIconMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetIconMsg {
    const NAME: &'static str = "CSetIconMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.image = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetIconMsg {
        CSetIconMsg::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetIconMsg {
        static instance: CSetIconMsg = CSetIconMsg {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            image: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetIconMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetIconMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetIconMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetIconMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetFlashStateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetFlashStateMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetFlashStateMsg.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetFlashStateMsg.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetFlashStateMsg.timeout_ms)
    pub timeout_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetFlashStateMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetFlashStateMsg {
    fn default() -> &'a CSetFlashStateMsg {
        <CSetFlashStateMsg as crate::Message>::default_instance()
    }
}

impl CSetFlashStateMsg {
    pub fn new() -> CSetFlashStateMsg {
        ::std::default::Default::default()
    }

    // optional uint32 flags = 1;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 2;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 timeout_ms = 3;

    pub fn timeout_ms(&self) -> u32 {
        self.timeout_ms.unwrap_or(0)
    }

    pub fn clear_timeout_ms(&mut self) {
        self.timeout_ms = ::std::option::Option::None;
    }

    pub fn has_timeout_ms(&self) -> bool {
        self.timeout_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout_ms(&mut self, v: u32) {
        self.timeout_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSetFlashStateMsg| { &m.flags },
            |m: &mut CSetFlashStateMsg| { &mut m.flags },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CSetFlashStateMsg| { &m.count },
            |m: &mut CSetFlashStateMsg| { &mut m.count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeout_ms",
            |m: &CSetFlashStateMsg| { &m.timeout_ms },
            |m: &mut CSetFlashStateMsg| { &mut m.timeout_ms },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetFlashStateMsg>(
            "CSetFlashStateMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetFlashStateMsg {
    const NAME: &'static str = "CSetFlashStateMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.timeout_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.flags {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.timeout_ms {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timeout_ms {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetFlashStateMsg {
        CSetFlashStateMsg::new()
    }

    fn clear(&mut self) {
        self.flags = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.timeout_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetFlashStateMsg {
        static instance: CSetFlashStateMsg = CSetFlashStateMsg {
            flags: ::std::option::Option::None,
            count: ::std::option::Option::None,
            timeout_ms: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetFlashStateMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetFlashStateMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetFlashStateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetFlashStateMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CShowCursorMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CShowCursorMsg {
    // message fields
    // @@protoc_insertion_point(field:CShowCursorMsg.x_normalized)
    pub x_normalized: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CShowCursorMsg.y_normalized)
    pub y_normalized: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CShowCursorMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CShowCursorMsg {
    fn default() -> &'a CShowCursorMsg {
        <CShowCursorMsg as crate::Message>::default_instance()
    }
}

impl CShowCursorMsg {
    pub fn new() -> CShowCursorMsg {
        ::std::default::Default::default()
    }

    // optional float x_normalized = 1;

    pub fn x_normalized(&self) -> f32 {
        self.x_normalized.unwrap_or(0.)
    }

    pub fn clear_x_normalized(&mut self) {
        self.x_normalized = ::std::option::Option::None;
    }

    pub fn has_x_normalized(&self) -> bool {
        self.x_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x_normalized(&mut self, v: f32) {
        self.x_normalized = ::std::option::Option::Some(v);
    }

    // optional float y_normalized = 2;

    pub fn y_normalized(&self) -> f32 {
        self.y_normalized.unwrap_or(0.)
    }

    pub fn clear_y_normalized(&mut self) {
        self.y_normalized = ::std::option::Option::None;
    }

    pub fn has_y_normalized(&self) -> bool {
        self.y_normalized.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y_normalized(&mut self, v: f32) {
        self.y_normalized = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "x_normalized",
            |m: &CShowCursorMsg| { &m.x_normalized },
            |m: &mut CShowCursorMsg| { &mut m.x_normalized },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "y_normalized",
            |m: &CShowCursorMsg| { &m.y_normalized },
            |m: &mut CShowCursorMsg| { &mut m.y_normalized },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CShowCursorMsg>(
            "CShowCursorMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CShowCursorMsg {
    const NAME: &'static str = "CShowCursorMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y_normalized = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x_normalized {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y_normalized {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.x_normalized {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y_normalized {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CShowCursorMsg {
        CShowCursorMsg::new()
    }

    fn clear(&mut self) {
        self.x_normalized = ::std::option::Option::None;
        self.y_normalized = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CShowCursorMsg {
        static instance: CShowCursorMsg = CShowCursorMsg {
            x_normalized: ::std::option::Option::None,
            y_normalized: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CShowCursorMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CShowCursorMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CShowCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CShowCursorMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CHideCursorMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHideCursorMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CHideCursorMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHideCursorMsg {
    fn default() -> &'a CHideCursorMsg {
        <CHideCursorMsg as crate::Message>::default_instance()
    }
}

impl CHideCursorMsg {
    pub fn new() -> CHideCursorMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CHideCursorMsg>(
            "CHideCursorMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CHideCursorMsg {
    const NAME: &'static str = "CHideCursorMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHideCursorMsg {
        CHideCursorMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHideCursorMsg {
        static instance: CHideCursorMsg = CHideCursorMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CHideCursorMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHideCursorMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHideCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CHideCursorMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetCursorMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetCursorMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetCursorMsg.cursor_id)
    pub cursor_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetCursorMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetCursorMsg {
    fn default() -> &'a CSetCursorMsg {
        <CSetCursorMsg as crate::Message>::default_instance()
    }
}

impl CSetCursorMsg {
    pub fn new() -> CSetCursorMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cursor_id",
            |m: &CSetCursorMsg| { &m.cursor_id },
            |m: &mut CSetCursorMsg| { &mut m.cursor_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetCursorMsg>(
            "CSetCursorMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetCursorMsg {
    const NAME: &'static str = "CSetCursorMsg";

    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetCursorMsg {
        CSetCursorMsg::new()
    }

    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetCursorMsg {
        static instance: CSetCursorMsg = CSetCursorMsg {
            cursor_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetCursorMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetCursorMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetCursorMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGetCursorImageMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGetCursorImageMsg {
    // message fields
    // @@protoc_insertion_point(field:CGetCursorImageMsg.cursor_id)
    pub cursor_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CGetCursorImageMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGetCursorImageMsg {
    fn default() -> &'a CGetCursorImageMsg {
        <CGetCursorImageMsg as crate::Message>::default_instance()
    }
}

impl CGetCursorImageMsg {
    pub fn new() -> CGetCursorImageMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cursor_id",
            |m: &CGetCursorImageMsg| { &m.cursor_id },
            |m: &mut CGetCursorImageMsg| { &mut m.cursor_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CGetCursorImageMsg>(
            "CGetCursorImageMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CGetCursorImageMsg {
    const NAME: &'static str = "CGetCursorImageMsg";

    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGetCursorImageMsg {
        CGetCursorImageMsg::new()
    }

    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGetCursorImageMsg {
        static instance: CGetCursorImageMsg = CGetCursorImageMsg {
            cursor_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CGetCursorImageMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGetCursorImageMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGetCursorImageMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CGetCursorImageMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetCursorImageMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetCursorImageMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetCursorImageMsg.cursor_id)
    pub cursor_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.hot_x)
    pub hot_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.hot_y)
    pub hot_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSetCursorImageMsg.image)
    pub image: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetCursorImageMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetCursorImageMsg {
    fn default() -> &'a CSetCursorImageMsg {
        <CSetCursorImageMsg as crate::Message>::default_instance()
    }
}

impl CSetCursorImageMsg {
    pub fn new() -> CSetCursorImageMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    // optional int32 width = 2;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 3;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 hot_x = 4;

    pub fn hot_x(&self) -> i32 {
        self.hot_x.unwrap_or(0)
    }

    pub fn clear_hot_x(&mut self) {
        self.hot_x = ::std::option::Option::None;
    }

    pub fn has_hot_x(&self) -> bool {
        self.hot_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_x(&mut self, v: i32) {
        self.hot_x = ::std::option::Option::Some(v);
    }

    // optional int32 hot_y = 5;

    pub fn hot_y(&self) -> i32 {
        self.hot_y.unwrap_or(0)
    }

    pub fn clear_hot_y(&mut self) {
        self.hot_y = ::std::option::Option::None;
    }

    pub fn has_hot_y(&self) -> bool {
        self.hot_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_y(&mut self, v: i32) {
        self.hot_y = ::std::option::Option::Some(v);
    }

    // optional bytes image = 6;

    pub fn image(&self) -> &[u8] {
        match self.image.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::bytes::Bytes) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::bytes::Bytes {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::bytes::Bytes {
        self.image.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cursor_id",
            |m: &CSetCursorImageMsg| { &m.cursor_id },
            |m: &mut CSetCursorImageMsg| { &mut m.cursor_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CSetCursorImageMsg| { &m.width },
            |m: &mut CSetCursorImageMsg| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CSetCursorImageMsg| { &m.height },
            |m: &mut CSetCursorImageMsg| { &mut m.height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hot_x",
            |m: &CSetCursorImageMsg| { &m.hot_x },
            |m: &mut CSetCursorImageMsg| { &mut m.hot_x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hot_y",
            |m: &CSetCursorImageMsg| { &m.hot_y },
            |m: &mut CSetCursorImageMsg| { &mut m.hot_y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &CSetCursorImageMsg| { &m.image },
            |m: &mut CSetCursorImageMsg| { &mut m.image },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetCursorImageMsg>(
            "CSetCursorImageMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetCursorImageMsg {
    const NAME: &'static str = "CSetCursorImageMsg";

    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.hot_x = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.hot_y = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.image = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.width {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.hot_x {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.hot_y {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += crate::rt::bytes_size(6, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.width {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.hot_x {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.hot_y {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_bytes(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetCursorImageMsg {
        CSetCursorImageMsg::new()
    }

    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.hot_x = ::std::option::Option::None;
        self.hot_y = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetCursorImageMsg {
        static instance: CSetCursorImageMsg = CSetCursorImageMsg {
            cursor_id: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            hot_x: ::std::option::Option::None,
            hot_y: ::std::option::Option::None,
            image: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetCursorImageMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetCursorImageMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetCursorImageMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetCursorImageMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetCursorScaleMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetCursorScaleMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetCursorScaleMsg.scale)
    pub scale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetCursorScaleMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetCursorScaleMsg {
    fn default() -> &'a CSetCursorScaleMsg {
        <CSetCursorScaleMsg as crate::Message>::default_instance()
    }
}

impl CSetCursorScaleMsg {
    pub fn new() -> CSetCursorScaleMsg {
        ::std::default::Default::default()
    }

    // optional float scale = 1;

    pub fn scale(&self) -> f32 {
        self.scale.unwrap_or(0.)
    }

    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f32) {
        self.scale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scale",
            |m: &CSetCursorScaleMsg| { &m.scale },
            |m: &mut CSetCursorScaleMsg| { &mut m.scale },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetCursorScaleMsg>(
            "CSetCursorScaleMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetCursorScaleMsg {
    const NAME: &'static str = "CSetCursorScaleMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.scale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scale {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.scale {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetCursorScaleMsg {
        CSetCursorScaleMsg::new()
    }

    fn clear(&mut self) {
        self.scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetCursorScaleMsg {
        static instance: CSetCursorScaleMsg = CSetCursorScaleMsg {
            scale: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetCursorScaleMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetCursorScaleMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetCursorScaleMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetCursorScaleMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CVideoDecoderInfoMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVideoDecoderInfoMsg {
    // message fields
    // @@protoc_insertion_point(field:CVideoDecoderInfoMsg.info)
    pub info: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CVideoDecoderInfoMsg.threads)
    pub threads: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CVideoDecoderInfoMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVideoDecoderInfoMsg {
    fn default() -> &'a CVideoDecoderInfoMsg {
        <CVideoDecoderInfoMsg as crate::Message>::default_instance()
    }
}

impl CVideoDecoderInfoMsg {
    pub fn new() -> CVideoDecoderInfoMsg {
        ::std::default::Default::default()
    }

    // optional string info = 1;

    pub fn info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_info(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info = ::std::option::Option::Some(::std::string::String::new());
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 threads = 2;

    pub fn threads(&self) -> i32 {
        self.threads.unwrap_or(0)
    }

    pub fn clear_threads(&mut self) {
        self.threads = ::std::option::Option::None;
    }

    pub fn has_threads(&self) -> bool {
        self.threads.is_some()
    }

    // Param is passed by value, moved
    pub fn set_threads(&mut self, v: i32) {
        self.threads = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "info",
            |m: &CVideoDecoderInfoMsg| { &m.info },
            |m: &mut CVideoDecoderInfoMsg| { &mut m.info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "threads",
            |m: &CVideoDecoderInfoMsg| { &m.threads },
            |m: &mut CVideoDecoderInfoMsg| { &mut m.threads },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CVideoDecoderInfoMsg>(
            "CVideoDecoderInfoMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CVideoDecoderInfoMsg {
    const NAME: &'static str = "CVideoDecoderInfoMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.info = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.threads = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.threads {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.threads {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVideoDecoderInfoMsg {
        CVideoDecoderInfoMsg::new()
    }

    fn clear(&mut self) {
        self.info = ::std::option::Option::None;
        self.threads = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVideoDecoderInfoMsg {
        static instance: CVideoDecoderInfoMsg = CVideoDecoderInfoMsg {
            info: ::std::option::Option::None,
            threads: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CVideoDecoderInfoMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CVideoDecoderInfoMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CVideoDecoderInfoMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CVideoDecoderInfoMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CVideoEncoderInfoMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVideoEncoderInfoMsg {
    // message fields
    // @@protoc_insertion_point(field:CVideoEncoderInfoMsg.info)
    pub info: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CVideoEncoderInfoMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVideoEncoderInfoMsg {
    fn default() -> &'a CVideoEncoderInfoMsg {
        <CVideoEncoderInfoMsg as crate::Message>::default_instance()
    }
}

impl CVideoEncoderInfoMsg {
    pub fn new() -> CVideoEncoderInfoMsg {
        ::std::default::Default::default()
    }

    // optional string info = 1;

    pub fn info(&self) -> &str {
        match self.info.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_info(&mut self) {
        self.info = ::std::option::Option::None;
    }

    pub fn has_info(&self) -> bool {
        self.info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_info(&mut self, v: ::std::string::String) {
        self.info = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_info(&mut self) -> &mut ::std::string::String {
        if self.info.is_none() {
            self.info = ::std::option::Option::Some(::std::string::String::new());
        }
        self.info.as_mut().unwrap()
    }

    // Take field
    pub fn take_info(&mut self) -> ::std::string::String {
        self.info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "info",
            |m: &CVideoEncoderInfoMsg| { &m.info },
            |m: &mut CVideoEncoderInfoMsg| { &mut m.info },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CVideoEncoderInfoMsg>(
            "CVideoEncoderInfoMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CVideoEncoderInfoMsg {
    const NAME: &'static str = "CVideoEncoderInfoMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.info = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.info.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVideoEncoderInfoMsg {
        CVideoEncoderInfoMsg::new()
    }

    fn clear(&mut self) {
        self.info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVideoEncoderInfoMsg {
        static instance: CVideoEncoderInfoMsg = CVideoEncoderInfoMsg {
            info: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CVideoEncoderInfoMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CVideoEncoderInfoMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CVideoEncoderInfoMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CVideoEncoderInfoMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CPauseMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CPauseMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CPauseMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPauseMsg {
    fn default() -> &'a CPauseMsg {
        <CPauseMsg as crate::Message>::default_instance()
    }
}

impl CPauseMsg {
    pub fn new() -> CPauseMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CPauseMsg>(
            "CPauseMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CPauseMsg {
    const NAME: &'static str = "CPauseMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPauseMsg {
        CPauseMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPauseMsg {
        static instance: CPauseMsg = CPauseMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CPauseMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CPauseMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CPauseMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CPauseMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CResumeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CResumeMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CResumeMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CResumeMsg {
    fn default() -> &'a CResumeMsg {
        <CResumeMsg as crate::Message>::default_instance()
    }
}

impl CResumeMsg {
    pub fn new() -> CResumeMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CResumeMsg>(
            "CResumeMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CResumeMsg {
    const NAME: &'static str = "CResumeMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CResumeMsg {
        CResumeMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CResumeMsg {
        static instance: CResumeMsg = CResumeMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CResumeMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CResumeMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CResumeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CResumeMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEnableHighResCaptureMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEnableHighResCaptureMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CEnableHighResCaptureMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEnableHighResCaptureMsg {
    fn default() -> &'a CEnableHighResCaptureMsg {
        <CEnableHighResCaptureMsg as crate::Message>::default_instance()
    }
}

impl CEnableHighResCaptureMsg {
    pub fn new() -> CEnableHighResCaptureMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CEnableHighResCaptureMsg>(
            "CEnableHighResCaptureMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CEnableHighResCaptureMsg {
    const NAME: &'static str = "CEnableHighResCaptureMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEnableHighResCaptureMsg {
        CEnableHighResCaptureMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEnableHighResCaptureMsg {
        static instance: CEnableHighResCaptureMsg = CEnableHighResCaptureMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CEnableHighResCaptureMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEnableHighResCaptureMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEnableHighResCaptureMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CEnableHighResCaptureMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDisableHighResCaptureMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDisableHighResCaptureMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CDisableHighResCaptureMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDisableHighResCaptureMsg {
    fn default() -> &'a CDisableHighResCaptureMsg {
        <CDisableHighResCaptureMsg as crate::Message>::default_instance()
    }
}

impl CDisableHighResCaptureMsg {
    pub fn new() -> CDisableHighResCaptureMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CDisableHighResCaptureMsg>(
            "CDisableHighResCaptureMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CDisableHighResCaptureMsg {
    const NAME: &'static str = "CDisableHighResCaptureMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDisableHighResCaptureMsg {
        CDisableHighResCaptureMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDisableHighResCaptureMsg {
        static instance: CDisableHighResCaptureMsg = CDisableHighResCaptureMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CDisableHighResCaptureMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDisableHighResCaptureMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDisableHighResCaptureMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CDisableHighResCaptureMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CEnableNeptuneDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEnableNeptuneDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CEnableNeptuneDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEnableNeptuneDataMsg {
    fn default() -> &'a CEnableNeptuneDataMsg {
        <CEnableNeptuneDataMsg as crate::Message>::default_instance()
    }
}

impl CEnableNeptuneDataMsg {
    pub fn new() -> CEnableNeptuneDataMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CEnableNeptuneDataMsg>(
            "CEnableNeptuneDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CEnableNeptuneDataMsg {
    const NAME: &'static str = "CEnableNeptuneDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEnableNeptuneDataMsg {
        CEnableNeptuneDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEnableNeptuneDataMsg {
        static instance: CEnableNeptuneDataMsg = CEnableNeptuneDataMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CEnableNeptuneDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEnableNeptuneDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEnableNeptuneDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CEnableNeptuneDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDisableNeptuneDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDisableNeptuneDataMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CDisableNeptuneDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDisableNeptuneDataMsg {
    fn default() -> &'a CDisableNeptuneDataMsg {
        <CDisableNeptuneDataMsg as crate::Message>::default_instance()
    }
}

impl CDisableNeptuneDataMsg {
    pub fn new() -> CDisableNeptuneDataMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CDisableNeptuneDataMsg>(
            "CDisableNeptuneDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CDisableNeptuneDataMsg {
    const NAME: &'static str = "CDisableNeptuneDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDisableNeptuneDataMsg {
        CDisableNeptuneDataMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDisableNeptuneDataMsg {
        static instance: CDisableNeptuneDataMsg = CDisableNeptuneDataMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CDisableNeptuneDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDisableNeptuneDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDisableNeptuneDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CDisableNeptuneDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CPauseControllerInputMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CPauseControllerInputMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CPauseControllerInputMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPauseControllerInputMsg {
    fn default() -> &'a CPauseControllerInputMsg {
        <CPauseControllerInputMsg as crate::Message>::default_instance()
    }
}

impl CPauseControllerInputMsg {
    pub fn new() -> CPauseControllerInputMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CPauseControllerInputMsg>(
            "CPauseControllerInputMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CPauseControllerInputMsg {
    const NAME: &'static str = "CPauseControllerInputMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPauseControllerInputMsg {
        CPauseControllerInputMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPauseControllerInputMsg {
        static instance: CPauseControllerInputMsg = CPauseControllerInputMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CPauseControllerInputMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CPauseControllerInputMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CPauseControllerInputMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CPauseControllerInputMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CResumeControllerInputMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CResumeControllerInputMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CResumeControllerInputMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CResumeControllerInputMsg {
    fn default() -> &'a CResumeControllerInputMsg {
        <CResumeControllerInputMsg as crate::Message>::default_instance()
    }
}

impl CResumeControllerInputMsg {
    pub fn new() -> CResumeControllerInputMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CResumeControllerInputMsg>(
            "CResumeControllerInputMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CResumeControllerInputMsg {
    const NAME: &'static str = "CResumeControllerInputMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CResumeControllerInputMsg {
        CResumeControllerInputMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CResumeControllerInputMsg {
        static instance: CResumeControllerInputMsg = CResumeControllerInputMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CResumeControllerInputMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CResumeControllerInputMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CResumeControllerInputMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CResumeControllerInputMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CToggleMagnificationMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CToggleMagnificationMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CToggleMagnificationMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CToggleMagnificationMsg {
    fn default() -> &'a CToggleMagnificationMsg {
        <CToggleMagnificationMsg as crate::Message>::default_instance()
    }
}

impl CToggleMagnificationMsg {
    pub fn new() -> CToggleMagnificationMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CToggleMagnificationMsg>(
            "CToggleMagnificationMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CToggleMagnificationMsg {
    const NAME: &'static str = "CToggleMagnificationMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CToggleMagnificationMsg {
        CToggleMagnificationMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CToggleMagnificationMsg {
        static instance: CToggleMagnificationMsg = CToggleMagnificationMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CToggleMagnificationMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CToggleMagnificationMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CToggleMagnificationMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CToggleMagnificationMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetCapslockMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetCapslockMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetCapslockMsg.pressed)
    pub pressed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetCapslockMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetCapslockMsg {
    fn default() -> &'a CSetCapslockMsg {
        <CSetCapslockMsg as crate::Message>::default_instance()
    }
}

impl CSetCapslockMsg {
    pub fn new() -> CSetCapslockMsg {
        ::std::default::Default::default()
    }

    // optional bool pressed = 1;

    pub fn pressed(&self) -> bool {
        self.pressed.unwrap_or(false)
    }

    pub fn clear_pressed(&mut self) {
        self.pressed = ::std::option::Option::None;
    }

    pub fn has_pressed(&self) -> bool {
        self.pressed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pressed(&mut self, v: bool) {
        self.pressed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pressed",
            |m: &CSetCapslockMsg| { &m.pressed },
            |m: &mut CSetCapslockMsg| { &mut m.pressed },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetCapslockMsg>(
            "CSetCapslockMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetCapslockMsg {
    const NAME: &'static str = "CSetCapslockMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pressed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pressed {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.pressed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetCapslockMsg {
        CSetCapslockMsg::new()
    }

    fn clear(&mut self) {
        self.pressed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetCapslockMsg {
        static instance: CSetCapslockMsg = CSetCapslockMsg {
            pressed: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetCapslockMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetCapslockMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetCapslockMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetCapslockMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamingKeymapEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingKeymapEntry {
    // message fields
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.scancode)
    pub scancode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.normal_keycode)
    pub normal_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.shift_keycode)
    pub shift_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.capslock_keycode)
    pub capslock_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.shift_capslock_keycode)
    pub shift_capslock_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.altgr_keycode)
    pub altgr_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.altgr_shift_keycode)
    pub altgr_shift_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.altgr_capslock_keycode)
    pub altgr_capslock_keycode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CStreamingKeymapEntry.altgr_shift_capslock_keycode)
    pub altgr_shift_capslock_keycode: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingKeymapEntry.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingKeymapEntry {
    fn default() -> &'a CStreamingKeymapEntry {
        <CStreamingKeymapEntry as crate::Message>::default_instance()
    }
}

impl CStreamingKeymapEntry {
    pub fn new() -> CStreamingKeymapEntry {
        ::std::default::Default::default()
    }

    // optional int32 scancode = 1;

    pub fn scancode(&self) -> i32 {
        self.scancode.unwrap_or(0)
    }

    pub fn clear_scancode(&mut self) {
        self.scancode = ::std::option::Option::None;
    }

    pub fn has_scancode(&self) -> bool {
        self.scancode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scancode(&mut self, v: i32) {
        self.scancode = ::std::option::Option::Some(v);
    }

    // optional int32 normal_keycode = 2;

    pub fn normal_keycode(&self) -> i32 {
        self.normal_keycode.unwrap_or(0)
    }

    pub fn clear_normal_keycode(&mut self) {
        self.normal_keycode = ::std::option::Option::None;
    }

    pub fn has_normal_keycode(&self) -> bool {
        self.normal_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_keycode(&mut self, v: i32) {
        self.normal_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 shift_keycode = 3;

    pub fn shift_keycode(&self) -> i32 {
        self.shift_keycode.unwrap_or(0)
    }

    pub fn clear_shift_keycode(&mut self) {
        self.shift_keycode = ::std::option::Option::None;
    }

    pub fn has_shift_keycode(&self) -> bool {
        self.shift_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shift_keycode(&mut self, v: i32) {
        self.shift_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 capslock_keycode = 4;

    pub fn capslock_keycode(&self) -> i32 {
        self.capslock_keycode.unwrap_or(0)
    }

    pub fn clear_capslock_keycode(&mut self) {
        self.capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_capslock_keycode(&self) -> bool {
        self.capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capslock_keycode(&mut self, v: i32) {
        self.capslock_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 shift_capslock_keycode = 5;

    pub fn shift_capslock_keycode(&self) -> i32 {
        self.shift_capslock_keycode.unwrap_or(0)
    }

    pub fn clear_shift_capslock_keycode(&mut self) {
        self.shift_capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_shift_capslock_keycode(&self) -> bool {
        self.shift_capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shift_capslock_keycode(&mut self, v: i32) {
        self.shift_capslock_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_keycode = 6;

    pub fn altgr_keycode(&self) -> i32 {
        self.altgr_keycode.unwrap_or(0)
    }

    pub fn clear_altgr_keycode(&mut self) {
        self.altgr_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_keycode(&self) -> bool {
        self.altgr_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_keycode(&mut self, v: i32) {
        self.altgr_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_shift_keycode = 7;

    pub fn altgr_shift_keycode(&self) -> i32 {
        self.altgr_shift_keycode.unwrap_or(0)
    }

    pub fn clear_altgr_shift_keycode(&mut self) {
        self.altgr_shift_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_shift_keycode(&self) -> bool {
        self.altgr_shift_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_shift_keycode(&mut self, v: i32) {
        self.altgr_shift_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_capslock_keycode = 8;

    pub fn altgr_capslock_keycode(&self) -> i32 {
        self.altgr_capslock_keycode.unwrap_or(0)
    }

    pub fn clear_altgr_capslock_keycode(&mut self) {
        self.altgr_capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_capslock_keycode(&self) -> bool {
        self.altgr_capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_capslock_keycode(&mut self, v: i32) {
        self.altgr_capslock_keycode = ::std::option::Option::Some(v);
    }

    // optional int32 altgr_shift_capslock_keycode = 9;

    pub fn altgr_shift_capslock_keycode(&self) -> i32 {
        self.altgr_shift_capslock_keycode.unwrap_or(0)
    }

    pub fn clear_altgr_shift_capslock_keycode(&mut self) {
        self.altgr_shift_capslock_keycode = ::std::option::Option::None;
    }

    pub fn has_altgr_shift_capslock_keycode(&self) -> bool {
        self.altgr_shift_capslock_keycode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_altgr_shift_capslock_keycode(&mut self, v: i32) {
        self.altgr_shift_capslock_keycode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "scancode",
            |m: &CStreamingKeymapEntry| { &m.scancode },
            |m: &mut CStreamingKeymapEntry| { &mut m.scancode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "normal_keycode",
            |m: &CStreamingKeymapEntry| { &m.normal_keycode },
            |m: &mut CStreamingKeymapEntry| { &mut m.normal_keycode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "shift_keycode",
            |m: &CStreamingKeymapEntry| { &m.shift_keycode },
            |m: &mut CStreamingKeymapEntry| { &mut m.shift_keycode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "capslock_keycode",
            |m: &CStreamingKeymapEntry| { &m.capslock_keycode },
            |m: &mut CStreamingKeymapEntry| { &mut m.capslock_keycode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "shift_capslock_keycode",
            |m: &CStreamingKeymapEntry| { &m.shift_capslock_keycode },
            |m: &mut CStreamingKeymapEntry| { &mut m.shift_capslock_keycode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "altgr_keycode",
            |m: &CStreamingKeymapEntry| { &m.altgr_keycode },
            |m: &mut CStreamingKeymapEntry| { &mut m.altgr_keycode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "altgr_shift_keycode",
            |m: &CStreamingKeymapEntry| { &m.altgr_shift_keycode },
            |m: &mut CStreamingKeymapEntry| { &mut m.altgr_shift_keycode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "altgr_capslock_keycode",
            |m: &CStreamingKeymapEntry| { &m.altgr_capslock_keycode },
            |m: &mut CStreamingKeymapEntry| { &mut m.altgr_capslock_keycode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "altgr_shift_capslock_keycode",
            |m: &CStreamingKeymapEntry| { &m.altgr_shift_capslock_keycode },
            |m: &mut CStreamingKeymapEntry| { &mut m.altgr_shift_capslock_keycode },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamingKeymapEntry>(
            "CStreamingKeymapEntry",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamingKeymapEntry {
    const NAME: &'static str = "CStreamingKeymapEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.scancode = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.normal_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.shift_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.capslock_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.shift_capslock_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.altgr_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.altgr_shift_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.altgr_capslock_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.altgr_shift_capslock_keycode = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.scancode {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.normal_keycode {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.shift_keycode {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.capslock_keycode {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.shift_capslock_keycode {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.altgr_keycode {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.altgr_shift_keycode {
            my_size += crate::rt::int32_size(7, v);
        }
        if let Some(v) = self.altgr_capslock_keycode {
            my_size += crate::rt::int32_size(8, v);
        }
        if let Some(v) = self.altgr_shift_capslock_keycode {
            my_size += crate::rt::int32_size(9, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.scancode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.normal_keycode {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.shift_keycode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.capslock_keycode {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.shift_capslock_keycode {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.altgr_keycode {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.altgr_shift_keycode {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.altgr_capslock_keycode {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.altgr_shift_capslock_keycode {
            os.write_int32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingKeymapEntry {
        CStreamingKeymapEntry::new()
    }

    fn clear(&mut self) {
        self.scancode = ::std::option::Option::None;
        self.normal_keycode = ::std::option::Option::None;
        self.shift_keycode = ::std::option::Option::None;
        self.capslock_keycode = ::std::option::Option::None;
        self.shift_capslock_keycode = ::std::option::Option::None;
        self.altgr_keycode = ::std::option::Option::None;
        self.altgr_shift_keycode = ::std::option::Option::None;
        self.altgr_capslock_keycode = ::std::option::Option::None;
        self.altgr_shift_capslock_keycode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingKeymapEntry {
        static instance: CStreamingKeymapEntry = CStreamingKeymapEntry {
            scancode: ::std::option::Option::None,
            normal_keycode: ::std::option::Option::None,
            shift_keycode: ::std::option::Option::None,
            capslock_keycode: ::std::option::Option::None,
            shift_capslock_keycode: ::std::option::Option::None,
            altgr_keycode: ::std::option::Option::None,
            altgr_shift_keycode: ::std::option::Option::None,
            altgr_capslock_keycode: ::std::option::Option::None,
            altgr_shift_capslock_keycode: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamingKeymapEntry {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamingKeymapEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamingKeymapEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamingKeymapEntry {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamingKeymap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingKeymap {
    // message fields
    // @@protoc_insertion_point(field:CStreamingKeymap.entries)
    pub entries: ::std::vec::Vec<CStreamingKeymapEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingKeymap.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingKeymap {
    fn default() -> &'a CStreamingKeymap {
        <CStreamingKeymap as crate::Message>::default_instance()
    }
}

impl CStreamingKeymap {
    pub fn new() -> CStreamingKeymap {
        ::std::default::Default::default()
    }

    // repeated .CStreamingKeymapEntry entries = 1;

    pub fn entries(&self) -> &[CStreamingKeymapEntry] {
        &self.entries
    }

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::vec::Vec<CStreamingKeymapEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::vec::Vec<CStreamingKeymapEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::vec::Vec<CStreamingKeymapEntry> {
        ::std::mem::replace(&mut self.entries, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CStreamingKeymap| { &m.entries },
            |m: &mut CStreamingKeymap| { &mut m.entries },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamingKeymap>(
            "CStreamingKeymap",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamingKeymap {
    const NAME: &'static str = "CStreamingKeymap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.entries {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingKeymap {
        CStreamingKeymap::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingKeymap {
        static instance: CStreamingKeymap = CStreamingKeymap {
            entries: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamingKeymap {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamingKeymap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamingKeymap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamingKeymap {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetKeymapMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetKeymapMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetKeymapMsg.keymap)
    pub keymap: crate::MessageField<CStreamingKeymap>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetKeymapMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetKeymapMsg {
    fn default() -> &'a CSetKeymapMsg {
        <CSetKeymapMsg as crate::Message>::default_instance()
    }
}

impl CSetKeymapMsg {
    pub fn new() -> CSetKeymapMsg {
        ::std::default::Default::default()
    }

    // optional .CStreamingKeymap keymap = 1;

    pub fn keymap(&self) -> &CStreamingKeymap {
        self.keymap.as_ref().unwrap_or_else(|| <CStreamingKeymap as crate::Message>::default_instance())
    }

    pub fn clear_keymap(&mut self) {
        self.keymap.clear();
    }

    pub fn has_keymap(&self) -> bool {
        self.keymap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keymap(&mut self, v: CStreamingKeymap) {
        self.keymap = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keymap(&mut self) -> &mut CStreamingKeymap {
        self.keymap.mut_or_insert_default()
    }

    // Take field
    pub fn take_keymap(&mut self) -> CStreamingKeymap {
        self.keymap.take().unwrap_or_else(|| CStreamingKeymap::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamingKeymap>(
            "keymap",
            |m: &CSetKeymapMsg| { &m.keymap },
            |m: &mut CSetKeymapMsg| { &mut m.keymap },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetKeymapMsg>(
            "CSetKeymapMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetKeymapMsg {
    const NAME: &'static str = "CSetKeymapMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.keymap)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keymap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.keymap.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetKeymapMsg {
        CSetKeymapMsg::new()
    }

    fn clear(&mut self) {
        self.keymap.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetKeymapMsg {
        static instance: CSetKeymapMsg = CSetKeymapMsg {
            keymap: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetKeymapMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetKeymapMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetKeymapMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetKeymapMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStopRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStopRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CStopRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStopRequest {
    fn default() -> &'a CStopRequest {
        <CStopRequest as crate::Message>::default_instance()
    }
}

impl CStopRequest {
    pub fn new() -> CStopRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStopRequest>(
            "CStopRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStopRequest {
    const NAME: &'static str = "CStopRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStopRequest {
        CStopRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStopRequest {
        static instance: CStopRequest = CStopRequest {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStopRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStopRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStopRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStopRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CQuitRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CQuitRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CQuitRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CQuitRequest {
    fn default() -> &'a CQuitRequest {
        <CQuitRequest as crate::Message>::default_instance()
    }
}

impl CQuitRequest {
    pub fn new() -> CQuitRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CQuitRequest>(
            "CQuitRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CQuitRequest {
    const NAME: &'static str = "CQuitRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CQuitRequest {
        CQuitRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CQuitRequest {
        static instance: CQuitRequest = CQuitRequest {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CQuitRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CQuitRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CQuitRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CQuitRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDeleteCursorMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDeleteCursorMsg {
    // message fields
    // @@protoc_insertion_point(field:CDeleteCursorMsg.cursor_id)
    pub cursor_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CDeleteCursorMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDeleteCursorMsg {
    fn default() -> &'a CDeleteCursorMsg {
        <CDeleteCursorMsg as crate::Message>::default_instance()
    }
}

impl CDeleteCursorMsg {
    pub fn new() -> CDeleteCursorMsg {
        ::std::default::Default::default()
    }

    // required uint64 cursor_id = 1;

    pub fn cursor_id(&self) -> u64 {
        self.cursor_id.unwrap_or(0)
    }

    pub fn clear_cursor_id(&mut self) {
        self.cursor_id = ::std::option::Option::None;
    }

    pub fn has_cursor_id(&self) -> bool {
        self.cursor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cursor_id(&mut self, v: u64) {
        self.cursor_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cursor_id",
            |m: &CDeleteCursorMsg| { &m.cursor_id },
            |m: &mut CDeleteCursorMsg| { &mut m.cursor_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CDeleteCursorMsg>(
            "CDeleteCursorMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CDeleteCursorMsg {
    const NAME: &'static str = "CDeleteCursorMsg";

    fn is_initialized(&self) -> bool {
        if self.cursor_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cursor_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cursor_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cursor_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDeleteCursorMsg {
        CDeleteCursorMsg::new()
    }

    fn clear(&mut self) {
        self.cursor_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDeleteCursorMsg {
        static instance: CDeleteCursorMsg = CDeleteCursorMsg {
            cursor_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CDeleteCursorMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDeleteCursorMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDeleteCursorMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CDeleteCursorMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetStreamingClientConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetStreamingClientConfig {
    // message fields
    // @@protoc_insertion_point(field:CSetStreamingClientConfig.config)
    pub config: crate::MessageField<CStreamingClientConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetStreamingClientConfig.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetStreamingClientConfig {
    fn default() -> &'a CSetStreamingClientConfig {
        <CSetStreamingClientConfig as crate::Message>::default_instance()
    }
}

impl CSetStreamingClientConfig {
    pub fn new() -> CSetStreamingClientConfig {
        ::std::default::Default::default()
    }

    // required .CStreamingClientConfig config = 1;

    pub fn config(&self) -> &CStreamingClientConfig {
        self.config.as_ref().unwrap_or_else(|| <CStreamingClientConfig as crate::Message>::default_instance())
    }

    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: CStreamingClientConfig) {
        self.config = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut CStreamingClientConfig {
        self.config.mut_or_insert_default()
    }

    // Take field
    pub fn take_config(&mut self) -> CStreamingClientConfig {
        self.config.take().unwrap_or_else(|| CStreamingClientConfig::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CStreamingClientConfig>(
            "config",
            |m: &CSetStreamingClientConfig| { &m.config },
            |m: &mut CSetStreamingClientConfig| { &mut m.config },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetStreamingClientConfig>(
            "CSetStreamingClientConfig",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetStreamingClientConfig {
    const NAME: &'static str = "CSetStreamingClientConfig";

    fn is_initialized(&self) -> bool {
        if self.config.is_none() {
            return false;
        }
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.config.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetStreamingClientConfig {
        CSetStreamingClientConfig::new()
    }

    fn clear(&mut self) {
        self.config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetStreamingClientConfig {
        static instance: CSetStreamingClientConfig = CSetStreamingClientConfig {
            config: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetStreamingClientConfig {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetStreamingClientConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetStreamingClientConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetStreamingClientConfig {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetQoSMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetQoSMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetQoSMsg.use_qos)
    pub use_qos: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetQoSMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetQoSMsg {
    fn default() -> &'a CSetQoSMsg {
        <CSetQoSMsg as crate::Message>::default_instance()
    }
}

impl CSetQoSMsg {
    pub fn new() -> CSetQoSMsg {
        ::std::default::Default::default()
    }

    // required bool use_qos = 1;

    pub fn use_qos(&self) -> bool {
        self.use_qos.unwrap_or(false)
    }

    pub fn clear_use_qos(&mut self) {
        self.use_qos = ::std::option::Option::None;
    }

    pub fn has_use_qos(&self) -> bool {
        self.use_qos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_qos(&mut self, v: bool) {
        self.use_qos = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_qos",
            |m: &CSetQoSMsg| { &m.use_qos },
            |m: &mut CSetQoSMsg| { &mut m.use_qos },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetQoSMsg>(
            "CSetQoSMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetQoSMsg {
    const NAME: &'static str = "CSetQoSMsg";

    fn is_initialized(&self) -> bool {
        if self.use_qos.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.use_qos = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.use_qos {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.use_qos {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetQoSMsg {
        CSetQoSMsg::new()
    }

    fn clear(&mut self) {
        self.use_qos = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetQoSMsg {
        static instance: CSetQoSMsg = CSetQoSMsg {
            use_qos: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetQoSMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetQoSMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetQoSMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetQoSMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetTargetFramerateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTargetFramerateMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTargetFramerateMsg.framerate)
    pub framerate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTargetFramerateMsg.reasons)
    pub reasons: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTargetFramerateMsg.framerate_numerator)
    pub framerate_numerator: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTargetFramerateMsg.framerate_denominator)
    pub framerate_denominator: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTargetFramerateMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTargetFramerateMsg {
    fn default() -> &'a CSetTargetFramerateMsg {
        <CSetTargetFramerateMsg as crate::Message>::default_instance()
    }
}

impl CSetTargetFramerateMsg {
    pub fn new() -> CSetTargetFramerateMsg {
        ::std::default::Default::default()
    }

    // required uint32 framerate = 1;

    pub fn framerate(&self) -> u32 {
        self.framerate.unwrap_or(0)
    }

    pub fn clear_framerate(&mut self) {
        self.framerate = ::std::option::Option::None;
    }

    pub fn has_framerate(&self) -> bool {
        self.framerate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate(&mut self, v: u32) {
        self.framerate = ::std::option::Option::Some(v);
    }

    // optional uint32 reasons = 2;

    pub fn reasons(&self) -> u32 {
        self.reasons.unwrap_or(0)
    }

    pub fn clear_reasons(&mut self) {
        self.reasons = ::std::option::Option::None;
    }

    pub fn has_reasons(&self) -> bool {
        self.reasons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reasons(&mut self, v: u32) {
        self.reasons = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate_numerator = 3;

    pub fn framerate_numerator(&self) -> u32 {
        self.framerate_numerator.unwrap_or(0)
    }

    pub fn clear_framerate_numerator(&mut self) {
        self.framerate_numerator = ::std::option::Option::None;
    }

    pub fn has_framerate_numerator(&self) -> bool {
        self.framerate_numerator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_numerator(&mut self, v: u32) {
        self.framerate_numerator = ::std::option::Option::Some(v);
    }

    // optional uint32 framerate_denominator = 4;

    pub fn framerate_denominator(&self) -> u32 {
        self.framerate_denominator.unwrap_or(0)
    }

    pub fn clear_framerate_denominator(&mut self) {
        self.framerate_denominator = ::std::option::Option::None;
    }

    pub fn has_framerate_denominator(&self) -> bool {
        self.framerate_denominator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_framerate_denominator(&mut self, v: u32) {
        self.framerate_denominator = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "framerate",
            |m: &CSetTargetFramerateMsg| { &m.framerate },
            |m: &mut CSetTargetFramerateMsg| { &mut m.framerate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reasons",
            |m: &CSetTargetFramerateMsg| { &m.reasons },
            |m: &mut CSetTargetFramerateMsg| { &mut m.reasons },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "framerate_numerator",
            |m: &CSetTargetFramerateMsg| { &m.framerate_numerator },
            |m: &mut CSetTargetFramerateMsg| { &mut m.framerate_numerator },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "framerate_denominator",
            |m: &CSetTargetFramerateMsg| { &m.framerate_denominator },
            |m: &mut CSetTargetFramerateMsg| { &mut m.framerate_denominator },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetTargetFramerateMsg>(
            "CSetTargetFramerateMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetTargetFramerateMsg {
    const NAME: &'static str = "CSetTargetFramerateMsg";

    fn is_initialized(&self) -> bool {
        if self.framerate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.framerate = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reasons = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.framerate_numerator = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.framerate_denominator = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.framerate {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reasons {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.framerate_numerator {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.framerate_denominator {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.framerate {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reasons {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.framerate_numerator {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.framerate_denominator {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTargetFramerateMsg {
        CSetTargetFramerateMsg::new()
    }

    fn clear(&mut self) {
        self.framerate = ::std::option::Option::None;
        self.reasons = ::std::option::Option::None;
        self.framerate_numerator = ::std::option::Option::None;
        self.framerate_denominator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTargetFramerateMsg {
        static instance: CSetTargetFramerateMsg = CSetTargetFramerateMsg {
            framerate: ::std::option::Option::None,
            reasons: ::std::option::Option::None,
            framerate_numerator: ::std::option::Option::None,
            framerate_denominator: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetTargetFramerateMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetTargetFramerateMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetTargetFramerateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetTargetFramerateMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetTargetBitrateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTargetBitrateMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTargetBitrateMsg.bitrate)
    pub bitrate: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTargetBitrateMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTargetBitrateMsg {
    fn default() -> &'a CSetTargetBitrateMsg {
        <CSetTargetBitrateMsg as crate::Message>::default_instance()
    }
}

impl CSetTargetBitrateMsg {
    pub fn new() -> CSetTargetBitrateMsg {
        ::std::default::Default::default()
    }

    // required int32 bitrate = 1;

    pub fn bitrate(&self) -> i32 {
        self.bitrate.unwrap_or(0)
    }

    pub fn clear_bitrate(&mut self) {
        self.bitrate = ::std::option::Option::None;
    }

    pub fn has_bitrate(&self) -> bool {
        self.bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bitrate(&mut self, v: i32) {
        self.bitrate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bitrate",
            |m: &CSetTargetBitrateMsg| { &m.bitrate },
            |m: &mut CSetTargetBitrateMsg| { &mut m.bitrate },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetTargetBitrateMsg>(
            "CSetTargetBitrateMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetTargetBitrateMsg {
    const NAME: &'static str = "CSetTargetBitrateMsg";

    fn is_initialized(&self) -> bool {
        if self.bitrate.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bitrate = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bitrate {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.bitrate {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTargetBitrateMsg {
        CSetTargetBitrateMsg::new()
    }

    fn clear(&mut self) {
        self.bitrate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTargetBitrateMsg {
        static instance: CSetTargetBitrateMsg = CSetTargetBitrateMsg {
            bitrate: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetTargetBitrateMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetTargetBitrateMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetTargetBitrateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetTargetBitrateMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:COverlayEnabledMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct COverlayEnabledMsg {
    // message fields
    // @@protoc_insertion_point(field:COverlayEnabledMsg.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:COverlayEnabledMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a COverlayEnabledMsg {
    fn default() -> &'a COverlayEnabledMsg {
        <COverlayEnabledMsg as crate::Message>::default_instance()
    }
}

impl COverlayEnabledMsg {
    pub fn new() -> COverlayEnabledMsg {
        ::std::default::Default::default()
    }

    // required bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled",
            |m: &COverlayEnabledMsg| { &m.enabled },
            |m: &mut COverlayEnabledMsg| { &mut m.enabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<COverlayEnabledMsg>(
            "COverlayEnabledMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for COverlayEnabledMsg {
    const NAME: &'static str = "COverlayEnabledMsg";

    fn is_initialized(&self) -> bool {
        if self.enabled.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> COverlayEnabledMsg {
        COverlayEnabledMsg::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static COverlayEnabledMsg {
        static instance: COverlayEnabledMsg = COverlayEnabledMsg {
            enabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for COverlayEnabledMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("COverlayEnabledMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for COverlayEnabledMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for COverlayEnabledMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetGammaRampMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetGammaRampMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetGammaRampMsg.gamma_ramp)
    pub gamma_ramp: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetGammaRampMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetGammaRampMsg {
    fn default() -> &'a CSetGammaRampMsg {
        <CSetGammaRampMsg as crate::Message>::default_instance()
    }
}

impl CSetGammaRampMsg {
    pub fn new() -> CSetGammaRampMsg {
        ::std::default::Default::default()
    }

    // optional bytes gamma_ramp = 1;

    pub fn gamma_ramp(&self) -> &[u8] {
        match self.gamma_ramp.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_gamma_ramp(&mut self) {
        self.gamma_ramp = ::std::option::Option::None;
    }

    pub fn has_gamma_ramp(&self) -> bool {
        self.gamma_ramp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamma_ramp(&mut self, v: ::bytes::Bytes) {
        self.gamma_ramp = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gamma_ramp(&mut self) -> &mut ::bytes::Bytes {
        if self.gamma_ramp.is_none() {
            self.gamma_ramp = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.gamma_ramp.as_mut().unwrap()
    }

    // Take field
    pub fn take_gamma_ramp(&mut self) -> ::bytes::Bytes {
        self.gamma_ramp.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamma_ramp",
            |m: &CSetGammaRampMsg| { &m.gamma_ramp },
            |m: &mut CSetGammaRampMsg| { &mut m.gamma_ramp },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetGammaRampMsg>(
            "CSetGammaRampMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetGammaRampMsg {
    const NAME: &'static str = "CSetGammaRampMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gamma_ramp = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gamma_ramp.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.gamma_ramp.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetGammaRampMsg {
        CSetGammaRampMsg::new()
    }

    fn clear(&mut self) {
        self.gamma_ramp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetGammaRampMsg {
        static instance: CSetGammaRampMsg = CSetGammaRampMsg {
            gamma_ramp: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetGammaRampMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetGammaRampMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetGammaRampMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetGammaRampMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetActivityMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetActivityMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetActivityMsg.activity)
    pub activity: ::std::option::Option<crate::EnumOrUnknown<EStreamActivity>>,
    // @@protoc_insertion_point(field:CSetActivityMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetActivityMsg.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSetActivityMsg.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetActivityMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetActivityMsg {
    fn default() -> &'a CSetActivityMsg {
        <CSetActivityMsg as crate::Message>::default_instance()
    }
}

impl CSetActivityMsg {
    pub fn new() -> CSetActivityMsg {
        ::std::default::Default::default()
    }

    // optional .EStreamActivity activity = 1;

    pub fn activity(&self) -> EStreamActivity {
        match self.activity {
            Some(e) => e.enum_value_or(EStreamActivity::k_EStreamActivityIdle),
            None => EStreamActivity::k_EStreamActivityIdle,
        }
    }

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: EStreamActivity) {
        self.activity = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 gameid = 3;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional string game_name = 4;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "activity",
            |m: &CSetActivityMsg| { &m.activity },
            |m: &mut CSetActivityMsg| { &mut m.activity },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSetActivityMsg| { &m.appid },
            |m: &mut CSetActivityMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CSetActivityMsg| { &m.gameid },
            |m: &mut CSetActivityMsg| { &mut m.gameid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_name",
            |m: &CSetActivityMsg| { &m.game_name },
            |m: &mut CSetActivityMsg| { &mut m.game_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetActivityMsg>(
            "CSetActivityMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetActivityMsg {
    const NAME: &'static str = "CSetActivityMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.activity = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.gameid {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.activity {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetActivityMsg {
        CSetActivityMsg::new()
    }

    fn clear(&mut self) {
        self.activity = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetActivityMsg {
        static instance: CSetActivityMsg = CSetActivityMsg {
            activity: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            gameid: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetActivityMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetActivityMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetActivityMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetActivityMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSystemSuspendMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSystemSuspendMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CSystemSuspendMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSystemSuspendMsg {
    fn default() -> &'a CSystemSuspendMsg {
        <CSystemSuspendMsg as crate::Message>::default_instance()
    }
}

impl CSystemSuspendMsg {
    pub fn new() -> CSystemSuspendMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSystemSuspendMsg>(
            "CSystemSuspendMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSystemSuspendMsg {
    const NAME: &'static str = "CSystemSuspendMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSystemSuspendMsg {
        CSystemSuspendMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSystemSuspendMsg {
        static instance: CSystemSuspendMsg = CSystemSuspendMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSystemSuspendMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSystemSuspendMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSystemSuspendMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSystemSuspendMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CVirtualHereRequestMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVirtualHereRequestMsg {
    // message fields
    // @@protoc_insertion_point(field:CVirtualHereRequestMsg.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CVirtualHereRequestMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVirtualHereRequestMsg {
    fn default() -> &'a CVirtualHereRequestMsg {
        <CVirtualHereRequestMsg as crate::Message>::default_instance()
    }
}

impl CVirtualHereRequestMsg {
    pub fn new() -> CVirtualHereRequestMsg {
        ::std::default::Default::default()
    }

    // optional string hostname = 1;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &CVirtualHereRequestMsg| { &m.hostname },
            |m: &mut CVirtualHereRequestMsg| { &mut m.hostname },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CVirtualHereRequestMsg>(
            "CVirtualHereRequestMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CVirtualHereRequestMsg {
    const NAME: &'static str = "CVirtualHereRequestMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hostname.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVirtualHereRequestMsg {
        CVirtualHereRequestMsg::new()
    }

    fn clear(&mut self) {
        self.hostname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVirtualHereRequestMsg {
        static instance: CVirtualHereRequestMsg = CVirtualHereRequestMsg {
            hostname: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CVirtualHereRequestMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CVirtualHereRequestMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CVirtualHereRequestMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CVirtualHereRequestMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CVirtualHereReadyMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVirtualHereReadyMsg {
    // message fields
    // @@protoc_insertion_point(field:CVirtualHereReadyMsg.licensed_device_count)
    pub licensed_device_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CVirtualHereReadyMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVirtualHereReadyMsg {
    fn default() -> &'a CVirtualHereReadyMsg {
        <CVirtualHereReadyMsg as crate::Message>::default_instance()
    }
}

impl CVirtualHereReadyMsg {
    pub fn new() -> CVirtualHereReadyMsg {
        ::std::default::Default::default()
    }

    // optional uint32 licensed_device_count = 1;

    pub fn licensed_device_count(&self) -> u32 {
        self.licensed_device_count.unwrap_or(0)
    }

    pub fn clear_licensed_device_count(&mut self) {
        self.licensed_device_count = ::std::option::Option::None;
    }

    pub fn has_licensed_device_count(&self) -> bool {
        self.licensed_device_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_licensed_device_count(&mut self, v: u32) {
        self.licensed_device_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "licensed_device_count",
            |m: &CVirtualHereReadyMsg| { &m.licensed_device_count },
            |m: &mut CVirtualHereReadyMsg| { &mut m.licensed_device_count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CVirtualHereReadyMsg>(
            "CVirtualHereReadyMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CVirtualHereReadyMsg {
    const NAME: &'static str = "CVirtualHereReadyMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.licensed_device_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.licensed_device_count {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.licensed_device_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVirtualHereReadyMsg {
        CVirtualHereReadyMsg::new()
    }

    fn clear(&mut self) {
        self.licensed_device_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVirtualHereReadyMsg {
        static instance: CVirtualHereReadyMsg = CVirtualHereReadyMsg {
            licensed_device_count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CVirtualHereReadyMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CVirtualHereReadyMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CVirtualHereReadyMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CVirtualHereReadyMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CVirtualHereShareDeviceMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVirtualHereShareDeviceMsg {
    // message fields
    // @@protoc_insertion_point(field:CVirtualHereShareDeviceMsg.device_address)
    pub device_address: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CVirtualHereShareDeviceMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVirtualHereShareDeviceMsg {
    fn default() -> &'a CVirtualHereShareDeviceMsg {
        <CVirtualHereShareDeviceMsg as crate::Message>::default_instance()
    }
}

impl CVirtualHereShareDeviceMsg {
    pub fn new() -> CVirtualHereShareDeviceMsg {
        ::std::default::Default::default()
    }

    // optional string device_address = 1;

    pub fn device_address(&self) -> &str {
        match self.device_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_address(&mut self) {
        self.device_address = ::std::option::Option::None;
    }

    pub fn has_device_address(&self) -> bool {
        self.device_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_address(&mut self, v: ::std::string::String) {
        self.device_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_address(&mut self) -> &mut ::std::string::String {
        if self.device_address.is_none() {
            self.device_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_address(&mut self) -> ::std::string::String {
        self.device_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_address",
            |m: &CVirtualHereShareDeviceMsg| { &m.device_address },
            |m: &mut CVirtualHereShareDeviceMsg| { &mut m.device_address },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CVirtualHereShareDeviceMsg>(
            "CVirtualHereShareDeviceMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CVirtualHereShareDeviceMsg {
    const NAME: &'static str = "CVirtualHereShareDeviceMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_address = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_address.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.device_address.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVirtualHereShareDeviceMsg {
        CVirtualHereShareDeviceMsg::new()
    }

    fn clear(&mut self) {
        self.device_address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVirtualHereShareDeviceMsg {
        static instance: CVirtualHereShareDeviceMsg = CVirtualHereShareDeviceMsg {
            device_address: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CVirtualHereShareDeviceMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CVirtualHereShareDeviceMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CVirtualHereShareDeviceMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CVirtualHereShareDeviceMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetSpectatorModeMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetSpectatorModeMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetSpectatorModeMsg.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetSpectatorModeMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetSpectatorModeMsg {
    fn default() -> &'a CSetSpectatorModeMsg {
        <CSetSpectatorModeMsg as crate::Message>::default_instance()
    }
}

impl CSetSpectatorModeMsg {
    pub fn new() -> CSetSpectatorModeMsg {
        ::std::default::Default::default()
    }

    // optional bool enabled = 1;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled",
            |m: &CSetSpectatorModeMsg| { &m.enabled },
            |m: &mut CSetSpectatorModeMsg| { &mut m.enabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetSpectatorModeMsg>(
            "CSetSpectatorModeMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetSpectatorModeMsg {
    const NAME: &'static str = "CSetSpectatorModeMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.enabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetSpectatorModeMsg {
        CSetSpectatorModeMsg::new()
    }

    fn clear(&mut self) {
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetSpectatorModeMsg {
        static instance: CSetSpectatorModeMsg = CSetSpectatorModeMsg {
            enabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetSpectatorModeMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetSpectatorModeMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetSpectatorModeMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetSpectatorModeMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CRemoteHIDMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRemoteHIDMsg {
    // message fields
    // @@protoc_insertion_point(field:CRemoteHIDMsg.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CRemoteHIDMsg.active_input)
    pub active_input: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CRemoteHIDMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRemoteHIDMsg {
    fn default() -> &'a CRemoteHIDMsg {
        <CRemoteHIDMsg as crate::Message>::default_instance()
    }
}

impl CRemoteHIDMsg {
    pub fn new() -> CRemoteHIDMsg {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool active_input = 2;

    pub fn active_input(&self) -> bool {
        self.active_input.unwrap_or(false)
    }

    pub fn clear_active_input(&mut self) {
        self.active_input = ::std::option::Option::None;
    }

    pub fn has_active_input(&self) -> bool {
        self.active_input.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_input(&mut self, v: bool) {
        self.active_input = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CRemoteHIDMsg| { &m.data },
            |m: &mut CRemoteHIDMsg| { &mut m.data },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_input",
            |m: &CRemoteHIDMsg| { &m.active_input },
            |m: &mut CRemoteHIDMsg| { &mut m.active_input },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CRemoteHIDMsg>(
            "CRemoteHIDMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CRemoteHIDMsg {
    const NAME: &'static str = "CRemoteHIDMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                16 => {
                    self.active_input = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.active_input {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.active_input {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRemoteHIDMsg {
        CRemoteHIDMsg::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.active_input = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRemoteHIDMsg {
        static instance: CRemoteHIDMsg = CRemoteHIDMsg {
            data: ::std::option::Option::None,
            active_input: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CRemoteHIDMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CRemoteHIDMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CRemoteHIDMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CRemoteHIDMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTouchConfigActiveMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTouchConfigActiveMsg {
    // message fields
    // @@protoc_insertion_point(field:CTouchConfigActiveMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchConfigActiveMsg.revision)
    pub revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchConfigActiveMsg.creator)
    pub creator: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CTouchConfigActiveMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTouchConfigActiveMsg {
    fn default() -> &'a CTouchConfigActiveMsg {
        <CTouchConfigActiveMsg as crate::Message>::default_instance()
    }
}

impl CTouchConfigActiveMsg {
    pub fn new() -> CTouchConfigActiveMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 2;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional uint64 creator = 3;

    pub fn creator(&self) -> u64 {
        self.creator.unwrap_or(0)
    }

    pub fn clear_creator(&mut self) {
        self.creator = ::std::option::Option::None;
    }

    pub fn has_creator(&self) -> bool {
        self.creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: u64) {
        self.creator = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CTouchConfigActiveMsg| { &m.appid },
            |m: &mut CTouchConfigActiveMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &CTouchConfigActiveMsg| { &m.revision },
            |m: &mut CTouchConfigActiveMsg| { &mut m.revision },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "creator",
            |m: &CTouchConfigActiveMsg| { &m.creator },
            |m: &mut CTouchConfigActiveMsg| { &mut m.creator },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CTouchConfigActiveMsg>(
            "CTouchConfigActiveMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CTouchConfigActiveMsg {
    const NAME: &'static str = "CTouchConfigActiveMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.creator = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.revision {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.creator {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.creator {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTouchConfigActiveMsg {
        CTouchConfigActiveMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.creator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTouchConfigActiveMsg {
        static instance: CTouchConfigActiveMsg = CTouchConfigActiveMsg {
            appid: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            creator: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CTouchConfigActiveMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTouchConfigActiveMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTouchConfigActiveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CTouchConfigActiveMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGetTouchConfigDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGetTouchConfigDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CGetTouchConfigDataMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGetTouchConfigDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGetTouchConfigDataMsg {
    fn default() -> &'a CGetTouchConfigDataMsg {
        <CGetTouchConfigDataMsg as crate::Message>::default_instance()
    }
}

impl CGetTouchConfigDataMsg {
    pub fn new() -> CGetTouchConfigDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CGetTouchConfigDataMsg| { &m.appid },
            |m: &mut CGetTouchConfigDataMsg| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CGetTouchConfigDataMsg>(
            "CGetTouchConfigDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CGetTouchConfigDataMsg {
    const NAME: &'static str = "CGetTouchConfigDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGetTouchConfigDataMsg {
        CGetTouchConfigDataMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGetTouchConfigDataMsg {
        static instance: CGetTouchConfigDataMsg = CGetTouchConfigDataMsg {
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CGetTouchConfigDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGetTouchConfigDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGetTouchConfigDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CGetTouchConfigDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetTouchConfigDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTouchConfigDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.revision)
    pub revision: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.layout)
    pub layout: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSetTouchConfigDataMsg.creator)
    pub creator: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTouchConfigDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTouchConfigDataMsg {
    fn default() -> &'a CSetTouchConfigDataMsg {
        <CSetTouchConfigDataMsg as crate::Message>::default_instance()
    }
}

impl CSetTouchConfigDataMsg {
    pub fn new() -> CSetTouchConfigDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 revision = 2;

    pub fn revision(&self) -> u32 {
        self.revision.unwrap_or(0)
    }

    pub fn clear_revision(&mut self) {
        self.revision = ::std::option::Option::None;
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: u32) {
        self.revision = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes layout = 4;

    pub fn layout(&self) -> &[u8] {
        match self.layout.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_layout(&mut self) {
        self.layout = ::std::option::Option::None;
    }

    pub fn has_layout(&self) -> bool {
        self.layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: ::bytes::Bytes) {
        self.layout = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout(&mut self) -> &mut ::bytes::Bytes {
        if self.layout.is_none() {
            self.layout = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout(&mut self) -> ::bytes::Bytes {
        self.layout.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint64 creator = 5;

    pub fn creator(&self) -> u64 {
        self.creator.unwrap_or(0)
    }

    pub fn clear_creator(&mut self) {
        self.creator = ::std::option::Option::None;
    }

    pub fn has_creator(&self) -> bool {
        self.creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator(&mut self, v: u64) {
        self.creator = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSetTouchConfigDataMsg| { &m.appid },
            |m: &mut CSetTouchConfigDataMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "revision",
            |m: &CSetTouchConfigDataMsg| { &m.revision },
            |m: &mut CSetTouchConfigDataMsg| { &mut m.revision },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CSetTouchConfigDataMsg| { &m.data },
            |m: &mut CSetTouchConfigDataMsg| { &mut m.data },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "layout",
            |m: &CSetTouchConfigDataMsg| { &m.layout },
            |m: &mut CSetTouchConfigDataMsg| { &mut m.layout },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "creator",
            |m: &CSetTouchConfigDataMsg| { &m.creator },
            |m: &mut CSetTouchConfigDataMsg| { &mut m.creator },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetTouchConfigDataMsg>(
            "CSetTouchConfigDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetTouchConfigDataMsg {
    const NAME: &'static str = "CSetTouchConfigDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.revision = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                34 => {
                    self.layout = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                40 => {
                    self.creator = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.revision {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.layout.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.creator {
            my_size += crate::rt::uint64_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.revision {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.layout.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.creator {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTouchConfigDataMsg {
        CSetTouchConfigDataMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.revision = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.layout = ::std::option::Option::None;
        self.creator = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTouchConfigDataMsg {
        static instance: CSetTouchConfigDataMsg = CSetTouchConfigDataMsg {
            appid: ::std::option::Option::None,
            revision: ::std::option::Option::None,
            data: ::std::option::Option::None,
            layout: ::std::option::Option::None,
            creator: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetTouchConfigDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetTouchConfigDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetTouchConfigDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetTouchConfigDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSaveTouchConfigLayoutMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSaveTouchConfigLayoutMsg {
    // message fields
    // @@protoc_insertion_point(field:CSaveTouchConfigLayoutMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSaveTouchConfigLayoutMsg.layout)
    pub layout: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSaveTouchConfigLayoutMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSaveTouchConfigLayoutMsg {
    fn default() -> &'a CSaveTouchConfigLayoutMsg {
        <CSaveTouchConfigLayoutMsg as crate::Message>::default_instance()
    }
}

impl CSaveTouchConfigLayoutMsg {
    pub fn new() -> CSaveTouchConfigLayoutMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional bytes layout = 4;

    pub fn layout(&self) -> &[u8] {
        match self.layout.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_layout(&mut self) {
        self.layout = ::std::option::Option::None;
    }

    pub fn has_layout(&self) -> bool {
        self.layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: ::bytes::Bytes) {
        self.layout = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout(&mut self) -> &mut ::bytes::Bytes {
        if self.layout.is_none() {
            self.layout = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout(&mut self) -> ::bytes::Bytes {
        self.layout.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSaveTouchConfigLayoutMsg| { &m.appid },
            |m: &mut CSaveTouchConfigLayoutMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "layout",
            |m: &CSaveTouchConfigLayoutMsg| { &m.layout },
            |m: &mut CSaveTouchConfigLayoutMsg| { &mut m.layout },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSaveTouchConfigLayoutMsg>(
            "CSaveTouchConfigLayoutMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSaveTouchConfigLayoutMsg {
    const NAME: &'static str = "CSaveTouchConfigLayoutMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.layout = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.layout.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.layout.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSaveTouchConfigLayoutMsg {
        CSaveTouchConfigLayoutMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.layout = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSaveTouchConfigLayoutMsg {
        static instance: CSaveTouchConfigLayoutMsg = CSaveTouchConfigLayoutMsg {
            appid: ::std::option::Option::None,
            layout: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSaveTouchConfigLayoutMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSaveTouchConfigLayoutMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSaveTouchConfigLayoutMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSaveTouchConfigLayoutMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTouchActionSetActiveMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTouchActionSetActiveMsg {
    // message fields
    // @@protoc_insertion_point(field:CTouchActionSetActiveMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchActionSetActiveMsg.actionset_id)
    pub actionset_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CTouchActionSetActiveMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetActiveMsg {
    fn default() -> &'a CTouchActionSetActiveMsg {
        <CTouchActionSetActiveMsg as crate::Message>::default_instance()
    }
}

impl CTouchActionSetActiveMsg {
    pub fn new() -> CTouchActionSetActiveMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;

    pub fn actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }

    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CTouchActionSetActiveMsg| { &m.appid },
            |m: &mut CTouchActionSetActiveMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "actionset_id",
            |m: &CTouchActionSetActiveMsg| { &m.actionset_id },
            |m: &mut CTouchActionSetActiveMsg| { &mut m.actionset_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CTouchActionSetActiveMsg>(
            "CTouchActionSetActiveMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CTouchActionSetActiveMsg {
    const NAME: &'static str = "CTouchActionSetActiveMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.actionset_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.actionset_id {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTouchActionSetActiveMsg {
        CTouchActionSetActiveMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTouchActionSetActiveMsg {
        static instance: CTouchActionSetActiveMsg = CTouchActionSetActiveMsg {
            appid: ::std::option::Option::None,
            actionset_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CTouchActionSetActiveMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTouchActionSetActiveMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTouchActionSetActiveMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CTouchActionSetActiveMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTouchActionSetLayerAddedMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTouchActionSetLayerAddedMsg {
    // message fields
    // @@protoc_insertion_point(field:CTouchActionSetLayerAddedMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchActionSetLayerAddedMsg.actionset_id)
    pub actionset_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CTouchActionSetLayerAddedMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetLayerAddedMsg {
    fn default() -> &'a CTouchActionSetLayerAddedMsg {
        <CTouchActionSetLayerAddedMsg as crate::Message>::default_instance()
    }
}

impl CTouchActionSetLayerAddedMsg {
    pub fn new() -> CTouchActionSetLayerAddedMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;

    pub fn actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }

    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CTouchActionSetLayerAddedMsg| { &m.appid },
            |m: &mut CTouchActionSetLayerAddedMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "actionset_id",
            |m: &CTouchActionSetLayerAddedMsg| { &m.actionset_id },
            |m: &mut CTouchActionSetLayerAddedMsg| { &mut m.actionset_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CTouchActionSetLayerAddedMsg>(
            "CTouchActionSetLayerAddedMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CTouchActionSetLayerAddedMsg {
    const NAME: &'static str = "CTouchActionSetLayerAddedMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.actionset_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.actionset_id {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTouchActionSetLayerAddedMsg {
        CTouchActionSetLayerAddedMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTouchActionSetLayerAddedMsg {
        static instance: CTouchActionSetLayerAddedMsg = CTouchActionSetLayerAddedMsg {
            appid: ::std::option::Option::None,
            actionset_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CTouchActionSetLayerAddedMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTouchActionSetLayerAddedMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTouchActionSetLayerAddedMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CTouchActionSetLayerAddedMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTouchActionSetLayerRemovedMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTouchActionSetLayerRemovedMsg {
    // message fields
    // @@protoc_insertion_point(field:CTouchActionSetLayerRemovedMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTouchActionSetLayerRemovedMsg.actionset_id)
    pub actionset_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CTouchActionSetLayerRemovedMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTouchActionSetLayerRemovedMsg {
    fn default() -> &'a CTouchActionSetLayerRemovedMsg {
        <CTouchActionSetLayerRemovedMsg as crate::Message>::default_instance()
    }
}

impl CTouchActionSetLayerRemovedMsg {
    pub fn new() -> CTouchActionSetLayerRemovedMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional int32 actionset_id = 2;

    pub fn actionset_id(&self) -> i32 {
        self.actionset_id.unwrap_or(0)
    }

    pub fn clear_actionset_id(&mut self) {
        self.actionset_id = ::std::option::Option::None;
    }

    pub fn has_actionset_id(&self) -> bool {
        self.actionset_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionset_id(&mut self, v: i32) {
        self.actionset_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CTouchActionSetLayerRemovedMsg| { &m.appid },
            |m: &mut CTouchActionSetLayerRemovedMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "actionset_id",
            |m: &CTouchActionSetLayerRemovedMsg| { &m.actionset_id },
            |m: &mut CTouchActionSetLayerRemovedMsg| { &mut m.actionset_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CTouchActionSetLayerRemovedMsg>(
            "CTouchActionSetLayerRemovedMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CTouchActionSetLayerRemovedMsg {
    const NAME: &'static str = "CTouchActionSetLayerRemovedMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.actionset_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.actionset_id {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.actionset_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTouchActionSetLayerRemovedMsg {
        CTouchActionSetLayerRemovedMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.actionset_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTouchActionSetLayerRemovedMsg {
        static instance: CTouchActionSetLayerRemovedMsg = CTouchActionSetLayerRemovedMsg {
            appid: ::std::option::Option::None,
            actionset_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CTouchActionSetLayerRemovedMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTouchActionSetLayerRemovedMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTouchActionSetLayerRemovedMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CTouchActionSetLayerRemovedMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CGetTouchIconDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGetTouchIconDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CGetTouchIconDataMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGetTouchIconDataMsg.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGetTouchIconDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGetTouchIconDataMsg {
    fn default() -> &'a CGetTouchIconDataMsg {
        <CGetTouchIconDataMsg as crate::Message>::default_instance()
    }
}

impl CGetTouchIconDataMsg {
    pub fn new() -> CGetTouchIconDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CGetTouchIconDataMsg| { &m.appid },
            |m: &mut CGetTouchIconDataMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon",
            |m: &CGetTouchIconDataMsg| { &m.icon },
            |m: &mut CGetTouchIconDataMsg| { &mut m.icon },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CGetTouchIconDataMsg>(
            "CGetTouchIconDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CGetTouchIconDataMsg {
    const NAME: &'static str = "CGetTouchIconDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGetTouchIconDataMsg {
        CGetTouchIconDataMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGetTouchIconDataMsg {
        static instance: CGetTouchIconDataMsg = CGetTouchIconDataMsg {
            appid: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CGetTouchIconDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CGetTouchIconDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CGetTouchIconDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CGetTouchIconDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetTouchIconDataMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetTouchIconDataMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetTouchIconDataMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSetTouchIconDataMsg.icon)
    pub icon: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSetTouchIconDataMsg.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetTouchIconDataMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetTouchIconDataMsg {
    fn default() -> &'a CSetTouchIconDataMsg {
        <CSetTouchIconDataMsg as crate::Message>::default_instance()
    }
}

impl CSetTouchIconDataMsg {
    pub fn new() -> CSetTouchIconDataMsg {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string icon = 2;

    pub fn icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_icon(&mut self) {
        self.icon = ::std::option::Option::None;
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon = ::std::option::Option::Some(::std::string::String::new());
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSetTouchIconDataMsg| { &m.appid },
            |m: &mut CSetTouchIconDataMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "icon",
            |m: &CSetTouchIconDataMsg| { &m.icon },
            |m: &mut CSetTouchIconDataMsg| { &mut m.icon },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CSetTouchIconDataMsg| { &m.data },
            |m: &mut CSetTouchIconDataMsg| { &mut m.data },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetTouchIconDataMsg>(
            "CSetTouchIconDataMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetTouchIconDataMsg {
    const NAME: &'static str = "CSetTouchIconDataMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.icon = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.icon.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.icon.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetTouchIconDataMsg {
        CSetTouchIconDataMsg::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.icon = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetTouchIconDataMsg {
        static instance: CSetTouchIconDataMsg = CSetTouchIconDataMsg {
            appid: ::std::option::Option::None,
            icon: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetTouchIconDataMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetTouchIconDataMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetTouchIconDataMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetTouchIconDataMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CRemotePlayTogetherGroupUpdateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CRemotePlayTogetherGroupUpdateMsg {
    // message fields
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.players)
    pub players: ::std::vec::Vec<cremote_play_together_group_update_msg::Player>,
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.player_index)
    pub player_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.miniprofile_location)
    pub miniprofile_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.avatar_location)
    pub avatar_location: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CRemotePlayTogetherGroupUpdateMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CRemotePlayTogetherGroupUpdateMsg {
    fn default() -> &'a CRemotePlayTogetherGroupUpdateMsg {
        <CRemotePlayTogetherGroupUpdateMsg as crate::Message>::default_instance()
    }
}

impl CRemotePlayTogetherGroupUpdateMsg {
    pub fn new() -> CRemotePlayTogetherGroupUpdateMsg {
        ::std::default::Default::default()
    }

    // repeated .CRemotePlayTogetherGroupUpdateMsg.Player players = 1;

    pub fn players(&self) -> &[cremote_play_together_group_update_msg::Player] {
        &self.players
    }

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::std::vec::Vec<cremote_play_together_group_update_msg::Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players(&mut self) -> &mut ::std::vec::Vec<cremote_play_together_group_update_msg::Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::std::vec::Vec<cremote_play_together_group_update_msg::Player> {
        ::std::mem::replace(&mut self.players, ::std::vec::Vec::new())
    }

    // optional int32 player_index = 2;

    pub fn player_index(&self) -> i32 {
        self.player_index.unwrap_or(0)
    }

    pub fn clear_player_index(&mut self) {
        self.player_index = ::std::option::Option::None;
    }

    pub fn has_player_index(&self) -> bool {
        self.player_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_index(&mut self, v: i32) {
        self.player_index = ::std::option::Option::Some(v);
    }

    // optional string miniprofile_location = 3;

    pub fn miniprofile_location(&self) -> &str {
        match self.miniprofile_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_miniprofile_location(&mut self) {
        self.miniprofile_location = ::std::option::Option::None;
    }

    pub fn has_miniprofile_location(&self) -> bool {
        self.miniprofile_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_miniprofile_location(&mut self, v: ::std::string::String) {
        self.miniprofile_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_miniprofile_location(&mut self) -> &mut ::std::string::String {
        if self.miniprofile_location.is_none() {
            self.miniprofile_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.miniprofile_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_miniprofile_location(&mut self) -> ::std::string::String {
        self.miniprofile_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_name = 4;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string avatar_location = 5;

    pub fn avatar_location(&self) -> &str {
        match self.avatar_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_location(&mut self) {
        self.avatar_location = ::std::option::Option::None;
    }

    pub fn has_avatar_location(&self) -> bool {
        self.avatar_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_location(&mut self, v: ::std::string::String) {
        self.avatar_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_location(&mut self) -> &mut ::std::string::String {
        if self.avatar_location.is_none() {
            self.avatar_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_location(&mut self) -> ::std::string::String {
        self.avatar_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &CRemotePlayTogetherGroupUpdateMsg| { &m.players },
            |m: &mut CRemotePlayTogetherGroupUpdateMsg| { &mut m.players },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_index",
            |m: &CRemotePlayTogetherGroupUpdateMsg| { &m.player_index },
            |m: &mut CRemotePlayTogetherGroupUpdateMsg| { &mut m.player_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "miniprofile_location",
            |m: &CRemotePlayTogetherGroupUpdateMsg| { &m.miniprofile_location },
            |m: &mut CRemotePlayTogetherGroupUpdateMsg| { &mut m.miniprofile_location },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_name",
            |m: &CRemotePlayTogetherGroupUpdateMsg| { &m.game_name },
            |m: &mut CRemotePlayTogetherGroupUpdateMsg| { &mut m.game_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_location",
            |m: &CRemotePlayTogetherGroupUpdateMsg| { &m.avatar_location },
            |m: &mut CRemotePlayTogetherGroupUpdateMsg| { &mut m.avatar_location },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CRemotePlayTogetherGroupUpdateMsg>(
            "CRemotePlayTogetherGroupUpdateMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CRemotePlayTogetherGroupUpdateMsg {
    const NAME: &'static str = "CRemotePlayTogetherGroupUpdateMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.player_index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.miniprofile_location = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.avatar_location = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.player_index {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.miniprofile_location.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.avatar_location.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.players {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.player_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.miniprofile_location.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.avatar_location.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CRemotePlayTogetherGroupUpdateMsg {
        CRemotePlayTogetherGroupUpdateMsg::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.player_index = ::std::option::Option::None;
        self.miniprofile_location = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.avatar_location = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CRemotePlayTogetherGroupUpdateMsg {
        static instance: CRemotePlayTogetherGroupUpdateMsg = CRemotePlayTogetherGroupUpdateMsg {
            players: ::std::vec::Vec::new(),
            player_index: ::std::option::Option::None,
            miniprofile_location: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            avatar_location: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CRemotePlayTogetherGroupUpdateMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CRemotePlayTogetherGroupUpdateMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CRemotePlayTogetherGroupUpdateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CRemotePlayTogetherGroupUpdateMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CRemotePlayTogetherGroupUpdateMsg`
pub mod cremote_play_together_group_update_msg {
    // @@protoc_insertion_point(message:CRemotePlayTogetherGroupUpdateMsg.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.guestid)
        pub guestid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.keyboard_enabled)
        pub keyboard_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.mouse_enabled)
        pub mouse_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.controller_enabled)
        pub controller_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.controller_slots)
        pub controller_slots: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:CRemotePlayTogetherGroupUpdateMsg.Player.avatar_hash)
        pub avatar_hash: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CRemotePlayTogetherGroupUpdateMsg.Player.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as crate::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 guestid = 2;

        pub fn guestid(&self) -> u32 {
            self.guestid.unwrap_or(0)
        }

        pub fn clear_guestid(&mut self) {
            self.guestid = ::std::option::Option::None;
        }

        pub fn has_guestid(&self) -> bool {
            self.guestid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guestid(&mut self, v: u32) {
            self.guestid = ::std::option::Option::Some(v);
        }

        // optional bool keyboard_enabled = 3;

        pub fn keyboard_enabled(&self) -> bool {
            self.keyboard_enabled.unwrap_or(false)
        }

        pub fn clear_keyboard_enabled(&mut self) {
            self.keyboard_enabled = ::std::option::Option::None;
        }

        pub fn has_keyboard_enabled(&self) -> bool {
            self.keyboard_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_keyboard_enabled(&mut self, v: bool) {
            self.keyboard_enabled = ::std::option::Option::Some(v);
        }

        // optional bool mouse_enabled = 4;

        pub fn mouse_enabled(&self) -> bool {
            self.mouse_enabled.unwrap_or(false)
        }

        pub fn clear_mouse_enabled(&mut self) {
            self.mouse_enabled = ::std::option::Option::None;
        }

        pub fn has_mouse_enabled(&self) -> bool {
            self.mouse_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mouse_enabled(&mut self, v: bool) {
            self.mouse_enabled = ::std::option::Option::Some(v);
        }

        // optional bool controller_enabled = 5;

        pub fn controller_enabled(&self) -> bool {
            self.controller_enabled.unwrap_or(false)
        }

        pub fn clear_controller_enabled(&mut self) {
            self.controller_enabled = ::std::option::Option::None;
        }

        pub fn has_controller_enabled(&self) -> bool {
            self.controller_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_enabled(&mut self, v: bool) {
            self.controller_enabled = ::std::option::Option::Some(v);
        }

        // repeated uint32 controller_slots = 6;

        pub fn controller_slots(&self) -> &[u32] {
            &self.controller_slots
        }

        pub fn clear_controller_slots(&mut self) {
            self.controller_slots.clear();
        }

        // Param is passed by value, moved
        pub fn set_controller_slots(&mut self, v: ::std::vec::Vec<u32>) {
            self.controller_slots = v;
        }

        // Mutable pointer to the field.
        pub fn mut_controller_slots(&mut self) -> &mut ::std::vec::Vec<u32> {
            &mut self.controller_slots
        }

        // Take field
        pub fn take_controller_slots(&mut self) -> ::std::vec::Vec<u32> {
            ::std::mem::replace(&mut self.controller_slots, ::std::vec::Vec::new())
        }

        // optional bytes avatar_hash = 7;

        pub fn avatar_hash(&self) -> &[u8] {
            match self.avatar_hash.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_avatar_hash(&mut self) {
            self.avatar_hash = ::std::option::Option::None;
        }

        pub fn has_avatar_hash(&self) -> bool {
            self.avatar_hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avatar_hash(&mut self, v: ::bytes::Bytes) {
            self.avatar_hash = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_avatar_hash(&mut self) -> &mut ::bytes::Bytes {
            if self.avatar_hash.is_none() {
                self.avatar_hash = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.avatar_hash.as_mut().unwrap()
        }

        // Take field
        pub fn take_avatar_hash(&mut self) -> ::bytes::Bytes {
            self.avatar_hash.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &Player| { &m.accountid },
                |m: &mut Player| { &mut m.accountid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "guestid",
                |m: &Player| { &m.guestid },
                |m: &mut Player| { &mut m.guestid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "keyboard_enabled",
                |m: &Player| { &m.keyboard_enabled },
                |m: &mut Player| { &mut m.keyboard_enabled },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "mouse_enabled",
                |m: &Player| { &m.mouse_enabled },
                |m: &mut Player| { &mut m.mouse_enabled },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controller_enabled",
                |m: &Player| { &m.controller_enabled },
                |m: &mut Player| { &mut m.controller_enabled },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "controller_slots",
                |m: &Player| { &m.controller_slots },
                |m: &mut Player| { &mut m.controller_slots },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "avatar_hash",
                |m: &Player| { &m.avatar_hash },
                |m: &mut Player| { &mut m.avatar_hash },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Player>(
                "CRemotePlayTogetherGroupUpdateMsg.Player",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.guestid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.keyboard_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.mouse_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.controller_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.controller_slots)?;
                    },
                    48 => {
                        self.controller_slots.push(is.read_uint32()?);
                    },
                    58 => {
                        self.avatar_hash = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.guestid {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.keyboard_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.mouse_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.controller_enabled {
                my_size += 1 + 1;
            }
            for value in &self.controller_slots {
                my_size += crate::rt::uint32_size(6, *value);
            };
            if let Some(v) = self.avatar_hash.as_ref() {
                my_size += crate::rt::bytes_size(7, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.guestid {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.keyboard_enabled {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.mouse_enabled {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.controller_enabled {
                os.write_bool(5, v)?;
            }
            for v in &self.controller_slots {
                os.write_uint32(6, *v)?;
            };
            if let Some(v) = self.avatar_hash.as_ref() {
                os.write_bytes(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.guestid = ::std::option::Option::None;
            self.keyboard_enabled = ::std::option::Option::None;
            self.mouse_enabled = ::std::option::Option::None;
            self.controller_enabled = ::std::option::Option::None;
            self.controller_slots.clear();
            self.avatar_hash = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                accountid: ::std::option::Option::None,
                guestid: ::std::option::Option::None,
                keyboard_enabled: ::std::option::Option::None,
                mouse_enabled: ::std::option::Option::None,
                controller_enabled: ::std::option::Option::None,
                controller_slots: ::std::vec::Vec::new(),
                avatar_hash: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Player {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CRemotePlayTogetherGroupUpdateMsg.Player").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Player {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Player {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSetInputTemporarilyDisabledMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetInputTemporarilyDisabledMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetInputTemporarilyDisabledMsg.disabled)
    pub disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetInputTemporarilyDisabledMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetInputTemporarilyDisabledMsg {
    fn default() -> &'a CSetInputTemporarilyDisabledMsg {
        <CSetInputTemporarilyDisabledMsg as crate::Message>::default_instance()
    }
}

impl CSetInputTemporarilyDisabledMsg {
    pub fn new() -> CSetInputTemporarilyDisabledMsg {
        ::std::default::Default::default()
    }

    // optional bool disabled = 1;

    pub fn disabled(&self) -> bool {
        self.disabled.unwrap_or(false)
    }

    pub fn clear_disabled(&mut self) {
        self.disabled = ::std::option::Option::None;
    }

    pub fn has_disabled(&self) -> bool {
        self.disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disabled",
            |m: &CSetInputTemporarilyDisabledMsg| { &m.disabled },
            |m: &mut CSetInputTemporarilyDisabledMsg| { &mut m.disabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetInputTemporarilyDisabledMsg>(
            "CSetInputTemporarilyDisabledMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetInputTemporarilyDisabledMsg {
    const NAME: &'static str = "CSetInputTemporarilyDisabledMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.disabled {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.disabled {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetInputTemporarilyDisabledMsg {
        CSetInputTemporarilyDisabledMsg::new()
    }

    fn clear(&mut self) {
        self.disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetInputTemporarilyDisabledMsg {
        static instance: CSetInputTemporarilyDisabledMsg = CSetInputTemporarilyDisabledMsg {
            disabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetInputTemporarilyDisabledMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetInputTemporarilyDisabledMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetInputTemporarilyDisabledMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetInputTemporarilyDisabledMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetQualityOverrideMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetQualityOverrideMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetQualityOverrideMsg.value)
    pub value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetQualityOverrideMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetQualityOverrideMsg {
    fn default() -> &'a CSetQualityOverrideMsg {
        <CSetQualityOverrideMsg as crate::Message>::default_instance()
    }
}

impl CSetQualityOverrideMsg {
    pub fn new() -> CSetQualityOverrideMsg {
        ::std::default::Default::default()
    }

    // optional int32 value = 1;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CSetQualityOverrideMsg| { &m.value },
            |m: &mut CSetQualityOverrideMsg| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetQualityOverrideMsg>(
            "CSetQualityOverrideMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetQualityOverrideMsg {
    const NAME: &'static str = "CSetQualityOverrideMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.value {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetQualityOverrideMsg {
        CSetQualityOverrideMsg::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetQualityOverrideMsg {
        static instance: CSetQualityOverrideMsg = CSetQualityOverrideMsg {
            value: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetQualityOverrideMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetQualityOverrideMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetQualityOverrideMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetQualityOverrideMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSetBitrateOverrideMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSetBitrateOverrideMsg {
    // message fields
    // @@protoc_insertion_point(field:CSetBitrateOverrideMsg.value)
    pub value: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSetBitrateOverrideMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSetBitrateOverrideMsg {
    fn default() -> &'a CSetBitrateOverrideMsg {
        <CSetBitrateOverrideMsg as crate::Message>::default_instance()
    }
}

impl CSetBitrateOverrideMsg {
    pub fn new() -> CSetBitrateOverrideMsg {
        ::std::default::Default::default()
    }

    // optional int32 value = 1;

    pub fn value(&self) -> i32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CSetBitrateOverrideMsg| { &m.value },
            |m: &mut CSetBitrateOverrideMsg| { &mut m.value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSetBitrateOverrideMsg>(
            "CSetBitrateOverrideMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSetBitrateOverrideMsg {
    const NAME: &'static str = "CSetBitrateOverrideMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.value = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value {
            my_size += crate::rt::int32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.value {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSetBitrateOverrideMsg {
        CSetBitrateOverrideMsg::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSetBitrateOverrideMsg {
        static instance: CSetBitrateOverrideMsg = CSetBitrateOverrideMsg {
            value: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSetBitrateOverrideMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSetBitrateOverrideMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSetBitrateOverrideMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSetBitrateOverrideMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CShowOnScreenKeyboardMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CShowOnScreenKeyboardMsg {
    // special fields
    // @@protoc_insertion_point(special_field:CShowOnScreenKeyboardMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CShowOnScreenKeyboardMsg {
    fn default() -> &'a CShowOnScreenKeyboardMsg {
        <CShowOnScreenKeyboardMsg as crate::Message>::default_instance()
    }
}

impl CShowOnScreenKeyboardMsg {
    pub fn new() -> CShowOnScreenKeyboardMsg {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CShowOnScreenKeyboardMsg>(
            "CShowOnScreenKeyboardMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CShowOnScreenKeyboardMsg {
    const NAME: &'static str = "CShowOnScreenKeyboardMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CShowOnScreenKeyboardMsg {
        CShowOnScreenKeyboardMsg::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CShowOnScreenKeyboardMsg {
        static instance: CShowOnScreenKeyboardMsg = CShowOnScreenKeyboardMsg {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CShowOnScreenKeyboardMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CShowOnScreenKeyboardMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CShowOnScreenKeyboardMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CShowOnScreenKeyboardMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CControllerPersonalizationUpdateMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CControllerPersonalizationUpdateMsg {
    // message fields
    // @@protoc_insertion_point(field:CControllerPersonalizationUpdateMsg.controller_path)
    pub controller_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CControllerPersonalizationUpdateMsg.controller_name)
    pub controller_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CControllerPersonalizationUpdateMsg.reverse_diamond_button_layout)
    pub reverse_diamond_button_layout: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CControllerPersonalizationUpdateMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CControllerPersonalizationUpdateMsg {
    fn default() -> &'a CControllerPersonalizationUpdateMsg {
        <CControllerPersonalizationUpdateMsg as crate::Message>::default_instance()
    }
}

impl CControllerPersonalizationUpdateMsg {
    pub fn new() -> CControllerPersonalizationUpdateMsg {
        ::std::default::Default::default()
    }

    // optional string controller_path = 1;

    pub fn controller_path(&self) -> &str {
        match self.controller_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controller_path(&mut self) {
        self.controller_path = ::std::option::Option::None;
    }

    pub fn has_controller_path(&self) -> bool {
        self.controller_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_path(&mut self, v: ::std::string::String) {
        self.controller_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controller_path(&mut self) -> &mut ::std::string::String {
        if self.controller_path.is_none() {
            self.controller_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controller_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_controller_path(&mut self) -> ::std::string::String {
        self.controller_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string controller_name = 2;

    pub fn controller_name(&self) -> &str {
        match self.controller_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controller_name(&mut self) {
        self.controller_name = ::std::option::Option::None;
    }

    pub fn has_controller_name(&self) -> bool {
        self.controller_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller_name(&mut self, v: ::std::string::String) {
        self.controller_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controller_name(&mut self) -> &mut ::std::string::String {
        if self.controller_name.is_none() {
            self.controller_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controller_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_controller_name(&mut self) -> ::std::string::String {
        self.controller_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool reverse_diamond_button_layout = 3;

    pub fn reverse_diamond_button_layout(&self) -> bool {
        self.reverse_diamond_button_layout.unwrap_or(false)
    }

    pub fn clear_reverse_diamond_button_layout(&mut self) {
        self.reverse_diamond_button_layout = ::std::option::Option::None;
    }

    pub fn has_reverse_diamond_button_layout(&self) -> bool {
        self.reverse_diamond_button_layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverse_diamond_button_layout(&mut self, v: bool) {
        self.reverse_diamond_button_layout = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_path",
            |m: &CControllerPersonalizationUpdateMsg| { &m.controller_path },
            |m: &mut CControllerPersonalizationUpdateMsg| { &mut m.controller_path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller_name",
            |m: &CControllerPersonalizationUpdateMsg| { &m.controller_name },
            |m: &mut CControllerPersonalizationUpdateMsg| { &mut m.controller_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reverse_diamond_button_layout",
            |m: &CControllerPersonalizationUpdateMsg| { &m.reverse_diamond_button_layout },
            |m: &mut CControllerPersonalizationUpdateMsg| { &mut m.reverse_diamond_button_layout },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CControllerPersonalizationUpdateMsg>(
            "CControllerPersonalizationUpdateMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CControllerPersonalizationUpdateMsg {
    const NAME: &'static str = "CControllerPersonalizationUpdateMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.controller_path = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.controller_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.reverse_diamond_button_layout = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.controller_path.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.controller_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.reverse_diamond_button_layout {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.controller_path.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.controller_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reverse_diamond_button_layout {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CControllerPersonalizationUpdateMsg {
        CControllerPersonalizationUpdateMsg::new()
    }

    fn clear(&mut self) {
        self.controller_path = ::std::option::Option::None;
        self.controller_name = ::std::option::Option::None;
        self.reverse_diamond_button_layout = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CControllerPersonalizationUpdateMsg {
        static instance: CControllerPersonalizationUpdateMsg = CControllerPersonalizationUpdateMsg {
            controller_path: ::std::option::Option::None,
            controller_name: ::std::option::Option::None,
            reverse_diamond_button_layout: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CControllerPersonalizationUpdateMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CControllerPersonalizationUpdateMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CControllerPersonalizationUpdateMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CControllerPersonalizationUpdateMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CVRConnectionReady)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVRConnectionReady {
    // message fields
    // @@protoc_insertion_point(field:CVRConnectionReady.connect_params)
    pub connect_params: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CVRConnectionReady.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVRConnectionReady {
    fn default() -> &'a CVRConnectionReady {
        <CVRConnectionReady as crate::Message>::default_instance()
    }
}

impl CVRConnectionReady {
    pub fn new() -> CVRConnectionReady {
        ::std::default::Default::default()
    }

    // optional string connect_params = 1;

    pub fn connect_params(&self) -> &str {
        match self.connect_params.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connect_params(&mut self) {
        self.connect_params = ::std::option::Option::None;
    }

    pub fn has_connect_params(&self) -> bool {
        self.connect_params.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_params(&mut self, v: ::std::string::String) {
        self.connect_params = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_params(&mut self) -> &mut ::std::string::String {
        if self.connect_params.is_none() {
            self.connect_params = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connect_params.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_params(&mut self) -> ::std::string::String {
        self.connect_params.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "connect_params",
            |m: &CVRConnectionReady| { &m.connect_params },
            |m: &mut CVRConnectionReady| { &mut m.connect_params },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CVRConnectionReady>(
            "CVRConnectionReady",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CVRConnectionReady {
    const NAME: &'static str = "CVRConnectionReady";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connect_params = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.connect_params.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.connect_params.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVRConnectionReady {
        CVRConnectionReady::new()
    }

    fn clear(&mut self) {
        self.connect_params = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVRConnectionReady {
        static instance: CVRConnectionReady = CVRConnectionReady {
            connect_params: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CVRConnectionReady {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CVRConnectionReady").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CVRConnectionReady {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CVRConnectionReady {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamDataLostMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamDataLostMsg {
    // message fields
    // @@protoc_insertion_point(field:CStreamDataLostMsg.packets)
    pub packets: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamDataLostMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamDataLostMsg {
    fn default() -> &'a CStreamDataLostMsg {
        <CStreamDataLostMsg as crate::Message>::default_instance()
    }
}

impl CStreamDataLostMsg {
    pub fn new() -> CStreamDataLostMsg {
        ::std::default::Default::default()
    }

    // repeated uint32 packets = 1;

    pub fn packets(&self) -> &[u32] {
        &self.packets
    }

    pub fn clear_packets(&mut self) {
        self.packets.clear();
    }

    // Param is passed by value, moved
    pub fn set_packets(&mut self, v: ::std::vec::Vec<u32>) {
        self.packets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packets(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packets
    }

    // Take field
    pub fn take_packets(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packets, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packets",
            |m: &CStreamDataLostMsg| { &m.packets },
            |m: &mut CStreamDataLostMsg| { &mut m.packets },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamDataLostMsg>(
            "CStreamDataLostMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamDataLostMsg {
    const NAME: &'static str = "CStreamDataLostMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.packets)?;
                },
                8 => {
                    self.packets.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.packets {
            my_size += crate::rt::uint32_size(1, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.packets {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamDataLostMsg {
        CStreamDataLostMsg::new()
    }

    fn clear(&mut self) {
        self.packets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamDataLostMsg {
        static instance: CStreamDataLostMsg = CStreamDataLostMsg {
            packets: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamDataLostMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamDataLostMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamDataLostMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamDataLostMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CAudioFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAudioFormat {
    // message fields
    // @@protoc_insertion_point(field:CAudioFormat.format)
    pub format: ::std::option::Option<crate::EnumOrUnknown<EAudioFormat>>,
    // @@protoc_insertion_point(field:CAudioFormat.frequency)
    pub frequency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAudioFormat.channels)
    pub channels: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAudioFormat.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAudioFormat {
    fn default() -> &'a CAudioFormat {
        <CAudioFormat as crate::Message>::default_instance()
    }
}

impl CAudioFormat {
    pub fn new() -> CAudioFormat {
        ::std::default::Default::default()
    }

    // required .EAudioFormat format = 1;

    pub fn format(&self) -> EAudioFormat {
        match self.format {
            Some(e) => e.enum_value_or(EAudioFormat::k_EAudioFormatNone),
            None => EAudioFormat::k_EAudioFormatNone,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EAudioFormat) {
        self.format = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 frequency = 2;

    pub fn frequency(&self) -> u32 {
        self.frequency.unwrap_or(0)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: u32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional uint32 channels = 3;

    pub fn channels(&self) -> u32 {
        self.channels.unwrap_or(0)
    }

    pub fn clear_channels(&mut self) {
        self.channels = ::std::option::Option::None;
    }

    pub fn has_channels(&self) -> bool {
        self.channels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: u32) {
        self.channels = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &CAudioFormat| { &m.format },
            |m: &mut CAudioFormat| { &mut m.format },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "frequency",
            |m: &CAudioFormat| { &m.frequency },
            |m: &mut CAudioFormat| { &mut m.frequency },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "channels",
            |m: &CAudioFormat| { &m.channels },
            |m: &mut CAudioFormat| { &mut m.channels },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CAudioFormat>(
            "CAudioFormat",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CAudioFormat {
    const NAME: &'static str = "CAudioFormat";

    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.frequency = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.channels = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.frequency {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.channels {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.format {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.frequency {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.channels {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAudioFormat {
        CAudioFormat::new()
    }

    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.channels = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAudioFormat {
        static instance: CAudioFormat = CAudioFormat {
            format: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            channels: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CAudioFormat {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAudioFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAudioFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CAudioFormat {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CVideoFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CVideoFormat {
    // message fields
    // @@protoc_insertion_point(field:CVideoFormat.format)
    pub format: ::std::option::Option<crate::EnumOrUnknown<EVideoFormat>>,
    // @@protoc_insertion_point(field:CVideoFormat.width)
    pub width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CVideoFormat.height)
    pub height: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CVideoFormat.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CVideoFormat {
    fn default() -> &'a CVideoFormat {
        <CVideoFormat as crate::Message>::default_instance()
    }
}

impl CVideoFormat {
    pub fn new() -> CVideoFormat {
        ::std::default::Default::default()
    }

    // required .EVideoFormat format = 1;

    pub fn format(&self) -> EVideoFormat {
        match self.format {
            Some(e) => e.enum_value_or(EVideoFormat::k_EVideoFormatNone),
            None => EVideoFormat::k_EVideoFormatNone,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: EVideoFormat) {
        self.format = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 width = 2;

    pub fn width(&self) -> u32 {
        self.width.unwrap_or(0)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: u32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional uint32 height = 3;

    pub fn height(&self) -> u32 {
        self.height.unwrap_or(0)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: u32) {
        self.height = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &CVideoFormat| { &m.format },
            |m: &mut CVideoFormat| { &mut m.format },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &CVideoFormat| { &m.width },
            |m: &mut CVideoFormat| { &mut m.width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &CVideoFormat| { &m.height },
            |m: &mut CVideoFormat| { &mut m.height },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CVideoFormat>(
            "CVideoFormat",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CVideoFormat {
    const NAME: &'static str = "CVideoFormat";

    fn is_initialized(&self) -> bool {
        if self.format.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.width = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.height = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.format {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.width {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.height {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.format {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.width {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.height {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CVideoFormat {
        CVideoFormat::new()
    }

    fn clear(&mut self) {
        self.format = ::std::option::Option::None;
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CVideoFormat {
        static instance: CVideoFormat = CVideoFormat {
            format: ::std::option::Option::None,
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CVideoFormat {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CVideoFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CVideoFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CVideoFormat {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFrameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFrameEvent {
    // message fields
    // @@protoc_insertion_point(field:CFrameEvent.event_id)
    pub event_id: ::std::option::Option<crate::EnumOrUnknown<EStreamFrameEvent>>,
    // @@protoc_insertion_point(field:CFrameEvent.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFrameEvent.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFrameEvent {
    fn default() -> &'a CFrameEvent {
        <CFrameEvent as crate::Message>::default_instance()
    }
}

impl CFrameEvent {
    pub fn new() -> CFrameEvent {
        ::std::default::Default::default()
    }

    // required .EStreamFrameEvent event_id = 1;

    pub fn event_id(&self) -> EStreamFrameEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(EStreamFrameEvent::k_EStreamInputEventStart),
            None => EStreamFrameEvent::k_EStreamInputEventStart,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: EStreamFrameEvent) {
        self.event_id = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // required uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CFrameEvent| { &m.event_id },
            |m: &mut CFrameEvent| { &mut m.event_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CFrameEvent| { &m.timestamp },
            |m: &mut CFrameEvent| { &mut m.timestamp },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFrameEvent>(
            "CFrameEvent",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFrameEvent {
    const NAME: &'static str = "CFrameEvent";

    fn is_initialized(&self) -> bool {
        if self.event_id.is_none() {
            return false;
        }
        if self.timestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFrameEvent {
        CFrameEvent::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFrameEvent {
        static instance: CFrameEvent = CFrameEvent {
            event_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFrameEvent {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFrameEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFrameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFrameEvent {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFrameStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFrameStats {
    // message fields
    // @@protoc_insertion_point(field:CFrameStats.frame_id)
    pub frame_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFrameStats.input_mark)
    pub input_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CFrameStats.events)
    pub events: ::std::vec::Vec<CFrameEvent>,
    // @@protoc_insertion_point(field:CFrameStats.result)
    pub result: ::std::option::Option<crate::EnumOrUnknown<EStreamFrameResult>>,
    // @@protoc_insertion_point(field:CFrameStats.frame_start_delta)
    pub frame_start_delta: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.frame_display_delta)
    pub frame_display_delta: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.ping_time)
    pub ping_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.server_bitrate)
    pub server_bitrate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.client_bitrate)
    pub client_bitrate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.link_bandwidth)
    pub link_bandwidth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.packet_loss)
    pub packet_loss: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStats.frame_size)
    pub frame_size: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFrameStats.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFrameStats {
    fn default() -> &'a CFrameStats {
        <CFrameStats as crate::Message>::default_instance()
    }
}

impl CFrameStats {
    pub fn new() -> CFrameStats {
        ::std::default::Default::default()
    }

    // required uint32 frame_id = 1;

    pub fn frame_id(&self) -> u32 {
        self.frame_id.unwrap_or(0)
    }

    pub fn clear_frame_id(&mut self) {
        self.frame_id = ::std::option::Option::None;
    }

    pub fn has_frame_id(&self) -> bool {
        self.frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_id(&mut self, v: u32) {
        self.frame_id = ::std::option::Option::Some(v);
    }

    // optional uint32 input_mark = 2;

    pub fn input_mark(&self) -> u32 {
        self.input_mark.unwrap_or(0)
    }

    pub fn clear_input_mark(&mut self) {
        self.input_mark = ::std::option::Option::None;
    }

    pub fn has_input_mark(&self) -> bool {
        self.input_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_mark(&mut self, v: u32) {
        self.input_mark = ::std::option::Option::Some(v);
    }

    // repeated .CFrameEvent events = 3;

    pub fn events(&self) -> &[CFrameEvent] {
        &self.events
    }

    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::std::vec::Vec<CFrameEvent>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::std::vec::Vec<CFrameEvent> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::std::vec::Vec<CFrameEvent> {
        ::std::mem::replace(&mut self.events, ::std::vec::Vec::new())
    }

    // required .EStreamFrameResult result = 4;

    pub fn result(&self) -> EStreamFrameResult {
        match self.result {
            Some(e) => e.enum_value_or(EStreamFrameResult::k_EStreamFrameResultPending),
            None => EStreamFrameResult::k_EStreamFrameResultPending,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EStreamFrameResult) {
        self.result = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional float frame_start_delta = 5;

    pub fn frame_start_delta(&self) -> f32 {
        self.frame_start_delta.unwrap_or(0.)
    }

    pub fn clear_frame_start_delta(&mut self) {
        self.frame_start_delta = ::std::option::Option::None;
    }

    pub fn has_frame_start_delta(&self) -> bool {
        self.frame_start_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_start_delta(&mut self, v: f32) {
        self.frame_start_delta = ::std::option::Option::Some(v);
    }

    // optional float frame_display_delta = 6;

    pub fn frame_display_delta(&self) -> f32 {
        self.frame_display_delta.unwrap_or(0.)
    }

    pub fn clear_frame_display_delta(&mut self) {
        self.frame_display_delta = ::std::option::Option::None;
    }

    pub fn has_frame_display_delta(&self) -> bool {
        self.frame_display_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_display_delta(&mut self, v: f32) {
        self.frame_display_delta = ::std::option::Option::Some(v);
    }

    // optional float ping_time = 7;

    pub fn ping_time(&self) -> f32 {
        self.ping_time.unwrap_or(0.)
    }

    pub fn clear_ping_time(&mut self) {
        self.ping_time = ::std::option::Option::None;
    }

    pub fn has_ping_time(&self) -> bool {
        self.ping_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_time(&mut self, v: f32) {
        self.ping_time = ::std::option::Option::Some(v);
    }

    // optional float server_bitrate = 8;

    pub fn server_bitrate(&self) -> f32 {
        self.server_bitrate.unwrap_or(0.)
    }

    pub fn clear_server_bitrate(&mut self) {
        self.server_bitrate = ::std::option::Option::None;
    }

    pub fn has_server_bitrate(&self) -> bool {
        self.server_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_bitrate(&mut self, v: f32) {
        self.server_bitrate = ::std::option::Option::Some(v);
    }

    // optional float client_bitrate = 9;

    pub fn client_bitrate(&self) -> f32 {
        self.client_bitrate.unwrap_or(0.)
    }

    pub fn clear_client_bitrate(&mut self) {
        self.client_bitrate = ::std::option::Option::None;
    }

    pub fn has_client_bitrate(&self) -> bool {
        self.client_bitrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_bitrate(&mut self, v: f32) {
        self.client_bitrate = ::std::option::Option::Some(v);
    }

    // optional float link_bandwidth = 10;

    pub fn link_bandwidth(&self) -> f32 {
        self.link_bandwidth.unwrap_or(0.)
    }

    pub fn clear_link_bandwidth(&mut self) {
        self.link_bandwidth = ::std::option::Option::None;
    }

    pub fn has_link_bandwidth(&self) -> bool {
        self.link_bandwidth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_link_bandwidth(&mut self, v: f32) {
        self.link_bandwidth = ::std::option::Option::Some(v);
    }

    // optional float packet_loss = 11;

    pub fn packet_loss(&self) -> f32 {
        self.packet_loss.unwrap_or(0.)
    }

    pub fn clear_packet_loss(&mut self) {
        self.packet_loss = ::std::option::Option::None;
    }

    pub fn has_packet_loss(&self) -> bool {
        self.packet_loss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet_loss(&mut self, v: f32) {
        self.packet_loss = ::std::option::Option::Some(v);
    }

    // optional uint32 frame_size = 12;

    pub fn frame_size(&self) -> u32 {
        self.frame_size.unwrap_or(0)
    }

    pub fn clear_frame_size(&mut self) {
        self.frame_size = ::std::option::Option::None;
    }

    pub fn has_frame_size(&self) -> bool {
        self.frame_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_size(&mut self, v: u32) {
        self.frame_size = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_id",
            |m: &CFrameStats| { &m.frame_id },
            |m: &mut CFrameStats| { &mut m.frame_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_mark",
            |m: &CFrameStats| { &m.input_mark },
            |m: &mut CFrameStats| { &mut m.input_mark },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &CFrameStats| { &m.events },
            |m: &mut CFrameStats| { &mut m.events },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CFrameStats| { &m.result },
            |m: &mut CFrameStats| { &mut m.result },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_start_delta",
            |m: &CFrameStats| { &m.frame_start_delta },
            |m: &mut CFrameStats| { &mut m.frame_start_delta },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_display_delta",
            |m: &CFrameStats| { &m.frame_display_delta },
            |m: &mut CFrameStats| { &mut m.frame_display_delta },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping_time",
            |m: &CFrameStats| { &m.ping_time },
            |m: &mut CFrameStats| { &mut m.ping_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_bitrate",
            |m: &CFrameStats| { &m.server_bitrate },
            |m: &mut CFrameStats| { &mut m.server_bitrate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_bitrate",
            |m: &CFrameStats| { &m.client_bitrate },
            |m: &mut CFrameStats| { &mut m.client_bitrate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "link_bandwidth",
            |m: &CFrameStats| { &m.link_bandwidth },
            |m: &mut CFrameStats| { &mut m.link_bandwidth },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "packet_loss",
            |m: &CFrameStats| { &m.packet_loss },
            |m: &mut CFrameStats| { &mut m.packet_loss },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_size",
            |m: &CFrameStats| { &m.frame_size },
            |m: &mut CFrameStats| { &mut m.frame_size },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFrameStats>(
            "CFrameStats",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFrameStats {
    const NAME: &'static str = "CFrameStats";

    fn is_initialized(&self) -> bool {
        if self.frame_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.frame_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.input_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.events.push(is.read_message()?);
                },
                32 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                45 => {
                    self.frame_start_delta = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.frame_display_delta = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.ping_time = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.server_bitrate = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.client_bitrate = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.link_bandwidth = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.packet_loss = ::std::option::Option::Some(is.read_float()?);
                },
                96 => {
                    self.frame_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.input_mark {
            my_size += crate::rt::uint32_size(2, v);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.result {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.frame_start_delta {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frame_display_delta {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ping_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_bitrate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.client_bitrate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.link_bandwidth {
            my_size += 1 + 4;
        }
        if let Some(v) = self.packet_loss {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frame_size {
            my_size += crate::rt::uint32_size(12, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.frame_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.input_mark {
            os.write_uint32(2, v)?;
        }
        for v in &self.events {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.result {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.frame_start_delta {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.frame_display_delta {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ping_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.server_bitrate {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.client_bitrate {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.link_bandwidth {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.packet_loss {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.frame_size {
            os.write_uint32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFrameStats {
        CFrameStats::new()
    }

    fn clear(&mut self) {
        self.frame_id = ::std::option::Option::None;
        self.input_mark = ::std::option::Option::None;
        self.events.clear();
        self.result = ::std::option::Option::None;
        self.frame_start_delta = ::std::option::Option::None;
        self.frame_display_delta = ::std::option::Option::None;
        self.ping_time = ::std::option::Option::None;
        self.server_bitrate = ::std::option::Option::None;
        self.client_bitrate = ::std::option::Option::None;
        self.link_bandwidth = ::std::option::Option::None;
        self.packet_loss = ::std::option::Option::None;
        self.frame_size = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFrameStats {
        static instance: CFrameStats = CFrameStats {
            frame_id: ::std::option::Option::None,
            input_mark: ::std::option::Option::None,
            events: ::std::vec::Vec::new(),
            result: ::std::option::Option::None,
            frame_start_delta: ::std::option::Option::None,
            frame_display_delta: ::std::option::Option::None,
            ping_time: ::std::option::Option::None,
            server_bitrate: ::std::option::Option::None,
            client_bitrate: ::std::option::Option::None,
            link_bandwidth: ::std::option::Option::None,
            packet_loss: ::std::option::Option::None,
            frame_size: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFrameStats {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFrameStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFrameStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFrameStats {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFrameStatAccumulatedValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFrameStatAccumulatedValue {
    // message fields
    // @@protoc_insertion_point(field:CFrameStatAccumulatedValue.stat_type)
    pub stat_type: ::std::option::Option<crate::EnumOrUnknown<EFrameAccumulatedStat>>,
    // @@protoc_insertion_point(field:CFrameStatAccumulatedValue.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CFrameStatAccumulatedValue.average)
    pub average: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CFrameStatAccumulatedValue.stddev)
    pub stddev: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFrameStatAccumulatedValue.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFrameStatAccumulatedValue {
    fn default() -> &'a CFrameStatAccumulatedValue {
        <CFrameStatAccumulatedValue as crate::Message>::default_instance()
    }
}

impl CFrameStatAccumulatedValue {
    pub fn new() -> CFrameStatAccumulatedValue {
        ::std::default::Default::default()
    }

    // required .EFrameAccumulatedStat stat_type = 1;

    pub fn stat_type(&self) -> EFrameAccumulatedStat {
        match self.stat_type {
            Some(e) => e.enum_value_or(EFrameAccumulatedStat::k_EFrameStatFPS),
            None => EFrameAccumulatedStat::k_EFrameStatFPS,
        }
    }

    pub fn clear_stat_type(&mut self) {
        self.stat_type = ::std::option::Option::None;
    }

    pub fn has_stat_type(&self) -> bool {
        self.stat_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_type(&mut self, v: EFrameAccumulatedStat) {
        self.stat_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // required int32 count = 2;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // required float average = 3;

    pub fn average(&self) -> f32 {
        self.average.unwrap_or(0.)
    }

    pub fn clear_average(&mut self) {
        self.average = ::std::option::Option::None;
    }

    pub fn has_average(&self) -> bool {
        self.average.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average(&mut self, v: f32) {
        self.average = ::std::option::Option::Some(v);
    }

    // optional float stddev = 4;

    pub fn stddev(&self) -> f32 {
        self.stddev.unwrap_or(0.)
    }

    pub fn clear_stddev(&mut self) {
        self.stddev = ::std::option::Option::None;
    }

    pub fn has_stddev(&self) -> bool {
        self.stddev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev(&mut self, v: f32) {
        self.stddev = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stat_type",
            |m: &CFrameStatAccumulatedValue| { &m.stat_type },
            |m: &mut CFrameStatAccumulatedValue| { &mut m.stat_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CFrameStatAccumulatedValue| { &m.count },
            |m: &mut CFrameStatAccumulatedValue| { &mut m.count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "average",
            |m: &CFrameStatAccumulatedValue| { &m.average },
            |m: &mut CFrameStatAccumulatedValue| { &mut m.average },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stddev",
            |m: &CFrameStatAccumulatedValue| { &m.stddev },
            |m: &mut CFrameStatAccumulatedValue| { &mut m.stddev },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFrameStatAccumulatedValue>(
            "CFrameStatAccumulatedValue",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFrameStatAccumulatedValue {
    const NAME: &'static str = "CFrameStatAccumulatedValue";

    fn is_initialized(&self) -> bool {
        if self.stat_type.is_none() {
            return false;
        }
        if self.count.is_none() {
            return false;
        }
        if self.average.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.average = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.stddev = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stat_type {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.count {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.average {
            my_size += 1 + 4;
        }
        if let Some(v) = self.stddev {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.stat_type {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.average {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.stddev {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFrameStatAccumulatedValue {
        CFrameStatAccumulatedValue::new()
    }

    fn clear(&mut self) {
        self.stat_type = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.average = ::std::option::Option::None;
        self.stddev = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFrameStatAccumulatedValue {
        static instance: CFrameStatAccumulatedValue = CFrameStatAccumulatedValue {
            stat_type: ::std::option::Option::None,
            count: ::std::option::Option::None,
            average: ::std::option::Option::None,
            stddev: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFrameStatAccumulatedValue {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFrameStatAccumulatedValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFrameStatAccumulatedValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFrameStatAccumulatedValue {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CFrameStatsListMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CFrameStatsListMsg {
    // message fields
    // @@protoc_insertion_point(field:CFrameStatsListMsg.data_type)
    pub data_type: ::std::option::Option<crate::EnumOrUnknown<EStreamingDataType>>,
    // @@protoc_insertion_point(field:CFrameStatsListMsg.stats)
    pub stats: ::std::vec::Vec<CFrameStats>,
    // @@protoc_insertion_point(field:CFrameStatsListMsg.accumulated_stats)
    pub accumulated_stats: ::std::vec::Vec<CFrameStatAccumulatedValue>,
    // @@protoc_insertion_point(field:CFrameStatsListMsg.latest_frame_id)
    pub latest_frame_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CFrameStatsListMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CFrameStatsListMsg {
    fn default() -> &'a CFrameStatsListMsg {
        <CFrameStatsListMsg as crate::Message>::default_instance()
    }
}

impl CFrameStatsListMsg {
    pub fn new() -> CFrameStatsListMsg {
        ::std::default::Default::default()
    }

    // required .EStreamingDataType data_type = 1;

    pub fn data_type(&self) -> EStreamingDataType {
        match self.data_type {
            Some(e) => e.enum_value_or(EStreamingDataType::k_EStreamingAudioData),
            None => EStreamingDataType::k_EStreamingAudioData,
        }
    }

    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: EStreamingDataType) {
        self.data_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // repeated .CFrameStats stats = 2;

    pub fn stats(&self) -> &[CFrameStats] {
        &self.stats
    }

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::std::vec::Vec<CFrameStats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::std::vec::Vec<CFrameStats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::std::vec::Vec<CFrameStats> {
        ::std::mem::replace(&mut self.stats, ::std::vec::Vec::new())
    }

    // repeated .CFrameStatAccumulatedValue accumulated_stats = 3;

    pub fn accumulated_stats(&self) -> &[CFrameStatAccumulatedValue] {
        &self.accumulated_stats
    }

    pub fn clear_accumulated_stats(&mut self) {
        self.accumulated_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_accumulated_stats(&mut self, v: ::std::vec::Vec<CFrameStatAccumulatedValue>) {
        self.accumulated_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accumulated_stats(&mut self) -> &mut ::std::vec::Vec<CFrameStatAccumulatedValue> {
        &mut self.accumulated_stats
    }

    // Take field
    pub fn take_accumulated_stats(&mut self) -> ::std::vec::Vec<CFrameStatAccumulatedValue> {
        ::std::mem::replace(&mut self.accumulated_stats, ::std::vec::Vec::new())
    }

    // required int32 latest_frame_id = 4;

    pub fn latest_frame_id(&self) -> i32 {
        self.latest_frame_id.unwrap_or(0)
    }

    pub fn clear_latest_frame_id(&mut self) {
        self.latest_frame_id = ::std::option::Option::None;
    }

    pub fn has_latest_frame_id(&self) -> bool {
        self.latest_frame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_frame_id(&mut self, v: i32) {
        self.latest_frame_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "data_type",
            |m: &CFrameStatsListMsg| { &m.data_type },
            |m: &mut CFrameStatsListMsg| { &mut m.data_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CFrameStatsListMsg| { &m.stats },
            |m: &mut CFrameStatsListMsg| { &mut m.stats },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accumulated_stats",
            |m: &CFrameStatsListMsg| { &m.accumulated_stats },
            |m: &mut CFrameStatsListMsg| { &mut m.accumulated_stats },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "latest_frame_id",
            |m: &CFrameStatsListMsg| { &m.latest_frame_id },
            |m: &mut CFrameStatsListMsg| { &mut m.latest_frame_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CFrameStatsListMsg>(
            "CFrameStatsListMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CFrameStatsListMsg {
    const NAME: &'static str = "CFrameStatsListMsg";

    fn is_initialized(&self) -> bool {
        if self.data_type.is_none() {
            return false;
        }
        if self.latest_frame_id.is_none() {
            return false;
        }
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.accumulated_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.data_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.stats.push(is.read_message()?);
                },
                26 => {
                    self.accumulated_stats.push(is.read_message()?);
                },
                32 => {
                    self.latest_frame_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data_type {
            my_size += crate::rt::int32_size(1, v.value());
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.accumulated_stats {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.latest_frame_id {
            my_size += crate::rt::int32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.data_type {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        for v in &self.stats {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.accumulated_stats {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.latest_frame_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CFrameStatsListMsg {
        CFrameStatsListMsg::new()
    }

    fn clear(&mut self) {
        self.data_type = ::std::option::Option::None;
        self.stats.clear();
        self.accumulated_stats.clear();
        self.latest_frame_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CFrameStatsListMsg {
        static instance: CFrameStatsListMsg = CFrameStatsListMsg {
            data_type: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            accumulated_stats: ::std::vec::Vec::new(),
            latest_frame_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CFrameStatsListMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CFrameStatsListMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CFrameStatsListMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CFrameStatsListMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStreamingSessionStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStreamingSessionStats {
    // message fields
    // @@protoc_insertion_point(field:CStreamingSessionStats.frame_loss_percentage)
    pub frame_loss_percentage: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CStreamingSessionStats.average_network_time_ms)
    pub average_network_time_ms: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CStreamingSessionStats.stddev_network_time_ms)
    pub stddev_network_time_ms: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CStreamingSessionStats.test_data)
    pub test_data: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CStreamingSessionStats.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStreamingSessionStats {
    fn default() -> &'a CStreamingSessionStats {
        <CStreamingSessionStats as crate::Message>::default_instance()
    }
}

impl CStreamingSessionStats {
    pub fn new() -> CStreamingSessionStats {
        ::std::default::Default::default()
    }

    // optional float frame_loss_percentage = 1;

    pub fn frame_loss_percentage(&self) -> f32 {
        self.frame_loss_percentage.unwrap_or(0.)
    }

    pub fn clear_frame_loss_percentage(&mut self) {
        self.frame_loss_percentage = ::std::option::Option::None;
    }

    pub fn has_frame_loss_percentage(&self) -> bool {
        self.frame_loss_percentage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_loss_percentage(&mut self, v: f32) {
        self.frame_loss_percentage = ::std::option::Option::Some(v);
    }

    // optional float average_network_time_ms = 2;

    pub fn average_network_time_ms(&self) -> f32 {
        self.average_network_time_ms.unwrap_or(0.)
    }

    pub fn clear_average_network_time_ms(&mut self) {
        self.average_network_time_ms = ::std::option::Option::None;
    }

    pub fn has_average_network_time_ms(&self) -> bool {
        self.average_network_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_network_time_ms(&mut self, v: f32) {
        self.average_network_time_ms = ::std::option::Option::Some(v);
    }

    // optional float stddev_network_time_ms = 3;

    pub fn stddev_network_time_ms(&self) -> f32 {
        self.stddev_network_time_ms.unwrap_or(0.)
    }

    pub fn clear_stddev_network_time_ms(&mut self) {
        self.stddev_network_time_ms = ::std::option::Option::None;
    }

    pub fn has_stddev_network_time_ms(&self) -> bool {
        self.stddev_network_time_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev_network_time_ms(&mut self, v: f32) {
        self.stddev_network_time_ms = ::std::option::Option::Some(v);
    }

    // optional string test_data = 4;

    pub fn test_data(&self) -> &str {
        match self.test_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_test_data(&mut self) {
        self.test_data = ::std::option::Option::None;
    }

    pub fn has_test_data(&self) -> bool {
        self.test_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_test_data(&mut self, v: ::std::string::String) {
        self.test_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_test_data(&mut self) -> &mut ::std::string::String {
        if self.test_data.is_none() {
            self.test_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.test_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_test_data(&mut self) -> ::std::string::String {
        self.test_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "frame_loss_percentage",
            |m: &CStreamingSessionStats| { &m.frame_loss_percentage },
            |m: &mut CStreamingSessionStats| { &mut m.frame_loss_percentage },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "average_network_time_ms",
            |m: &CStreamingSessionStats| { &m.average_network_time_ms },
            |m: &mut CStreamingSessionStats| { &mut m.average_network_time_ms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stddev_network_time_ms",
            |m: &CStreamingSessionStats| { &m.stddev_network_time_ms },
            |m: &mut CStreamingSessionStats| { &mut m.stddev_network_time_ms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "test_data",
            |m: &CStreamingSessionStats| { &m.test_data },
            |m: &mut CStreamingSessionStats| { &mut m.test_data },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStreamingSessionStats>(
            "CStreamingSessionStats",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStreamingSessionStats {
    const NAME: &'static str = "CStreamingSessionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.frame_loss_percentage = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.average_network_time_ms = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.stddev_network_time_ms = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    self.test_data = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_loss_percentage {
            my_size += 1 + 4;
        }
        if let Some(v) = self.average_network_time_ms {
            my_size += 1 + 4;
        }
        if let Some(v) = self.stddev_network_time_ms {
            my_size += 1 + 4;
        }
        if let Some(v) = self.test_data.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.frame_loss_percentage {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.average_network_time_ms {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.stddev_network_time_ms {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.test_data.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStreamingSessionStats {
        CStreamingSessionStats::new()
    }

    fn clear(&mut self) {
        self.frame_loss_percentage = ::std::option::Option::None;
        self.average_network_time_ms = ::std::option::Option::None;
        self.stddev_network_time_ms = ::std::option::Option::None;
        self.test_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStreamingSessionStats {
        static instance: CStreamingSessionStats = CStreamingSessionStats {
            frame_loss_percentage: ::std::option::Option::None,
            average_network_time_ms: ::std::option::Option::None,
            stddev_network_time_ms: ::std::option::Option::None,
            test_data: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStreamingSessionStats {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStreamingSessionStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStreamingSessionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStreamingSessionStats {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CDebugDumpMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CDebugDumpMsg {
    // message fields
    // @@protoc_insertion_point(field:CDebugDumpMsg.screenshot)
    pub screenshot: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CDebugDumpMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDebugDumpMsg {
    fn default() -> &'a CDebugDumpMsg {
        <CDebugDumpMsg as crate::Message>::default_instance()
    }
}

impl CDebugDumpMsg {
    pub fn new() -> CDebugDumpMsg {
        ::std::default::Default::default()
    }

    // optional bytes screenshot = 1;

    pub fn screenshot(&self) -> &[u8] {
        match self.screenshot.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_screenshot(&mut self) {
        self.screenshot = ::std::option::Option::None;
    }

    pub fn has_screenshot(&self) -> bool {
        self.screenshot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshot(&mut self, v: ::bytes::Bytes) {
        self.screenshot = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshot(&mut self) -> &mut ::bytes::Bytes {
        if self.screenshot.is_none() {
            self.screenshot = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.screenshot.as_mut().unwrap()
    }

    // Take field
    pub fn take_screenshot(&mut self) -> ::bytes::Bytes {
        self.screenshot.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "screenshot",
            |m: &CDebugDumpMsg| { &m.screenshot },
            |m: &mut CDebugDumpMsg| { &mut m.screenshot },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CDebugDumpMsg>(
            "CDebugDumpMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CDebugDumpMsg {
    const NAME: &'static str = "CDebugDumpMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.screenshot = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.screenshot.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.screenshot.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDebugDumpMsg {
        CDebugDumpMsg::new()
    }

    fn clear(&mut self) {
        self.screenshot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDebugDumpMsg {
        static instance: CDebugDumpMsg = CDebugDumpMsg {
            screenshot: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CDebugDumpMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDebugDumpMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDebugDumpMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CDebugDumpMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CLogMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLogMsg {
    // message fields
    // @@protoc_insertion_point(field:CLogMsg.type)
    pub type_: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CLogMsg.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CLogMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLogMsg {
    fn default() -> &'a CLogMsg {
        <CLogMsg as crate::Message>::default_instance()
    }
}

impl CLogMsg {
    pub fn new() -> CLogMsg {
        ::std::default::Default::default()
    }

    // optional int32 type = 1;

    pub fn type_(&self) -> i32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: i32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CLogMsg| { &m.type_ },
            |m: &mut CLogMsg| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CLogMsg| { &m.message },
            |m: &mut CLogMsg| { &mut m.message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CLogMsg>(
            "CLogMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CLogMsg {
    const NAME: &'static str = "CLogMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_ {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLogMsg {
        CLogMsg::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLogMsg {
        static instance: CLogMsg = CLogMsg {
            type_: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CLogMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CLogMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CLogMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CLogMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CLogUploadMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CLogUploadMsg {
    // message fields
    // @@protoc_insertion_point(field:CLogUploadMsg.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<ELogFileType>>,
    // @@protoc_insertion_point(field:CLogUploadMsg.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CLogUploadMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CLogUploadMsg {
    fn default() -> &'a CLogUploadMsg {
        <CLogUploadMsg as crate::Message>::default_instance()
    }
}

impl CLogUploadMsg {
    pub fn new() -> CLogUploadMsg {
        ::std::default::Default::default()
    }

    // optional .ELogFileType type = 1;

    pub fn type_(&self) -> ELogFileType {
        match self.type_ {
            Some(e) => e.enum_value_or(ELogFileType::k_ELogFileSystemBoot),
            None => ELogFileType::k_ELogFileSystemBoot,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ELogFileType) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CLogUploadMsg| { &m.type_ },
            |m: &mut CLogUploadMsg| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CLogUploadMsg| { &m.data },
            |m: &mut CLogUploadMsg| { &mut m.data },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CLogUploadMsg>(
            "CLogUploadMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CLogUploadMsg {
    const NAME: &'static str = "CLogUploadMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.data.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CLogUploadMsg {
        CLogUploadMsg::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CLogUploadMsg {
        static instance: CLogUploadMsg = CLogUploadMsg {
            type_: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CLogUploadMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CLogUploadMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CLogUploadMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CLogUploadMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CTransportSignalMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTransportSignalMsg {
    // message fields
    // @@protoc_insertion_point(field:CTransportSignalMsg.webrtc)
    pub webrtc: crate::MessageField<ctransport_signal_msg::WebRTCMessage>,
    // @@protoc_insertion_point(field:CTransportSignalMsg.sdr)
    pub sdr: ::std::vec::Vec<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CTransportSignalMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTransportSignalMsg {
    fn default() -> &'a CTransportSignalMsg {
        <CTransportSignalMsg as crate::Message>::default_instance()
    }
}

impl CTransportSignalMsg {
    pub fn new() -> CTransportSignalMsg {
        ::std::default::Default::default()
    }

    // optional .CTransportSignalMsg.WebRTCMessage webrtc = 1;

    pub fn webrtc(&self) -> &ctransport_signal_msg::WebRTCMessage {
        self.webrtc.as_ref().unwrap_or_else(|| <ctransport_signal_msg::WebRTCMessage as crate::Message>::default_instance())
    }

    pub fn clear_webrtc(&mut self) {
        self.webrtc.clear();
    }

    pub fn has_webrtc(&self) -> bool {
        self.webrtc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webrtc(&mut self, v: ctransport_signal_msg::WebRTCMessage) {
        self.webrtc = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webrtc(&mut self) -> &mut ctransport_signal_msg::WebRTCMessage {
        self.webrtc.mut_or_insert_default()
    }

    // Take field
    pub fn take_webrtc(&mut self) -> ctransport_signal_msg::WebRTCMessage {
        self.webrtc.take().unwrap_or_else(|| ctransport_signal_msg::WebRTCMessage::new())
    }

    // repeated bytes sdr = 2;

    pub fn sdr(&self) -> &[::bytes::Bytes] {
        &self.sdr
    }

    pub fn clear_sdr(&mut self) {
        self.sdr.clear();
    }

    // Param is passed by value, moved
    pub fn set_sdr(&mut self, v: ::std::vec::Vec<::bytes::Bytes>) {
        self.sdr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sdr(&mut self) -> &mut ::std::vec::Vec<::bytes::Bytes> {
        &mut self.sdr
    }

    // Take field
    pub fn take_sdr(&mut self) -> ::std::vec::Vec<::bytes::Bytes> {
        ::std::mem::replace(&mut self.sdr, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, ctransport_signal_msg::WebRTCMessage>(
            "webrtc",
            |m: &CTransportSignalMsg| { &m.webrtc },
            |m: &mut CTransportSignalMsg| { &mut m.webrtc },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sdr",
            |m: &CTransportSignalMsg| { &m.sdr },
            |m: &mut CTransportSignalMsg| { &mut m.sdr },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CTransportSignalMsg>(
            "CTransportSignalMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CTransportSignalMsg {
    const NAME: &'static str = "CTransportSignalMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.webrtc)?;
                },
                18 => {
                    self.sdr.push(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.webrtc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.sdr {
            my_size += crate::rt::bytes_size(2, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.webrtc.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.sdr {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTransportSignalMsg {
        CTransportSignalMsg::new()
    }

    fn clear(&mut self) {
        self.webrtc.clear();
        self.sdr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTransportSignalMsg {
        static instance: CTransportSignalMsg = CTransportSignalMsg {
            webrtc: crate::MessageField::none(),
            sdr: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CTransportSignalMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CTransportSignalMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CTransportSignalMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CTransportSignalMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CTransportSignalMsg`
pub mod ctransport_signal_msg {
    // @@protoc_insertion_point(message:CTransportSignalMsg.WebRTCMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WebRTCMessage {
        // message oneof groups
        pub msg: ::std::option::Option<web_rtcmessage::Msg>,
        // special fields
        // @@protoc_insertion_point(special_field:CTransportSignalMsg.WebRTCMessage.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WebRTCMessage {
        fn default() -> &'a WebRTCMessage {
            <WebRTCMessage as crate::Message>::default_instance()
        }
    }

    impl WebRTCMessage {
        pub fn new() -> WebRTCMessage {
            ::std::default::Default::default()
        }

        // optional bool greeting = 1;

        pub fn greeting(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Greeting(v)) => v,
                _ => false,
            }
        }

        pub fn clear_greeting(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_greeting(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Greeting(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_greeting(&mut self, v: bool) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Greeting(v))
        }

        // optional string offer = 2;

        pub fn offer(&self) -> &str {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Offer(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_offer(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_offer(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Offer(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_offer(&mut self, v: ::std::string::String) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Offer(v))
        }

        // Mutable pointer to the field.
        pub fn mut_offer(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(web_rtcmessage::Msg::Offer(_)) = self.msg {
            } else {
                self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Offer(::std::string::String::new()));
            }
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Offer(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_offer(&mut self) -> ::std::string::String {
            if self.has_offer() {
                match self.msg.take() {
                    ::std::option::Option::Some(web_rtcmessage::Msg::Offer(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // optional string answer = 3;

        pub fn answer(&self) -> &str {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Answer(ref v)) => v,
                _ => "",
            }
        }

        pub fn clear_answer(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_answer(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Answer(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_answer(&mut self, v: ::std::string::String) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Answer(v))
        }

        // Mutable pointer to the field.
        pub fn mut_answer(&mut self) -> &mut ::std::string::String {
            if let ::std::option::Option::Some(web_rtcmessage::Msg::Answer(_)) = self.msg {
            } else {
                self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Answer(::std::string::String::new()));
            }
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Answer(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_answer(&mut self) -> ::std::string::String {
            if self.has_answer() {
                match self.msg.take() {
                    ::std::option::Option::Some(web_rtcmessage::Msg::Answer(v)) => v,
                    _ => panic!(),
                }
            } else {
                ::std::string::String::new()
            }
        }

        // optional .CTransportSignalMsg.WebRTCMessage.Candidate candidate = 4;

        pub fn candidate(&self) -> &web_rtcmessage::Candidate {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(ref v)) => v,
                _ => <web_rtcmessage::Candidate as crate::Message>::default_instance(),
            }
        }

        pub fn clear_candidate(&mut self) {
            self.msg = ::std::option::Option::None;
        }

        pub fn has_candidate(&self) -> bool {
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(..)) => true,
                _ => false,
            }
        }

        // Param is passed by value, moved
        pub fn set_candidate(&mut self, v: web_rtcmessage::Candidate) {
            self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(v))
        }

        // Mutable pointer to the field.
        pub fn mut_candidate(&mut self) -> &mut web_rtcmessage::Candidate {
            if let ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(_)) = self.msg {
            } else {
                self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(web_rtcmessage::Candidate::new()));
            }
            match self.msg {
                ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(ref mut v)) => v,
                _ => panic!(),
            }
        }

        // Take field
        pub fn take_candidate(&mut self) -> web_rtcmessage::Candidate {
            if self.has_candidate() {
                match self.msg.take() {
                    ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(v)) => v,
                    _ => panic!(),
                }
            } else {
                web_rtcmessage::Candidate::new()
            }
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(1);
            fields.push(crate::reflect::rt::v2::make_oneof_copy_has_get_set_simpler_accessors::<_, _>(
                "greeting",
                WebRTCMessage::has_greeting,
                WebRTCMessage::greeting,
                WebRTCMessage::set_greeting,
            ));
            fields.push(crate::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                "offer",
                WebRTCMessage::has_offer,
                WebRTCMessage::offer,
                WebRTCMessage::set_offer,
            ));
            fields.push(crate::reflect::rt::v2::make_oneof_deref_has_get_set_simpler_accessor::<_, _>(
                "answer",
                WebRTCMessage::has_answer,
                WebRTCMessage::answer,
                WebRTCMessage::set_answer,
            ));
            fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, web_rtcmessage::Candidate>(
                "candidate",
                WebRTCMessage::has_candidate,
                WebRTCMessage::candidate,
                WebRTCMessage::mut_candidate,
                WebRTCMessage::set_candidate,
            ));
            oneofs.push(web_rtcmessage::Msg::generated_oneof_descriptor_data());
            crate::reflect::GeneratedMessageDescriptorData::new_2::<WebRTCMessage>(
                "CTransportSignalMsg.WebRTCMessage",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for WebRTCMessage {
        const NAME: &'static str = "WebRTCMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Greeting(is.read_bool()?));
                    },
                    18 => {
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Offer(is.read_string()?));
                    },
                    26 => {
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Answer(is.read_string()?));
                    },
                    34 => {
                        self.msg = ::std::option::Option::Some(web_rtcmessage::Msg::Candidate(is.read_message()?));
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let ::std::option::Option::Some(ref v) = self.msg {
                match v {
                    &web_rtcmessage::Msg::Greeting(v) => {
                        my_size += 1 + 1;
                    },
                    &web_rtcmessage::Msg::Offer(ref v) => {
                        my_size += crate::rt::string_size(2, &v);
                    },
                    &web_rtcmessage::Msg::Answer(ref v) => {
                        my_size += crate::rt::string_size(3, &v);
                    },
                    &web_rtcmessage::Msg::Candidate(ref v) => {
                        let len = v.compute_size();
                        my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                    },
                };
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let ::std::option::Option::Some(ref v) = self.msg {
                match v {
                    &web_rtcmessage::Msg::Greeting(v) => {
                        os.write_bool(1, v)?;
                    },
                    &web_rtcmessage::Msg::Offer(ref v) => {
                        os.write_string(2, v)?;
                    },
                    &web_rtcmessage::Msg::Answer(ref v) => {
                        os.write_string(3, v)?;
                    },
                    &web_rtcmessage::Msg::Candidate(ref v) => {
                        crate::rt::write_message_field_with_cached_size(4, v, os)?;
                    },
                };
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WebRTCMessage {
            WebRTCMessage::new()
        }

        fn clear(&mut self) {
            self.msg = ::std::option::Option::None;
            self.msg = ::std::option::Option::None;
            self.msg = ::std::option::Option::None;
            self.msg = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WebRTCMessage {
            static instance: WebRTCMessage = WebRTCMessage {
                msg: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for WebRTCMessage {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CTransportSignalMsg.WebRTCMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for WebRTCMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for WebRTCMessage {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `WebRTCMessage`
    pub mod web_rtcmessage {

        #[derive(Clone,PartialEq,Debug)]
        #[non_exhaustive]
        // @@protoc_insertion_point(oneof:CTransportSignalMsg.WebRTCMessage.msg)
        pub enum Msg {
            // @@protoc_insertion_point(oneof_field:CTransportSignalMsg.WebRTCMessage.greeting)
            Greeting(bool),
            // @@protoc_insertion_point(oneof_field:CTransportSignalMsg.WebRTCMessage.offer)
            Offer(::std::string::String),
            // @@protoc_insertion_point(oneof_field:CTransportSignalMsg.WebRTCMessage.answer)
            Answer(::std::string::String),
            // @@protoc_insertion_point(oneof_field:CTransportSignalMsg.WebRTCMessage.candidate)
            Candidate(Candidate),
        }

        impl crate::Oneof for Msg {
        }

        impl crate::OneofFull for Msg {
            fn descriptor() -> crate::reflect::OneofDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::OneofDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| <super::WebRTCMessage as crate::MessageFull>::descriptor().oneof_by_name("msg").unwrap()).clone()
            }
        }

        impl Msg {
            pub(in super::super) fn generated_oneof_descriptor_data() -> crate::reflect::GeneratedOneofDescriptorData {
                crate::reflect::GeneratedOneofDescriptorData::new::<Msg>("msg")
            }
        }
        // @@protoc_insertion_point(message:CTransportSignalMsg.WebRTCMessage.Candidate)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Candidate {
            // message fields
            // @@protoc_insertion_point(field:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mid)
            pub sdp_mid: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mline_index)
            pub sdp_mline_index: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CTransportSignalMsg.WebRTCMessage.Candidate.candidate)
            pub candidate: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CTransportSignalMsg.WebRTCMessage.Candidate.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Candidate {
            fn default() -> &'a Candidate {
                <Candidate as crate::Message>::default_instance()
            }
        }

        impl Candidate {
            pub fn new() -> Candidate {
                ::std::default::Default::default()
            }

            // optional string sdp_mid = 1;

            pub fn sdp_mid(&self) -> &str {
                match self.sdp_mid.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_sdp_mid(&mut self) {
                self.sdp_mid = ::std::option::Option::None;
            }

            pub fn has_sdp_mid(&self) -> bool {
                self.sdp_mid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_sdp_mid(&mut self, v: ::std::string::String) {
                self.sdp_mid = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_sdp_mid(&mut self) -> &mut ::std::string::String {
                if self.sdp_mid.is_none() {
                    self.sdp_mid = ::std::option::Option::Some(::std::string::String::new());
                }
                self.sdp_mid.as_mut().unwrap()
            }

            // Take field
            pub fn take_sdp_mid(&mut self) -> ::std::string::String {
                self.sdp_mid.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional int32 sdp_mline_index = 2;

            pub fn sdp_mline_index(&self) -> i32 {
                self.sdp_mline_index.unwrap_or(0)
            }

            pub fn clear_sdp_mline_index(&mut self) {
                self.sdp_mline_index = ::std::option::Option::None;
            }

            pub fn has_sdp_mline_index(&self) -> bool {
                self.sdp_mline_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_sdp_mline_index(&mut self, v: i32) {
                self.sdp_mline_index = ::std::option::Option::Some(v);
            }

            // optional string candidate = 3;

            pub fn candidate(&self) -> &str {
                match self.candidate.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_candidate(&mut self) {
                self.candidate = ::std::option::Option::None;
            }

            pub fn has_candidate(&self) -> bool {
                self.candidate.is_some()
            }

            // Param is passed by value, moved
            pub fn set_candidate(&mut self, v: ::std::string::String) {
                self.candidate = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
                if self.candidate.is_none() {
                    self.candidate = ::std::option::Option::Some(::std::string::String::new());
                }
                self.candidate.as_mut().unwrap()
            }

            // Take field
            pub fn take_candidate(&mut self) -> ::std::string::String {
                self.candidate.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "sdp_mid",
                    |m: &Candidate| { &m.sdp_mid },
                    |m: &mut Candidate| { &mut m.sdp_mid },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "sdp_mline_index",
                    |m: &Candidate| { &m.sdp_mline_index },
                    |m: &mut Candidate| { &mut m.sdp_mline_index },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "candidate",
                    |m: &Candidate| { &m.candidate },
                    |m: &mut Candidate| { &mut m.candidate },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<Candidate>(
                    "CTransportSignalMsg.WebRTCMessage.Candidate",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for Candidate {
            const NAME: &'static str = "Candidate";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.sdp_mid = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.sdp_mline_index = ::std::option::Option::Some(is.read_int32()?);
                        },
                        26 => {
                            self.candidate = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.sdp_mid.as_ref() {
                    my_size += crate::rt::string_size(1, &v);
                }
                if let Some(v) = self.sdp_mline_index {
                    my_size += crate::rt::int32_size(2, v);
                }
                if let Some(v) = self.candidate.as_ref() {
                    my_size += crate::rt::string_size(3, &v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.sdp_mid.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.sdp_mline_index {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.candidate.as_ref() {
                    os.write_string(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Candidate {
                Candidate::new()
            }

            fn clear(&mut self) {
                self.sdp_mid = ::std::option::Option::None;
                self.sdp_mline_index = ::std::option::Option::None;
                self.candidate = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Candidate {
                static instance: Candidate = Candidate {
                    sdp_mid: ::std::option::Option::None,
                    sdp_mline_index: ::std::option::Option::None,
                    candidate: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for Candidate {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CTransportSignalMsg.WebRTCMessage.Candidate").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Candidate {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for Candidate {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CControllerConfigMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CControllerConfigMsg {
    // message fields
    // @@protoc_insertion_point(field:CControllerConfigMsg.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<EStreamControllerConfigMsg>>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.controllerPath)
    pub controllerPath: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.personalizationResponse)
    pub personalizationResponse: crate::MessageField<ccontroller_config_msg::ControllerPersonalizationResponse>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.configResponse)
    pub configResponse: ::std::vec::Vec<ccontroller_config_msg::ControllerConfigResponse>,
    // @@protoc_insertion_point(field:CControllerConfigMsg.activeConfigChangeMsg)
    pub activeConfigChangeMsg: crate::MessageField<ccontroller_config_msg::ControllerActiveConfigMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CControllerConfigMsg.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CControllerConfigMsg {
    fn default() -> &'a CControllerConfigMsg {
        <CControllerConfigMsg as crate::Message>::default_instance()
    }
}

impl CControllerConfigMsg {
    pub fn new() -> CControllerConfigMsg {
        ::std::default::Default::default()
    }

    // required .EStreamControllerConfigMsg type = 1;

    pub fn type_(&self) -> EStreamControllerConfigMsg {
        match self.type_ {
            Some(e) => e.enum_value_or(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp),
            None => EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EStreamControllerConfigMsg) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string controllerPath = 2;

    pub fn controllerPath(&self) -> &str {
        match self.controllerPath.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_controllerPath(&mut self) {
        self.controllerPath = ::std::option::Option::None;
    }

    pub fn has_controllerPath(&self) -> bool {
        self.controllerPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controllerPath(&mut self, v: ::std::string::String) {
        self.controllerPath = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controllerPath(&mut self) -> &mut ::std::string::String {
        if self.controllerPath.is_none() {
            self.controllerPath = ::std::option::Option::Some(::std::string::String::new());
        }
        self.controllerPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_controllerPath(&mut self) -> ::std::string::String {
        self.controllerPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 3;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional .CControllerConfigMsg.ControllerPersonalizationResponse personalizationResponse = 4;

    pub fn personalizationResponse(&self) -> &ccontroller_config_msg::ControllerPersonalizationResponse {
        self.personalizationResponse.as_ref().unwrap_or_else(|| <ccontroller_config_msg::ControllerPersonalizationResponse as crate::Message>::default_instance())
    }

    pub fn clear_personalizationResponse(&mut self) {
        self.personalizationResponse.clear();
    }

    pub fn has_personalizationResponse(&self) -> bool {
        self.personalizationResponse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_personalizationResponse(&mut self, v: ccontroller_config_msg::ControllerPersonalizationResponse) {
        self.personalizationResponse = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_personalizationResponse(&mut self) -> &mut ccontroller_config_msg::ControllerPersonalizationResponse {
        self.personalizationResponse.mut_or_insert_default()
    }

    // Take field
    pub fn take_personalizationResponse(&mut self) -> ccontroller_config_msg::ControllerPersonalizationResponse {
        self.personalizationResponse.take().unwrap_or_else(|| ccontroller_config_msg::ControllerPersonalizationResponse::new())
    }

    // repeated .CControllerConfigMsg.ControllerConfigResponse configResponse = 6;

    pub fn configResponse(&self) -> &[ccontroller_config_msg::ControllerConfigResponse] {
        &self.configResponse
    }

    pub fn clear_configResponse(&mut self) {
        self.configResponse.clear();
    }

    // Param is passed by value, moved
    pub fn set_configResponse(&mut self, v: ::std::vec::Vec<ccontroller_config_msg::ControllerConfigResponse>) {
        self.configResponse = v;
    }

    // Mutable pointer to the field.
    pub fn mut_configResponse(&mut self) -> &mut ::std::vec::Vec<ccontroller_config_msg::ControllerConfigResponse> {
        &mut self.configResponse
    }

    // Take field
    pub fn take_configResponse(&mut self) -> ::std::vec::Vec<ccontroller_config_msg::ControllerConfigResponse> {
        ::std::mem::replace(&mut self.configResponse, ::std::vec::Vec::new())
    }

    // optional .CControllerConfigMsg.ControllerActiveConfigMsg activeConfigChangeMsg = 7;

    pub fn activeConfigChangeMsg(&self) -> &ccontroller_config_msg::ControllerActiveConfigMsg {
        self.activeConfigChangeMsg.as_ref().unwrap_or_else(|| <ccontroller_config_msg::ControllerActiveConfigMsg as crate::Message>::default_instance())
    }

    pub fn clear_activeConfigChangeMsg(&mut self) {
        self.activeConfigChangeMsg.clear();
    }

    pub fn has_activeConfigChangeMsg(&self) -> bool {
        self.activeConfigChangeMsg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activeConfigChangeMsg(&mut self, v: ccontroller_config_msg::ControllerActiveConfigMsg) {
        self.activeConfigChangeMsg = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_activeConfigChangeMsg(&mut self) -> &mut ccontroller_config_msg::ControllerActiveConfigMsg {
        self.activeConfigChangeMsg.mut_or_insert_default()
    }

    // Take field
    pub fn take_activeConfigChangeMsg(&mut self) -> ccontroller_config_msg::ControllerActiveConfigMsg {
        self.activeConfigChangeMsg.take().unwrap_or_else(|| ccontroller_config_msg::ControllerActiveConfigMsg::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CControllerConfigMsg| { &m.type_ },
            |m: &mut CControllerConfigMsg| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "controllerPath",
            |m: &CControllerConfigMsg| { &m.controllerPath },
            |m: &mut CControllerConfigMsg| { &mut m.controllerPath },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CControllerConfigMsg| { &m.appid },
            |m: &mut CControllerConfigMsg| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, ccontroller_config_msg::ControllerPersonalizationResponse>(
            "personalizationResponse",
            |m: &CControllerConfigMsg| { &m.personalizationResponse },
            |m: &mut CControllerConfigMsg| { &mut m.personalizationResponse },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "configResponse",
            |m: &CControllerConfigMsg| { &m.configResponse },
            |m: &mut CControllerConfigMsg| { &mut m.configResponse },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, ccontroller_config_msg::ControllerActiveConfigMsg>(
            "activeConfigChangeMsg",
            |m: &CControllerConfigMsg| { &m.activeConfigChangeMsg },
            |m: &mut CControllerConfigMsg| { &mut m.activeConfigChangeMsg },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CControllerConfigMsg>(
            "CControllerConfigMsg",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CControllerConfigMsg {
    const NAME: &'static str = "CControllerConfigMsg";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        for v in &self.personalizationResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configResponse {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.activeConfigChangeMsg {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.controllerPath = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.personalizationResponse)?;
                },
                50 => {
                    self.configResponse.push(is.read_message()?);
                },
                58 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.activeConfigChangeMsg)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.controllerPath.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.personalizationResponse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.configResponse {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.activeConfigChangeMsg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.controllerPath.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.personalizationResponse.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.configResponse {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.activeConfigChangeMsg.as_ref() {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CControllerConfigMsg {
        CControllerConfigMsg::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.controllerPath = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.personalizationResponse.clear();
        self.configResponse.clear();
        self.activeConfigChangeMsg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CControllerConfigMsg {
        static instance: CControllerConfigMsg = CControllerConfigMsg {
            type_: ::std::option::Option::None,
            controllerPath: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            personalizationResponse: crate::MessageField::none(),
            configResponse: ::std::vec::Vec::new(),
            activeConfigChangeMsg: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CControllerConfigMsg {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CControllerConfigMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CControllerConfigMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CControllerConfigMsg {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CControllerConfigMsg`
pub mod ccontroller_config_msg {
    // @@protoc_insertion_point(message:CControllerConfigMsg.ControllerConfigResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ControllerConfigResponse {
        // message fields
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.configURL)
        pub configURL: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.controllerType)
        pub controllerType: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.controllerData)
        pub controllerData: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.selectionOrder)
        pub selectionOrder: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerConfigResponse.actionBlock)
        pub actionBlock: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CControllerConfigMsg.ControllerConfigResponse.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControllerConfigResponse {
        fn default() -> &'a ControllerConfigResponse {
            <ControllerConfigResponse as crate::Message>::default_instance()
        }
    }

    impl ControllerConfigResponse {
        pub fn new() -> ControllerConfigResponse {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string configURL = 2;

        pub fn configURL(&self) -> &str {
            match self.configURL.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_configURL(&mut self) {
            self.configURL = ::std::option::Option::None;
        }

        pub fn has_configURL(&self) -> bool {
            self.configURL.is_some()
        }

        // Param is passed by value, moved
        pub fn set_configURL(&mut self, v: ::std::string::String) {
            self.configURL = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_configURL(&mut self) -> &mut ::std::string::String {
            if self.configURL.is_none() {
                self.configURL = ::std::option::Option::Some(::std::string::String::new());
            }
            self.configURL.as_mut().unwrap()
        }

        // Take field
        pub fn take_configURL(&mut self) -> ::std::string::String {
            self.configURL.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 controllerType = 3;

        pub fn controllerType(&self) -> u32 {
            self.controllerType.unwrap_or(0)
        }

        pub fn clear_controllerType(&mut self) {
            self.controllerType = ::std::option::Option::None;
        }

        pub fn has_controllerType(&self) -> bool {
            self.controllerType.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerType(&mut self, v: u32) {
            self.controllerType = ::std::option::Option::Some(v);
        }

        // optional string controllerData = 4;

        pub fn controllerData(&self) -> &str {
            match self.controllerData.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_controllerData(&mut self) {
            self.controllerData = ::std::option::Option::None;
        }

        pub fn has_controllerData(&self) -> bool {
            self.controllerData.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerData(&mut self, v: ::std::string::String) {
            self.controllerData = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_controllerData(&mut self) -> &mut ::std::string::String {
            if self.controllerData.is_none() {
                self.controllerData = ::std::option::Option::Some(::std::string::String::new());
            }
            self.controllerData.as_mut().unwrap()
        }

        // Take field
        pub fn take_controllerData(&mut self) -> ::std::string::String {
            self.controllerData.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 selectionOrder = 5;

        pub fn selectionOrder(&self) -> u32 {
            self.selectionOrder.unwrap_or(0)
        }

        pub fn clear_selectionOrder(&mut self) {
            self.selectionOrder = ::std::option::Option::None;
        }

        pub fn has_selectionOrder(&self) -> bool {
            self.selectionOrder.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selectionOrder(&mut self, v: u32) {
            self.selectionOrder = ::std::option::Option::Some(v);
        }

        // optional bool actionBlock = 6;

        pub fn actionBlock(&self) -> bool {
            self.actionBlock.unwrap_or(false)
        }

        pub fn clear_actionBlock(&mut self) {
            self.actionBlock = ::std::option::Option::None;
        }

        pub fn has_actionBlock(&self) -> bool {
            self.actionBlock.is_some()
        }

        // Param is passed by value, moved
        pub fn set_actionBlock(&mut self, v: bool) {
            self.actionBlock = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &ControllerConfigResponse| { &m.appid },
                |m: &mut ControllerConfigResponse| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "configURL",
                |m: &ControllerConfigResponse| { &m.configURL },
                |m: &mut ControllerConfigResponse| { &mut m.configURL },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controllerType",
                |m: &ControllerConfigResponse| { &m.controllerType },
                |m: &mut ControllerConfigResponse| { &mut m.controllerType },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controllerData",
                |m: &ControllerConfigResponse| { &m.controllerData },
                |m: &mut ControllerConfigResponse| { &mut m.controllerData },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "selectionOrder",
                |m: &ControllerConfigResponse| { &m.selectionOrder },
                |m: &mut ControllerConfigResponse| { &mut m.selectionOrder },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "actionBlock",
                |m: &ControllerConfigResponse| { &m.actionBlock },
                |m: &mut ControllerConfigResponse| { &mut m.actionBlock },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ControllerConfigResponse>(
                "CControllerConfigMsg.ControllerConfigResponse",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ControllerConfigResponse {
        const NAME: &'static str = "ControllerConfigResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.configURL = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.controllerType = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.controllerData = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.selectionOrder = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.actionBlock = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.configURL.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.controllerType {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.controllerData.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.selectionOrder {
                my_size += crate::rt::uint32_size(5, v);
            }
            if let Some(v) = self.actionBlock {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.configURL.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.controllerType {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.controllerData.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.selectionOrder {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.actionBlock {
                os.write_bool(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControllerConfigResponse {
            ControllerConfigResponse::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.configURL = ::std::option::Option::None;
            self.controllerType = ::std::option::Option::None;
            self.controllerData = ::std::option::Option::None;
            self.selectionOrder = ::std::option::Option::None;
            self.actionBlock = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControllerConfigResponse {
            static instance: ControllerConfigResponse = ControllerConfigResponse {
                appid: ::std::option::Option::None,
                configURL: ::std::option::Option::None,
                controllerType: ::std::option::Option::None,
                controllerData: ::std::option::Option::None,
                selectionOrder: ::std::option::Option::None,
                actionBlock: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ControllerConfigResponse {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CControllerConfigMsg.ControllerConfigResponse").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ControllerConfigResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ControllerConfigResponse {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CControllerConfigMsg.ControllerPersonalizationResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ControllerPersonalizationResponse {
        // message fields
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerPersonalizationResponse.personalizationData)
        pub personalizationData: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CControllerConfigMsg.ControllerPersonalizationResponse.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControllerPersonalizationResponse {
        fn default() -> &'a ControllerPersonalizationResponse {
            <ControllerPersonalizationResponse as crate::Message>::default_instance()
        }
    }

    impl ControllerPersonalizationResponse {
        pub fn new() -> ControllerPersonalizationResponse {
            ::std::default::Default::default()
        }

        // optional string personalizationData = 1;

        pub fn personalizationData(&self) -> &str {
            match self.personalizationData.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_personalizationData(&mut self) {
            self.personalizationData = ::std::option::Option::None;
        }

        pub fn has_personalizationData(&self) -> bool {
            self.personalizationData.is_some()
        }

        // Param is passed by value, moved
        pub fn set_personalizationData(&mut self, v: ::std::string::String) {
            self.personalizationData = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_personalizationData(&mut self) -> &mut ::std::string::String {
            if self.personalizationData.is_none() {
                self.personalizationData = ::std::option::Option::Some(::std::string::String::new());
            }
            self.personalizationData.as_mut().unwrap()
        }

        // Take field
        pub fn take_personalizationData(&mut self) -> ::std::string::String {
            self.personalizationData.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "personalizationData",
                |m: &ControllerPersonalizationResponse| { &m.personalizationData },
                |m: &mut ControllerPersonalizationResponse| { &mut m.personalizationData },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ControllerPersonalizationResponse>(
                "CControllerConfigMsg.ControllerPersonalizationResponse",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ControllerPersonalizationResponse {
        const NAME: &'static str = "ControllerPersonalizationResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.personalizationData = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.personalizationData.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.personalizationData.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControllerPersonalizationResponse {
            ControllerPersonalizationResponse::new()
        }

        fn clear(&mut self) {
            self.personalizationData = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControllerPersonalizationResponse {
            static instance: ControllerPersonalizationResponse = ControllerPersonalizationResponse {
                personalizationData: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ControllerPersonalizationResponse {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CControllerConfigMsg.ControllerPersonalizationResponse").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ControllerPersonalizationResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ControllerPersonalizationResponse {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ControllerActiveConfigChangeResponse {
        // message fields
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.configURL)
        pub configURL: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerType)
        pub controllerType: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerData)
        pub controllerData: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.selectionOrder)
        pub selectionOrder: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CControllerConfigMsg.ControllerActiveConfigChangeResponse.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControllerActiveConfigChangeResponse {
        fn default() -> &'a ControllerActiveConfigChangeResponse {
            <ControllerActiveConfigChangeResponse as crate::Message>::default_instance()
        }
    }

    impl ControllerActiveConfigChangeResponse {
        pub fn new() -> ControllerActiveConfigChangeResponse {
            ::std::default::Default::default()
        }

        // optional string configURL = 2;

        pub fn configURL(&self) -> &str {
            match self.configURL.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_configURL(&mut self) {
            self.configURL = ::std::option::Option::None;
        }

        pub fn has_configURL(&self) -> bool {
            self.configURL.is_some()
        }

        // Param is passed by value, moved
        pub fn set_configURL(&mut self, v: ::std::string::String) {
            self.configURL = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_configURL(&mut self) -> &mut ::std::string::String {
            if self.configURL.is_none() {
                self.configURL = ::std::option::Option::Some(::std::string::String::new());
            }
            self.configURL.as_mut().unwrap()
        }

        // Take field
        pub fn take_configURL(&mut self) -> ::std::string::String {
            self.configURL.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 controllerType = 3;

        pub fn controllerType(&self) -> u32 {
            self.controllerType.unwrap_or(0)
        }

        pub fn clear_controllerType(&mut self) {
            self.controllerType = ::std::option::Option::None;
        }

        pub fn has_controllerType(&self) -> bool {
            self.controllerType.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerType(&mut self, v: u32) {
            self.controllerType = ::std::option::Option::Some(v);
        }

        // optional string controllerData = 4;

        pub fn controllerData(&self) -> &str {
            match self.controllerData.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_controllerData(&mut self) {
            self.controllerData = ::std::option::Option::None;
        }

        pub fn has_controllerData(&self) -> bool {
            self.controllerData.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerData(&mut self, v: ::std::string::String) {
            self.controllerData = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_controllerData(&mut self) -> &mut ::std::string::String {
            if self.controllerData.is_none() {
                self.controllerData = ::std::option::Option::Some(::std::string::String::new());
            }
            self.controllerData.as_mut().unwrap()
        }

        // Take field
        pub fn take_controllerData(&mut self) -> ::std::string::String {
            self.controllerData.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 selectionOrder = 5;

        pub fn selectionOrder(&self) -> u32 {
            self.selectionOrder.unwrap_or(0)
        }

        pub fn clear_selectionOrder(&mut self) {
            self.selectionOrder = ::std::option::Option::None;
        }

        pub fn has_selectionOrder(&self) -> bool {
            self.selectionOrder.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selectionOrder(&mut self, v: u32) {
            self.selectionOrder = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "configURL",
                |m: &ControllerActiveConfigChangeResponse| { &m.configURL },
                |m: &mut ControllerActiveConfigChangeResponse| { &mut m.configURL },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controllerType",
                |m: &ControllerActiveConfigChangeResponse| { &m.controllerType },
                |m: &mut ControllerActiveConfigChangeResponse| { &mut m.controllerType },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controllerData",
                |m: &ControllerActiveConfigChangeResponse| { &m.controllerData },
                |m: &mut ControllerActiveConfigChangeResponse| { &mut m.controllerData },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "selectionOrder",
                |m: &ControllerActiveConfigChangeResponse| { &m.selectionOrder },
                |m: &mut ControllerActiveConfigChangeResponse| { &mut m.selectionOrder },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ControllerActiveConfigChangeResponse>(
                "CControllerConfigMsg.ControllerActiveConfigChangeResponse",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ControllerActiveConfigChangeResponse {
        const NAME: &'static str = "ControllerActiveConfigChangeResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        self.configURL = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.controllerType = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.controllerData = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.selectionOrder = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.configURL.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.controllerType {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.controllerData.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.selectionOrder {
                my_size += crate::rt::uint32_size(5, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.configURL.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.controllerType {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.controllerData.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.selectionOrder {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControllerActiveConfigChangeResponse {
            ControllerActiveConfigChangeResponse::new()
        }

        fn clear(&mut self) {
            self.configURL = ::std::option::Option::None;
            self.controllerType = ::std::option::Option::None;
            self.controllerData = ::std::option::Option::None;
            self.selectionOrder = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControllerActiveConfigChangeResponse {
            static instance: ControllerActiveConfigChangeResponse = ControllerActiveConfigChangeResponse {
                configURL: ::std::option::Option::None,
                controllerType: ::std::option::Option::None,
                controllerData: ::std::option::Option::None,
                selectionOrder: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ControllerActiveConfigChangeResponse {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CControllerConfigMsg.ControllerActiveConfigChangeResponse").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ControllerActiveConfigChangeResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ControllerActiveConfigChangeResponse {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CControllerConfigMsg.ControllerActiveConfigMsg)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ControllerActiveConfigMsg {
        // message fields
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigMsg.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigMsg.configURL)
        pub configURL: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigMsg.controllerType)
        pub controllerType: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CControllerConfigMsg.ControllerActiveConfigMsg.controllerData)
        pub controllerData: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CControllerConfigMsg.ControllerActiveConfigMsg.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ControllerActiveConfigMsg {
        fn default() -> &'a ControllerActiveConfigMsg {
            <ControllerActiveConfigMsg as crate::Message>::default_instance()
        }
    }

    impl ControllerActiveConfigMsg {
        pub fn new() -> ControllerActiveConfigMsg {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional string configURL = 2;

        pub fn configURL(&self) -> &str {
            match self.configURL.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_configURL(&mut self) {
            self.configURL = ::std::option::Option::None;
        }

        pub fn has_configURL(&self) -> bool {
            self.configURL.is_some()
        }

        // Param is passed by value, moved
        pub fn set_configURL(&mut self, v: ::std::string::String) {
            self.configURL = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_configURL(&mut self) -> &mut ::std::string::String {
            if self.configURL.is_none() {
                self.configURL = ::std::option::Option::Some(::std::string::String::new());
            }
            self.configURL.as_mut().unwrap()
        }

        // Take field
        pub fn take_configURL(&mut self) -> ::std::string::String {
            self.configURL.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 controllerType = 3;

        pub fn controllerType(&self) -> u32 {
            self.controllerType.unwrap_or(0)
        }

        pub fn clear_controllerType(&mut self) {
            self.controllerType = ::std::option::Option::None;
        }

        pub fn has_controllerType(&self) -> bool {
            self.controllerType.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerType(&mut self, v: u32) {
            self.controllerType = ::std::option::Option::Some(v);
        }

        // optional string controllerData = 4;

        pub fn controllerData(&self) -> &str {
            match self.controllerData.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_controllerData(&mut self) {
            self.controllerData = ::std::option::Option::None;
        }

        pub fn has_controllerData(&self) -> bool {
            self.controllerData.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controllerData(&mut self, v: ::std::string::String) {
            self.controllerData = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_controllerData(&mut self) -> &mut ::std::string::String {
            if self.controllerData.is_none() {
                self.controllerData = ::std::option::Option::Some(::std::string::String::new());
            }
            self.controllerData.as_mut().unwrap()
        }

        // Take field
        pub fn take_controllerData(&mut self) -> ::std::string::String {
            self.controllerData.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &ControllerActiveConfigMsg| { &m.appid },
                |m: &mut ControllerActiveConfigMsg| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "configURL",
                |m: &ControllerActiveConfigMsg| { &m.configURL },
                |m: &mut ControllerActiveConfigMsg| { &mut m.configURL },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controllerType",
                |m: &ControllerActiveConfigMsg| { &m.controllerType },
                |m: &mut ControllerActiveConfigMsg| { &mut m.controllerType },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controllerData",
                |m: &ControllerActiveConfigMsg| { &m.controllerData },
                |m: &mut ControllerActiveConfigMsg| { &mut m.controllerData },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ControllerActiveConfigMsg>(
                "CControllerConfigMsg.ControllerActiveConfigMsg",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ControllerActiveConfigMsg {
        const NAME: &'static str = "ControllerActiveConfigMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.configURL = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.controllerType = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.controllerData = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.configURL.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.controllerType {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.controllerData.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.configURL.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.controllerType {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.controllerData.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ControllerActiveConfigMsg {
            ControllerActiveConfigMsg::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.configURL = ::std::option::Option::None;
            self.controllerType = ::std::option::Option::None;
            self.controllerData = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ControllerActiveConfigMsg {
            static instance: ControllerActiveConfigMsg = ControllerActiveConfigMsg {
                appid: ::std::option::Option::None,
                configURL: ::std::option::Option::None,
                controllerType: ::std::option::Option::None,
                controllerData: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ControllerActiveConfigMsg {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CControllerConfigMsg.ControllerActiveConfigMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ControllerActiveConfigMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ControllerActiveConfigMsg {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamChannel)
pub enum EStreamChannel {
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelInvalid)
    k_EStreamChannelInvalid = -1,
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelDiscovery)
    k_EStreamChannelDiscovery = 0,
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelControl)
    k_EStreamChannelControl = 1,
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelStats)
    k_EStreamChannelStats = 2,
    // @@protoc_insertion_point(enum_value:EStreamChannel.k_EStreamChannelDataChannelStart)
    k_EStreamChannelDataChannelStart = 3,
}

impl crate::Enum for EStreamChannel {
    const NAME: &'static str = "EStreamChannel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamChannel> {
        match value {
            -1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelInvalid),
            0 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDiscovery),
            1 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelControl),
            2 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelStats),
            3 => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDataChannelStart),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamChannel> {
        match str {
            "k_EStreamChannelInvalid" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelInvalid),
            "k_EStreamChannelDiscovery" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDiscovery),
            "k_EStreamChannelControl" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelControl),
            "k_EStreamChannelStats" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelStats),
            "k_EStreamChannelDataChannelStart" => ::std::option::Option::Some(EStreamChannel::k_EStreamChannelDataChannelStart),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamChannel] = &[
        EStreamChannel::k_EStreamChannelInvalid,
        EStreamChannel::k_EStreamChannelDiscovery,
        EStreamChannel::k_EStreamChannelControl,
        EStreamChannel::k_EStreamChannelStats,
        EStreamChannel::k_EStreamChannelDataChannelStart,
    ];
}

impl crate::EnumFull for EStreamChannel {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamChannel").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamChannel::k_EStreamChannelInvalid => 0,
            EStreamChannel::k_EStreamChannelDiscovery => 1,
            EStreamChannel::k_EStreamChannelControl => 2,
            EStreamChannel::k_EStreamChannelStats => 3,
            EStreamChannel::k_EStreamChannelDataChannelStart => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamChannel {
    fn default() -> Self {
        EStreamChannel::k_EStreamChannelInvalid
    }
}

impl EStreamChannel {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamChannel>("EStreamChannel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamDiscoveryMessage)
pub enum EStreamDiscoveryMessage {
    // @@protoc_insertion_point(enum_value:EStreamDiscoveryMessage.k_EStreamDiscoveryPingRequest)
    k_EStreamDiscoveryPingRequest = 1,
    // @@protoc_insertion_point(enum_value:EStreamDiscoveryMessage.k_EStreamDiscoveryPingResponse)
    k_EStreamDiscoveryPingResponse = 2,
}

impl crate::Enum for EStreamDiscoveryMessage {
    const NAME: &'static str = "EStreamDiscoveryMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDiscoveryMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest),
            2 => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamDiscoveryMessage> {
        match str {
            "k_EStreamDiscoveryPingRequest" => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest),
            "k_EStreamDiscoveryPingResponse" => ::std::option::Option::Some(EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamDiscoveryMessage] = &[
        EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest,
        EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse,
    ];
}

impl crate::EnumFull for EStreamDiscoveryMessage {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamDiscoveryMessage").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest => 0,
            EStreamDiscoveryMessage::k_EStreamDiscoveryPingResponse => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamDiscoveryMessage {
    fn default() -> Self {
        EStreamDiscoveryMessage::k_EStreamDiscoveryPingRequest
    }
}

impl EStreamDiscoveryMessage {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamDiscoveryMessage>("EStreamDiscoveryMessage")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamControlMessage)
pub enum EStreamControlMessage {
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlAuthenticationRequest)
    k_EStreamControlAuthenticationRequest = 1,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlAuthenticationResponse)
    k_EStreamControlAuthenticationResponse = 2,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlNegotiationInit)
    k_EStreamControlNegotiationInit = 3,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlNegotiationSetConfig)
    k_EStreamControlNegotiationSetConfig = 4,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlNegotiationComplete)
    k_EStreamControlNegotiationComplete = 5,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlClientHandshake)
    k_EStreamControlClientHandshake = 6,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlServerHandshake)
    k_EStreamControlServerHandshake = 7,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartNetworkTest)
    k_EStreamControlStartNetworkTest = 8,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlKeepAlive)
    k_EStreamControlKeepAlive = 9,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControl_LAST_SETUP_MESSAGE)
    k_EStreamControl_LAST_SETUP_MESSAGE = 15,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartAudioData)
    k_EStreamControlStartAudioData = 50,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopAudioData)
    k_EStreamControlStopAudioData = 51,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartVideoData)
    k_EStreamControlStartVideoData = 52,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopVideoData)
    k_EStreamControlStopVideoData = 53,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputMouseMotion)
    k_EStreamControlInputMouseMotion = 54,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputMouseWheel)
    k_EStreamControlInputMouseWheel = 55,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputMouseDown)
    k_EStreamControlInputMouseDown = 56,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputMouseUp)
    k_EStreamControlInputMouseUp = 57,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputKeyDown)
    k_EStreamControlInputKeyDown = 58,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputKeyUp)
    k_EStreamControlInputKeyUp = 59,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputGamepadAttached_OBSOLETE)
    k_EStreamControlInputGamepadAttached_OBSOLETE = 60,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputGamepadEvent_OBSOLETE)
    k_EStreamControlInputGamepadEvent_OBSOLETE = 61,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputGamepadDetached_OBSOLETE)
    k_EStreamControlInputGamepadDetached_OBSOLETE = 62,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlShowCursor)
    k_EStreamControlShowCursor = 63,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlHideCursor)
    k_EStreamControlHideCursor = 64,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetCursor)
    k_EStreamControlSetCursor = 65,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlGetCursorImage)
    k_EStreamControlGetCursorImage = 66,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetCursorImage)
    k_EStreamControlSetCursorImage = 67,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlDeleteCursor)
    k_EStreamControlDeleteCursor = 68,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTargetFramerate)
    k_EStreamControlSetTargetFramerate = 69,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputLatencyTest)
    k_EStreamControlInputLatencyTest = 70,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlGamepadRumble_OBSOLETE)
    k_EStreamControlGamepadRumble_OBSOLETE = 71,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlOverlayEnabled)
    k_EStreamControlOverlayEnabled = 74,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerAttached_OBSOLETE)
    k_EStreamControlInputControllerAttached_OBSOLETE = 75,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerState_OBSOLETE)
    k_EStreamControlInputControllerState_OBSOLETE = 76,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTriggerHapticPulse_OBSOLETE)
    k_EStreamControlTriggerHapticPulse_OBSOLETE = 77,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerDetached_OBSOLETE)
    k_EStreamControlInputControllerDetached_OBSOLETE = 78,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVideoDecoderInfo)
    k_EStreamControlVideoDecoderInfo = 80,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTitle)
    k_EStreamControlSetTitle = 81,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetIcon)
    k_EStreamControlSetIcon = 82,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlQuitRequest)
    k_EStreamControlQuitRequest = 83,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetQoS)
    k_EStreamControlSetQoS = 87,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerWirelessPresence_OBSOLETE)
    k_EStreamControlInputControllerWirelessPresence_OBSOLETE = 88,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetGammaRamp)
    k_EStreamControlSetGammaRamp = 89,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVideoEncoderInfo)
    k_EStreamControlVideoEncoderInfo = 90,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputControllerStateHID_OBSOLETE)
    k_EStreamControlInputControllerStateHID_OBSOLETE = 93,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTargetBitrate)
    k_EStreamControlSetTargetBitrate = 94,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetControllerPairingEnabled_OBSOLETE)
    k_EStreamControlSetControllerPairingEnabled_OBSOLETE = 95,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetControllerPairingResult_OBSOLETE)
    k_EStreamControlSetControllerPairingResult_OBSOLETE = 96,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTriggerControllerDisconnect_OBSOLETE)
    k_EStreamControlTriggerControllerDisconnect_OBSOLETE = 97,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetActivity)
    k_EStreamControlSetActivity = 98,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetStreamingClientConfig)
    k_EStreamControlSetStreamingClientConfig = 99,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSystemSuspend)
    k_EStreamControlSystemSuspend = 100,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetControllerSettings_OBSOLETE)
    k_EStreamControlSetControllerSettings_OBSOLETE = 101,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVirtualHereRequest)
    k_EStreamControlVirtualHereRequest = 102,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVirtualHereReady)
    k_EStreamControlVirtualHereReady = 103,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVirtualHereShareDevice)
    k_EStreamControlVirtualHereShareDevice = 104,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetSpectatorMode)
    k_EStreamControlSetSpectatorMode = 105,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlRemoteHID)
    k_EStreamControlRemoteHID = 106,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartMicrophoneData)
    k_EStreamControlStartMicrophoneData = 107,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopMicrophoneData)
    k_EStreamControlStopMicrophoneData = 108,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputText)
    k_EStreamControlInputText = 109,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTouchConfigActive)
    k_EStreamControlTouchConfigActive = 110,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlGetTouchConfigData)
    k_EStreamControlGetTouchConfigData = 111,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTouchConfigData)
    k_EStreamControlSetTouchConfigData = 112,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSaveTouchConfigLayout)
    k_EStreamControlSaveTouchConfigLayout = 113,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTouchActionSetActive)
    k_EStreamControlTouchActionSetActive = 114,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlGetTouchIconData)
    k_EStreamControlGetTouchIconData = 115,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetTouchIconData)
    k_EStreamControlSetTouchIconData = 116,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputTouchFingerDown)
    k_EStreamControlInputTouchFingerDown = 117,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputTouchFingerMotion)
    k_EStreamControlInputTouchFingerMotion = 118,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlInputTouchFingerUp)
    k_EStreamControlInputTouchFingerUp = 119,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetCaptureSize)
    k_EStreamControlSetCaptureSize = 120,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetFlashState)
    k_EStreamControlSetFlashState = 121,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlPause)
    k_EStreamControlPause = 122,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlResume)
    k_EStreamControlResume = 123,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlEnableHighResCapture)
    k_EStreamControlEnableHighResCapture = 124,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlDisableHighResCapture)
    k_EStreamControlDisableHighResCapture = 125,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlToggleMagnification)
    k_EStreamControlToggleMagnification = 126,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetCapslock)
    k_EStreamControlSetCapslock = 127,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetKeymap)
    k_EStreamControlSetKeymap = 128,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopRequest)
    k_EStreamControlStopRequest = 129,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTouchActionSetLayerAdded)
    k_EStreamControlTouchActionSetLayerAdded = 130,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlTouchActionSetLayerRemoved)
    k_EStreamControlTouchActionSetLayerRemoved = 131,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlRemotePlayTogetherGroupUpdate)
    k_EStreamControlRemotePlayTogetherGroupUpdate = 132,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetInputTemporarilyDisabled)
    k_EStreamControlSetInputTemporarilyDisabled = 133,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetQualityOverride)
    k_EStreamControlSetQualityOverride = 134,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetBitrateOverride)
    k_EStreamControlSetBitrateOverride = 135,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlShowOnScreenKeyboard)
    k_EStreamControlShowOnScreenKeyboard = 136,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlControllerConfigMsg)
    k_EStreamControlControllerConfigMsg = 137,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlControllerPersonalizationUpdate)
    k_EStreamControlControllerPersonalizationUpdate = 138,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlEnableNeptuneData)
    k_EStreamControlEnableNeptuneData = 139,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlDisableNeptuneData)
    k_EStreamControlDisableNeptuneData = 140,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStartNeptuneData)
    k_EStreamControlStartNeptuneData = 141,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlStopNeptuneData)
    k_EStreamControlStopNeptuneData = 142,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlPauseControllerInput)
    k_EStreamControlPauseControllerInput = 143,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlResumeControllerInput)
    k_EStreamControlResumeControllerInput = 144,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlVRConnectionReady)
    k_EStreamControlVRConnectionReady = 145,
    // @@protoc_insertion_point(enum_value:EStreamControlMessage.k_EStreamControlSetCursorScale)
    k_EStreamControlSetCursorScale = 146,
}

impl crate::Enum for EStreamControlMessage {
    const NAME: &'static str = "EStreamControlMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamControlMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationRequest),
            2 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationResponse),
            3 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationInit),
            4 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationSetConfig),
            5 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationComplete),
            6 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlClientHandshake),
            7 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlServerHandshake),
            8 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNetworkTest),
            9 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlKeepAlive),
            15 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE),
            50 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartAudioData),
            51 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopAudioData),
            52 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartVideoData),
            53 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopVideoData),
            54 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseMotion),
            55 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseWheel),
            56 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseDown),
            57 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseUp),
            58 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyDown),
            59 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyUp),
            60 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE),
            61 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE),
            62 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE),
            63 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowCursor),
            64 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlHideCursor),
            65 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursor),
            66 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetCursorImage),
            67 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursorImage),
            68 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDeleteCursor),
            69 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetFramerate),
            70 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputLatencyTest),
            71 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE),
            74 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlOverlayEnabled),
            75 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE),
            76 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE),
            77 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE),
            78 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE),
            80 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoDecoderInfo),
            81 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTitle),
            82 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetIcon),
            83 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlQuitRequest),
            87 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQoS),
            88 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE),
            89 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetGammaRamp),
            90 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoEncoderInfo),
            93 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE),
            94 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetBitrate),
            95 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE),
            96 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE),
            97 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE),
            98 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetActivity),
            99 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetStreamingClientConfig),
            100 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSystemSuspend),
            101 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE),
            102 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereRequest),
            103 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereReady),
            104 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereShareDevice),
            105 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetSpectatorMode),
            106 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemoteHID),
            107 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartMicrophoneData),
            108 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopMicrophoneData),
            109 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputText),
            110 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchConfigActive),
            111 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchConfigData),
            112 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchConfigData),
            113 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout),
            114 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetActive),
            115 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchIconData),
            116 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchIconData),
            117 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerDown),
            118 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerMotion),
            119 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerUp),
            120 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCaptureSize),
            121 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetFlashState),
            122 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPause),
            123 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResume),
            124 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlEnableHighResCapture),
            125 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDisableHighResCapture),
            126 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlToggleMagnification),
            127 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCapslock),
            128 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetKeymap),
            129 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopRequest),
            130 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerAdded),
            131 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerRemoved),
            132 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemotePlayTogetherGroupUpdate),
            133 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetInputTemporarilyDisabled),
            134 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQualityOverride),
            135 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetBitrateOverride),
            136 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowOnScreenKeyboard),
            137 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlControllerConfigMsg),
            138 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlControllerPersonalizationUpdate),
            139 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlEnableNeptuneData),
            140 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDisableNeptuneData),
            141 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNeptuneData),
            142 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopNeptuneData),
            143 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPauseControllerInput),
            144 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResumeControllerInput),
            145 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVRConnectionReady),
            146 => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursorScale),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamControlMessage> {
        match str {
            "k_EStreamControlAuthenticationRequest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationRequest),
            "k_EStreamControlAuthenticationResponse" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlAuthenticationResponse),
            "k_EStreamControlNegotiationInit" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationInit),
            "k_EStreamControlNegotiationSetConfig" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationSetConfig),
            "k_EStreamControlNegotiationComplete" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlNegotiationComplete),
            "k_EStreamControlClientHandshake" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlClientHandshake),
            "k_EStreamControlServerHandshake" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlServerHandshake),
            "k_EStreamControlStartNetworkTest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNetworkTest),
            "k_EStreamControlKeepAlive" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlKeepAlive),
            "k_EStreamControl_LAST_SETUP_MESSAGE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE),
            "k_EStreamControlStartAudioData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartAudioData),
            "k_EStreamControlStopAudioData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopAudioData),
            "k_EStreamControlStartVideoData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartVideoData),
            "k_EStreamControlStopVideoData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopVideoData),
            "k_EStreamControlInputMouseMotion" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseMotion),
            "k_EStreamControlInputMouseWheel" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseWheel),
            "k_EStreamControlInputMouseDown" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseDown),
            "k_EStreamControlInputMouseUp" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputMouseUp),
            "k_EStreamControlInputKeyDown" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyDown),
            "k_EStreamControlInputKeyUp" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputKeyUp),
            "k_EStreamControlInputGamepadAttached_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE),
            "k_EStreamControlInputGamepadEvent_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE),
            "k_EStreamControlInputGamepadDetached_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE),
            "k_EStreamControlShowCursor" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowCursor),
            "k_EStreamControlHideCursor" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlHideCursor),
            "k_EStreamControlSetCursor" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursor),
            "k_EStreamControlGetCursorImage" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetCursorImage),
            "k_EStreamControlSetCursorImage" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursorImage),
            "k_EStreamControlDeleteCursor" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDeleteCursor),
            "k_EStreamControlSetTargetFramerate" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetFramerate),
            "k_EStreamControlInputLatencyTest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputLatencyTest),
            "k_EStreamControlGamepadRumble_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE),
            "k_EStreamControlOverlayEnabled" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlOverlayEnabled),
            "k_EStreamControlInputControllerAttached_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE),
            "k_EStreamControlInputControllerState_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE),
            "k_EStreamControlTriggerHapticPulse_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE),
            "k_EStreamControlInputControllerDetached_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE),
            "k_EStreamControlVideoDecoderInfo" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoDecoderInfo),
            "k_EStreamControlSetTitle" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTitle),
            "k_EStreamControlSetIcon" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetIcon),
            "k_EStreamControlQuitRequest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlQuitRequest),
            "k_EStreamControlSetQoS" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQoS),
            "k_EStreamControlInputControllerWirelessPresence_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE),
            "k_EStreamControlSetGammaRamp" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetGammaRamp),
            "k_EStreamControlVideoEncoderInfo" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVideoEncoderInfo),
            "k_EStreamControlInputControllerStateHID_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE),
            "k_EStreamControlSetTargetBitrate" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTargetBitrate),
            "k_EStreamControlSetControllerPairingEnabled_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE),
            "k_EStreamControlSetControllerPairingResult_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE),
            "k_EStreamControlTriggerControllerDisconnect_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE),
            "k_EStreamControlSetActivity" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetActivity),
            "k_EStreamControlSetStreamingClientConfig" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetStreamingClientConfig),
            "k_EStreamControlSystemSuspend" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSystemSuspend),
            "k_EStreamControlSetControllerSettings_OBSOLETE" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE),
            "k_EStreamControlVirtualHereRequest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereRequest),
            "k_EStreamControlVirtualHereReady" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereReady),
            "k_EStreamControlVirtualHereShareDevice" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVirtualHereShareDevice),
            "k_EStreamControlSetSpectatorMode" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetSpectatorMode),
            "k_EStreamControlRemoteHID" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemoteHID),
            "k_EStreamControlStartMicrophoneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartMicrophoneData),
            "k_EStreamControlStopMicrophoneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopMicrophoneData),
            "k_EStreamControlInputText" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputText),
            "k_EStreamControlTouchConfigActive" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchConfigActive),
            "k_EStreamControlGetTouchConfigData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchConfigData),
            "k_EStreamControlSetTouchConfigData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchConfigData),
            "k_EStreamControlSaveTouchConfigLayout" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout),
            "k_EStreamControlTouchActionSetActive" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetActive),
            "k_EStreamControlGetTouchIconData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlGetTouchIconData),
            "k_EStreamControlSetTouchIconData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetTouchIconData),
            "k_EStreamControlInputTouchFingerDown" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerDown),
            "k_EStreamControlInputTouchFingerMotion" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerMotion),
            "k_EStreamControlInputTouchFingerUp" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlInputTouchFingerUp),
            "k_EStreamControlSetCaptureSize" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCaptureSize),
            "k_EStreamControlSetFlashState" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetFlashState),
            "k_EStreamControlPause" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPause),
            "k_EStreamControlResume" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResume),
            "k_EStreamControlEnableHighResCapture" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlEnableHighResCapture),
            "k_EStreamControlDisableHighResCapture" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDisableHighResCapture),
            "k_EStreamControlToggleMagnification" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlToggleMagnification),
            "k_EStreamControlSetCapslock" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCapslock),
            "k_EStreamControlSetKeymap" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetKeymap),
            "k_EStreamControlStopRequest" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopRequest),
            "k_EStreamControlTouchActionSetLayerAdded" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerAdded),
            "k_EStreamControlTouchActionSetLayerRemoved" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlTouchActionSetLayerRemoved),
            "k_EStreamControlRemotePlayTogetherGroupUpdate" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlRemotePlayTogetherGroupUpdate),
            "k_EStreamControlSetInputTemporarilyDisabled" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetInputTemporarilyDisabled),
            "k_EStreamControlSetQualityOverride" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetQualityOverride),
            "k_EStreamControlSetBitrateOverride" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetBitrateOverride),
            "k_EStreamControlShowOnScreenKeyboard" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlShowOnScreenKeyboard),
            "k_EStreamControlControllerConfigMsg" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlControllerConfigMsg),
            "k_EStreamControlControllerPersonalizationUpdate" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlControllerPersonalizationUpdate),
            "k_EStreamControlEnableNeptuneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlEnableNeptuneData),
            "k_EStreamControlDisableNeptuneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlDisableNeptuneData),
            "k_EStreamControlStartNeptuneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStartNeptuneData),
            "k_EStreamControlStopNeptuneData" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlStopNeptuneData),
            "k_EStreamControlPauseControllerInput" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlPauseControllerInput),
            "k_EStreamControlResumeControllerInput" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlResumeControllerInput),
            "k_EStreamControlVRConnectionReady" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlVRConnectionReady),
            "k_EStreamControlSetCursorScale" => ::std::option::Option::Some(EStreamControlMessage::k_EStreamControlSetCursorScale),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamControlMessage] = &[
        EStreamControlMessage::k_EStreamControlAuthenticationRequest,
        EStreamControlMessage::k_EStreamControlAuthenticationResponse,
        EStreamControlMessage::k_EStreamControlNegotiationInit,
        EStreamControlMessage::k_EStreamControlNegotiationSetConfig,
        EStreamControlMessage::k_EStreamControlNegotiationComplete,
        EStreamControlMessage::k_EStreamControlClientHandshake,
        EStreamControlMessage::k_EStreamControlServerHandshake,
        EStreamControlMessage::k_EStreamControlStartNetworkTest,
        EStreamControlMessage::k_EStreamControlKeepAlive,
        EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE,
        EStreamControlMessage::k_EStreamControlStartAudioData,
        EStreamControlMessage::k_EStreamControlStopAudioData,
        EStreamControlMessage::k_EStreamControlStartVideoData,
        EStreamControlMessage::k_EStreamControlStopVideoData,
        EStreamControlMessage::k_EStreamControlInputMouseMotion,
        EStreamControlMessage::k_EStreamControlInputMouseWheel,
        EStreamControlMessage::k_EStreamControlInputMouseDown,
        EStreamControlMessage::k_EStreamControlInputMouseUp,
        EStreamControlMessage::k_EStreamControlInputKeyDown,
        EStreamControlMessage::k_EStreamControlInputKeyUp,
        EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE,
        EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE,
        EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE,
        EStreamControlMessage::k_EStreamControlShowCursor,
        EStreamControlMessage::k_EStreamControlHideCursor,
        EStreamControlMessage::k_EStreamControlSetCursor,
        EStreamControlMessage::k_EStreamControlGetCursorImage,
        EStreamControlMessage::k_EStreamControlSetCursorImage,
        EStreamControlMessage::k_EStreamControlDeleteCursor,
        EStreamControlMessage::k_EStreamControlSetTargetFramerate,
        EStreamControlMessage::k_EStreamControlInputLatencyTest,
        EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE,
        EStreamControlMessage::k_EStreamControlOverlayEnabled,
        EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE,
        EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE,
        EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE,
        EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE,
        EStreamControlMessage::k_EStreamControlVideoDecoderInfo,
        EStreamControlMessage::k_EStreamControlSetTitle,
        EStreamControlMessage::k_EStreamControlSetIcon,
        EStreamControlMessage::k_EStreamControlQuitRequest,
        EStreamControlMessage::k_EStreamControlSetQoS,
        EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE,
        EStreamControlMessage::k_EStreamControlSetGammaRamp,
        EStreamControlMessage::k_EStreamControlVideoEncoderInfo,
        EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE,
        EStreamControlMessage::k_EStreamControlSetTargetBitrate,
        EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE,
        EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE,
        EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE,
        EStreamControlMessage::k_EStreamControlSetActivity,
        EStreamControlMessage::k_EStreamControlSetStreamingClientConfig,
        EStreamControlMessage::k_EStreamControlSystemSuspend,
        EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE,
        EStreamControlMessage::k_EStreamControlVirtualHereRequest,
        EStreamControlMessage::k_EStreamControlVirtualHereReady,
        EStreamControlMessage::k_EStreamControlVirtualHereShareDevice,
        EStreamControlMessage::k_EStreamControlSetSpectatorMode,
        EStreamControlMessage::k_EStreamControlRemoteHID,
        EStreamControlMessage::k_EStreamControlStartMicrophoneData,
        EStreamControlMessage::k_EStreamControlStopMicrophoneData,
        EStreamControlMessage::k_EStreamControlInputText,
        EStreamControlMessage::k_EStreamControlTouchConfigActive,
        EStreamControlMessage::k_EStreamControlGetTouchConfigData,
        EStreamControlMessage::k_EStreamControlSetTouchConfigData,
        EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout,
        EStreamControlMessage::k_EStreamControlTouchActionSetActive,
        EStreamControlMessage::k_EStreamControlGetTouchIconData,
        EStreamControlMessage::k_EStreamControlSetTouchIconData,
        EStreamControlMessage::k_EStreamControlInputTouchFingerDown,
        EStreamControlMessage::k_EStreamControlInputTouchFingerMotion,
        EStreamControlMessage::k_EStreamControlInputTouchFingerUp,
        EStreamControlMessage::k_EStreamControlSetCaptureSize,
        EStreamControlMessage::k_EStreamControlSetFlashState,
        EStreamControlMessage::k_EStreamControlPause,
        EStreamControlMessage::k_EStreamControlResume,
        EStreamControlMessage::k_EStreamControlEnableHighResCapture,
        EStreamControlMessage::k_EStreamControlDisableHighResCapture,
        EStreamControlMessage::k_EStreamControlToggleMagnification,
        EStreamControlMessage::k_EStreamControlSetCapslock,
        EStreamControlMessage::k_EStreamControlSetKeymap,
        EStreamControlMessage::k_EStreamControlStopRequest,
        EStreamControlMessage::k_EStreamControlTouchActionSetLayerAdded,
        EStreamControlMessage::k_EStreamControlTouchActionSetLayerRemoved,
        EStreamControlMessage::k_EStreamControlRemotePlayTogetherGroupUpdate,
        EStreamControlMessage::k_EStreamControlSetInputTemporarilyDisabled,
        EStreamControlMessage::k_EStreamControlSetQualityOverride,
        EStreamControlMessage::k_EStreamControlSetBitrateOverride,
        EStreamControlMessage::k_EStreamControlShowOnScreenKeyboard,
        EStreamControlMessage::k_EStreamControlControllerConfigMsg,
        EStreamControlMessage::k_EStreamControlControllerPersonalizationUpdate,
        EStreamControlMessage::k_EStreamControlEnableNeptuneData,
        EStreamControlMessage::k_EStreamControlDisableNeptuneData,
        EStreamControlMessage::k_EStreamControlStartNeptuneData,
        EStreamControlMessage::k_EStreamControlStopNeptuneData,
        EStreamControlMessage::k_EStreamControlPauseControllerInput,
        EStreamControlMessage::k_EStreamControlResumeControllerInput,
        EStreamControlMessage::k_EStreamControlVRConnectionReady,
        EStreamControlMessage::k_EStreamControlSetCursorScale,
    ];
}

impl crate::EnumFull for EStreamControlMessage {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamControlMessage").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamControlMessage::k_EStreamControlAuthenticationRequest => 0,
            EStreamControlMessage::k_EStreamControlAuthenticationResponse => 1,
            EStreamControlMessage::k_EStreamControlNegotiationInit => 2,
            EStreamControlMessage::k_EStreamControlNegotiationSetConfig => 3,
            EStreamControlMessage::k_EStreamControlNegotiationComplete => 4,
            EStreamControlMessage::k_EStreamControlClientHandshake => 5,
            EStreamControlMessage::k_EStreamControlServerHandshake => 6,
            EStreamControlMessage::k_EStreamControlStartNetworkTest => 7,
            EStreamControlMessage::k_EStreamControlKeepAlive => 8,
            EStreamControlMessage::k_EStreamControl_LAST_SETUP_MESSAGE => 9,
            EStreamControlMessage::k_EStreamControlStartAudioData => 10,
            EStreamControlMessage::k_EStreamControlStopAudioData => 11,
            EStreamControlMessage::k_EStreamControlStartVideoData => 12,
            EStreamControlMessage::k_EStreamControlStopVideoData => 13,
            EStreamControlMessage::k_EStreamControlInputMouseMotion => 14,
            EStreamControlMessage::k_EStreamControlInputMouseWheel => 15,
            EStreamControlMessage::k_EStreamControlInputMouseDown => 16,
            EStreamControlMessage::k_EStreamControlInputMouseUp => 17,
            EStreamControlMessage::k_EStreamControlInputKeyDown => 18,
            EStreamControlMessage::k_EStreamControlInputKeyUp => 19,
            EStreamControlMessage::k_EStreamControlInputGamepadAttached_OBSOLETE => 20,
            EStreamControlMessage::k_EStreamControlInputGamepadEvent_OBSOLETE => 21,
            EStreamControlMessage::k_EStreamControlInputGamepadDetached_OBSOLETE => 22,
            EStreamControlMessage::k_EStreamControlShowCursor => 23,
            EStreamControlMessage::k_EStreamControlHideCursor => 24,
            EStreamControlMessage::k_EStreamControlSetCursor => 25,
            EStreamControlMessage::k_EStreamControlGetCursorImage => 26,
            EStreamControlMessage::k_EStreamControlSetCursorImage => 27,
            EStreamControlMessage::k_EStreamControlDeleteCursor => 28,
            EStreamControlMessage::k_EStreamControlSetTargetFramerate => 29,
            EStreamControlMessage::k_EStreamControlInputLatencyTest => 30,
            EStreamControlMessage::k_EStreamControlGamepadRumble_OBSOLETE => 31,
            EStreamControlMessage::k_EStreamControlOverlayEnabled => 32,
            EStreamControlMessage::k_EStreamControlInputControllerAttached_OBSOLETE => 33,
            EStreamControlMessage::k_EStreamControlInputControllerState_OBSOLETE => 34,
            EStreamControlMessage::k_EStreamControlTriggerHapticPulse_OBSOLETE => 35,
            EStreamControlMessage::k_EStreamControlInputControllerDetached_OBSOLETE => 36,
            EStreamControlMessage::k_EStreamControlVideoDecoderInfo => 37,
            EStreamControlMessage::k_EStreamControlSetTitle => 38,
            EStreamControlMessage::k_EStreamControlSetIcon => 39,
            EStreamControlMessage::k_EStreamControlQuitRequest => 40,
            EStreamControlMessage::k_EStreamControlSetQoS => 41,
            EStreamControlMessage::k_EStreamControlInputControllerWirelessPresence_OBSOLETE => 42,
            EStreamControlMessage::k_EStreamControlSetGammaRamp => 43,
            EStreamControlMessage::k_EStreamControlVideoEncoderInfo => 44,
            EStreamControlMessage::k_EStreamControlInputControllerStateHID_OBSOLETE => 45,
            EStreamControlMessage::k_EStreamControlSetTargetBitrate => 46,
            EStreamControlMessage::k_EStreamControlSetControllerPairingEnabled_OBSOLETE => 47,
            EStreamControlMessage::k_EStreamControlSetControllerPairingResult_OBSOLETE => 48,
            EStreamControlMessage::k_EStreamControlTriggerControllerDisconnect_OBSOLETE => 49,
            EStreamControlMessage::k_EStreamControlSetActivity => 50,
            EStreamControlMessage::k_EStreamControlSetStreamingClientConfig => 51,
            EStreamControlMessage::k_EStreamControlSystemSuspend => 52,
            EStreamControlMessage::k_EStreamControlSetControllerSettings_OBSOLETE => 53,
            EStreamControlMessage::k_EStreamControlVirtualHereRequest => 54,
            EStreamControlMessage::k_EStreamControlVirtualHereReady => 55,
            EStreamControlMessage::k_EStreamControlVirtualHereShareDevice => 56,
            EStreamControlMessage::k_EStreamControlSetSpectatorMode => 57,
            EStreamControlMessage::k_EStreamControlRemoteHID => 58,
            EStreamControlMessage::k_EStreamControlStartMicrophoneData => 59,
            EStreamControlMessage::k_EStreamControlStopMicrophoneData => 60,
            EStreamControlMessage::k_EStreamControlInputText => 61,
            EStreamControlMessage::k_EStreamControlTouchConfigActive => 62,
            EStreamControlMessage::k_EStreamControlGetTouchConfigData => 63,
            EStreamControlMessage::k_EStreamControlSetTouchConfigData => 64,
            EStreamControlMessage::k_EStreamControlSaveTouchConfigLayout => 65,
            EStreamControlMessage::k_EStreamControlTouchActionSetActive => 66,
            EStreamControlMessage::k_EStreamControlGetTouchIconData => 67,
            EStreamControlMessage::k_EStreamControlSetTouchIconData => 68,
            EStreamControlMessage::k_EStreamControlInputTouchFingerDown => 69,
            EStreamControlMessage::k_EStreamControlInputTouchFingerMotion => 70,
            EStreamControlMessage::k_EStreamControlInputTouchFingerUp => 71,
            EStreamControlMessage::k_EStreamControlSetCaptureSize => 72,
            EStreamControlMessage::k_EStreamControlSetFlashState => 73,
            EStreamControlMessage::k_EStreamControlPause => 74,
            EStreamControlMessage::k_EStreamControlResume => 75,
            EStreamControlMessage::k_EStreamControlEnableHighResCapture => 76,
            EStreamControlMessage::k_EStreamControlDisableHighResCapture => 77,
            EStreamControlMessage::k_EStreamControlToggleMagnification => 78,
            EStreamControlMessage::k_EStreamControlSetCapslock => 79,
            EStreamControlMessage::k_EStreamControlSetKeymap => 80,
            EStreamControlMessage::k_EStreamControlStopRequest => 81,
            EStreamControlMessage::k_EStreamControlTouchActionSetLayerAdded => 82,
            EStreamControlMessage::k_EStreamControlTouchActionSetLayerRemoved => 83,
            EStreamControlMessage::k_EStreamControlRemotePlayTogetherGroupUpdate => 84,
            EStreamControlMessage::k_EStreamControlSetInputTemporarilyDisabled => 85,
            EStreamControlMessage::k_EStreamControlSetQualityOverride => 86,
            EStreamControlMessage::k_EStreamControlSetBitrateOverride => 87,
            EStreamControlMessage::k_EStreamControlShowOnScreenKeyboard => 88,
            EStreamControlMessage::k_EStreamControlControllerConfigMsg => 89,
            EStreamControlMessage::k_EStreamControlControllerPersonalizationUpdate => 90,
            EStreamControlMessage::k_EStreamControlEnableNeptuneData => 91,
            EStreamControlMessage::k_EStreamControlDisableNeptuneData => 92,
            EStreamControlMessage::k_EStreamControlStartNeptuneData => 93,
            EStreamControlMessage::k_EStreamControlStopNeptuneData => 94,
            EStreamControlMessage::k_EStreamControlPauseControllerInput => 95,
            EStreamControlMessage::k_EStreamControlResumeControllerInput => 96,
            EStreamControlMessage::k_EStreamControlVRConnectionReady => 97,
            EStreamControlMessage::k_EStreamControlSetCursorScale => 98,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamControlMessage {
    fn default() -> Self {
        EStreamControlMessage::k_EStreamControlAuthenticationRequest
    }
}

impl EStreamControlMessage {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamControlMessage>("EStreamControlMessage")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamVersion)
pub enum EStreamVersion {
    // @@protoc_insertion_point(enum_value:EStreamVersion.k_EStreamVersionNone)
    k_EStreamVersionNone = 0,
    // @@protoc_insertion_point(enum_value:EStreamVersion.k_EStreamVersionCurrent)
    k_EStreamVersionCurrent = 1,
}

impl crate::Enum for EStreamVersion {
    const NAME: &'static str = "EStreamVersion";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVersion> {
        match value {
            0 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionNone),
            1 => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionCurrent),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamVersion> {
        match str {
            "k_EStreamVersionNone" => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionNone),
            "k_EStreamVersionCurrent" => ::std::option::Option::Some(EStreamVersion::k_EStreamVersionCurrent),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamVersion] = &[
        EStreamVersion::k_EStreamVersionNone,
        EStreamVersion::k_EStreamVersionCurrent,
    ];
}

impl crate::EnumFull for EStreamVersion {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamVersion").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamVersion {
    fn default() -> Self {
        EStreamVersion::k_EStreamVersionNone
    }
}

impl EStreamVersion {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamVersion>("EStreamVersion")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamAudioCodec)
pub enum EStreamAudioCodec {
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecNone)
    k_EStreamAudioCodecNone = 0,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecRaw)
    k_EStreamAudioCodecRaw = 1,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecVorbis)
    k_EStreamAudioCodecVorbis = 2,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecOpus)
    k_EStreamAudioCodecOpus = 3,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecMP3)
    k_EStreamAudioCodecMP3 = 4,
    // @@protoc_insertion_point(enum_value:EStreamAudioCodec.k_EStreamAudioCodecAAC)
    k_EStreamAudioCodecAAC = 5,
}

impl crate::Enum for EStreamAudioCodec {
    const NAME: &'static str = "EStreamAudioCodec";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamAudioCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecNone),
            1 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecRaw),
            2 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecVorbis),
            3 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecOpus),
            4 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecMP3),
            5 => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecAAC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamAudioCodec> {
        match str {
            "k_EStreamAudioCodecNone" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecNone),
            "k_EStreamAudioCodecRaw" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecRaw),
            "k_EStreamAudioCodecVorbis" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecVorbis),
            "k_EStreamAudioCodecOpus" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecOpus),
            "k_EStreamAudioCodecMP3" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecMP3),
            "k_EStreamAudioCodecAAC" => ::std::option::Option::Some(EStreamAudioCodec::k_EStreamAudioCodecAAC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamAudioCodec] = &[
        EStreamAudioCodec::k_EStreamAudioCodecNone,
        EStreamAudioCodec::k_EStreamAudioCodecRaw,
        EStreamAudioCodec::k_EStreamAudioCodecVorbis,
        EStreamAudioCodec::k_EStreamAudioCodecOpus,
        EStreamAudioCodec::k_EStreamAudioCodecMP3,
        EStreamAudioCodec::k_EStreamAudioCodecAAC,
    ];
}

impl crate::EnumFull for EStreamAudioCodec {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamAudioCodec").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamAudioCodec {
    fn default() -> Self {
        EStreamAudioCodec::k_EStreamAudioCodecNone
    }
}

impl EStreamAudioCodec {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamAudioCodec>("EStreamAudioCodec")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamVideoCodec)
pub enum EStreamVideoCodec {
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecNone)
    k_EStreamVideoCodecNone = 0,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecRaw)
    k_EStreamVideoCodecRaw = 1,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecVP8)
    k_EStreamVideoCodecVP8 = 2,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecVP9)
    k_EStreamVideoCodecVP9 = 3,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecH264)
    k_EStreamVideoCodecH264 = 4,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecHEVC)
    k_EStreamVideoCodecHEVC = 5,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecORBX1)
    k_EStreamVideoCodecORBX1 = 6,
    // @@protoc_insertion_point(enum_value:EStreamVideoCodec.k_EStreamVideoCodecORBX2)
    k_EStreamVideoCodecORBX2 = 7,
}

impl crate::Enum for EStreamVideoCodec {
    const NAME: &'static str = "EStreamVideoCodec";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamVideoCodec> {
        match value {
            0 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecNone),
            1 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecRaw),
            2 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP8),
            3 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP9),
            4 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecH264),
            5 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecHEVC),
            6 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX1),
            7 => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamVideoCodec> {
        match str {
            "k_EStreamVideoCodecNone" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecNone),
            "k_EStreamVideoCodecRaw" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecRaw),
            "k_EStreamVideoCodecVP8" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP8),
            "k_EStreamVideoCodecVP9" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecVP9),
            "k_EStreamVideoCodecH264" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecH264),
            "k_EStreamVideoCodecHEVC" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecHEVC),
            "k_EStreamVideoCodecORBX1" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX1),
            "k_EStreamVideoCodecORBX2" => ::std::option::Option::Some(EStreamVideoCodec::k_EStreamVideoCodecORBX2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamVideoCodec] = &[
        EStreamVideoCodec::k_EStreamVideoCodecNone,
        EStreamVideoCodec::k_EStreamVideoCodecRaw,
        EStreamVideoCodec::k_EStreamVideoCodecVP8,
        EStreamVideoCodec::k_EStreamVideoCodecVP9,
        EStreamVideoCodec::k_EStreamVideoCodecH264,
        EStreamVideoCodec::k_EStreamVideoCodecHEVC,
        EStreamVideoCodec::k_EStreamVideoCodecORBX1,
        EStreamVideoCodec::k_EStreamVideoCodecORBX2,
    ];
}

impl crate::EnumFull for EStreamVideoCodec {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamVideoCodec").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamVideoCodec {
    fn default() -> Self {
        EStreamVideoCodec::k_EStreamVideoCodecNone
    }
}

impl EStreamVideoCodec {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamVideoCodec>("EStreamVideoCodec")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamQualityPreference)
pub enum EStreamQualityPreference {
    // @@protoc_insertion_point(enum_value:EStreamQualityPreference.k_EStreamQualityAutomatic)
    k_EStreamQualityAutomatic = -1,
    // @@protoc_insertion_point(enum_value:EStreamQualityPreference.k_EStreamQualityFast)
    k_EStreamQualityFast = 1,
    // @@protoc_insertion_point(enum_value:EStreamQualityPreference.k_EStreamQualityBalanced)
    k_EStreamQualityBalanced = 2,
    // @@protoc_insertion_point(enum_value:EStreamQualityPreference.k_EStreamQualityBeautiful)
    k_EStreamQualityBeautiful = 3,
}

impl crate::Enum for EStreamQualityPreference {
    const NAME: &'static str = "EStreamQualityPreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamQualityPreference> {
        match value {
            -1 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityAutomatic),
            1 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityFast),
            2 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBalanced),
            3 => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBeautiful),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamQualityPreference> {
        match str {
            "k_EStreamQualityAutomatic" => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityAutomatic),
            "k_EStreamQualityFast" => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityFast),
            "k_EStreamQualityBalanced" => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBalanced),
            "k_EStreamQualityBeautiful" => ::std::option::Option::Some(EStreamQualityPreference::k_EStreamQualityBeautiful),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamQualityPreference] = &[
        EStreamQualityPreference::k_EStreamQualityAutomatic,
        EStreamQualityPreference::k_EStreamQualityFast,
        EStreamQualityPreference::k_EStreamQualityBalanced,
        EStreamQualityPreference::k_EStreamQualityBeautiful,
    ];
}

impl crate::EnumFull for EStreamQualityPreference {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamQualityPreference").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamQualityPreference::k_EStreamQualityAutomatic => 0,
            EStreamQualityPreference::k_EStreamQualityFast => 1,
            EStreamQualityPreference::k_EStreamQualityBalanced => 2,
            EStreamQualityPreference::k_EStreamQualityBeautiful => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamQualityPreference {
    fn default() -> Self {
        EStreamQualityPreference::k_EStreamQualityAutomatic
    }
}

impl EStreamQualityPreference {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamQualityPreference>("EStreamQualityPreference")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamBitrate)
pub enum EStreamBitrate {
    // @@protoc_insertion_point(enum_value:EStreamBitrate.k_EStreamBitrateAutodetect)
    k_EStreamBitrateAutodetect = -1,
    // @@protoc_insertion_point(enum_value:EStreamBitrate.k_EStreamBitrateUnlimited)
    k_EStreamBitrateUnlimited = 0,
}

impl crate::Enum for EStreamBitrate {
    const NAME: &'static str = "EStreamBitrate";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamBitrate> {
        match value {
            -1 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateAutodetect),
            0 => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateUnlimited),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamBitrate> {
        match str {
            "k_EStreamBitrateAutodetect" => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateAutodetect),
            "k_EStreamBitrateUnlimited" => ::std::option::Option::Some(EStreamBitrate::k_EStreamBitrateUnlimited),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamBitrate] = &[
        EStreamBitrate::k_EStreamBitrateAutodetect,
        EStreamBitrate::k_EStreamBitrateUnlimited,
    ];
}

impl crate::EnumFull for EStreamBitrate {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamBitrate").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamBitrate::k_EStreamBitrateAutodetect => 0,
            EStreamBitrate::k_EStreamBitrateUnlimited => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamBitrate {
    fn default() -> Self {
        EStreamBitrate::k_EStreamBitrateAutodetect
    }
}

impl EStreamBitrate {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamBitrate>("EStreamBitrate")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamColorspace)
pub enum EStreamColorspace {
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_Unknown)
    k_EStreamColorspace_Unknown = 0,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT601)
    k_EStreamColorspace_BT601 = 1,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT601_Full)
    k_EStreamColorspace_BT601_Full = 2,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT709)
    k_EStreamColorspace_BT709 = 3,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT709_Full)
    k_EStreamColorspace_BT709_Full = 4,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT2020)
    k_EStreamColorspace_BT2020 = 5,
    // @@protoc_insertion_point(enum_value:EStreamColorspace.k_EStreamColorspace_BT2020_Full)
    k_EStreamColorspace_BT2020_Full = 6,
}

impl crate::Enum for EStreamColorspace {
    const NAME: &'static str = "EStreamColorspace";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamColorspace> {
        match value {
            0 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_Unknown),
            1 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT601),
            2 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT601_Full),
            3 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT709),
            4 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT709_Full),
            5 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT2020),
            6 => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT2020_Full),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamColorspace> {
        match str {
            "k_EStreamColorspace_Unknown" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_Unknown),
            "k_EStreamColorspace_BT601" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT601),
            "k_EStreamColorspace_BT601_Full" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT601_Full),
            "k_EStreamColorspace_BT709" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT709),
            "k_EStreamColorspace_BT709_Full" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT709_Full),
            "k_EStreamColorspace_BT2020" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT2020),
            "k_EStreamColorspace_BT2020_Full" => ::std::option::Option::Some(EStreamColorspace::k_EStreamColorspace_BT2020_Full),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamColorspace] = &[
        EStreamColorspace::k_EStreamColorspace_Unknown,
        EStreamColorspace::k_EStreamColorspace_BT601,
        EStreamColorspace::k_EStreamColorspace_BT601_Full,
        EStreamColorspace::k_EStreamColorspace_BT709,
        EStreamColorspace::k_EStreamColorspace_BT709_Full,
        EStreamColorspace::k_EStreamColorspace_BT2020,
        EStreamColorspace::k_EStreamColorspace_BT2020_Full,
    ];
}

impl crate::EnumFull for EStreamColorspace {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamColorspace").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamColorspace {
    fn default() -> Self {
        EStreamColorspace::k_EStreamColorspace_Unknown
    }
}

impl EStreamColorspace {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamColorspace>("EStreamColorspace")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamP2PScope)
pub enum EStreamP2PScope {
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeAutomatic)
    k_EStreamP2PScopeAutomatic = 0,
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeDisabled)
    k_EStreamP2PScopeDisabled = 1,
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeOnlyMe)
    k_EStreamP2PScopeOnlyMe = 2,
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeFriends)
    k_EStreamP2PScopeFriends = 3,
    // @@protoc_insertion_point(enum_value:EStreamP2PScope.k_EStreamP2PScopeEveryone)
    k_EStreamP2PScopeEveryone = 4,
}

impl crate::Enum for EStreamP2PScope {
    const NAME: &'static str = "EStreamP2PScope";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamP2PScope> {
        match value {
            0 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeAutomatic),
            1 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeDisabled),
            2 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeOnlyMe),
            3 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeFriends),
            4 => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeEveryone),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamP2PScope> {
        match str {
            "k_EStreamP2PScopeAutomatic" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeAutomatic),
            "k_EStreamP2PScopeDisabled" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeDisabled),
            "k_EStreamP2PScopeOnlyMe" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeOnlyMe),
            "k_EStreamP2PScopeFriends" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeFriends),
            "k_EStreamP2PScopeEveryone" => ::std::option::Option::Some(EStreamP2PScope::k_EStreamP2PScopeEveryone),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamP2PScope] = &[
        EStreamP2PScope::k_EStreamP2PScopeAutomatic,
        EStreamP2PScope::k_EStreamP2PScopeDisabled,
        EStreamP2PScope::k_EStreamP2PScopeOnlyMe,
        EStreamP2PScope::k_EStreamP2PScopeFriends,
        EStreamP2PScope::k_EStreamP2PScopeEveryone,
    ];
}

impl crate::EnumFull for EStreamP2PScope {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamP2PScope").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamP2PScope {
    fn default() -> Self {
        EStreamP2PScope::k_EStreamP2PScopeAutomatic
    }
}

impl EStreamP2PScope {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamP2PScope>("EStreamP2PScope")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamHostPlayAudioPreference)
pub enum EStreamHostPlayAudioPreference {
    // @@protoc_insertion_point(enum_value:EStreamHostPlayAudioPreference.k_EStreamHostPlayAudioDefault)
    k_EStreamHostPlayAudioDefault = 0,
    // @@protoc_insertion_point(enum_value:EStreamHostPlayAudioPreference.k_EStreamHostPlayAudioAlways)
    k_EStreamHostPlayAudioAlways = 1,
}

impl crate::Enum for EStreamHostPlayAudioPreference {
    const NAME: &'static str = "EStreamHostPlayAudioPreference";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamHostPlayAudioPreference> {
        match value {
            0 => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault),
            1 => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamHostPlayAudioPreference> {
        match str {
            "k_EStreamHostPlayAudioDefault" => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault),
            "k_EStreamHostPlayAudioAlways" => ::std::option::Option::Some(EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamHostPlayAudioPreference] = &[
        EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault,
        EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioAlways,
    ];
}

impl crate::EnumFull for EStreamHostPlayAudioPreference {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamHostPlayAudioPreference").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamHostPlayAudioPreference {
    fn default() -> Self {
        EStreamHostPlayAudioPreference::k_EStreamHostPlayAudioDefault
    }
}

impl EStreamHostPlayAudioPreference {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamHostPlayAudioPreference>("EStreamHostPlayAudioPreference")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamingDataType)
pub enum EStreamingDataType {
    // @@protoc_insertion_point(enum_value:EStreamingDataType.k_EStreamingAudioData)
    k_EStreamingAudioData = 0,
    // @@protoc_insertion_point(enum_value:EStreamingDataType.k_EStreamingVideoData)
    k_EStreamingVideoData = 1,
    // @@protoc_insertion_point(enum_value:EStreamingDataType.k_EStreamingMicrophoneData)
    k_EStreamingMicrophoneData = 2,
    // @@protoc_insertion_point(enum_value:EStreamingDataType.k_EStreamingNeptuneData)
    k_EStreamingNeptuneData = 3,
}

impl crate::Enum for EStreamingDataType {
    const NAME: &'static str = "EStreamingDataType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamingDataType> {
        match value {
            0 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingAudioData),
            1 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingVideoData),
            2 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingMicrophoneData),
            3 => ::std::option::Option::Some(EStreamingDataType::k_EStreamingNeptuneData),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamingDataType> {
        match str {
            "k_EStreamingAudioData" => ::std::option::Option::Some(EStreamingDataType::k_EStreamingAudioData),
            "k_EStreamingVideoData" => ::std::option::Option::Some(EStreamingDataType::k_EStreamingVideoData),
            "k_EStreamingMicrophoneData" => ::std::option::Option::Some(EStreamingDataType::k_EStreamingMicrophoneData),
            "k_EStreamingNeptuneData" => ::std::option::Option::Some(EStreamingDataType::k_EStreamingNeptuneData),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamingDataType] = &[
        EStreamingDataType::k_EStreamingAudioData,
        EStreamingDataType::k_EStreamingVideoData,
        EStreamingDataType::k_EStreamingMicrophoneData,
        EStreamingDataType::k_EStreamingNeptuneData,
    ];
}

impl crate::EnumFull for EStreamingDataType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamingDataType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamingDataType {
    fn default() -> Self {
        EStreamingDataType::k_EStreamingAudioData
    }
}

impl EStreamingDataType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamingDataType>("EStreamingDataType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamMouseButton)
pub enum EStreamMouseButton {
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonLeft)
    k_EStreamMouseButtonLeft = 1,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonRight)
    k_EStreamMouseButtonRight = 2,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonMiddle)
    k_EStreamMouseButtonMiddle = 16,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonX1)
    k_EStreamMouseButtonX1 = 32,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonX2)
    k_EStreamMouseButtonX2 = 64,
    // @@protoc_insertion_point(enum_value:EStreamMouseButton.k_EStreamMouseButtonUnknown)
    k_EStreamMouseButtonUnknown = 4096,
}

impl crate::Enum for EStreamMouseButton {
    const NAME: &'static str = "EStreamMouseButton";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseButton> {
        match value {
            1 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonLeft),
            2 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonRight),
            16 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonMiddle),
            32 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX1),
            64 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX2),
            4096 => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonUnknown),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamMouseButton> {
        match str {
            "k_EStreamMouseButtonLeft" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonLeft),
            "k_EStreamMouseButtonRight" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonRight),
            "k_EStreamMouseButtonMiddle" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonMiddle),
            "k_EStreamMouseButtonX1" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX1),
            "k_EStreamMouseButtonX2" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonX2),
            "k_EStreamMouseButtonUnknown" => ::std::option::Option::Some(EStreamMouseButton::k_EStreamMouseButtonUnknown),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamMouseButton] = &[
        EStreamMouseButton::k_EStreamMouseButtonLeft,
        EStreamMouseButton::k_EStreamMouseButtonRight,
        EStreamMouseButton::k_EStreamMouseButtonMiddle,
        EStreamMouseButton::k_EStreamMouseButtonX1,
        EStreamMouseButton::k_EStreamMouseButtonX2,
        EStreamMouseButton::k_EStreamMouseButtonUnknown,
    ];
}

impl crate::EnumFull for EStreamMouseButton {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamMouseButton").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamMouseButton::k_EStreamMouseButtonLeft => 0,
            EStreamMouseButton::k_EStreamMouseButtonRight => 1,
            EStreamMouseButton::k_EStreamMouseButtonMiddle => 2,
            EStreamMouseButton::k_EStreamMouseButtonX1 => 3,
            EStreamMouseButton::k_EStreamMouseButtonX2 => 4,
            EStreamMouseButton::k_EStreamMouseButtonUnknown => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamMouseButton {
    fn default() -> Self {
        EStreamMouseButton::k_EStreamMouseButtonLeft
    }
}

impl EStreamMouseButton {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamMouseButton>("EStreamMouseButton")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamMouseWheelDirection)
pub enum EStreamMouseWheelDirection {
    // @@protoc_insertion_point(enum_value:EStreamMouseWheelDirection.k_EStreamMouseWheelUp)
    k_EStreamMouseWheelUp = 120,
    // @@protoc_insertion_point(enum_value:EStreamMouseWheelDirection.k_EStreamMouseWheelDown)
    k_EStreamMouseWheelDown = -120,
    // @@protoc_insertion_point(enum_value:EStreamMouseWheelDirection.k_EStreamMouseWheelLeft)
    k_EStreamMouseWheelLeft = 3,
    // @@protoc_insertion_point(enum_value:EStreamMouseWheelDirection.k_EStreamMouseWheelRight)
    k_EStreamMouseWheelRight = 4,
}

impl crate::Enum for EStreamMouseWheelDirection {
    const NAME: &'static str = "EStreamMouseWheelDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamMouseWheelDirection> {
        match value {
            120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            -120 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelDown),
            3 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelLeft),
            4 => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelRight),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamMouseWheelDirection> {
        match str {
            "k_EStreamMouseWheelUp" => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelUp),
            "k_EStreamMouseWheelDown" => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelDown),
            "k_EStreamMouseWheelLeft" => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelLeft),
            "k_EStreamMouseWheelRight" => ::std::option::Option::Some(EStreamMouseWheelDirection::k_EStreamMouseWheelRight),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamMouseWheelDirection] = &[
        EStreamMouseWheelDirection::k_EStreamMouseWheelUp,
        EStreamMouseWheelDirection::k_EStreamMouseWheelDown,
        EStreamMouseWheelDirection::k_EStreamMouseWheelLeft,
        EStreamMouseWheelDirection::k_EStreamMouseWheelRight,
    ];
}

impl crate::EnumFull for EStreamMouseWheelDirection {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamMouseWheelDirection").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamMouseWheelDirection::k_EStreamMouseWheelUp => 0,
            EStreamMouseWheelDirection::k_EStreamMouseWheelDown => 1,
            EStreamMouseWheelDirection::k_EStreamMouseWheelLeft => 2,
            EStreamMouseWheelDirection::k_EStreamMouseWheelRight => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamMouseWheelDirection {
    fn default() -> Self {
        EStreamMouseWheelDirection::k_EStreamMouseWheelUp
    }
}

impl EStreamMouseWheelDirection {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamMouseWheelDirection>("EStreamMouseWheelDirection")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamFramerateLimiter)
pub enum EStreamFramerateLimiter {
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowCapture)
    k_EStreamFramerateSlowCapture = 1,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowConvert)
    k_EStreamFramerateSlowConvert = 2,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowEncode)
    k_EStreamFramerateSlowEncode = 4,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowNetwork)
    k_EStreamFramerateSlowNetwork = 8,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowDecode)
    k_EStreamFramerateSlowDecode = 16,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowGame)
    k_EStreamFramerateSlowGame = 32,
    // @@protoc_insertion_point(enum_value:EStreamFramerateLimiter.k_EStreamFramerateSlowDisplay)
    k_EStreamFramerateSlowDisplay = 64,
}

impl crate::Enum for EStreamFramerateLimiter {
    const NAME: &'static str = "EStreamFramerateLimiter";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFramerateLimiter> {
        match value {
            1 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowCapture),
            2 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowConvert),
            4 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowEncode),
            8 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork),
            16 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDecode),
            32 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowGame),
            64 => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamFramerateLimiter> {
        match str {
            "k_EStreamFramerateSlowCapture" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowCapture),
            "k_EStreamFramerateSlowConvert" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowConvert),
            "k_EStreamFramerateSlowEncode" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowEncode),
            "k_EStreamFramerateSlowNetwork" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork),
            "k_EStreamFramerateSlowDecode" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDecode),
            "k_EStreamFramerateSlowGame" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowGame),
            "k_EStreamFramerateSlowDisplay" => ::std::option::Option::Some(EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamFramerateLimiter] = &[
        EStreamFramerateLimiter::k_EStreamFramerateSlowCapture,
        EStreamFramerateLimiter::k_EStreamFramerateSlowConvert,
        EStreamFramerateLimiter::k_EStreamFramerateSlowEncode,
        EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork,
        EStreamFramerateLimiter::k_EStreamFramerateSlowDecode,
        EStreamFramerateLimiter::k_EStreamFramerateSlowGame,
        EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay,
    ];
}

impl crate::EnumFull for EStreamFramerateLimiter {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamFramerateLimiter").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamFramerateLimiter::k_EStreamFramerateSlowCapture => 0,
            EStreamFramerateLimiter::k_EStreamFramerateSlowConvert => 1,
            EStreamFramerateLimiter::k_EStreamFramerateSlowEncode => 2,
            EStreamFramerateLimiter::k_EStreamFramerateSlowNetwork => 3,
            EStreamFramerateLimiter::k_EStreamFramerateSlowDecode => 4,
            EStreamFramerateLimiter::k_EStreamFramerateSlowGame => 5,
            EStreamFramerateLimiter::k_EStreamFramerateSlowDisplay => 6,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamFramerateLimiter {
    fn default() -> Self {
        EStreamFramerateLimiter::k_EStreamFramerateSlowCapture
    }
}

impl EStreamFramerateLimiter {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamFramerateLimiter>("EStreamFramerateLimiter")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamActivity)
pub enum EStreamActivity {
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivityIdle)
    k_EStreamActivityIdle = 1,
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivityGame)
    k_EStreamActivityGame = 2,
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivityDesktop)
    k_EStreamActivityDesktop = 3,
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivitySecureDesktop)
    k_EStreamActivitySecureDesktop = 4,
    // @@protoc_insertion_point(enum_value:EStreamActivity.k_EStreamActivityMusic)
    k_EStreamActivityMusic = 5,
}

impl crate::Enum for EStreamActivity {
    const NAME: &'static str = "EStreamActivity";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamActivity> {
        match value {
            1 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityIdle),
            2 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityGame),
            3 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityDesktop),
            4 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivitySecureDesktop),
            5 => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityMusic),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamActivity> {
        match str {
            "k_EStreamActivityIdle" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityIdle),
            "k_EStreamActivityGame" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityGame),
            "k_EStreamActivityDesktop" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityDesktop),
            "k_EStreamActivitySecureDesktop" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivitySecureDesktop),
            "k_EStreamActivityMusic" => ::std::option::Option::Some(EStreamActivity::k_EStreamActivityMusic),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamActivity] = &[
        EStreamActivity::k_EStreamActivityIdle,
        EStreamActivity::k_EStreamActivityGame,
        EStreamActivity::k_EStreamActivityDesktop,
        EStreamActivity::k_EStreamActivitySecureDesktop,
        EStreamActivity::k_EStreamActivityMusic,
    ];
}

impl crate::EnumFull for EStreamActivity {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamActivity").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamActivity::k_EStreamActivityIdle => 0,
            EStreamActivity::k_EStreamActivityGame => 1,
            EStreamActivity::k_EStreamActivityDesktop => 2,
            EStreamActivity::k_EStreamActivitySecureDesktop => 3,
            EStreamActivity::k_EStreamActivityMusic => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamActivity {
    fn default() -> Self {
        EStreamActivity::k_EStreamActivityIdle
    }
}

impl EStreamActivity {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamActivity>("EStreamActivity")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamDataMessage)
pub enum EStreamDataMessage {
    // @@protoc_insertion_point(enum_value:EStreamDataMessage.k_EStreamDataPacket)
    k_EStreamDataPacket = 1,
    // @@protoc_insertion_point(enum_value:EStreamDataMessage.k_EStreamDataLost)
    k_EStreamDataLost = 2,
}

impl crate::Enum for EStreamDataMessage {
    const NAME: &'static str = "EStreamDataMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDataMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataPacket),
            2 => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataLost),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamDataMessage> {
        match str {
            "k_EStreamDataPacket" => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataPacket),
            "k_EStreamDataLost" => ::std::option::Option::Some(EStreamDataMessage::k_EStreamDataLost),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamDataMessage] = &[
        EStreamDataMessage::k_EStreamDataPacket,
        EStreamDataMessage::k_EStreamDataLost,
    ];
}

impl crate::EnumFull for EStreamDataMessage {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamDataMessage").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamDataMessage::k_EStreamDataPacket => 0,
            EStreamDataMessage::k_EStreamDataLost => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamDataMessage {
    fn default() -> Self {
        EStreamDataMessage::k_EStreamDataPacket
    }
}

impl EStreamDataMessage {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamDataMessage>("EStreamDataMessage")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EAudioFormat)
pub enum EAudioFormat {
    // @@protoc_insertion_point(enum_value:EAudioFormat.k_EAudioFormatNone)
    k_EAudioFormatNone = 0,
    // @@protoc_insertion_point(enum_value:EAudioFormat.k_EAudioFormat16BitLittleEndian)
    k_EAudioFormat16BitLittleEndian = 1,
    // @@protoc_insertion_point(enum_value:EAudioFormat.k_EAudioFormatFloat)
    k_EAudioFormatFloat = 2,
}

impl crate::Enum for EAudioFormat {
    const NAME: &'static str = "EAudioFormat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EAudioFormat> {
        match value {
            0 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatNone),
            1 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormat16BitLittleEndian),
            2 => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatFloat),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EAudioFormat> {
        match str {
            "k_EAudioFormatNone" => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatNone),
            "k_EAudioFormat16BitLittleEndian" => ::std::option::Option::Some(EAudioFormat::k_EAudioFormat16BitLittleEndian),
            "k_EAudioFormatFloat" => ::std::option::Option::Some(EAudioFormat::k_EAudioFormatFloat),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EAudioFormat] = &[
        EAudioFormat::k_EAudioFormatNone,
        EAudioFormat::k_EAudioFormat16BitLittleEndian,
        EAudioFormat::k_EAudioFormatFloat,
    ];
}

impl crate::EnumFull for EAudioFormat {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EAudioFormat").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EAudioFormat {
    fn default() -> Self {
        EAudioFormat::k_EAudioFormatNone
    }
}

impl EAudioFormat {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EAudioFormat>("EAudioFormat")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EVideoFormat)
pub enum EVideoFormat {
    // @@protoc_insertion_point(enum_value:EVideoFormat.k_EVideoFormatNone)
    k_EVideoFormatNone = 0,
    // @@protoc_insertion_point(enum_value:EVideoFormat.k_EVideoFormatYV12)
    k_EVideoFormatYV12 = 1,
    // @@protoc_insertion_point(enum_value:EVideoFormat.k_EVideoFormatAccel)
    k_EVideoFormatAccel = 2,
}

impl crate::Enum for EVideoFormat {
    const NAME: &'static str = "EVideoFormat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EVideoFormat> {
        match value {
            0 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatNone),
            1 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatYV12),
            2 => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatAccel),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EVideoFormat> {
        match str {
            "k_EVideoFormatNone" => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatNone),
            "k_EVideoFormatYV12" => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatYV12),
            "k_EVideoFormatAccel" => ::std::option::Option::Some(EVideoFormat::k_EVideoFormatAccel),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EVideoFormat] = &[
        EVideoFormat::k_EVideoFormatNone,
        EVideoFormat::k_EVideoFormatYV12,
        EVideoFormat::k_EVideoFormatAccel,
    ];
}

impl crate::EnumFull for EVideoFormat {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EVideoFormat").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EVideoFormat {
    fn default() -> Self {
        EVideoFormat::k_EVideoFormatNone
    }
}

impl EVideoFormat {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EVideoFormat>("EVideoFormat")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamStatsMessage)
pub enum EStreamStatsMessage {
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsFrameEvents)
    k_EStreamStatsFrameEvents = 1,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsDebugDump)
    k_EStreamStatsDebugDump = 2,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsLogMessage)
    k_EStreamStatsLogMessage = 3,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsLogUploadBegin)
    k_EStreamStatsLogUploadBegin = 4,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsLogUploadData)
    k_EStreamStatsLogUploadData = 5,
    // @@protoc_insertion_point(enum_value:EStreamStatsMessage.k_EStreamStatsLogUploadComplete)
    k_EStreamStatsLogUploadComplete = 6,
}

impl crate::Enum for EStreamStatsMessage {
    const NAME: &'static str = "EStreamStatsMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamStatsMessage> {
        match value {
            1 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsFrameEvents),
            2 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsDebugDump),
            3 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogMessage),
            4 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadBegin),
            5 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadData),
            6 => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadComplete),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamStatsMessage> {
        match str {
            "k_EStreamStatsFrameEvents" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsFrameEvents),
            "k_EStreamStatsDebugDump" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsDebugDump),
            "k_EStreamStatsLogMessage" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogMessage),
            "k_EStreamStatsLogUploadBegin" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadBegin),
            "k_EStreamStatsLogUploadData" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadData),
            "k_EStreamStatsLogUploadComplete" => ::std::option::Option::Some(EStreamStatsMessage::k_EStreamStatsLogUploadComplete),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamStatsMessage] = &[
        EStreamStatsMessage::k_EStreamStatsFrameEvents,
        EStreamStatsMessage::k_EStreamStatsDebugDump,
        EStreamStatsMessage::k_EStreamStatsLogMessage,
        EStreamStatsMessage::k_EStreamStatsLogUploadBegin,
        EStreamStatsMessage::k_EStreamStatsLogUploadData,
        EStreamStatsMessage::k_EStreamStatsLogUploadComplete,
    ];
}

impl crate::EnumFull for EStreamStatsMessage {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamStatsMessage").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStreamStatsMessage::k_EStreamStatsFrameEvents => 0,
            EStreamStatsMessage::k_EStreamStatsDebugDump => 1,
            EStreamStatsMessage::k_EStreamStatsLogMessage => 2,
            EStreamStatsMessage::k_EStreamStatsLogUploadBegin => 3,
            EStreamStatsMessage::k_EStreamStatsLogUploadData => 4,
            EStreamStatsMessage::k_EStreamStatsLogUploadComplete => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStreamStatsMessage {
    fn default() -> Self {
        EStreamStatsMessage::k_EStreamStatsFrameEvents
    }
}

impl EStreamStatsMessage {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamStatsMessage>("EStreamStatsMessage")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamFrameEvent)
pub enum EStreamFrameEvent {
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventStart)
    k_EStreamInputEventStart = 0,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventSend)
    k_EStreamInputEventSend = 1,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventRecv)
    k_EStreamInputEventRecv = 2,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventQueued)
    k_EStreamInputEventQueued = 3,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamInputEventHandled)
    k_EStreamInputEventHandled = 4,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventStart)
    k_EStreamFrameEventStart = 5,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventCaptureBegin)
    k_EStreamFrameEventCaptureBegin = 6,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventCaptureEnd)
    k_EStreamFrameEventCaptureEnd = 7,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventConvertBegin)
    k_EStreamFrameEventConvertBegin = 8,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventConvertEnd)
    k_EStreamFrameEventConvertEnd = 9,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventEncodeBegin)
    k_EStreamFrameEventEncodeBegin = 10,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventEncodeEnd)
    k_EStreamFrameEventEncodeEnd = 11,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventSend)
    k_EStreamFrameEventSend = 12,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventRecv)
    k_EStreamFrameEventRecv = 13,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventDecodeBegin)
    k_EStreamFrameEventDecodeBegin = 14,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventDecodeEnd)
    k_EStreamFrameEventDecodeEnd = 15,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventUploadBegin)
    k_EStreamFrameEventUploadBegin = 16,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventUploadEnd)
    k_EStreamFrameEventUploadEnd = 17,
    // @@protoc_insertion_point(enum_value:EStreamFrameEvent.k_EStreamFrameEventComplete)
    k_EStreamFrameEventComplete = 18,
}

impl crate::Enum for EStreamFrameEvent {
    const NAME: &'static str = "EStreamFrameEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameEvent> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventStart),
            1 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventSend),
            2 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventRecv),
            3 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventQueued),
            4 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventHandled),
            5 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventStart),
            6 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureBegin),
            7 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureEnd),
            8 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertBegin),
            9 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertEnd),
            10 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeBegin),
            11 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeEnd),
            12 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventSend),
            13 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventRecv),
            14 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeBegin),
            15 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeEnd),
            16 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadBegin),
            17 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadEnd),
            18 => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventComplete),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamFrameEvent> {
        match str {
            "k_EStreamInputEventStart" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventStart),
            "k_EStreamInputEventSend" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventSend),
            "k_EStreamInputEventRecv" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventRecv),
            "k_EStreamInputEventQueued" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventQueued),
            "k_EStreamInputEventHandled" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamInputEventHandled),
            "k_EStreamFrameEventStart" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventStart),
            "k_EStreamFrameEventCaptureBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureBegin),
            "k_EStreamFrameEventCaptureEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventCaptureEnd),
            "k_EStreamFrameEventConvertBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertBegin),
            "k_EStreamFrameEventConvertEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventConvertEnd),
            "k_EStreamFrameEventEncodeBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeBegin),
            "k_EStreamFrameEventEncodeEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventEncodeEnd),
            "k_EStreamFrameEventSend" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventSend),
            "k_EStreamFrameEventRecv" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventRecv),
            "k_EStreamFrameEventDecodeBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeBegin),
            "k_EStreamFrameEventDecodeEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventDecodeEnd),
            "k_EStreamFrameEventUploadBegin" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadBegin),
            "k_EStreamFrameEventUploadEnd" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventUploadEnd),
            "k_EStreamFrameEventComplete" => ::std::option::Option::Some(EStreamFrameEvent::k_EStreamFrameEventComplete),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamFrameEvent] = &[
        EStreamFrameEvent::k_EStreamInputEventStart,
        EStreamFrameEvent::k_EStreamInputEventSend,
        EStreamFrameEvent::k_EStreamInputEventRecv,
        EStreamFrameEvent::k_EStreamInputEventQueued,
        EStreamFrameEvent::k_EStreamInputEventHandled,
        EStreamFrameEvent::k_EStreamFrameEventStart,
        EStreamFrameEvent::k_EStreamFrameEventCaptureBegin,
        EStreamFrameEvent::k_EStreamFrameEventCaptureEnd,
        EStreamFrameEvent::k_EStreamFrameEventConvertBegin,
        EStreamFrameEvent::k_EStreamFrameEventConvertEnd,
        EStreamFrameEvent::k_EStreamFrameEventEncodeBegin,
        EStreamFrameEvent::k_EStreamFrameEventEncodeEnd,
        EStreamFrameEvent::k_EStreamFrameEventSend,
        EStreamFrameEvent::k_EStreamFrameEventRecv,
        EStreamFrameEvent::k_EStreamFrameEventDecodeBegin,
        EStreamFrameEvent::k_EStreamFrameEventDecodeEnd,
        EStreamFrameEvent::k_EStreamFrameEventUploadBegin,
        EStreamFrameEvent::k_EStreamFrameEventUploadEnd,
        EStreamFrameEvent::k_EStreamFrameEventComplete,
    ];
}

impl crate::EnumFull for EStreamFrameEvent {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamFrameEvent").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamFrameEvent {
    fn default() -> Self {
        EStreamFrameEvent::k_EStreamInputEventStart
    }
}

impl EStreamFrameEvent {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamFrameEvent>("EStreamFrameEvent")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamFrameResult)
pub enum EStreamFrameResult {
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultPending)
    k_EStreamFrameResultPending = 0,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDisplayed)
    k_EStreamFrameResultDisplayed = 1,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedNetworkSlow)
    k_EStreamFrameResultDroppedNetworkSlow = 2,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedNetworkLost)
    k_EStreamFrameResultDroppedNetworkLost = 3,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedDecodeSlow)
    k_EStreamFrameResultDroppedDecodeSlow = 4,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedDecodeCorrupt)
    k_EStreamFrameResultDroppedDecodeCorrupt = 5,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedLate)
    k_EStreamFrameResultDroppedLate = 6,
    // @@protoc_insertion_point(enum_value:EStreamFrameResult.k_EStreamFrameResultDroppedReset)
    k_EStreamFrameResultDroppedReset = 7,
}

impl crate::Enum for EStreamFrameResult {
    const NAME: &'static str = "EStreamFrameResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamFrameResult> {
        match value {
            0 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultPending),
            1 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDisplayed),
            2 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow),
            3 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost),
            4 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow),
            5 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt),
            6 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedLate),
            7 => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedReset),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamFrameResult> {
        match str {
            "k_EStreamFrameResultPending" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultPending),
            "k_EStreamFrameResultDisplayed" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDisplayed),
            "k_EStreamFrameResultDroppedNetworkSlow" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow),
            "k_EStreamFrameResultDroppedNetworkLost" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost),
            "k_EStreamFrameResultDroppedDecodeSlow" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow),
            "k_EStreamFrameResultDroppedDecodeCorrupt" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt),
            "k_EStreamFrameResultDroppedLate" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedLate),
            "k_EStreamFrameResultDroppedReset" => ::std::option::Option::Some(EStreamFrameResult::k_EStreamFrameResultDroppedReset),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamFrameResult] = &[
        EStreamFrameResult::k_EStreamFrameResultPending,
        EStreamFrameResult::k_EStreamFrameResultDisplayed,
        EStreamFrameResult::k_EStreamFrameResultDroppedNetworkSlow,
        EStreamFrameResult::k_EStreamFrameResultDroppedNetworkLost,
        EStreamFrameResult::k_EStreamFrameResultDroppedDecodeSlow,
        EStreamFrameResult::k_EStreamFrameResultDroppedDecodeCorrupt,
        EStreamFrameResult::k_EStreamFrameResultDroppedLate,
        EStreamFrameResult::k_EStreamFrameResultDroppedReset,
    ];
}

impl crate::EnumFull for EStreamFrameResult {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamFrameResult").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamFrameResult {
    fn default() -> Self {
        EStreamFrameResult::k_EStreamFrameResultPending
    }
}

impl EStreamFrameResult {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamFrameResult>("EStreamFrameResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EFrameAccumulatedStat)
pub enum EFrameAccumulatedStat {
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatFPS)
    k_EFrameStatFPS = 0,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatCaptureDurationMS)
    k_EFrameStatCaptureDurationMS = 1,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatConvertDurationMS)
    k_EFrameStatConvertDurationMS = 2,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatEncodeDurationMS)
    k_EFrameStatEncodeDurationMS = 3,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatSteamDurationMS)
    k_EFrameStatSteamDurationMS = 4,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatServerDurationMS)
    k_EFrameStatServerDurationMS = 5,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatNetworkDurationMS)
    k_EFrameStatNetworkDurationMS = 6,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatDecodeDurationMS)
    k_EFrameStatDecodeDurationMS = 7,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatDisplayDurationMS)
    k_EFrameStatDisplayDurationMS = 8,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatClientDurationMS)
    k_EFrameStatClientDurationMS = 9,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatFrameDurationMS)
    k_EFrameStatFrameDurationMS = 10,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatInputLatencyMS)
    k_EFrameStatInputLatencyMS = 11,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatGameLatencyMS)
    k_EFrameStatGameLatencyMS = 12,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatRoundTripLatencyMS)
    k_EFrameStatRoundTripLatencyMS = 13,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatPingTimeMS)
    k_EFrameStatPingTimeMS = 14,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatServerBitrateKbitPerSec)
    k_EFrameStatServerBitrateKbitPerSec = 15,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatClientBitrateKbitPerSec)
    k_EFrameStatClientBitrateKbitPerSec = 16,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatLinkBandwidthKbitPerSec)
    k_EFrameStatLinkBandwidthKbitPerSec = 17,
    // @@protoc_insertion_point(enum_value:EFrameAccumulatedStat.k_EFrameStatPacketLossPercentage)
    k_EFrameStatPacketLossPercentage = 18,
}

impl crate::Enum for EFrameAccumulatedStat {
    const NAME: &'static str = "EFrameAccumulatedStat";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EFrameAccumulatedStat> {
        match value {
            0 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFPS),
            1 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS),
            2 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatConvertDurationMS),
            3 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS),
            4 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatSteamDurationMS),
            5 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerDurationMS),
            6 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS),
            7 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS),
            8 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS),
            9 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientDurationMS),
            10 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFrameDurationMS),
            11 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatInputLatencyMS),
            12 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatGameLatencyMS),
            13 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS),
            14 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPingTimeMS),
            15 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec),
            16 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec),
            17 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec),
            18 => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EFrameAccumulatedStat> {
        match str {
            "k_EFrameStatFPS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFPS),
            "k_EFrameStatCaptureDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS),
            "k_EFrameStatConvertDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatConvertDurationMS),
            "k_EFrameStatEncodeDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS),
            "k_EFrameStatSteamDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatSteamDurationMS),
            "k_EFrameStatServerDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerDurationMS),
            "k_EFrameStatNetworkDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS),
            "k_EFrameStatDecodeDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS),
            "k_EFrameStatDisplayDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS),
            "k_EFrameStatClientDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientDurationMS),
            "k_EFrameStatFrameDurationMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatFrameDurationMS),
            "k_EFrameStatInputLatencyMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatInputLatencyMS),
            "k_EFrameStatGameLatencyMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatGameLatencyMS),
            "k_EFrameStatRoundTripLatencyMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS),
            "k_EFrameStatPingTimeMS" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPingTimeMS),
            "k_EFrameStatServerBitrateKbitPerSec" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec),
            "k_EFrameStatClientBitrateKbitPerSec" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec),
            "k_EFrameStatLinkBandwidthKbitPerSec" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec),
            "k_EFrameStatPacketLossPercentage" => ::std::option::Option::Some(EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EFrameAccumulatedStat] = &[
        EFrameAccumulatedStat::k_EFrameStatFPS,
        EFrameAccumulatedStat::k_EFrameStatCaptureDurationMS,
        EFrameAccumulatedStat::k_EFrameStatConvertDurationMS,
        EFrameAccumulatedStat::k_EFrameStatEncodeDurationMS,
        EFrameAccumulatedStat::k_EFrameStatSteamDurationMS,
        EFrameAccumulatedStat::k_EFrameStatServerDurationMS,
        EFrameAccumulatedStat::k_EFrameStatNetworkDurationMS,
        EFrameAccumulatedStat::k_EFrameStatDecodeDurationMS,
        EFrameAccumulatedStat::k_EFrameStatDisplayDurationMS,
        EFrameAccumulatedStat::k_EFrameStatClientDurationMS,
        EFrameAccumulatedStat::k_EFrameStatFrameDurationMS,
        EFrameAccumulatedStat::k_EFrameStatInputLatencyMS,
        EFrameAccumulatedStat::k_EFrameStatGameLatencyMS,
        EFrameAccumulatedStat::k_EFrameStatRoundTripLatencyMS,
        EFrameAccumulatedStat::k_EFrameStatPingTimeMS,
        EFrameAccumulatedStat::k_EFrameStatServerBitrateKbitPerSec,
        EFrameAccumulatedStat::k_EFrameStatClientBitrateKbitPerSec,
        EFrameAccumulatedStat::k_EFrameStatLinkBandwidthKbitPerSec,
        EFrameAccumulatedStat::k_EFrameStatPacketLossPercentage,
    ];
}

impl crate::EnumFull for EFrameAccumulatedStat {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EFrameAccumulatedStat").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EFrameAccumulatedStat {
    fn default() -> Self {
        EFrameAccumulatedStat::k_EFrameStatFPS
    }
}

impl EFrameAccumulatedStat {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EFrameAccumulatedStat>("EFrameAccumulatedStat")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ELogFileType)
pub enum ELogFileType {
    // @@protoc_insertion_point(enum_value:ELogFileType.k_ELogFileSystemBoot)
    k_ELogFileSystemBoot = 0,
    // @@protoc_insertion_point(enum_value:ELogFileType.k_ELogFileSystemReset)
    k_ELogFileSystemReset = 1,
    // @@protoc_insertion_point(enum_value:ELogFileType.k_ELogFileSystemDebug)
    k_ELogFileSystemDebug = 2,
}

impl crate::Enum for ELogFileType {
    const NAME: &'static str = "ELogFileType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ELogFileType> {
        match value {
            0 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemBoot),
            1 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemReset),
            2 => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemDebug),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ELogFileType> {
        match str {
            "k_ELogFileSystemBoot" => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemBoot),
            "k_ELogFileSystemReset" => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemReset),
            "k_ELogFileSystemDebug" => ::std::option::Option::Some(ELogFileType::k_ELogFileSystemDebug),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ELogFileType] = &[
        ELogFileType::k_ELogFileSystemBoot,
        ELogFileType::k_ELogFileSystemReset,
        ELogFileType::k_ELogFileSystemDebug,
    ];
}

impl crate::EnumFull for ELogFileType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ELogFileType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ELogFileType {
    fn default() -> Self {
        ELogFileType::k_ELogFileSystemBoot
    }
}

impl ELogFileType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ELogFileType>("ELogFileType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamControllerConfigMsg)
pub enum EStreamControllerConfigMsg {
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_RequestConfigsForApp)
    k_EStreamControllerConfigMsg_RequestConfigsForApp = 0,
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_ConfigResponse)
    k_EStreamControllerConfigMsg_ConfigResponse = 1,
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_PersonalizationResponse)
    k_EStreamControllerConfigMsg_PersonalizationResponse = 2,
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_ActiveConfigChange)
    k_EStreamControllerConfigMsg_ActiveConfigChange = 3,
    // @@protoc_insertion_point(enum_value:EStreamControllerConfigMsg.k_EStreamControllerConfigMsg_RequestActiveConfig)
    k_EStreamControllerConfigMsg_RequestActiveConfig = 4,
}

impl crate::Enum for EStreamControllerConfigMsg {
    const NAME: &'static str = "EStreamControllerConfigMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamControllerConfigMsg> {
        match value {
            0 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp),
            1 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ConfigResponse),
            2 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_PersonalizationResponse),
            3 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ActiveConfigChange),
            4 => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestActiveConfig),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamControllerConfigMsg> {
        match str {
            "k_EStreamControllerConfigMsg_RequestConfigsForApp" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp),
            "k_EStreamControllerConfigMsg_ConfigResponse" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ConfigResponse),
            "k_EStreamControllerConfigMsg_PersonalizationResponse" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_PersonalizationResponse),
            "k_EStreamControllerConfigMsg_ActiveConfigChange" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ActiveConfigChange),
            "k_EStreamControllerConfigMsg_RequestActiveConfig" => ::std::option::Option::Some(EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestActiveConfig),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamControllerConfigMsg] = &[
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp,
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ConfigResponse,
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_PersonalizationResponse,
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_ActiveConfigChange,
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestActiveConfig,
    ];
}

impl crate::EnumFull for EStreamControllerConfigMsg {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamControllerConfigMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamControllerConfigMsg {
    fn default() -> Self {
        EStreamControllerConfigMsg::k_EStreamControllerConfigMsg_RequestConfigsForApp
    }
}

impl EStreamControllerConfigMsg {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamControllerConfigMsg>("EStreamControllerConfigMsg")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1esteammessages_remoteplay.proto\"g\n\x15CDiscoveryPingRequest\x12\
    \x1a\n\x08sequence\x18\x01\x20\x01(\rR\x08sequence\x122\n\x15packet_size\
    _requested\x18\x02\x20\x01(\rR\x13packetSizeRequested\"f\n\x16CDiscovery\
    PingResponse\x12\x1a\n\x08sequence\x18\x01\x20\x01(\rR\x08sequence\x120\
    \n\x14packet_size_received\x18\x02\x20\x01(\rR\x12packetSizeReceived\"B\
    \n\x1dCStreamingClientHandshakeInfo\x12!\n\x0cnetwork_test\x18\x02\x20\
    \x01(\x05R\x0bnetworkTest\"I\n\x13CClientHandshakeMsg\x122\n\x04info\x18\
    \x01\x20\x02(\x0b2\x1e.CStreamingClientHandshakeInfoR\x04info\"1\n\x1dCS\
    treamingServerHandshakeInfo\x12\x10\n\x03mtu\x18\x01\x20\x01(\x05R\x03mt\
    u\"I\n\x13CServerHandshakeMsg\x122\n\x04info\x18\x01\x20\x02(\x0b2\x1e.C\
    StreamingServerHandshakeInfoR\x04info\"\x8c\x01\n\x19CAuthenticationRequ\
    estMsg\x12\x14\n\x05token\x18\x01\x20\x01(\x0cR\x05token\x12?\n\x07versi\
    on\x18\x02\x20\x01(\x0e2\x0f.EStreamVersion:\x14k_EStreamVersionNoneR\
    \x07version\x12\x18\n\x07steamid\x18\x03\x20\x01(\x04R\x07steamid\"\xe5\
    \x01\n\x1aCAuthenticationResponseMsg\x12S\n\x06result\x18\x01\x20\x01(\
    \x0e20.CAuthenticationResponseMsg.AuthenticationResult:\tSUCCEEDEDR\x06r\
    esult\x12?\n\x07version\x18\x02\x20\x01(\x0e2\x0f.EStreamVersion:\x14k_E\
    StreamVersionNoneR\x07version\"1\n\x14AuthenticationResult\x12\r\n\tSUCC\
    EEDED\x10\0\x12\n\n\x06FAILED\x10\x01\"\x0f\n\rCKeepAliveMsg\"\xc4\x01\n\
    \x14CStartNetworkTestMsg\x12\x16\n\x06frames\x18\x01\x20\x01(\rR\x06fram\
    es\x12\x1c\n\tframerate\x18\x02\x20\x01(\rR\tframerate\x12!\n\x0cbitrate\
    _kbps\x18\x03\x20\x01(\rR\x0bbitrateKbps\x12,\n\x12burst_bitrate_kbps\
    \x18\x04\x20\x01(\rR\x10burstBitrateKbps\x12%\n\x0ebandwidth_test\x18\
    \x05\x20\x01(\x08R\rbandwidthTest\"\xd3\x01\n\x10CStreamVideoMode\x12\
    \x14\n\x05width\x18\x01\x20\x02(\rR\x05width\x12\x16\n\x06height\x18\x02\
    \x20\x02(\rR\x06height\x12!\n\x0crefresh_rate\x18\x03\x20\x01(\rR\x0bref\
    reshRate\x124\n\x16refresh_rate_numerator\x18\x04\x20\x01(\rR\x14refresh\
    RateNumerator\x128\n\x18refresh_rate_denominator\x18\x05\x20\x01(\rR\x16\
    refreshRateDenominator\"\xce\x01\n\x11CStreamVideoLimit\x12A\n\x05codec\
    \x18\x01\x20\x01(\x0e2\x12.EStreamVideoCodec:\x17k_EStreamVideoCodecNone\
    R\x05codec\x12%\n\x04mode\x18\x02\x20\x01(\x0b2\x11.CStreamVideoModeR\
    \x04mode\x12!\n\x0cbitrate_kbps\x18\x03\x20\x01(\x05R\x0bbitrateKbps\x12\
    ,\n\x12burst_bitrate_kbps\x18\x04\x20\x01(\x05R\x10burstBitrateKbps\"\
    \xe7\x05\n\x14CStreamingClientCaps\x12\x1f\n\x0bsystem_info\x18\x01\x20\
    \x01(\tR\nsystemInfo\x12,\n\x12system_can_suspend\x18\x02\x20\x01(\x08R\
    \x10systemCanSuspend\x12=\n\x1bmaximum_decode_bitrate_kbps\x18\x03\x20\
    \x01(\x05R\x18maximumDecodeBitrateKbps\x12;\n\x1amaximum_burst_bitrate_k\
    bps\x18\x04\x20\x01(\x05R\x17maximumBurstBitrateKbps\x12.\n\x13supports_\
    video_hevc\x18\x05\x20\x01(\x08R\x11supportsVideoHevc\x12.\n\x13disable_\
    steam_store\x18\x06\x20\x01(\x08R\x11disableSteamStore\x122\n\x15disable\
    _client_cursor\x18\x07\x20\x01(\x08R\x13disableClientCursor\x12E\n\x1fdi\
    sable_intel_hardware_encoding\x18\x08\x20\x01(\x08R\x1cdisableIntelHardw\
    areEncoding\x12A\n\x1ddisable_amd_hardware_encoding\x18\t\x20\x01(\x08R\
    \x1adisableAmdHardwareEncoding\x12G\n\x20disable_nvidia_hardware_encodin\
    g\x18\n\x20\x01(\x08R\x1ddisableNvidiaHardwareEncoding\x12\x1f\n\x0bform\
    _factor\x18\x0b\x20\x01(\x05R\nformFactor\x123\n\x16has_on_screen_keyboa\
    rd\x18\x0c\x20\x01(\x08R\x13hasOnScreenKeyboard\x12G\n\x15supported_colo\
    rspaces\x18\r\x20\x03(\x0e2\x12.EStreamColorspaceR\x14supportedColorspac\
    es\"\xdb\x0b\n\x16CStreamingClientConfig\x12M\n\x07quality\x18\x01\x20\
    \x01(\x0e2\x19.EStreamQualityPreference:\x18k_EStreamQualityBalancedR\
    \x07quality\x120\n\x14desired_resolution_x\x18\x02\x20\x01(\rR\x12desire\
    dResolutionX\x120\n\x14desired_resolution_y\x18\x03\x20\x01(\rR\x12desir\
    edResolutionY\x12>\n\x1bdesired_framerate_numerator\x18\x04\x20\x01(\rR\
    \x19desiredFramerateNumerator\x12B\n\x1ddesired_framerate_denominator\
    \x18\x05\x20\x01(\rR\x1bdesiredFramerateDenominator\x124\n\x14desired_bi\
    trate_kbps\x18\x06\x20\x01(\x05:\x02-1R\x12desiredBitrateKbps\x12>\n\x18\
    enable_hardware_decoding\x18\x07\x20\x01(\x08:\x04trueR\x16enableHardwar\
    eDecoding\x12C\n\x1aenable_performance_overlay\x18\x08\x20\x01(\x08:\x05\
    falseR\x18enablePerformanceOverlay\x12:\n\x16enable_video_streaming\x18\
    \t\x20\x01(\x08:\x04trueR\x14enableVideoStreaming\x12:\n\x16enable_audio\
    _streaming\x18\n\x20\x01(\x08:\x04trueR\x14enableAudioStreaming\x12:\n\
    \x16enable_input_streaming\x18\x0b\x20\x01(\x08:\x04trueR\x14enableInput\
    Streaming\x12(\n\x0eaudio_channels\x18\x0c\x20\x01(\x05:\x012R\raudioCha\
    nnels\x121\n\x11enable_video_hevc\x18\r\x20\x01(\x08:\x05falseR\x0fenabl\
    eVideoHevc\x12>\n\x18enable_performance_icons\x18\x0e\x20\x01(\x08:\x04t\
    rueR\x16enablePerformanceIcons\x12E\n\x1benable_microphone_streaming\x18\
    \x0f\x20\x01(\x08:\x05falseR\x19enableMicrophoneStreaming\x12:\n\x19cont\
    roller_overlay_hotkey\x18\x10\x20\x01(\tR\x17controllerOverlayHotkey\x12\
    N\n\x20enable_touch_controller_OBSOLETE\x18\x11\x20\x01(\x08:\x05falseR\
    \x1denableTouchControllerOBSOLETE\x12I\n\tp2p_scope\x18\x13\x20\x01(\x0e\
    2\x10.EStreamP2PScope:\x1ak_EStreamP2PScopeAutomaticR\x08p2pScope\x12A\n\
    \x19enable_audio_uncompressed\x18\x14\x20\x01(\x08:\x05falseR\x17enableA\
    udioUncompressed\x127\n\rdisplay_limit\x18\x15\x20\x01(\x0b2\x12.CStream\
    VideoLimitR\x0cdisplayLimit\x127\n\rquality_limit\x18\x16\x20\x01(\x0b2\
    \x12.CStreamVideoLimitR\x0cqualityLimit\x127\n\rruntime_limit\x18\x17\
    \x20\x01(\x0b2\x12.CStreamVideoLimitR\x0cruntimeLimit\x127\n\rdecoder_li\
    mit\x18\x18\x20\x03(\x0b2\x12.CStreamVideoLimitR\x0cdecoderLimit\x129\n\
    \x15enable_unreliable_fec\x18\x19\x20\x01(\x08:\x05falseR\x13enableUnrel\
    iableFec\"\xf3\x04\n\x16CStreamingServerConfig\x12:\n\x19change_desktop_\
    resolution\x18\x01\x20\x01(\x08R\x17changeDesktopResolution\x12B\n\x1ddy\
    namically_adjust_resolution\x18\x02\x20\x01(\x08R\x1bdynamicallyAdjustRe\
    solution\x120\n\x14enable_capture_nvfbc\x18\x03\x20\x01(\x08R\x12enableC\
    aptureNvfbc\x12E\n\x1fenable_hardware_encoding_nvidia\x18\x04\x20\x01(\
    \x08R\x1cenableHardwareEncodingNvidia\x12?\n\x1cenable_hardware_encoding\
    _amd\x18\x05\x20\x01(\x08R\x19enableHardwareEncodingAmd\x12C\n\x1eenable\
    _hardware_encoding_intel\x18\x06\x20\x01(\x08R\x1benableHardwareEncoding\
    Intel\x12:\n\x19software_encoding_threads\x18\x07\x20\x01(\x05R\x17softw\
    areEncodingThreads\x126\n\x17enable_traffic_priority\x18\x08\x20\x01(\
    \x08R\x15enableTrafficPriority\x12f\n\x0fhost_play_audio\x18\t\x20\x01(\
    \x0e2\x1f.EStreamHostPlayAudioPreference:\x1dk_EStreamHostPlayAudioDefau\
    ltR\rhostPlayAudio\"\xdc\x03\n\x11CNegotiatedConfig\x12#\n\rreliable_dat\
    a\x18\x01\x20\x01(\x08R\x0creliableData\x12]\n\x14selected_audio_codec\
    \x18\x02\x20\x01(\x0e2\x12.EStreamAudioCodec:\x17k_EStreamAudioCodecNone\
    R\x12selectedAudioCodec\x12]\n\x14selected_video_codec\x18\x03\x20\x01(\
    \x0e2\x12.EStreamVideoCodec:\x17k_EStreamVideoCodecNoneR\x12selectedVide\
    oCodec\x12V\n\x1eavailable_video_modes_OBSOLETE\x18\x04\x20\x03(\x0b2\
    \x11.CStreamVideoModeR\x1bavailableVideoModesOBSOLETE\x12*\n\x11enable_r\
    emote_hid\x18\x05\x20\x01(\x08R\x0fenableRemoteHid\x12,\n\x12enable_touc\
    h_input\x18\x06\x20\x01(\x08R\x10enableTouchInput\x122\n\x15disable_clie\
    nt_cursor\x18\x07\x20\x01(\x08R\x13disableClientCursor\"\xb0\x02\n\x13CN\
    egotiationInitMsg\x12#\n\rreliable_data\x18\x01\x20\x01(\x08R\x0creliabl\
    eData\x12H\n\x16supported_audio_codecs\x18\x02\x20\x03(\x0e2\x12.EStream\
    AudioCodecR\x14supportedAudioCodecs\x12H\n\x16supported_video_codecs\x18\
    \x03\x20\x03(\x0e2\x12.EStreamVideoCodecR\x14supportedVideoCodecs\x12.\n\
    \x13supports_remote_hid\x18\x04\x20\x01(\x08R\x11supportsRemoteHid\x120\
    \n\x14supports_touch_input\x18\x05\x20\x01(\x08R\x12supportsTouchInput\"\
    \xe2\x01\n\x18CNegotiationSetConfigMsg\x12*\n\x06config\x18\x01\x20\x02(\
    \x0b2\x12.CNegotiatedConfigR\x06config\x12O\n\x17streaming_client_config\
    \x18\x02\x20\x01(\x0b2\x17.CStreamingClientConfigR\x15streamingClientCon\
    fig\x12I\n\x15streaming_client_caps\x18\x03\x20\x01(\x0b2\x15.CStreaming\
    ClientCapsR\x13streamingClientCaps\"\x19\n\x17CNegotiationCompleteMsg\"\
    \xca\x01\n\x12CStartAudioDataMsg\x12\x18\n\x07channel\x18\x02\x20\x02(\r\
    R\x07channel\x12A\n\x05codec\x18\x03\x20\x01(\x0e2\x12.EStreamAudioCodec\
    :\x17k_EStreamAudioCodecNoneR\x05codec\x12\x1d\n\ncodec_data\x18\x04\x20\
    \x01(\x0cR\tcodecData\x12\x1c\n\tfrequency\x18\x05\x20\x01(\rR\tfrequenc\
    y\x12\x1a\n\x08channels\x18\x06\x20\x01(\rR\x08channels\"\x13\n\x11CStop\
    AudioDataMsg\"\xbe\x01\n\x12CStartVideoDataMsg\x12\x18\n\x07channel\x18\
    \x01\x20\x02(\rR\x07channel\x12A\n\x05codec\x18\x02\x20\x01(\x0e2\x12.ES\
    treamVideoCodec:\x17k_EStreamVideoCodecNoneR\x05codec\x12\x1d\n\ncodec_d\
    ata\x18\x03\x20\x01(\x0cR\tcodecData\x12\x14\n\x05width\x18\x04\x20\x01(\
    \rR\x05width\x12\x16\n\x06height\x18\x05\x20\x01(\rR\x06height\"\x13\n\
    \x11CStopVideoDataMsg\"0\n\x14CStartNeptuneDataMsg\x12\x18\n\x07channel\
    \x18\x01\x20\x02(\rR\x07channel\"\x15\n\x13CStopNeptuneDataMsg\"\xc2\x05\
    \n\x0eCRecordedInput\x12Q\n\x04type\x18\x01\x20\x01(\x0e2\x16.EStreamCon\
    trolMessage:%k_EStreamControlAuthenticationRequestR\x04type\x12\x1c\n\tt\
    imestamp\x18\x02\x20\x01(\rR\ttimestamp\x12<\n\x0bfinger_down\x18\x03\
    \x20\x01(\x0b2\x19.CInputTouchFingerDownMsgH\0R\nfingerDown\x12B\n\rfing\
    er_motion\x18\x04\x20\x01(\x0b2\x1b.CInputTouchFingerMotionMsgH\0R\x0cfi\
    ngerMotion\x126\n\tfinger_up\x18\x05\x20\x01(\x0b2\x17.CInputTouchFinger\
    UpMsgH\0R\x08fingerUp\x12:\n\x0cmouse_motion\x18\x06\x20\x01(\x0b2\x15.C\
    InputMouseMotionMsgH\0R\x0bmouseMotion\x127\n\x0bmouse_wheel\x18\x07\x20\
    \x01(\x0b2\x14.CInputMouseWheelMsgH\0R\nmouseWheel\x124\n\nmouse_down\
    \x18\x08\x20\x01(\x0b2\x13.CInputMouseDownMsgH\0R\tmouseDown\x12.\n\x08m\
    ouse_up\x18\t\x20\x01(\x0b2\x11.CInputMouseUpMsgH\0R\x07mouseUp\x12.\n\
    \x08key_down\x18\n\x20\x01(\x0b2\x11.CInputKeyDownMsgH\0R\x07keyDown\x12\
    (\n\x06key_up\x18\x0b\x20\x01(\x0b2\x0f.CInputKeyUpMsgH\0R\x05keyUp\x12$\
    \n\x04text\x18\x0c\x20\x01(\x0b2\x0e.CInputTextMsgH\0R\x04text\x12\"\n\
    \x03hid\x18\r\x20\x01(\x0b2\x0e.CRemoteHIDMsgH\0R\x03hidB\x06\n\x04data\
    \"A\n\x14CRecordedInputStream\x12)\n\x07entries\x18\x01\x20\x03(\x0b2\
    \x0f.CRecordedInputR\x07entries\"K\n\x14CInputLatencyTestMsg\x12\x1d\n\n\
    input_mark\x18\x01\x20\x02(\rR\tinputMark\x12\x14\n\x05color\x18\x02\x20\
    \x01(\rR\x05color\"\x9b\x01\n\x18CInputTouchFingerDownMsg\x12\x1d\n\ninp\
    ut_mark\x18\x01\x20\x01(\rR\tinputMark\x12\x1a\n\x08fingerid\x18\x02\x20\
    \x01(\x04R\x08fingerid\x12!\n\x0cx_normalized\x18\x03\x20\x01(\x02R\x0bx\
    Normalized\x12!\n\x0cy_normalized\x18\x04\x20\x01(\x02R\x0byNormalized\"\
    \x9d\x01\n\x1aCInputTouchFingerMotionMsg\x12\x1d\n\ninput_mark\x18\x01\
    \x20\x01(\rR\tinputMark\x12\x1a\n\x08fingerid\x18\x02\x20\x01(\x04R\x08f\
    ingerid\x12!\n\x0cx_normalized\x18\x03\x20\x01(\x02R\x0bxNormalized\x12!\
    \n\x0cy_normalized\x18\x04\x20\x01(\x02R\x0byNormalized\"\x99\x01\n\x16C\
    InputTouchFingerUpMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMa\
    rk\x12\x1a\n\x08fingerid\x18\x02\x20\x01(\x04R\x08fingerid\x12!\n\x0cx_n\
    ormalized\x18\x03\x20\x01(\x02R\x0bxNormalized\x12!\n\x0cy_normalized\
    \x18\x04\x20\x01(\x02R\x0byNormalized\"\x9b\x01\n\x14CInputMouseMotionMs\
    g\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\x12!\n\x0cx_norma\
    lized\x18\x02\x20\x01(\x02R\x0bxNormalized\x12!\n\x0cy_normalized\x18\
    \x03\x20\x01(\x02R\x0byNormalized\x12\x0e\n\x02dx\x18\x04\x20\x01(\x05R\
    \x02dx\x12\x0e\n\x02dy\x18\x05\x20\x01(\x05R\x02dy\"\x86\x01\n\x13CInput\
    MouseWheelMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\x12P\
    \n\tdirection\x18\x02\x20\x02(\x0e2\x1b.EStreamMouseWheelDirection:\x15k\
    _EStreamMouseWheelUpR\tdirection\"z\n\x12CInputMouseDownMsg\x12\x1d\n\ni\
    nput_mark\x18\x01\x20\x01(\rR\tinputMark\x12E\n\x06button\x18\x02\x20\
    \x02(\x0e2\x13.EStreamMouseButton:\x18k_EStreamMouseButtonLeftR\x06butto\
    n\"x\n\x10CInputMouseUpMsg\x12\x1d\n\ninput_mark\x18\x01\x20\x01(\rR\tin\
    putMark\x12E\n\x06button\x18\x02\x20\x02(\x0e2\x13.EStreamMouseButton:\
    \x18k_EStreamMouseButtonLeftR\x06button\"M\n\x10CInputKeyDownMsg\x12\x1d\
    \n\ninput_mark\x18\x01\x20\x01(\rR\tinputMark\x12\x1a\n\x08scancode\x18\
    \x02\x20\x02(\rR\x08scancode\"K\n\x0eCInputKeyUpMsg\x12\x1d\n\ninput_mar\
    k\x18\x01\x20\x01(\rR\tinputMark\x12\x1a\n\x08scancode\x18\x02\x20\x02(\
    \rR\x08scancode\"K\n\rCInputTextMsg\x12\x1d\n\ninput_mark\x18\x01\x20\
    \x01(\rR\tinputMark\x12\x1b\n\ttext_utf8\x18\x02\x20\x02(\tR\x08textUtf8\
    \"\"\n\x0cCSetTitleMsg\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"B\
    \n\x12CSetCaptureSizeMsg\x12\x14\n\x05width\x18\x01\x20\x01(\x05R\x05wid\
    th\x12\x16\n\x06height\x18\x02\x20\x01(\x05R\x06height\"Q\n\x0bCSetIconM\
    sg\x12\x14\n\x05width\x18\x01\x20\x01(\x05R\x05width\x12\x16\n\x06height\
    \x18\x02\x20\x01(\x05R\x06height\x12\x14\n\x05image\x18\x03\x20\x01(\x0c\
    R\x05image\"^\n\x11CSetFlashStateMsg\x12\x14\n\x05flags\x18\x01\x20\x01(\
    \rR\x05flags\x12\x14\n\x05count\x18\x02\x20\x01(\rR\x05count\x12\x1d\n\n\
    timeout_ms\x18\x03\x20\x01(\rR\ttimeoutMs\"V\n\x0eCShowCursorMsg\x12!\n\
    \x0cx_normalized\x18\x01\x20\x01(\x02R\x0bxNormalized\x12!\n\x0cy_normal\
    ized\x18\x02\x20\x01(\x02R\x0byNormalized\"\x10\n\x0eCHideCursorMsg\",\n\
    \rCSetCursorMsg\x12\x1b\n\tcursor_id\x18\x01\x20\x02(\x04R\x08cursorId\"\
    1\n\x12CGetCursorImageMsg\x12\x1b\n\tcursor_id\x18\x01\x20\x02(\x04R\x08\
    cursorId\"\x9f\x01\n\x12CSetCursorImageMsg\x12\x1b\n\tcursor_id\x18\x01\
    \x20\x02(\x04R\x08cursorId\x12\x14\n\x05width\x18\x02\x20\x01(\x05R\x05w\
    idth\x12\x16\n\x06height\x18\x03\x20\x01(\x05R\x06height\x12\x13\n\x05ho\
    t_x\x18\x04\x20\x01(\x05R\x04hotX\x12\x13\n\x05hot_y\x18\x05\x20\x01(\
    \x05R\x04hotY\x12\x14\n\x05image\x18\x06\x20\x01(\x0cR\x05image\"*\n\x12\
    CSetCursorScaleMsg\x12\x14\n\x05scale\x18\x01\x20\x01(\x02R\x05scale\"D\
    \n\x14CVideoDecoderInfoMsg\x12\x12\n\x04info\x18\x01\x20\x01(\tR\x04info\
    \x12\x18\n\x07threads\x18\x02\x20\x01(\x05R\x07threads\"*\n\x14CVideoEnc\
    oderInfoMsg\x12\x12\n\x04info\x18\x01\x20\x01(\tR\x04info\"\x0b\n\tCPaus\
    eMsg\"\x0c\n\nCResumeMsg\"\x1a\n\x18CEnableHighResCaptureMsg\"\x1b\n\x19\
    CDisableHighResCaptureMsg\"\x17\n\x15CEnableNeptuneDataMsg\"\x18\n\x16CD\
    isableNeptuneDataMsg\"\x1a\n\x18CPauseControllerInputMsg\"\x1b\n\x19CRes\
    umeControllerInputMsg\"\x19\n\x17CToggleMagnificationMsg\"+\n\x0fCSetCap\
    slockMsg\x12\x18\n\x07pressed\x18\x01\x20\x01(\x08R\x07pressed\"\xac\x03\
    \n\x15CStreamingKeymapEntry\x12\x1a\n\x08scancode\x18\x01\x20\x01(\x05R\
    \x08scancode\x12%\n\x0enormal_keycode\x18\x02\x20\x01(\x05R\rnormalKeyco\
    de\x12#\n\rshift_keycode\x18\x03\x20\x01(\x05R\x0cshiftKeycode\x12)\n\
    \x10capslock_keycode\x18\x04\x20\x01(\x05R\x0fcapslockKeycode\x124\n\x16\
    shift_capslock_keycode\x18\x05\x20\x01(\x05R\x14shiftCapslockKeycode\x12\
    #\n\raltgr_keycode\x18\x06\x20\x01(\x05R\x0caltgrKeycode\x12.\n\x13altgr\
    _shift_keycode\x18\x07\x20\x01(\x05R\x11altgrShiftKeycode\x124\n\x16altg\
    r_capslock_keycode\x18\x08\x20\x01(\x05R\x14altgrCapslockKeycode\x12?\n\
    \x1caltgr_shift_capslock_keycode\x18\t\x20\x01(\x05R\x19altgrShiftCapslo\
    ckKeycode\"D\n\x10CStreamingKeymap\x120\n\x07entries\x18\x01\x20\x03(\
    \x0b2\x16.CStreamingKeymapEntryR\x07entries\":\n\rCSetKeymapMsg\x12)\n\
    \x06keymap\x18\x01\x20\x01(\x0b2\x11.CStreamingKeymapR\x06keymap\"\x0e\n\
    \x0cCStopRequest\"\x0e\n\x0cCQuitRequest\"/\n\x10CDeleteCursorMsg\x12\
    \x1b\n\tcursor_id\x18\x01\x20\x02(\x04R\x08cursorId\"L\n\x19CSetStreamin\
    gClientConfig\x12/\n\x06config\x18\x01\x20\x02(\x0b2\x17.CStreamingClien\
    tConfigR\x06config\"%\n\nCSetQoSMsg\x12\x17\n\x07use_qos\x18\x01\x20\x02\
    (\x08R\x06useQos\"\xb6\x01\n\x16CSetTargetFramerateMsg\x12\x1c\n\tframer\
    ate\x18\x01\x20\x02(\rR\tframerate\x12\x18\n\x07reasons\x18\x02\x20\x01(\
    \rR\x07reasons\x12/\n\x13framerate_numerator\x18\x03\x20\x01(\rR\x12fram\
    erateNumerator\x123\n\x15framerate_denominator\x18\x04\x20\x01(\rR\x14fr\
    amerateDenominator\"0\n\x14CSetTargetBitrateMsg\x12\x18\n\x07bitrate\x18\
    \x01\x20\x02(\x05R\x07bitrate\".\n\x12COverlayEnabledMsg\x12\x18\n\x07en\
    abled\x18\x01\x20\x02(\x08R\x07enabled\"1\n\x10CSetGammaRampMsg\x12\x1d\
    \n\ngamma_ramp\x18\x01\x20\x01(\x0cR\tgammaRamp\"\xa1\x01\n\x0fCSetActiv\
    ityMsg\x12C\n\x08activity\x18\x01\x20\x01(\x0e2\x10.EStreamActivity:\x15\
    k_EStreamActivityIdleR\x08activity\x12\x14\n\x05appid\x18\x02\x20\x01(\r\
    R\x05appid\x12\x16\n\x06gameid\x18\x03\x20\x01(\x04R\x06gameid\x12\x1b\n\
    \tgame_name\x18\x04\x20\x01(\tR\x08gameName\"\x13\n\x11CSystemSuspendMsg\
    \"4\n\x16CVirtualHereRequestMsg\x12\x1a\n\x08hostname\x18\x01\x20\x01(\t\
    R\x08hostname\"J\n\x14CVirtualHereReadyMsg\x122\n\x15licensed_device_cou\
    nt\x18\x01\x20\x01(\rR\x13licensedDeviceCount\"C\n\x1aCVirtualHereShareD\
    eviceMsg\x12%\n\x0edevice_address\x18\x01\x20\x01(\tR\rdeviceAddress\"0\
    \n\x14CSetSpectatorModeMsg\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\
    \x07enabled\"F\n\rCRemoteHIDMsg\x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\
    \x04data\x12!\n\x0cactive_input\x18\x02\x20\x01(\x08R\x0bactiveInput\"c\
    \n\x15CTouchConfigActiveMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05ap\
    pid\x12\x1a\n\x08revision\x18\x02\x20\x01(\rR\x08revision\x12\x18\n\x07c\
    reator\x18\x03\x20\x01(\x04R\x07creator\".\n\x16CGetTouchConfigDataMsg\
    \x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\"\x90\x01\n\x16CSetTouc\
    hConfigDataMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1a\n\
    \x08revision\x18\x02\x20\x01(\rR\x08revision\x12\x12\n\x04data\x18\x03\
    \x20\x01(\x0cR\x04data\x12\x16\n\x06layout\x18\x04\x20\x01(\x0cR\x06layo\
    ut\x12\x18\n\x07creator\x18\x05\x20\x01(\x04R\x07creator\"I\n\x19CSaveTo\
    uchConfigLayoutMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x16\n\x06layout\x18\x04\x20\x01(\x0cR\x06layout\"S\n\x18CTouchActionSet\
    ActiveMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12!\n\x0cacti\
    onset_id\x18\x02\x20\x01(\x05R\x0bactionsetId\"W\n\x1cCTouchActionSetLay\
    erAddedMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12!\n\x0cact\
    ionset_id\x18\x02\x20\x01(\x05R\x0bactionsetId\"Y\n\x1eCTouchActionSetLa\
    yerRemovedMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12!\n\x0c\
    actionset_id\x18\x02\x20\x01(\x05R\x0bactionsetId\"@\n\x14CGetTouchIconD\
    ataMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x12\n\x04icon\
    \x18\x02\x20\x01(\tR\x04icon\"T\n\x14CSetTouchIconDataMsg\x12\x14\n\x05a\
    ppid\x18\x01\x20\x01(\rR\x05appid\x12\x12\n\x04icon\x18\x02\x20\x01(\tR\
    \x04icon\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\x92\x04\n!CRe\
    motePlayTogetherGroupUpdateMsg\x12C\n\x07players\x18\x01\x20\x03(\x0b2).\
    CRemotePlayTogetherGroupUpdateMsg.PlayerR\x07players\x12!\n\x0cplayer_in\
    dex\x18\x02\x20\x01(\x05R\x0bplayerIndex\x121\n\x14miniprofile_location\
    \x18\x03\x20\x01(\tR\x13miniprofileLocation\x12\x1b\n\tgame_name\x18\x04\
    \x20\x01(\tR\x08gameName\x12'\n\x0favatar_location\x18\x05\x20\x01(\tR\
    \x0eavatarLocation\x1a\x8b\x02\n\x06Player\x12\x1c\n\taccountid\x18\x01\
    \x20\x01(\rR\taccountid\x12\x18\n\x07guestid\x18\x02\x20\x01(\rR\x07gues\
    tid\x12)\n\x10keyboard_enabled\x18\x03\x20\x01(\x08R\x0fkeyboardEnabled\
    \x12#\n\rmouse_enabled\x18\x04\x20\x01(\x08R\x0cmouseEnabled\x12-\n\x12c\
    ontroller_enabled\x18\x05\x20\x01(\x08R\x11controllerEnabled\x12)\n\x10c\
    ontroller_slots\x18\x06\x20\x03(\rR\x0fcontrollerSlots\x12\x1f\n\x0bavat\
    ar_hash\x18\x07\x20\x01(\x0cR\navatarHash\"=\n\x1fCSetInputTemporarilyDi\
    sabledMsg\x12\x1a\n\x08disabled\x18\x01\x20\x01(\x08R\x08disabled\".\n\
    \x16CSetQualityOverrideMsg\x12\x14\n\x05value\x18\x01\x20\x01(\x05R\x05v\
    alue\".\n\x16CSetBitrateOverrideMsg\x12\x14\n\x05value\x18\x01\x20\x01(\
    \x05R\x05value\"\x1a\n\x18CShowOnScreenKeyboardMsg\"\xba\x01\n#CControll\
    erPersonalizationUpdateMsg\x12'\n\x0fcontroller_path\x18\x01\x20\x01(\tR\
    \x0econtrollerPath\x12'\n\x0fcontroller_name\x18\x02\x20\x01(\tR\x0econt\
    rollerName\x12A\n\x1dreverse_diamond_button_layout\x18\x03\x20\x01(\x08R\
    \x1areverseDiamondButtonLayout\";\n\x12CVRConnectionReady\x12%\n\x0econn\
    ect_params\x18\x01\x20\x01(\tR\rconnectParams\".\n\x12CStreamDataLostMsg\
    \x12\x18\n\x07packets\x18\x01\x20\x03(\rR\x07packets\"\x83\x01\n\x0cCAud\
    ioFormat\x129\n\x06format\x18\x01\x20\x02(\x0e2\r.EAudioFormat:\x12k_EAu\
    dioFormatNoneR\x06format\x12\x1c\n\tfrequency\x18\x02\x20\x01(\rR\tfrequ\
    ency\x12\x1a\n\x08channels\x18\x03\x20\x01(\rR\x08channels\"w\n\x0cCVide\
    oFormat\x129\n\x06format\x18\x01\x20\x02(\x0e2\r.EVideoFormat:\x12k_EVid\
    eoFormatNoneR\x06format\x12\x14\n\x05width\x18\x02\x20\x01(\rR\x05width\
    \x12\x16\n\x06height\x18\x03\x20\x01(\rR\x06height\"t\n\x0bCFrameEvent\
    \x12G\n\x08event_id\x18\x01\x20\x02(\x0e2\x12.EStreamFrameEvent:\x18k_ES\
    treamInputEventStartR\x07eventId\x12\x1c\n\ttimestamp\x18\x02\x20\x02(\r\
    R\ttimestamp\"\xe5\x03\n\x0bCFrameStats\x12\x19\n\x08frame_id\x18\x01\
    \x20\x02(\rR\x07frameId\x12\x1d\n\ninput_mark\x18\x02\x20\x01(\rR\tinput\
    Mark\x12$\n\x06events\x18\x03\x20\x03(\x0b2\x0c.CFrameEventR\x06events\
    \x12H\n\x06result\x18\x04\x20\x02(\x0e2\x13.EStreamFrameResult:\x1bk_ESt\
    reamFrameResultPendingR\x06result\x12*\n\x11frame_start_delta\x18\x05\
    \x20\x01(\x02R\x0fframeStartDelta\x12.\n\x13frame_display_delta\x18\x06\
    \x20\x01(\x02R\x11frameDisplayDelta\x12\x1b\n\tping_time\x18\x07\x20\x01\
    (\x02R\x08pingTime\x12%\n\x0eserver_bitrate\x18\x08\x20\x01(\x02R\rserve\
    rBitrate\x12%\n\x0eclient_bitrate\x18\t\x20\x01(\x02R\rclientBitrate\x12\
    %\n\x0elink_bandwidth\x18\n\x20\x01(\x02R\rlinkBandwidth\x12\x1f\n\x0bpa\
    cket_loss\x18\x0b\x20\x01(\x02R\npacketLoss\x12\x1d\n\nframe_size\x18\
    \x0c\x20\x01(\rR\tframeSize\"\xaa\x01\n\x1aCFrameStatAccumulatedValue\
    \x12D\n\tstat_type\x18\x01\x20\x02(\x0e2\x16.EFrameAccumulatedStat:\x0fk\
    _EFrameStatFPSR\x08statType\x12\x14\n\x05count\x18\x02\x20\x02(\x05R\x05\
    count\x12\x18\n\x07average\x18\x03\x20\x02(\x02R\x07average\x12\x16\n\
    \x06stddev\x18\x04\x20\x01(\x02R\x06stddev\"\xf3\x01\n\x12CFrameStatsLis\
    tMsg\x12G\n\tdata_type\x18\x01\x20\x02(\x0e2\x13.EStreamingDataType:\x15\
    k_EStreamingAudioDataR\x08dataType\x12\"\n\x05stats\x18\x02\x20\x03(\x0b\
    2\x0c.CFrameStatsR\x05stats\x12H\n\x11accumulated_stats\x18\x03\x20\x03(\
    \x0b2\x1b.CFrameStatAccumulatedValueR\x10accumulatedStats\x12&\n\x0flate\
    st_frame_id\x18\x04\x20\x02(\x05R\rlatestFrameId\"\xd5\x01\n\x16CStreami\
    ngSessionStats\x122\n\x15frame_loss_percentage\x18\x01\x20\x01(\x02R\x13\
    frameLossPercentage\x125\n\x17average_network_time_ms\x18\x02\x20\x01(\
    \x02R\x14averageNetworkTimeMs\x123\n\x16stddev_network_time_ms\x18\x03\
    \x20\x01(\x02R\x13stddevNetworkTimeMs\x12\x1b\n\ttest_data\x18\x04\x20\
    \x01(\tR\x08testData\"/\n\rCDebugDumpMsg\x12\x1e\n\nscreenshot\x18\x01\
    \x20\x01(\x0cR\nscreenshot\"7\n\x07CLogMsg\x12\x12\n\x04type\x18\x01\x20\
    \x01(\x05R\x04type\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\
    \\\n\rCLogUploadMsg\x127\n\x04type\x18\x01\x20\x01(\x0e2\r.ELogFileType:\
    \x14k_ELogFileSystemBootR\x04type\x12\x12\n\x04data\x18\x03\x20\x01(\x0c\
    R\x04data\"\x86\x03\n\x13CTransportSignalMsg\x12:\n\x06webrtc\x18\x01\
    \x20\x01(\x0b2\".CTransportSignalMsg.WebRTCMessageR\x06webrtc\x12\x10\n\
    \x03sdr\x18\x02\x20\x03(\x0cR\x03sdr\x1a\xa0\x02\n\rWebRTCMessage\x12\
    \x1c\n\x08greeting\x18\x01\x20\x01(\x08H\0R\x08greeting\x12\x16\n\x05off\
    er\x18\x02\x20\x01(\tH\0R\x05offer\x12\x18\n\x06answer\x18\x03\x20\x01(\
    \tH\0R\x06answer\x12L\n\tcandidate\x18\x04\x20\x01(\x0b2,.CTransportSign\
    alMsg.WebRTCMessage.CandidateH\0R\tcandidate\x1aj\n\tCandidate\x12\x17\n\
    \x07sdp_mid\x18\x01\x20\x01(\tR\x06sdpMid\x12&\n\x0fsdp_mline_index\x18\
    \x02\x20\x01(\x05R\rsdpMlineIndex\x12\x1c\n\tcandidate\x18\x03\x20\x01(\
    \tR\tcandidateB\x05\n\x03msg\"\x8d\t\n\x14CControllerConfigMsg\x12b\n\
    \x04type\x18\x01\x20\x02(\x0e2\x1b.EStreamControllerConfigMsg:1k_EStream\
    ControllerConfigMsg_RequestConfigsForAppR\x04type\x12&\n\x0econtrollerPa\
    th\x18\x02\x20\x01(\tR\x0econtrollerPath\x12\x14\n\x05appid\x18\x03\x20\
    \x01(\rR\x05appid\x12q\n\x17personalizationResponse\x18\x04\x20\x01(\x0b\
    27.CControllerConfigMsg.ControllerPersonalizationResponseR\x17personaliz\
    ationResponse\x12V\n\x0econfigResponse\x18\x06\x20\x03(\x0b2..CControlle\
    rConfigMsg.ControllerConfigResponseR\x0econfigResponse\x12e\n\x15activeC\
    onfigChangeMsg\x18\x07\x20\x01(\x0b2/.CControllerConfigMsg.ControllerAct\
    iveConfigMsgR\x15activeConfigChangeMsg\x1a\xe8\x01\n\x18ControllerConfig\
    Response\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1c\n\tconf\
    igURL\x18\x02\x20\x01(\tR\tconfigURL\x12&\n\x0econtrollerType\x18\x03\
    \x20\x01(\rR\x0econtrollerType\x12&\n\x0econtrollerData\x18\x04\x20\x01(\
    \tR\x0econtrollerData\x12&\n\x0eselectionOrder\x18\x05\x20\x01(\rR\x0ese\
    lectionOrder\x12\x20\n\x0bactionBlock\x18\x06\x20\x01(\x08R\x0bactionBlo\
    ck\x1aU\n!ControllerPersonalizationResponse\x120\n\x13personalizationDat\
    a\x18\x01\x20\x01(\tR\x13personalizationData\x1a\xbc\x01\n$ControllerAct\
    iveConfigChangeResponse\x12\x1c\n\tconfigURL\x18\x02\x20\x01(\tR\tconfig\
    URL\x12&\n\x0econtrollerType\x18\x03\x20\x01(\rR\x0econtrollerType\x12&\
    \n\x0econtrollerData\x18\x04\x20\x01(\tR\x0econtrollerData\x12&\n\x0esel\
    ectionOrder\x18\x05\x20\x01(\rR\x0eselectionOrder\x1a\x9f\x01\n\x19Contr\
    ollerActiveConfigMsg\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\
    \x1c\n\tconfigURL\x18\x02\x20\x01(\tR\tconfigURL\x12&\n\x0econtrollerTyp\
    e\x18\x03\x20\x01(\rR\x0econtrollerType\x12&\n\x0econtrollerData\x18\x04\
    \x20\x01(\tR\x0econtrollerData*\xb3\x01\n\x0eEStreamChannel\x12$\n\x17k_\
    EStreamChannelInvalid\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\x12\
    \x1d\n\x19k_EStreamChannelDiscovery\x10\0\x12\x1b\n\x17k_EStreamChannelC\
    ontrol\x10\x01\x12\x19\n\x15k_EStreamChannelStats\x10\x02\x12$\n\x20k_ES\
    treamChannelDataChannelStart\x10\x03*`\n\x17EStreamDiscoveryMessage\x12!\
    \n\x1dk_EStreamDiscoveryPingRequest\x10\x01\x12\"\n\x1ek_EStreamDiscover\
    yPingResponse\x10\x02*\xa8\x1f\n\x15EStreamControlMessage\x12)\n%k_EStre\
    amControlAuthenticationRequest\x10\x01\x12*\n&k_EStreamControlAuthentica\
    tionResponse\x10\x02\x12#\n\x1fk_EStreamControlNegotiationInit\x10\x03\
    \x12(\n$k_EStreamControlNegotiationSetConfig\x10\x04\x12'\n#k_EStreamCon\
    trolNegotiationComplete\x10\x05\x12#\n\x1fk_EStreamControlClientHandshak\
    e\x10\x06\x12#\n\x1fk_EStreamControlServerHandshake\x10\x07\x12$\n\x20k_\
    EStreamControlStartNetworkTest\x10\x08\x12\x1d\n\x19k_EStreamControlKeep\
    Alive\x10\t\x12'\n#k_EStreamControl_LAST_SETUP_MESSAGE\x10\x0f\x12\"\n\
    \x1ek_EStreamControlStartAudioData\x102\x12!\n\x1dk_EStreamControlStopAu\
    dioData\x103\x12\"\n\x1ek_EStreamControlStartVideoData\x104\x12!\n\x1dk_\
    EStreamControlStopVideoData\x105\x12$\n\x20k_EStreamControlInputMouseMot\
    ion\x106\x12#\n\x1fk_EStreamControlInputMouseWheel\x107\x12\"\n\x1ek_ESt\
    reamControlInputMouseDown\x108\x12\x20\n\x1ck_EStreamControlInputMouseUp\
    \x109\x12\x20\n\x1ck_EStreamControlInputKeyDown\x10:\x12\x1e\n\x1ak_EStr\
    eamControlInputKeyUp\x10;\x121\n-k_EStreamControlInputGamepadAttached_OB\
    SOLETE\x10<\x12.\n*k_EStreamControlInputGamepadEvent_OBSOLETE\x10=\x121\
    \n-k_EStreamControlInputGamepadDetached_OBSOLETE\x10>\x12\x1e\n\x1ak_ESt\
    reamControlShowCursor\x10?\x12\x1e\n\x1ak_EStreamControlHideCursor\x10@\
    \x12\x1d\n\x19k_EStreamControlSetCursor\x10A\x12\"\n\x1ek_EStreamControl\
    GetCursorImage\x10B\x12\"\n\x1ek_EStreamControlSetCursorImage\x10C\x12\
    \x20\n\x1ck_EStreamControlDeleteCursor\x10D\x12&\n\"k_EStreamControlSetT\
    argetFramerate\x10E\x12$\n\x20k_EStreamControlInputLatencyTest\x10F\x12*\
    \n&k_EStreamControlGamepadRumble_OBSOLETE\x10G\x12\"\n\x1ek_EStreamContr\
    olOverlayEnabled\x10J\x124\n0k_EStreamControlInputControllerAttached_OBS\
    OLETE\x10K\x121\n-k_EStreamControlInputControllerState_OBSOLETE\x10L\x12\
    /\n+k_EStreamControlTriggerHapticPulse_OBSOLETE\x10M\x124\n0k_EStreamCon\
    trolInputControllerDetached_OBSOLETE\x10N\x12$\n\x20k_EStreamControlVide\
    oDecoderInfo\x10P\x12\x1c\n\x18k_EStreamControlSetTitle\x10Q\x12\x1b\n\
    \x17k_EStreamControlSetIcon\x10R\x12\x1f\n\x1bk_EStreamControlQuitReques\
    t\x10S\x12\x1a\n\x16k_EStreamControlSetQoS\x10W\x12<\n8k_EStreamControlI\
    nputControllerWirelessPresence_OBSOLETE\x10X\x12\x20\n\x1ck_EStreamContr\
    olSetGammaRamp\x10Y\x12$\n\x20k_EStreamControlVideoEncoderInfo\x10Z\x124\
    \n0k_EStreamControlInputControllerStateHID_OBSOLETE\x10]\x12$\n\x20k_ESt\
    reamControlSetTargetBitrate\x10^\x128\n4k_EStreamControlSetControllerPai\
    ringEnabled_OBSOLETE\x10_\x127\n3k_EStreamControlSetControllerPairingRes\
    ult_OBSOLETE\x10`\x128\n4k_EStreamControlTriggerControllerDisconnect_OBS\
    OLETE\x10a\x12\x1f\n\x1bk_EStreamControlSetActivity\x10b\x12,\n(k_EStrea\
    mControlSetStreamingClientConfig\x10c\x12!\n\x1dk_EStreamControlSystemSu\
    spend\x10d\x122\n.k_EStreamControlSetControllerSettings_OBSOLETE\x10e\
    \x12&\n\"k_EStreamControlVirtualHereRequest\x10f\x12$\n\x20k_EStreamCont\
    rolVirtualHereReady\x10g\x12*\n&k_EStreamControlVirtualHereShareDevice\
    \x10h\x12$\n\x20k_EStreamControlSetSpectatorMode\x10i\x12\x1d\n\x19k_ESt\
    reamControlRemoteHID\x10j\x12'\n#k_EStreamControlStartMicrophoneData\x10\
    k\x12&\n\"k_EStreamControlStopMicrophoneData\x10l\x12\x1d\n\x19k_EStream\
    ControlInputText\x10m\x12%\n!k_EStreamControlTouchConfigActive\x10n\x12&\
    \n\"k_EStreamControlGetTouchConfigData\x10o\x12&\n\"k_EStreamControlSetT\
    ouchConfigData\x10p\x12)\n%k_EStreamControlSaveTouchConfigLayout\x10q\
    \x12(\n$k_EStreamControlTouchActionSetActive\x10r\x12$\n\x20k_EStreamCon\
    trolGetTouchIconData\x10s\x12$\n\x20k_EStreamControlSetTouchIconData\x10\
    t\x12(\n$k_EStreamControlInputTouchFingerDown\x10u\x12*\n&k_EStreamContr\
    olInputTouchFingerMotion\x10v\x12&\n\"k_EStreamControlInputTouchFingerUp\
    \x10w\x12\"\n\x1ek_EStreamControlSetCaptureSize\x10x\x12!\n\x1dk_EStream\
    ControlSetFlashState\x10y\x12\x19\n\x15k_EStreamControlPause\x10z\x12\
    \x1a\n\x16k_EStreamControlResume\x10{\x12(\n$k_EStreamControlEnableHighR\
    esCapture\x10|\x12)\n%k_EStreamControlDisableHighResCapture\x10}\x12'\n#\
    k_EStreamControlToggleMagnification\x10~\x12\x1f\n\x1bk_EStreamControlSe\
    tCapslock\x10\x7f\x12\x1e\n\x19k_EStreamControlSetKeymap\x10\x80\x01\x12\
    \x20\n\x1bk_EStreamControlStopRequest\x10\x81\x01\x12-\n(k_EStreamContro\
    lTouchActionSetLayerAdded\x10\x82\x01\x12/\n*k_EStreamControlTouchAction\
    SetLayerRemoved\x10\x83\x01\x122\n-k_EStreamControlRemotePlayTogetherGro\
    upUpdate\x10\x84\x01\x120\n+k_EStreamControlSetInputTemporarilyDisabled\
    \x10\x85\x01\x12'\n\"k_EStreamControlSetQualityOverride\x10\x86\x01\x12'\
    \n\"k_EStreamControlSetBitrateOverride\x10\x87\x01\x12)\n$k_EStreamContr\
    olShowOnScreenKeyboard\x10\x88\x01\x12(\n#k_EStreamControlControllerConf\
    igMsg\x10\x89\x01\x124\n/k_EStreamControlControllerPersonalizationUpdate\
    \x10\x8a\x01\x12&\n!k_EStreamControlEnableNeptuneData\x10\x8b\x01\x12'\n\
    \"k_EStreamControlDisableNeptuneData\x10\x8c\x01\x12%\n\x20k_EStreamCont\
    rolStartNeptuneData\x10\x8d\x01\x12$\n\x1fk_EStreamControlStopNeptuneDat\
    a\x10\x8e\x01\x12)\n$k_EStreamControlPauseControllerInput\x10\x8f\x01\
    \x12*\n%k_EStreamControlResumeControllerInput\x10\x90\x01\x12&\n!k_EStre\
    amControlVRConnectionReady\x10\x91\x01\x12#\n\x1ek_EStreamControlSetCurs\
    orScale\x10\x92\x01*G\n\x0eEStreamVersion\x12\x18\n\x14k_EStreamVersionN\
    one\x10\0\x12\x1b\n\x17k_EStreamVersionCurrent\x10\x01*\xc0\x01\n\x11ESt\
    reamAudioCodec\x12\x1b\n\x17k_EStreamAudioCodecNone\x10\0\x12\x1a\n\x16k\
    _EStreamAudioCodecRaw\x10\x01\x12\x1d\n\x19k_EStreamAudioCodecVorbis\x10\
    \x02\x12\x1b\n\x17k_EStreamAudioCodecOpus\x10\x03\x12\x1a\n\x16k_EStream\
    AudioCodecMP3\x10\x04\x12\x1a\n\x16k_EStreamAudioCodecAAC\x10\x05*\xfa\
    \x01\n\x11EStreamVideoCodec\x12\x1b\n\x17k_EStreamVideoCodecNone\x10\0\
    \x12\x1a\n\x16k_EStreamVideoCodecRaw\x10\x01\x12\x1a\n\x16k_EStreamVideo\
    CodecVP8\x10\x02\x12\x1a\n\x16k_EStreamVideoCodecVP9\x10\x03\x12\x1b\n\
    \x17k_EStreamVideoCodecH264\x10\x04\x12\x1b\n\x17k_EStreamVideoCodecHEVC\
    \x10\x05\x12\x1c\n\x18k_EStreamVideoCodecORBX1\x10\x06\x12\x1c\n\x18k_ES\
    treamVideoCodecORBX2\x10\x07*\x99\x01\n\x18EStreamQualityPreference\x12&\
    \n\x19k_EStreamQualityAutomatic\x10\xff\xff\xff\xff\xff\xff\xff\xff\xff\
    \x01\x12\x18\n\x14k_EStreamQualityFast\x10\x01\x12\x1c\n\x18k_EStreamQua\
    lityBalanced\x10\x02\x12\x1d\n\x19k_EStreamQualityBeautiful\x10\x03*X\n\
    \x0eEStreamBitrate\x12'\n\x1ak_EStreamBitrateAutodetect\x10\xff\xff\xff\
    \xff\xff\xff\xff\xff\xff\x01\x12\x1d\n\x19k_EStreamBitrateUnlimited\x10\
    \0*\xff\x01\n\x11EStreamColorspace\x12\x1f\n\x1bk_EStreamColorspace_Unkn\
    own\x10\0\x12\x1d\n\x19k_EStreamColorspace_BT601\x10\x01\x12\"\n\x1ek_ES\
    treamColorspace_BT601_Full\x10\x02\x12\x1d\n\x19k_EStreamColorspace_BT70\
    9\x10\x03\x12\"\n\x1ek_EStreamColorspace_BT709_Full\x10\x04\x12\x1e\n\
    \x1ak_EStreamColorspace_BT2020\x10\x05\x12#\n\x1fk_EStreamColorspace_BT2\
    020_Full\x10\x06*\xaa\x01\n\x0fEStreamP2PScope\x12\x1e\n\x1ak_EStreamP2P\
    ScopeAutomatic\x10\0\x12\x1d\n\x19k_EStreamP2PScopeDisabled\x10\x01\x12\
    \x1b\n\x17k_EStreamP2PScopeOnlyMe\x10\x02\x12\x1c\n\x18k_EStreamP2PScope\
    Friends\x10\x03\x12\x1d\n\x19k_EStreamP2PScopeEveryone\x10\x04*e\n\x1eES\
    treamHostPlayAudioPreference\x12!\n\x1dk_EStreamHostPlayAudioDefault\x10\
    \0\x12\x20\n\x1ck_EStreamHostPlayAudioAlways\x10\x01*\x87\x01\n\x12EStre\
    amingDataType\x12\x19\n\x15k_EStreamingAudioData\x10\0\x12\x19\n\x15k_ES\
    treamingVideoData\x10\x01\x12\x1e\n\x1ak_EStreamingMicrophoneData\x10\
    \x02\x12\x1b\n\x17k_EStreamingNeptuneData\x10\x03*\xcb\x01\n\x12EStreamM\
    ouseButton\x12\x1c\n\x18k_EStreamMouseButtonLeft\x10\x01\x12\x1d\n\x19k_\
    EStreamMouseButtonRight\x10\x02\x12\x1e\n\x1ak_EStreamMouseButtonMiddle\
    \x10\x10\x12\x1a\n\x16k_EStreamMouseButtonX1\x10\x20\x12\x1a\n\x16k_EStr\
    eamMouseButtonX2\x10@\x12\x20\n\x1bk_EStreamMouseButtonUnknown\x10\x80\
    \x20*\x98\x01\n\x1aEStreamMouseWheelDirection\x12\x19\n\x15k_EStreamMous\
    eWheelUp\x10x\x12$\n\x17k_EStreamMouseWheelDown\x10\x88\xff\xff\xff\xff\
    \xff\xff\xff\xff\x01\x12\x1b\n\x17k_EStreamMouseWheelLeft\x10\x03\x12\
    \x1c\n\x18k_EStreamMouseWheelRight\x10\x04*\x89\x02\n\x17EStreamFramerat\
    eLimiter\x12!\n\x1dk_EStreamFramerateSlowCapture\x10\x01\x12!\n\x1dk_ESt\
    reamFramerateSlowConvert\x10\x02\x12\x20\n\x1ck_EStreamFramerateSlowEnco\
    de\x10\x04\x12!\n\x1dk_EStreamFramerateSlowNetwork\x10\x08\x12\x20\n\x1c\
    k_EStreamFramerateSlowDecode\x10\x10\x12\x1e\n\x1ak_EStreamFramerateSlow\
    Game\x10\x20\x12!\n\x1dk_EStreamFramerateSlowDisplay\x10@*\xa5\x01\n\x0f\
    EStreamActivity\x12\x19\n\x15k_EStreamActivityIdle\x10\x01\x12\x19\n\x15\
    k_EStreamActivityGame\x10\x02\x12\x1c\n\x18k_EStreamActivityDesktop\x10\
    \x03\x12\"\n\x1ek_EStreamActivitySecureDesktop\x10\x04\x12\x1a\n\x16k_ES\
    treamActivityMusic\x10\x05*D\n\x12EStreamDataMessage\x12\x17\n\x13k_EStr\
    eamDataPacket\x10\x01\x12\x15\n\x11k_EStreamDataLost\x10\x02*d\n\x0cEAud\
    ioFormat\x12\x16\n\x12k_EAudioFormatNone\x10\0\x12#\n\x1fk_EAudioFormat1\
    6BitLittleEndian\x10\x01\x12\x17\n\x13k_EAudioFormatFloat\x10\x02*W\n\
    \x0cEVideoFormat\x12\x16\n\x12k_EVideoFormatNone\x10\0\x12\x16\n\x12k_EV\
    ideoFormatYV12\x10\x01\x12\x17\n\x13k_EVideoFormatAccel\x10\x02*\xd7\x01\
    \n\x13EStreamStatsMessage\x12\x1d\n\x19k_EStreamStatsFrameEvents\x10\x01\
    \x12\x1b\n\x17k_EStreamStatsDebugDump\x10\x02\x12\x1c\n\x18k_EStreamStat\
    sLogMessage\x10\x03\x12\x20\n\x1ck_EStreamStatsLogUploadBegin\x10\x04\
    \x12\x1f\n\x1bk_EStreamStatsLogUploadData\x10\x05\x12#\n\x1fk_EStreamSta\
    tsLogUploadComplete\x10\x06*\x85\x05\n\x11EStreamFrameEvent\x12\x1c\n\
    \x18k_EStreamInputEventStart\x10\0\x12\x1b\n\x17k_EStreamInputEventSend\
    \x10\x01\x12\x1b\n\x17k_EStreamInputEventRecv\x10\x02\x12\x1d\n\x19k_ESt\
    reamInputEventQueued\x10\x03\x12\x1e\n\x1ak_EStreamInputEventHandled\x10\
    \x04\x12\x1c\n\x18k_EStreamFrameEventStart\x10\x05\x12#\n\x1fk_EStreamFr\
    ameEventCaptureBegin\x10\x06\x12!\n\x1dk_EStreamFrameEventCaptureEnd\x10\
    \x07\x12#\n\x1fk_EStreamFrameEventConvertBegin\x10\x08\x12!\n\x1dk_EStre\
    amFrameEventConvertEnd\x10\t\x12\"\n\x1ek_EStreamFrameEventEncodeBegin\
    \x10\n\x12\x20\n\x1ck_EStreamFrameEventEncodeEnd\x10\x0b\x12\x1b\n\x17k_\
    EStreamFrameEventSend\x10\x0c\x12\x1b\n\x17k_EStreamFrameEventRecv\x10\r\
    \x12\"\n\x1ek_EStreamFrameEventDecodeBegin\x10\x0e\x12\x20\n\x1ck_EStrea\
    mFrameEventDecodeEnd\x10\x0f\x12\"\n\x1ek_EStreamFrameEventUploadBegin\
    \x10\x10\x12\x20\n\x1ck_EStreamFrameEventUploadEnd\x10\x11\x12\x1f\n\x1b\
    k_EStreamFrameEventComplete\x10\x12*\xd4\x02\n\x12EStreamFrameResult\x12\
    \x1f\n\x1bk_EStreamFrameResultPending\x10\0\x12!\n\x1dk_EStreamFrameResu\
    ltDisplayed\x10\x01\x12*\n&k_EStreamFrameResultDroppedNetworkSlow\x10\
    \x02\x12*\n&k_EStreamFrameResultDroppedNetworkLost\x10\x03\x12)\n%k_EStr\
    eamFrameResultDroppedDecodeSlow\x10\x04\x12,\n(k_EStreamFrameResultDropp\
    edDecodeCorrupt\x10\x05\x12#\n\x1fk_EStreamFrameResultDroppedLate\x10\
    \x06\x12$\n\x20k_EStreamFrameResultDroppedReset\x10\x07*\xa2\x05\n\x15EF\
    rameAccumulatedStat\x12\x13\n\x0fk_EFrameStatFPS\x10\0\x12!\n\x1dk_EFram\
    eStatCaptureDurationMS\x10\x01\x12!\n\x1dk_EFrameStatConvertDurationMS\
    \x10\x02\x12\x20\n\x1ck_EFrameStatEncodeDurationMS\x10\x03\x12\x1f\n\x1b\
    k_EFrameStatSteamDurationMS\x10\x04\x12\x20\n\x1ck_EFrameStatServerDurat\
    ionMS\x10\x05\x12!\n\x1dk_EFrameStatNetworkDurationMS\x10\x06\x12\x20\n\
    \x1ck_EFrameStatDecodeDurationMS\x10\x07\x12!\n\x1dk_EFrameStatDisplayDu\
    rationMS\x10\x08\x12\x20\n\x1ck_EFrameStatClientDurationMS\x10\t\x12\x1f\
    \n\x1bk_EFrameStatFrameDurationMS\x10\n\x12\x1e\n\x1ak_EFrameStatInputLa\
    tencyMS\x10\x0b\x12\x1d\n\x19k_EFrameStatGameLatencyMS\x10\x0c\x12\"\n\
    \x1ek_EFrameStatRoundTripLatencyMS\x10\r\x12\x1a\n\x16k_EFrameStatPingTi\
    meMS\x10\x0e\x12'\n#k_EFrameStatServerBitrateKbitPerSec\x10\x0f\x12'\n#k\
    _EFrameStatClientBitrateKbitPerSec\x10\x10\x12'\n#k_EFrameStatLinkBandwi\
    dthKbitPerSec\x10\x11\x12$\n\x20k_EFrameStatPacketLossPercentage\x10\x12\
    *^\n\x0cELogFileType\x12\x18\n\x14k_ELogFileSystemBoot\x10\0\x12\x19\n\
    \x15k_ELogFileSystemReset\x10\x01\x12\x19\n\x15k_ELogFileSystemDebug\x10\
    \x02*\xa9\x02\n\x1aEStreamControllerConfigMsg\x125\n1k_EStreamController\
    ConfigMsg_RequestConfigsForApp\x10\0\x12/\n+k_EStreamControllerConfigMsg\
    _ConfigResponse\x10\x01\x128\n4k_EStreamControllerConfigMsg_Personalizat\
    ionResponse\x10\x02\x123\n/k_EStreamControllerConfigMsg_ActiveConfigChan\
    ge\x10\x03\x124\n0k_EStreamControllerConfigMsg_RequestActiveConfig\x10\
    \x04B\x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(115);
            messages.push(CDiscoveryPingRequest::generated_message_descriptor_data());
            messages.push(CDiscoveryPingResponse::generated_message_descriptor_data());
            messages.push(CStreamingClientHandshakeInfo::generated_message_descriptor_data());
            messages.push(CClientHandshakeMsg::generated_message_descriptor_data());
            messages.push(CStreamingServerHandshakeInfo::generated_message_descriptor_data());
            messages.push(CServerHandshakeMsg::generated_message_descriptor_data());
            messages.push(CAuthenticationRequestMsg::generated_message_descriptor_data());
            messages.push(CAuthenticationResponseMsg::generated_message_descriptor_data());
            messages.push(CKeepAliveMsg::generated_message_descriptor_data());
            messages.push(CStartNetworkTestMsg::generated_message_descriptor_data());
            messages.push(CStreamVideoMode::generated_message_descriptor_data());
            messages.push(CStreamVideoLimit::generated_message_descriptor_data());
            messages.push(CStreamingClientCaps::generated_message_descriptor_data());
            messages.push(CStreamingClientConfig::generated_message_descriptor_data());
            messages.push(CStreamingServerConfig::generated_message_descriptor_data());
            messages.push(CNegotiatedConfig::generated_message_descriptor_data());
            messages.push(CNegotiationInitMsg::generated_message_descriptor_data());
            messages.push(CNegotiationSetConfigMsg::generated_message_descriptor_data());
            messages.push(CNegotiationCompleteMsg::generated_message_descriptor_data());
            messages.push(CStartAudioDataMsg::generated_message_descriptor_data());
            messages.push(CStopAudioDataMsg::generated_message_descriptor_data());
            messages.push(CStartVideoDataMsg::generated_message_descriptor_data());
            messages.push(CStopVideoDataMsg::generated_message_descriptor_data());
            messages.push(CStartNeptuneDataMsg::generated_message_descriptor_data());
            messages.push(CStopNeptuneDataMsg::generated_message_descriptor_data());
            messages.push(CRecordedInput::generated_message_descriptor_data());
            messages.push(CRecordedInputStream::generated_message_descriptor_data());
            messages.push(CInputLatencyTestMsg::generated_message_descriptor_data());
            messages.push(CInputTouchFingerDownMsg::generated_message_descriptor_data());
            messages.push(CInputTouchFingerMotionMsg::generated_message_descriptor_data());
            messages.push(CInputTouchFingerUpMsg::generated_message_descriptor_data());
            messages.push(CInputMouseMotionMsg::generated_message_descriptor_data());
            messages.push(CInputMouseWheelMsg::generated_message_descriptor_data());
            messages.push(CInputMouseDownMsg::generated_message_descriptor_data());
            messages.push(CInputMouseUpMsg::generated_message_descriptor_data());
            messages.push(CInputKeyDownMsg::generated_message_descriptor_data());
            messages.push(CInputKeyUpMsg::generated_message_descriptor_data());
            messages.push(CInputTextMsg::generated_message_descriptor_data());
            messages.push(CSetTitleMsg::generated_message_descriptor_data());
            messages.push(CSetCaptureSizeMsg::generated_message_descriptor_data());
            messages.push(CSetIconMsg::generated_message_descriptor_data());
            messages.push(CSetFlashStateMsg::generated_message_descriptor_data());
            messages.push(CShowCursorMsg::generated_message_descriptor_data());
            messages.push(CHideCursorMsg::generated_message_descriptor_data());
            messages.push(CSetCursorMsg::generated_message_descriptor_data());
            messages.push(CGetCursorImageMsg::generated_message_descriptor_data());
            messages.push(CSetCursorImageMsg::generated_message_descriptor_data());
            messages.push(CSetCursorScaleMsg::generated_message_descriptor_data());
            messages.push(CVideoDecoderInfoMsg::generated_message_descriptor_data());
            messages.push(CVideoEncoderInfoMsg::generated_message_descriptor_data());
            messages.push(CPauseMsg::generated_message_descriptor_data());
            messages.push(CResumeMsg::generated_message_descriptor_data());
            messages.push(CEnableHighResCaptureMsg::generated_message_descriptor_data());
            messages.push(CDisableHighResCaptureMsg::generated_message_descriptor_data());
            messages.push(CEnableNeptuneDataMsg::generated_message_descriptor_data());
            messages.push(CDisableNeptuneDataMsg::generated_message_descriptor_data());
            messages.push(CPauseControllerInputMsg::generated_message_descriptor_data());
            messages.push(CResumeControllerInputMsg::generated_message_descriptor_data());
            messages.push(CToggleMagnificationMsg::generated_message_descriptor_data());
            messages.push(CSetCapslockMsg::generated_message_descriptor_data());
            messages.push(CStreamingKeymapEntry::generated_message_descriptor_data());
            messages.push(CStreamingKeymap::generated_message_descriptor_data());
            messages.push(CSetKeymapMsg::generated_message_descriptor_data());
            messages.push(CStopRequest::generated_message_descriptor_data());
            messages.push(CQuitRequest::generated_message_descriptor_data());
            messages.push(CDeleteCursorMsg::generated_message_descriptor_data());
            messages.push(CSetStreamingClientConfig::generated_message_descriptor_data());
            messages.push(CSetQoSMsg::generated_message_descriptor_data());
            messages.push(CSetTargetFramerateMsg::generated_message_descriptor_data());
            messages.push(CSetTargetBitrateMsg::generated_message_descriptor_data());
            messages.push(COverlayEnabledMsg::generated_message_descriptor_data());
            messages.push(CSetGammaRampMsg::generated_message_descriptor_data());
            messages.push(CSetActivityMsg::generated_message_descriptor_data());
            messages.push(CSystemSuspendMsg::generated_message_descriptor_data());
            messages.push(CVirtualHereRequestMsg::generated_message_descriptor_data());
            messages.push(CVirtualHereReadyMsg::generated_message_descriptor_data());
            messages.push(CVirtualHereShareDeviceMsg::generated_message_descriptor_data());
            messages.push(CSetSpectatorModeMsg::generated_message_descriptor_data());
            messages.push(CRemoteHIDMsg::generated_message_descriptor_data());
            messages.push(CTouchConfigActiveMsg::generated_message_descriptor_data());
            messages.push(CGetTouchConfigDataMsg::generated_message_descriptor_data());
            messages.push(CSetTouchConfigDataMsg::generated_message_descriptor_data());
            messages.push(CSaveTouchConfigLayoutMsg::generated_message_descriptor_data());
            messages.push(CTouchActionSetActiveMsg::generated_message_descriptor_data());
            messages.push(CTouchActionSetLayerAddedMsg::generated_message_descriptor_data());
            messages.push(CTouchActionSetLayerRemovedMsg::generated_message_descriptor_data());
            messages.push(CGetTouchIconDataMsg::generated_message_descriptor_data());
            messages.push(CSetTouchIconDataMsg::generated_message_descriptor_data());
            messages.push(CRemotePlayTogetherGroupUpdateMsg::generated_message_descriptor_data());
            messages.push(CSetInputTemporarilyDisabledMsg::generated_message_descriptor_data());
            messages.push(CSetQualityOverrideMsg::generated_message_descriptor_data());
            messages.push(CSetBitrateOverrideMsg::generated_message_descriptor_data());
            messages.push(CShowOnScreenKeyboardMsg::generated_message_descriptor_data());
            messages.push(CControllerPersonalizationUpdateMsg::generated_message_descriptor_data());
            messages.push(CVRConnectionReady::generated_message_descriptor_data());
            messages.push(CStreamDataLostMsg::generated_message_descriptor_data());
            messages.push(CAudioFormat::generated_message_descriptor_data());
            messages.push(CVideoFormat::generated_message_descriptor_data());
            messages.push(CFrameEvent::generated_message_descriptor_data());
            messages.push(CFrameStats::generated_message_descriptor_data());
            messages.push(CFrameStatAccumulatedValue::generated_message_descriptor_data());
            messages.push(CFrameStatsListMsg::generated_message_descriptor_data());
            messages.push(CStreamingSessionStats::generated_message_descriptor_data());
            messages.push(CDebugDumpMsg::generated_message_descriptor_data());
            messages.push(CLogMsg::generated_message_descriptor_data());
            messages.push(CLogUploadMsg::generated_message_descriptor_data());
            messages.push(CTransportSignalMsg::generated_message_descriptor_data());
            messages.push(CControllerConfigMsg::generated_message_descriptor_data());
            messages.push(cremote_play_together_group_update_msg::Player::generated_message_descriptor_data());
            messages.push(ctransport_signal_msg::WebRTCMessage::generated_message_descriptor_data());
            messages.push(ctransport_signal_msg::web_rtcmessage::Candidate::generated_message_descriptor_data());
            messages.push(ccontroller_config_msg::ControllerConfigResponse::generated_message_descriptor_data());
            messages.push(ccontroller_config_msg::ControllerPersonalizationResponse::generated_message_descriptor_data());
            messages.push(ccontroller_config_msg::ControllerActiveConfigChangeResponse::generated_message_descriptor_data());
            messages.push(ccontroller_config_msg::ControllerActiveConfigMsg::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(26);
            enums.push(EStreamChannel::generated_enum_descriptor_data());
            enums.push(EStreamDiscoveryMessage::generated_enum_descriptor_data());
            enums.push(EStreamControlMessage::generated_enum_descriptor_data());
            enums.push(EStreamVersion::generated_enum_descriptor_data());
            enums.push(EStreamAudioCodec::generated_enum_descriptor_data());
            enums.push(EStreamVideoCodec::generated_enum_descriptor_data());
            enums.push(EStreamQualityPreference::generated_enum_descriptor_data());
            enums.push(EStreamBitrate::generated_enum_descriptor_data());
            enums.push(EStreamColorspace::generated_enum_descriptor_data());
            enums.push(EStreamP2PScope::generated_enum_descriptor_data());
            enums.push(EStreamHostPlayAudioPreference::generated_enum_descriptor_data());
            enums.push(EStreamingDataType::generated_enum_descriptor_data());
            enums.push(EStreamMouseButton::generated_enum_descriptor_data());
            enums.push(EStreamMouseWheelDirection::generated_enum_descriptor_data());
            enums.push(EStreamFramerateLimiter::generated_enum_descriptor_data());
            enums.push(EStreamActivity::generated_enum_descriptor_data());
            enums.push(EStreamDataMessage::generated_enum_descriptor_data());
            enums.push(EAudioFormat::generated_enum_descriptor_data());
            enums.push(EVideoFormat::generated_enum_descriptor_data());
            enums.push(EStreamStatsMessage::generated_enum_descriptor_data());
            enums.push(EStreamFrameEvent::generated_enum_descriptor_data());
            enums.push(EStreamFrameResult::generated_enum_descriptor_data());
            enums.push(EFrameAccumulatedStat::generated_enum_descriptor_data());
            enums.push(ELogFileType::generated_enum_descriptor_data());
            enums.push(EStreamControllerConfigMsg::generated_enum_descriptor_data());
            enums.push(cauthentication_response_msg::AuthenticationResult::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
