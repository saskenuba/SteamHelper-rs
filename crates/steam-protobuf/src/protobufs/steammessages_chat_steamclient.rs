// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_chat.steamclient.proto`

// @@protoc_insertion_point(message:CChat_RequestFriendPersonaStates_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChat_RequestFriendPersonaStates_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CChat_RequestFriendPersonaStates_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Request {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Request {
        <CChat_RequestFriendPersonaStates_Request as crate::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Request {
    pub fn new() -> CChat_RequestFriendPersonaStates_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChat_RequestFriendPersonaStates_Request>(
            "CChat_RequestFriendPersonaStates_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChat_RequestFriendPersonaStates_Request {
    const NAME: &'static str = "CChat_RequestFriendPersonaStates_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChat_RequestFriendPersonaStates_Request {
        CChat_RequestFriendPersonaStates_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Request {
        static instance: CChat_RequestFriendPersonaStates_Request = CChat_RequestFriendPersonaStates_Request {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChat_RequestFriendPersonaStates_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChat_RequestFriendPersonaStates_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChat_RequestFriendPersonaStates_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChat_RequestFriendPersonaStates_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChat_RequestFriendPersonaStates_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChat_RequestFriendPersonaStates_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChat_RequestFriendPersonaStates_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChat_RequestFriendPersonaStates_Response {
    fn default() -> &'a CChat_RequestFriendPersonaStates_Response {
        <CChat_RequestFriendPersonaStates_Response as crate::Message>::default_instance()
    }
}

impl CChat_RequestFriendPersonaStates_Response {
    pub fn new() -> CChat_RequestFriendPersonaStates_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChat_RequestFriendPersonaStates_Response>(
            "CChat_RequestFriendPersonaStates_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChat_RequestFriendPersonaStates_Response {
    const NAME: &'static str = "CChat_RequestFriendPersonaStates_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChat_RequestFriendPersonaStates_Response {
        CChat_RequestFriendPersonaStates_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChat_RequestFriendPersonaStates_Response {
        static instance: CChat_RequestFriendPersonaStates_Response = CChat_RequestFriendPersonaStates_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChat_RequestFriendPersonaStates_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChat_RequestFriendPersonaStates_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChat_RequestFriendPersonaStates_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChat_RequestFriendPersonaStates_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.steamid_partner)
    pub steamid_partner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.steamid_invited)
    pub steamid_invited: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.steamid_invitees)
    pub steamid_invitees: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Request.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoomGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Request {
        <CChatRoom_CreateChatRoomGroup_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Request {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_partner = 1;

    pub fn steamid_partner(&self) -> u64 {
        self.steamid_partner.unwrap_or(0)
    }

    pub fn clear_steamid_partner(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
    }

    pub fn has_steamid_partner(&self) -> bool {
        self.steamid_partner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_partner(&mut self, v: u64) {
        self.steamid_partner = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_invited = 2;

    pub fn steamid_invited(&self) -> u64 {
        self.steamid_invited.unwrap_or(0)
    }

    pub fn clear_steamid_invited(&mut self) {
        self.steamid_invited = ::std::option::Option::None;
    }

    pub fn has_steamid_invited(&self) -> bool {
        self.steamid_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invited(&mut self, v: u64) {
        self.steamid_invited = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated fixed64 steamid_invitees = 4;

    pub fn steamid_invitees(&self) -> &[u64] {
        &self.steamid_invitees
    }

    pub fn clear_steamid_invitees(&mut self) {
        self.steamid_invitees.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_invitees(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_invitees = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_invitees(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_invitees
    }

    // Take field
    pub fn take_steamid_invitees(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_invitees, ::std::vec::Vec::new())
    }

    // optional uint32 watching_broadcast_accountid = 6;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 7;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_partner",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_partner },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_partner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_invited",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_invited },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_invited },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.name },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "steamid_invitees",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.steamid_invitees },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.steamid_invitees },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_accountid",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.watching_broadcast_accountid },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.watching_broadcast_accountid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_channel_id",
            |m: &CChatRoom_CreateChatRoomGroup_Request| { &m.watching_broadcast_channel_id },
            |m: &mut CChatRoom_CreateChatRoomGroup_Request| { &mut m.watching_broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateChatRoomGroup_Request>(
            "CChatRoom_CreateChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_CreateChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_CreateChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_partner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.steamid_invited = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamid_invitees)?;
                },
                33 => {
                    self.steamid_invitees.push(is.read_fixed64()?);
                },
                48 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_partner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.steamid_invited {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += 9 * self.steamid_invitees.len() as u64;
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += crate::rt::uint64_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_partner {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.steamid_invited {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.steamid_invitees {
            os.write_fixed64(4, *v)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Request {
        CChatRoom_CreateChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.steamid_partner = ::std::option::Option::None;
        self.steamid_invited = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.steamid_invitees.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Request {
        static instance: CChatRoom_CreateChatRoomGroup_Request = CChatRoom_CreateChatRoomGroup_Request {
            steamid_partner: ::std::option::Option::None,
            steamid_invited: ::std::option::Option::None,
            name: ::std::option::Option::None,
            steamid_invitees: ::std::vec::Vec::new(),
            watching_broadcast_accountid: ::std::option::Option::None,
            watching_broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_CreateChatRoomGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_CreateChatRoomGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRole)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRole {
    // message fields
    // @@protoc_insertion_point(field:CChatRole.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRole.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRole.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRole.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRole {
    fn default() -> &'a CChatRole {
        <CChatRole as crate::Message>::default_instance()
    }
}

impl CChatRole {
    pub fn new() -> CChatRole {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 ordinal = 3;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRole| { &m.role_id },
            |m: &mut CChatRole| { &mut m.role_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRole| { &m.name },
            |m: &mut CChatRole| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRole| { &m.ordinal },
            |m: &mut CChatRole| { &mut m.ordinal },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRole>(
            "CChatRole",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRole {
    const NAME: &'static str = "CChatRole";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.ordinal {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRole {
        CChatRole::new()
    }

    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRole {
        static instance: CChatRole = CChatRole {
            role_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRole {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRole").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRole {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRole {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoleActions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoleActions {
    // message fields
    // @@protoc_insertion_point(field:CChatRoleActions.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_create_rename_delete_channel)
    pub can_create_rename_delete_channel: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_kick)
    pub can_kick: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_ban)
    pub can_ban: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_invite)
    pub can_invite: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_change_tagline_avatar_name)
    pub can_change_tagline_avatar_name: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_chat)
    pub can_chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_view_history)
    pub can_view_history: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_change_group_roles)
    pub can_change_group_roles: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_change_user_roles)
    pub can_change_user_roles: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_mention_all)
    pub can_mention_all: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoleActions.can_set_watching_broadcast)
    pub can_set_watching_broadcast: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoleActions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoleActions {
    fn default() -> &'a CChatRoleActions {
        <CChatRoleActions as crate::Message>::default_instance()
    }
}

impl CChatRoleActions {
    pub fn new() -> CChatRoleActions {
        ::std::default::Default::default()
    }

    // optional uint64 role_id = 1;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional bool can_create_rename_delete_channel = 2;

    pub fn can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.unwrap_or(false)
    }

    pub fn clear_can_create_rename_delete_channel(&mut self) {
        self.can_create_rename_delete_channel = ::std::option::Option::None;
    }

    pub fn has_can_create_rename_delete_channel(&self) -> bool {
        self.can_create_rename_delete_channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_create_rename_delete_channel(&mut self, v: bool) {
        self.can_create_rename_delete_channel = ::std::option::Option::Some(v);
    }

    // optional bool can_kick = 3;

    pub fn can_kick(&self) -> bool {
        self.can_kick.unwrap_or(false)
    }

    pub fn clear_can_kick(&mut self) {
        self.can_kick = ::std::option::Option::None;
    }

    pub fn has_can_kick(&self) -> bool {
        self.can_kick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_kick(&mut self, v: bool) {
        self.can_kick = ::std::option::Option::Some(v);
    }

    // optional bool can_ban = 4;

    pub fn can_ban(&self) -> bool {
        self.can_ban.unwrap_or(false)
    }

    pub fn clear_can_ban(&mut self) {
        self.can_ban = ::std::option::Option::None;
    }

    pub fn has_can_ban(&self) -> bool {
        self.can_ban.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_ban(&mut self, v: bool) {
        self.can_ban = ::std::option::Option::Some(v);
    }

    // optional bool can_invite = 5;

    pub fn can_invite(&self) -> bool {
        self.can_invite.unwrap_or(false)
    }

    pub fn clear_can_invite(&mut self) {
        self.can_invite = ::std::option::Option::None;
    }

    pub fn has_can_invite(&self) -> bool {
        self.can_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_invite(&mut self, v: bool) {
        self.can_invite = ::std::option::Option::Some(v);
    }

    // optional bool can_change_tagline_avatar_name = 6;

    pub fn can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.unwrap_or(false)
    }

    pub fn clear_can_change_tagline_avatar_name(&mut self) {
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
    }

    pub fn has_can_change_tagline_avatar_name(&self) -> bool {
        self.can_change_tagline_avatar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_tagline_avatar_name(&mut self, v: bool) {
        self.can_change_tagline_avatar_name = ::std::option::Option::Some(v);
    }

    // optional bool can_chat = 7;

    pub fn can_chat(&self) -> bool {
        self.can_chat.unwrap_or(false)
    }

    pub fn clear_can_chat(&mut self) {
        self.can_chat = ::std::option::Option::None;
    }

    pub fn has_can_chat(&self) -> bool {
        self.can_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_chat(&mut self, v: bool) {
        self.can_chat = ::std::option::Option::Some(v);
    }

    // optional bool can_view_history = 8;

    pub fn can_view_history(&self) -> bool {
        self.can_view_history.unwrap_or(false)
    }

    pub fn clear_can_view_history(&mut self) {
        self.can_view_history = ::std::option::Option::None;
    }

    pub fn has_can_view_history(&self) -> bool {
        self.can_view_history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_view_history(&mut self, v: bool) {
        self.can_view_history = ::std::option::Option::Some(v);
    }

    // optional bool can_change_group_roles = 9;

    pub fn can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.unwrap_or(false)
    }

    pub fn clear_can_change_group_roles(&mut self) {
        self.can_change_group_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_group_roles(&self) -> bool {
        self.can_change_group_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_group_roles(&mut self, v: bool) {
        self.can_change_group_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_change_user_roles = 10;

    pub fn can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.unwrap_or(false)
    }

    pub fn clear_can_change_user_roles(&mut self) {
        self.can_change_user_roles = ::std::option::Option::None;
    }

    pub fn has_can_change_user_roles(&self) -> bool {
        self.can_change_user_roles.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_change_user_roles(&mut self, v: bool) {
        self.can_change_user_roles = ::std::option::Option::Some(v);
    }

    // optional bool can_mention_all = 11;

    pub fn can_mention_all(&self) -> bool {
        self.can_mention_all.unwrap_or(false)
    }

    pub fn clear_can_mention_all(&mut self) {
        self.can_mention_all = ::std::option::Option::None;
    }

    pub fn has_can_mention_all(&self) -> bool {
        self.can_mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_mention_all(&mut self, v: bool) {
        self.can_mention_all = ::std::option::Option::Some(v);
    }

    // optional bool can_set_watching_broadcast = 12;

    pub fn can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.unwrap_or(false)
    }

    pub fn clear_can_set_watching_broadcast(&mut self) {
        self.can_set_watching_broadcast = ::std::option::Option::None;
    }

    pub fn has_can_set_watching_broadcast(&self) -> bool {
        self.can_set_watching_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_set_watching_broadcast(&mut self, v: bool) {
        self.can_set_watching_broadcast = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoleActions| { &m.role_id },
            |m: &mut CChatRoleActions| { &mut m.role_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_create_rename_delete_channel",
            |m: &CChatRoleActions| { &m.can_create_rename_delete_channel },
            |m: &mut CChatRoleActions| { &mut m.can_create_rename_delete_channel },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_kick",
            |m: &CChatRoleActions| { &m.can_kick },
            |m: &mut CChatRoleActions| { &mut m.can_kick },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_ban",
            |m: &CChatRoleActions| { &m.can_ban },
            |m: &mut CChatRoleActions| { &mut m.can_ban },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_invite",
            |m: &CChatRoleActions| { &m.can_invite },
            |m: &mut CChatRoleActions| { &mut m.can_invite },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_change_tagline_avatar_name",
            |m: &CChatRoleActions| { &m.can_change_tagline_avatar_name },
            |m: &mut CChatRoleActions| { &mut m.can_change_tagline_avatar_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_chat",
            |m: &CChatRoleActions| { &m.can_chat },
            |m: &mut CChatRoleActions| { &mut m.can_chat },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_view_history",
            |m: &CChatRoleActions| { &m.can_view_history },
            |m: &mut CChatRoleActions| { &mut m.can_view_history },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_change_group_roles",
            |m: &CChatRoleActions| { &m.can_change_group_roles },
            |m: &mut CChatRoleActions| { &mut m.can_change_group_roles },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_change_user_roles",
            |m: &CChatRoleActions| { &m.can_change_user_roles },
            |m: &mut CChatRoleActions| { &mut m.can_change_user_roles },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_mention_all",
            |m: &CChatRoleActions| { &m.can_mention_all },
            |m: &mut CChatRoleActions| { &mut m.can_mention_all },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_set_watching_broadcast",
            |m: &CChatRoleActions| { &m.can_set_watching_broadcast },
            |m: &mut CChatRoleActions| { &mut m.can_set_watching_broadcast },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoleActions>(
            "CChatRoleActions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoleActions {
    const NAME: &'static str = "CChatRoleActions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.can_create_rename_delete_channel = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.can_kick = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.can_ban = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.can_invite = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.can_change_tagline_avatar_name = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.can_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.can_view_history = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.can_change_group_roles = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.can_change_user_roles = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.can_mention_all = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.can_set_watching_broadcast = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.role_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_kick {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_ban {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_invite {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_chat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_view_history {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_change_group_roles {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_change_user_roles {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_mention_all {
            my_size += 1 + 1;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.role_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.can_create_rename_delete_channel {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.can_kick {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.can_ban {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.can_invite {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.can_change_tagline_avatar_name {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.can_chat {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.can_view_history {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.can_change_group_roles {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.can_change_user_roles {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.can_mention_all {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.can_set_watching_broadcast {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoleActions {
        CChatRoleActions::new()
    }

    fn clear(&mut self) {
        self.role_id = ::std::option::Option::None;
        self.can_create_rename_delete_channel = ::std::option::Option::None;
        self.can_kick = ::std::option::Option::None;
        self.can_ban = ::std::option::Option::None;
        self.can_invite = ::std::option::Option::None;
        self.can_change_tagline_avatar_name = ::std::option::Option::None;
        self.can_chat = ::std::option::Option::None;
        self.can_view_history = ::std::option::Option::None;
        self.can_change_group_roles = ::std::option::Option::None;
        self.can_change_user_roles = ::std::option::Option::None;
        self.can_mention_all = ::std::option::Option::None;
        self.can_set_watching_broadcast = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoleActions {
        static instance: CChatRoleActions = CChatRoleActions {
            role_id: ::std::option::Option::None,
            can_create_rename_delete_channel: ::std::option::Option::None,
            can_kick: ::std::option::Option::None,
            can_ban: ::std::option::Option::None,
            can_invite: ::std::option::Option::None,
            can_change_tagline_avatar_name: ::std::option::Option::None,
            can_chat: ::std::option::Option::None,
            can_view_history: ::std::option::Option::None,
            can_change_group_roles: ::std::option::Option::None,
            can_change_user_roles: ::std::option::Option::None,
            can_mention_all: ::std::option::Option::None,
            can_set_watching_broadcast: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoleActions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoleActions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoleActions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoleActions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatPartyBeacon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatPartyBeacon {
    // message fields
    // @@protoc_insertion_point(field:CChatPartyBeacon.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatPartyBeacon.steamid_owner)
    pub steamid_owner: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatPartyBeacon.beacon_id)
    pub beacon_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatPartyBeacon.game_metadata)
    pub game_metadata: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatPartyBeacon.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatPartyBeacon {
    fn default() -> &'a CChatPartyBeacon {
        <CChatPartyBeacon as crate::Message>::default_instance()
    }
}

impl CChatPartyBeacon {
    pub fn new() -> CChatPartyBeacon {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_owner = 2;

    pub fn steamid_owner(&self) -> u64 {
        self.steamid_owner.unwrap_or(0)
    }

    pub fn clear_steamid_owner(&mut self) {
        self.steamid_owner = ::std::option::Option::None;
    }

    pub fn has_steamid_owner(&self) -> bool {
        self.steamid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_owner(&mut self, v: u64) {
        self.steamid_owner = ::std::option::Option::Some(v);
    }

    // optional fixed64 beacon_id = 3;

    pub fn beacon_id(&self) -> u64 {
        self.beacon_id.unwrap_or(0)
    }

    pub fn clear_beacon_id(&mut self) {
        self.beacon_id = ::std::option::Option::None;
    }

    pub fn has_beacon_id(&self) -> bool {
        self.beacon_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_id(&mut self, v: u64) {
        self.beacon_id = ::std::option::Option::Some(v);
    }

    // optional string game_metadata = 4;

    pub fn game_metadata(&self) -> &str {
        match self.game_metadata.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_metadata(&mut self) {
        self.game_metadata = ::std::option::Option::None;
    }

    pub fn has_game_metadata(&self) -> bool {
        self.game_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_metadata(&mut self, v: ::std::string::String) {
        self.game_metadata = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_metadata(&mut self) -> &mut ::std::string::String {
        if self.game_metadata.is_none() {
            self.game_metadata = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_metadata(&mut self) -> ::std::string::String {
        self.game_metadata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CChatPartyBeacon| { &m.app_id },
            |m: &mut CChatPartyBeacon| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_owner",
            |m: &CChatPartyBeacon| { &m.steamid_owner },
            |m: &mut CChatPartyBeacon| { &mut m.steamid_owner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "beacon_id",
            |m: &CChatPartyBeacon| { &m.beacon_id },
            |m: &mut CChatPartyBeacon| { &mut m.beacon_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_metadata",
            |m: &CChatPartyBeacon| { &m.game_metadata },
            |m: &mut CChatPartyBeacon| { &mut m.game_metadata },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatPartyBeacon>(
            "CChatPartyBeacon",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatPartyBeacon {
    const NAME: &'static str = "CChatPartyBeacon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.steamid_owner = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.beacon_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.game_metadata = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.steamid_owner {
            my_size += 1 + 8;
        }
        if let Some(v) = self.beacon_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_metadata.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.steamid_owner {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.beacon_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.game_metadata.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatPartyBeacon {
        CChatPartyBeacon::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.steamid_owner = ::std::option::Option::None;
        self.beacon_id = ::std::option::Option::None;
        self.game_metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatPartyBeacon {
        static instance: CChatPartyBeacon = CChatPartyBeacon {
            app_id: ::std::option::Option::None,
            steamid_owner: ::std::option::Option::None,
            beacon_id: ::std::option::Option::None,
            game_metadata: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatPartyBeacon {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatPartyBeacon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatPartyBeacon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatPartyBeacon {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomGroupHeaderState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomGroupHeaderState {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.tagline)
    pub tagline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.avatar_sha)
    pub avatar_sha: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.default_role_id)
    pub default_role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.roles)
    pub roles: ::std::vec::Vec<CChatRole>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.role_actions)
    pub role_actions: ::std::vec::Vec<CChatRoleActions>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.party_beacons)
    pub party_beacons: ::std::vec::Vec<CChatPartyBeacon>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.active_minigame_id)
    pub active_minigame_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.avatar_ugc_url)
    pub avatar_ugc_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomGroupHeaderState.disabled)
    pub disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomGroupHeaderState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupHeaderState {
    fn default() -> &'a CChatRoomGroupHeaderState {
        <CChatRoomGroupHeaderState as crate::Message>::default_instance()
    }
}

impl CChatRoomGroupHeaderState {
    pub fn new() -> CChatRoomGroupHeaderState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 clanid = 13;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_owner = 14;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 21;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string tagline = 15;

    pub fn tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tagline(&mut self) {
        self.tagline = ::std::option::Option::None;
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes avatar_sha = 16;

    pub fn avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha = ::std::option::Option::None;
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::bytes::Bytes) {
        self.avatar_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::bytes::Bytes {
        if self.avatar_sha.is_none() {
            self.avatar_sha = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::bytes::Bytes {
        self.avatar_sha.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint64 default_role_id = 17;

    pub fn default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }

    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRole roles = 18;

    pub fn roles(&self) -> &[CChatRole] {
        &self.roles
    }

    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::std::vec::Vec<CChatRole>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::std::vec::Vec<CChatRole> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::std::vec::Vec<CChatRole> {
        ::std::mem::replace(&mut self.roles, ::std::vec::Vec::new())
    }

    // repeated .CChatRoleActions role_actions = 19;

    pub fn role_actions(&self) -> &[CChatRoleActions] {
        &self.role_actions
    }

    pub fn clear_role_actions(&mut self) {
        self.role_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_actions(&mut self, v: ::std::vec::Vec<CChatRoleActions>) {
        self.role_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_actions(&mut self) -> &mut ::std::vec::Vec<CChatRoleActions> {
        &mut self.role_actions
    }

    // Take field
    pub fn take_role_actions(&mut self) -> ::std::vec::Vec<CChatRoleActions> {
        ::std::mem::replace(&mut self.role_actions, ::std::vec::Vec::new())
    }

    // optional uint32 watching_broadcast_accountid = 20;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // repeated .CChatPartyBeacon party_beacons = 22;

    pub fn party_beacons(&self) -> &[CChatPartyBeacon] {
        &self.party_beacons
    }

    pub fn clear_party_beacons(&mut self) {
        self.party_beacons.clear();
    }

    // Param is passed by value, moved
    pub fn set_party_beacons(&mut self, v: ::std::vec::Vec<CChatPartyBeacon>) {
        self.party_beacons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_party_beacons(&mut self) -> &mut ::std::vec::Vec<CChatPartyBeacon> {
        &mut self.party_beacons
    }

    // Take field
    pub fn take_party_beacons(&mut self) -> ::std::vec::Vec<CChatPartyBeacon> {
        ::std::mem::replace(&mut self.party_beacons, ::std::vec::Vec::new())
    }

    // optional uint64 watching_broadcast_channel_id = 23;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_minigame_id = 24;

    pub fn active_minigame_id(&self) -> u64 {
        self.active_minigame_id.unwrap_or(0)
    }

    pub fn clear_active_minigame_id(&mut self) {
        self.active_minigame_id = ::std::option::Option::None;
    }

    pub fn has_active_minigame_id(&self) -> bool {
        self.active_minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_minigame_id(&mut self, v: u64) {
        self.active_minigame_id = ::std::option::Option::Some(v);
    }

    // optional string avatar_ugc_url = 25;

    pub fn avatar_ugc_url(&self) -> &str {
        match self.avatar_ugc_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_ugc_url(&mut self) {
        self.avatar_ugc_url = ::std::option::Option::None;
    }

    pub fn has_avatar_ugc_url(&self) -> bool {
        self.avatar_ugc_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_ugc_url(&mut self, v: ::std::string::String) {
        self.avatar_ugc_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_ugc_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_ugc_url.is_none() {
            self.avatar_ugc_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_ugc_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_ugc_url(&mut self) -> ::std::string::String {
        self.avatar_ugc_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool disabled = 26;

    pub fn disabled(&self) -> bool {
        self.disabled.unwrap_or(false)
    }

    pub fn clear_disabled(&mut self) {
        self.disabled = ::std::option::Option::None;
    }

    pub fn has_disabled(&self) -> bool {
        self.disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoomGroupHeaderState| { &m.chat_group_id },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_name",
            |m: &CChatRoomGroupHeaderState| { &m.chat_name },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.chat_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "clanid",
            |m: &CChatRoomGroupHeaderState| { &m.clanid },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.clanid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_owner",
            |m: &CChatRoomGroupHeaderState| { &m.accountid_owner },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.accountid_owner },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CChatRoomGroupHeaderState| { &m.appid },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tagline",
            |m: &CChatRoomGroupHeaderState| { &m.tagline },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.tagline },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_sha",
            |m: &CChatRoomGroupHeaderState| { &m.avatar_sha },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.avatar_sha },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_role_id",
            |m: &CChatRoomGroupHeaderState| { &m.default_role_id },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.default_role_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "roles",
            |m: &CChatRoomGroupHeaderState| { &m.roles },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.roles },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_actions",
            |m: &CChatRoomGroupHeaderState| { &m.role_actions },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.role_actions },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_accountid",
            |m: &CChatRoomGroupHeaderState| { &m.watching_broadcast_accountid },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.watching_broadcast_accountid },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "party_beacons",
            |m: &CChatRoomGroupHeaderState| { &m.party_beacons },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.party_beacons },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_channel_id",
            |m: &CChatRoomGroupHeaderState| { &m.watching_broadcast_channel_id },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.watching_broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_minigame_id",
            |m: &CChatRoomGroupHeaderState| { &m.active_minigame_id },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.active_minigame_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_ugc_url",
            |m: &CChatRoomGroupHeaderState| { &m.avatar_ugc_url },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.avatar_ugc_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disabled",
            |m: &CChatRoomGroupHeaderState| { &m.disabled },
            |m: &mut CChatRoomGroupHeaderState| { &mut m.disabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomGroupHeaderState>(
            "CChatRoomGroupHeaderState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoomGroupHeaderState {
    const NAME: &'static str = "CChatRoomGroupHeaderState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.tagline = ::std::option::Option::Some(is.read_string()?);
                },
                130 => {
                    self.avatar_sha = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                136 => {
                    self.default_role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                146 => {
                    self.roles.push(is.read_message()?);
                },
                154 => {
                    self.role_actions.push(is.read_message()?);
                },
                160 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                178 => {
                    self.party_beacons.push(is.read_message()?);
                },
                184 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                192 => {
                    self.active_minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                202 => {
                    self.avatar_ugc_url = ::std::option::Option::Some(is.read_string()?);
                },
                208 => {
                    self.disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.clanid {
            my_size += crate::rt::uint32_size(13, v);
        }
        if let Some(v) = self.accountid_owner {
            my_size += crate::rt::uint32_size(14, v);
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(21, v);
        }
        if let Some(v) = self.tagline.as_ref() {
            my_size += crate::rt::string_size(15, &v);
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            my_size += crate::rt::bytes_size(16, &v);
        }
        if let Some(v) = self.default_role_id {
            my_size += crate::rt::uint64_size(17, v);
        }
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += crate::rt::uint32_size(20, v);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += crate::rt::uint64_size(23, v);
        }
        if let Some(v) = self.active_minigame_id {
            my_size += crate::rt::uint64_size(24, v);
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            my_size += crate::rt::string_size(25, &v);
        }
        if let Some(v) = self.disabled {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.tagline.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            os.write_bytes(16, v)?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(17, v)?;
        }
        for v in &self.roles {
            crate::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        for v in &self.role_actions {
            crate::rt::write_message_field_with_cached_size(19, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(20, v)?;
        }
        for v in &self.party_beacons {
            crate::rt::write_message_field_with_cached_size(22, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(23, v)?;
        }
        if let Some(v) = self.active_minigame_id {
            os.write_uint64(24, v)?;
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            os.write_string(25, v)?;
        }
        if let Some(v) = self.disabled {
            os.write_bool(26, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomGroupHeaderState {
        CChatRoomGroupHeaderState::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.clanid = ::std::option::Option::None;
        self.accountid_owner = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.tagline = ::std::option::Option::None;
        self.avatar_sha = ::std::option::Option::None;
        self.default_role_id = ::std::option::Option::None;
        self.roles.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.active_minigame_id = ::std::option::Option::None;
        self.avatar_ugc_url = ::std::option::Option::None;
        self.disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomGroupHeaderState {
        static instance: CChatRoomGroupHeaderState = CChatRoomGroupHeaderState {
            chat_group_id: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            clanid: ::std::option::Option::None,
            accountid_owner: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            tagline: ::std::option::Option::None,
            avatar_sha: ::std::option::Option::None,
            default_role_id: ::std::option::Option::None,
            roles: ::std::vec::Vec::new(),
            role_actions: ::std::vec::Vec::new(),
            watching_broadcast_accountid: ::std::option::Option::None,
            party_beacons: ::std::vec::Vec::new(),
            watching_broadcast_channel_id: ::std::option::Option::None,
            active_minigame_id: ::std::option::Option::None,
            avatar_ugc_url: ::std::option::Option::None,
            disabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoomGroupHeaderState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomGroupHeaderState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomGroupHeaderState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoomGroupHeaderState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomMember {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomMember.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomMember.state)
    pub state: ::std::option::Option<crate::EnumOrUnknown<EChatRoomJoinState>>,
    // @@protoc_insertion_point(field:CChatRoomMember.rank)
    pub rank: ::std::option::Option<crate::EnumOrUnknown<EChatRoomGroupRank>>,
    // @@protoc_insertion_point(field:CChatRoomMember.time_kick_expire)
    pub time_kick_expire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomMember.role_ids)
    pub role_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomMember.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomMember {
    fn default() -> &'a CChatRoomMember {
        <CChatRoomMember as crate::Message>::default_instance()
    }
}

impl CChatRoomMember {
    pub fn new() -> CChatRoomMember {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomJoinState state = 3;

    pub fn state(&self) -> EChatRoomJoinState {
        match self.state {
            Some(e) => e.enum_value_or(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            None => EChatRoomJoinState::k_EChatRoomJoinState_Default,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: EChatRoomJoinState) {
        self.state = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EChatRoomGroupRank rank = 4;

    pub fn rank(&self) -> EChatRoomGroupRank {
        match self.rank {
            Some(e) => e.enum_value_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            None => EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
        }
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 time_kick_expire = 6;

    pub fn time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }

    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // repeated uint64 role_ids = 7;

    pub fn role_ids(&self) -> &[u64] {
        &self.role_ids
    }

    pub fn clear_role_ids(&mut self) {
        self.role_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.role_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.role_ids
    }

    // Take field
    pub fn take_role_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.role_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CChatRoomMember| { &m.accountid },
            |m: &mut CChatRoomMember| { &mut m.accountid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "state",
            |m: &CChatRoomMember| { &m.state },
            |m: &mut CChatRoomMember| { &mut m.state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &CChatRoomMember| { &m.rank },
            |m: &mut CChatRoomMember| { &mut m.rank },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_kick_expire",
            |m: &CChatRoomMember| { &m.time_kick_expire },
            |m: &mut CChatRoomMember| { &mut m.time_kick_expire },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_ids",
            |m: &CChatRoomMember| { &m.role_ids },
            |m: &mut CChatRoomMember| { &mut m.role_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomMember>(
            "CChatRoomMember",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoomMember {
    const NAME: &'static str = "CChatRoomMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.rank = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.time_kick_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint64_into(&mut self.role_ids)?;
                },
                56 => {
                    self.role_ids.push(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.state {
            my_size += crate::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.rank {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.time_kick_expire {
            my_size += crate::rt::uint32_size(6, v);
        }
        for value in &self.role_ids {
            my_size += crate::rt::uint64_size(7, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rank {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(6, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomMember {
        CChatRoomMember::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.time_kick_expire = ::std::option::Option::None;
        self.role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomMember {
        static instance: CChatRoomMember = CChatRoomMember {
            accountid: ::std::option::Option::None,
            state: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            time_kick_expire: ::std::option::Option::None,
            role_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoomMember {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomMember").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomMember {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoomMember {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomState {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomState.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomState.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomState.voice_allowed)
    pub voice_allowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoomState.members_in_voice)
    pub members_in_voice: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CChatRoomState.time_last_message)
    pub time_last_message: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomState.sort_order)
    pub sort_order: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomState.last_message)
    pub last_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoomState.accountid_last_message)
    pub accountid_last_message: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomState {
    fn default() -> &'a CChatRoomState {
        <CChatRoomState as crate::Message>::default_instance()
    }
}

impl CChatRoomState {
    pub fn new() -> CChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string chat_name = 2;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool voice_allowed = 3;

    pub fn voice_allowed(&self) -> bool {
        self.voice_allowed.unwrap_or(false)
    }

    pub fn clear_voice_allowed(&mut self) {
        self.voice_allowed = ::std::option::Option::None;
    }

    pub fn has_voice_allowed(&self) -> bool {
        self.voice_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_allowed(&mut self, v: bool) {
        self.voice_allowed = ::std::option::Option::Some(v);
    }

    // repeated uint32 members_in_voice = 4;

    pub fn members_in_voice(&self) -> &[u32] {
        &self.members_in_voice
    }

    pub fn clear_members_in_voice(&mut self) {
        self.members_in_voice.clear();
    }

    // Param is passed by value, moved
    pub fn set_members_in_voice(&mut self, v: ::std::vec::Vec<u32>) {
        self.members_in_voice = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members_in_voice(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.members_in_voice
    }

    // Take field
    pub fn take_members_in_voice(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.members_in_voice, ::std::vec::Vec::new())
    }

    // optional uint32 time_last_message = 5;

    pub fn time_last_message(&self) -> u32 {
        self.time_last_message.unwrap_or(0)
    }

    pub fn clear_time_last_message(&mut self) {
        self.time_last_message = ::std::option::Option::None;
    }

    pub fn has_time_last_message(&self) -> bool {
        self.time_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_message(&mut self, v: u32) {
        self.time_last_message = ::std::option::Option::Some(v);
    }

    // optional uint32 sort_order = 6;

    pub fn sort_order(&self) -> u32 {
        self.sort_order.unwrap_or(0)
    }

    pub fn clear_sort_order(&mut self) {
        self.sort_order = ::std::option::Option::None;
    }

    pub fn has_sort_order(&self) -> bool {
        self.sort_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_order(&mut self, v: u32) {
        self.sort_order = ::std::option::Option::Some(v);
    }

    // optional string last_message = 7;

    pub fn last_message(&self) -> &str {
        match self.last_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_last_message(&mut self) {
        self.last_message = ::std::option::Option::None;
    }

    pub fn has_last_message(&self) -> bool {
        self.last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_message(&mut self, v: ::std::string::String) {
        self.last_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_message(&mut self) -> &mut ::std::string::String {
        if self.last_message.is_none() {
            self.last_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.last_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_message(&mut self) -> ::std::string::String {
        self.last_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_last_message = 8;

    pub fn accountid_last_message(&self) -> u32 {
        self.accountid_last_message.unwrap_or(0)
    }

    pub fn clear_accountid_last_message(&mut self) {
        self.accountid_last_message = ::std::option::Option::None;
    }

    pub fn has_accountid_last_message(&self) -> bool {
        self.accountid_last_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_last_message(&mut self, v: u32) {
        self.accountid_last_message = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoomState| { &m.chat_id },
            |m: &mut CChatRoomState| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_name",
            |m: &CChatRoomState| { &m.chat_name },
            |m: &mut CChatRoomState| { &mut m.chat_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_allowed",
            |m: &CChatRoomState| { &m.voice_allowed },
            |m: &mut CChatRoomState| { &mut m.voice_allowed },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members_in_voice",
            |m: &CChatRoomState| { &m.members_in_voice },
            |m: &mut CChatRoomState| { &mut m.members_in_voice },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_message",
            |m: &CChatRoomState| { &m.time_last_message },
            |m: &mut CChatRoomState| { &mut m.time_last_message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "sort_order",
            |m: &CChatRoomState| { &m.sort_order },
            |m: &mut CChatRoomState| { &mut m.sort_order },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_message",
            |m: &CChatRoomState| { &m.last_message },
            |m: &mut CChatRoomState| { &mut m.last_message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_last_message",
            |m: &CChatRoomState| { &m.accountid_last_message },
            |m: &mut CChatRoomState| { &mut m.accountid_last_message },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomState>(
            "CChatRoomState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoomState {
    const NAME: &'static str = "CChatRoomState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.voice_allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.members_in_voice)?;
                },
                32 => {
                    self.members_in_voice.push(is.read_uint32()?);
                },
                40 => {
                    self.time_last_message = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.sort_order = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.last_message = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.accountid_last_message = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.voice_allowed {
            my_size += 1 + 1;
        }
        for value in &self.members_in_voice {
            my_size += crate::rt::uint32_size(4, *value);
        };
        if let Some(v) = self.time_last_message {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.sort_order {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.last_message.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.accountid_last_message {
            my_size += crate::rt::uint32_size(8, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.voice_allowed {
            os.write_bool(3, v)?;
        }
        for v in &self.members_in_voice {
            os.write_uint32(4, *v)?;
        };
        if let Some(v) = self.time_last_message {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.sort_order {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.last_message.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.accountid_last_message {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomState {
        CChatRoomState::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.voice_allowed = ::std::option::Option::None;
        self.members_in_voice.clear();
        self.time_last_message = ::std::option::Option::None;
        self.sort_order = ::std::option::Option::None;
        self.last_message = ::std::option::Option::None;
        self.accountid_last_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomState {
        static instance: CChatRoomState = CChatRoomState {
            chat_id: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            voice_allowed: ::std::option::Option::None,
            members_in_voice: ::std::vec::Vec::new(),
            time_last_message: ::std::option::Option::None,
            sort_order: ::std::option::Option::None,
            last_message: ::std::option::Option::None,
            accountid_last_message: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoomState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoomState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomGroupState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomGroupState {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomGroupState.header_state)
    pub header_state: crate::MessageField<CChatRoomGroupHeaderState>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.members)
    pub members: ::std::vec::Vec<CChatRoomMember>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.default_chat_id)
    pub default_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.chat_rooms)
    pub chat_rooms: ::std::vec::Vec<CChatRoomState>,
    // @@protoc_insertion_point(field:CChatRoomGroupState.kicked)
    pub kicked: ::std::vec::Vec<CChatRoomMember>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomGroupState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupState {
    fn default() -> &'a CChatRoomGroupState {
        <CChatRoomGroupState as crate::Message>::default_instance()
    }
}

impl CChatRoomGroupState {
    pub fn new() -> CChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupHeaderState header_state = 1;

    pub fn header_state(&self) -> &CChatRoomGroupHeaderState {
        self.header_state.as_ref().unwrap_or_else(|| <CChatRoomGroupHeaderState as crate::Message>::default_instance())
    }

    pub fn clear_header_state(&mut self) {
        self.header_state.clear();
    }

    pub fn has_header_state(&self) -> bool {
        self.header_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_state(&mut self, v: CChatRoomGroupHeaderState) {
        self.header_state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_state(&mut self) -> &mut CChatRoomGroupHeaderState {
        self.header_state.mut_or_insert_default()
    }

    // Take field
    pub fn take_header_state(&mut self) -> CChatRoomGroupHeaderState {
        self.header_state.take().unwrap_or_else(|| CChatRoomGroupHeaderState::new())
    }

    // repeated .CChatRoomMember members = 2;

    pub fn members(&self) -> &[CChatRoomMember] {
        &self.members
    }

    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::std::vec::Vec<CChatRoomMember>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::std::vec::Vec<CChatRoomMember> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::std::vec::Vec<CChatRoomMember> {
        ::std::mem::replace(&mut self.members, ::std::vec::Vec::new())
    }

    // optional uint64 default_chat_id = 4;

    pub fn default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }

    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoomState chat_rooms = 5;

    pub fn chat_rooms(&self) -> &[CChatRoomState] {
        &self.chat_rooms
    }

    pub fn clear_chat_rooms(&mut self) {
        self.chat_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_rooms(&mut self, v: ::std::vec::Vec<CChatRoomState>) {
        self.chat_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_rooms(&mut self) -> &mut ::std::vec::Vec<CChatRoomState> {
        &mut self.chat_rooms
    }

    // Take field
    pub fn take_chat_rooms(&mut self) -> ::std::vec::Vec<CChatRoomState> {
        ::std::mem::replace(&mut self.chat_rooms, ::std::vec::Vec::new())
    }

    // repeated .CChatRoomMember kicked = 7;

    pub fn kicked(&self) -> &[CChatRoomMember] {
        &self.kicked
    }

    pub fn clear_kicked(&mut self) {
        self.kicked.clear();
    }

    // Param is passed by value, moved
    pub fn set_kicked(&mut self, v: ::std::vec::Vec<CChatRoomMember>) {
        self.kicked = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kicked(&mut self) -> &mut ::std::vec::Vec<CChatRoomMember> {
        &mut self.kicked
    }

    // Take field
    pub fn take_kicked(&mut self) -> ::std::vec::Vec<CChatRoomMember> {
        ::std::mem::replace(&mut self.kicked, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupHeaderState>(
            "header_state",
            |m: &CChatRoomGroupState| { &m.header_state },
            |m: &mut CChatRoomGroupState| { &mut m.header_state },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CChatRoomGroupState| { &m.members },
            |m: &mut CChatRoomGroupState| { &mut m.members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_chat_id",
            |m: &CChatRoomGroupState| { &m.default_chat_id },
            |m: &mut CChatRoomGroupState| { &mut m.default_chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_rooms",
            |m: &CChatRoomGroupState| { &m.chat_rooms },
            |m: &mut CChatRoomGroupState| { &mut m.chat_rooms },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kicked",
            |m: &CChatRoomGroupState| { &m.kicked },
            |m: &mut CChatRoomGroupState| { &mut m.kicked },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomGroupState>(
            "CChatRoomGroupState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoomGroupState {
    const NAME: &'static str = "CChatRoomGroupState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.header_state)?;
                },
                18 => {
                    self.members.push(is.read_message()?);
                },
                32 => {
                    self.default_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.chat_rooms.push(is.read_message()?);
                },
                58 => {
                    self.kicked.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.default_chat_id {
            my_size += crate::rt::uint64_size(4, v);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.kicked {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.header_state.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.members {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.default_chat_id {
            os.write_uint64(4, v)?;
        }
        for v in &self.chat_rooms {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.kicked {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomGroupState {
        CChatRoomGroupState::new()
    }

    fn clear(&mut self) {
        self.header_state.clear();
        self.members.clear();
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.kicked.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomGroupState {
        static instance: CChatRoomGroupState = CChatRoomGroupState {
            header_state: crate::MessageField::none(),
            members: ::std::vec::Vec::new(),
            default_chat_id: ::std::option::Option::None,
            chat_rooms: ::std::vec::Vec::new(),
            kicked: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoomGroupState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomGroupState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomGroupState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoomGroupState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserChatRoomState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserChatRoomState {
    // message fields
    // @@protoc_insertion_point(field:CUserChatRoomState.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_joined)
    pub time_joined: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_last_ack)
    pub time_last_ack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomState.desktop_notification_level)
    pub desktop_notification_level: ::std::option::Option<crate::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomState.mobile_notification_level)
    pub mobile_notification_level: ::std::option::Option<crate::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_last_mention)
    pub time_last_mention: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomState.unread_indicator_muted)
    pub unread_indicator_muted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserChatRoomState.time_first_unread)
    pub time_first_unread: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserChatRoomState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomState {
    fn default() -> &'a CUserChatRoomState {
        <CUserChatRoomState as crate::Message>::default_instance()
    }
}

impl CUserChatRoomState {
    pub fn new() -> CUserChatRoomState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;

    pub fn time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }

    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_ack = 3;

    pub fn time_last_ack(&self) -> u32 {
        self.time_last_ack.unwrap_or(0)
    }

    pub fn clear_time_last_ack(&mut self) {
        self.time_last_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_ack(&self) -> bool {
        self.time_last_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_ack(&mut self, v: u32) {
        self.time_last_ack = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;

    pub fn desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.desktop_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;

    pub fn mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.mobile_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 time_last_mention = 6;

    pub fn time_last_mention(&self) -> u32 {
        self.time_last_mention.unwrap_or(0)
    }

    pub fn clear_time_last_mention(&mut self) {
        self.time_last_mention = ::std::option::Option::None;
    }

    pub fn has_time_last_mention(&self) -> bool {
        self.time_last_mention.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_mention(&mut self, v: u32) {
        self.time_last_mention = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;

    pub fn unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }

    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }

    // optional uint32 time_first_unread = 8;

    pub fn time_first_unread(&self) -> u32 {
        self.time_first_unread.unwrap_or(0)
    }

    pub fn clear_time_first_unread(&mut self) {
        self.time_first_unread = ::std::option::Option::None;
    }

    pub fn has_time_first_unread(&self) -> bool {
        self.time_first_unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_first_unread(&mut self, v: u32) {
        self.time_first_unread = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CUserChatRoomState| { &m.chat_id },
            |m: &mut CUserChatRoomState| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_joined",
            |m: &CUserChatRoomState| { &m.time_joined },
            |m: &mut CUserChatRoomState| { &mut m.time_joined },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_ack",
            |m: &CUserChatRoomState| { &m.time_last_ack },
            |m: &mut CUserChatRoomState| { &mut m.time_last_ack },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "desktop_notification_level",
            |m: &CUserChatRoomState| { &m.desktop_notification_level },
            |m: &mut CUserChatRoomState| { &mut m.desktop_notification_level },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mobile_notification_level",
            |m: &CUserChatRoomState| { &m.mobile_notification_level },
            |m: &mut CUserChatRoomState| { &mut m.mobile_notification_level },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_mention",
            |m: &CUserChatRoomState| { &m.time_last_mention },
            |m: &mut CUserChatRoomState| { &mut m.time_last_mention },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unread_indicator_muted",
            |m: &CUserChatRoomState| { &m.unread_indicator_muted },
            |m: &mut CUserChatRoomState| { &mut m.unread_indicator_muted },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_first_unread",
            |m: &CUserChatRoomState| { &m.time_first_unread },
            |m: &mut CUserChatRoomState| { &mut m.time_first_unread },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CUserChatRoomState>(
            "CUserChatRoomState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CUserChatRoomState {
    const NAME: &'static str = "CUserChatRoomState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_last_ack = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.time_last_mention = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.time_first_unread = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.time_joined {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_last_ack {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.desktop_notification_level {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += crate::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.time_last_mention {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.time_first_unread {
            my_size += crate::rt::uint32_size(8, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_last_ack {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_last_mention {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.time_first_unread {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserChatRoomState {
        CUserChatRoomState::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.time_last_ack = ::std::option::Option::None;
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_mention = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.time_first_unread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserChatRoomState {
        static instance: CUserChatRoomState = CUserChatRoomState {
            chat_id: ::std::option::Option::None,
            time_joined: ::std::option::Option::None,
            time_last_ack: ::std::option::Option::None,
            desktop_notification_level: ::std::option::Option::None,
            mobile_notification_level: ::std::option::Option::None,
            time_last_mention: ::std::option::Option::None,
            unread_indicator_muted: ::std::option::Option::None,
            time_first_unread: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CUserChatRoomState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserChatRoomState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserChatRoomState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CUserChatRoomState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CUserChatRoomGroupState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserChatRoomGroupState {
    // message fields
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.time_joined)
    pub time_joined: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.user_chat_room_state)
    pub user_chat_room_state: ::std::vec::Vec<CUserChatRoomState>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.desktop_notification_level)
    pub desktop_notification_level: ::std::option::Option<crate::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.mobile_notification_level)
    pub mobile_notification_level: ::std::option::Option<crate::EnumOrUnknown<EChatRoomNotificationLevel>>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.time_last_group_ack)
    pub time_last_group_ack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserChatRoomGroupState.unread_indicator_muted)
    pub unread_indicator_muted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserChatRoomGroupState.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserChatRoomGroupState {
    fn default() -> &'a CUserChatRoomGroupState {
        <CUserChatRoomGroupState as crate::Message>::default_instance()
    }
}

impl CUserChatRoomGroupState {
    pub fn new() -> CUserChatRoomGroupState {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_joined = 2;

    pub fn time_joined(&self) -> u32 {
        self.time_joined.unwrap_or(0)
    }

    pub fn clear_time_joined(&mut self) {
        self.time_joined = ::std::option::Option::None;
    }

    pub fn has_time_joined(&self) -> bool {
        self.time_joined.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_joined(&mut self, v: u32) {
        self.time_joined = ::std::option::Option::Some(v);
    }

    // repeated .CUserChatRoomState user_chat_room_state = 3;

    pub fn user_chat_room_state(&self) -> &[CUserChatRoomState] {
        &self.user_chat_room_state
    }

    pub fn clear_user_chat_room_state(&mut self) {
        self.user_chat_room_state.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_chat_room_state(&mut self, v: ::std::vec::Vec<CUserChatRoomState>) {
        self.user_chat_room_state = v;
    }

    // Mutable pointer to the field.
    pub fn mut_user_chat_room_state(&mut self) -> &mut ::std::vec::Vec<CUserChatRoomState> {
        &mut self.user_chat_room_state
    }

    // Take field
    pub fn take_user_chat_room_state(&mut self) -> ::std::vec::Vec<CUserChatRoomState> {
        ::std::mem::replace(&mut self.user_chat_room_state, ::std::vec::Vec::new())
    }

    // optional .EChatRoomNotificationLevel desktop_notification_level = 4;

    pub fn desktop_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.desktop_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_desktop_notification_level(&mut self) {
        self.desktop_notification_level = ::std::option::Option::None;
    }

    pub fn has_desktop_notification_level(&self) -> bool {
        self.desktop_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desktop_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.desktop_notification_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .EChatRoomNotificationLevel mobile_notification_level = 5;

    pub fn mobile_notification_level(&self) -> EChatRoomNotificationLevel {
        match self.mobile_notification_level {
            Some(e) => e.enum_value_or(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            None => EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        }
    }

    pub fn clear_mobile_notification_level(&mut self) {
        self.mobile_notification_level = ::std::option::Option::None;
    }

    pub fn has_mobile_notification_level(&self) -> bool {
        self.mobile_notification_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mobile_notification_level(&mut self, v: EChatRoomNotificationLevel) {
        self.mobile_notification_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 time_last_group_ack = 6;

    pub fn time_last_group_ack(&self) -> u32 {
        self.time_last_group_ack.unwrap_or(0)
    }

    pub fn clear_time_last_group_ack(&mut self) {
        self.time_last_group_ack = ::std::option::Option::None;
    }

    pub fn has_time_last_group_ack(&self) -> bool {
        self.time_last_group_ack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_group_ack(&mut self, v: u32) {
        self.time_last_group_ack = ::std::option::Option::Some(v);
    }

    // optional bool unread_indicator_muted = 7;

    pub fn unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.unwrap_or(false)
    }

    pub fn clear_unread_indicator_muted(&mut self) {
        self.unread_indicator_muted = ::std::option::Option::None;
    }

    pub fn has_unread_indicator_muted(&self) -> bool {
        self.unread_indicator_muted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread_indicator_muted(&mut self, v: bool) {
        self.unread_indicator_muted = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CUserChatRoomGroupState| { &m.chat_group_id },
            |m: &mut CUserChatRoomGroupState| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_joined",
            |m: &CUserChatRoomGroupState| { &m.time_joined },
            |m: &mut CUserChatRoomGroupState| { &mut m.time_joined },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_chat_room_state",
            |m: &CUserChatRoomGroupState| { &m.user_chat_room_state },
            |m: &mut CUserChatRoomGroupState| { &mut m.user_chat_room_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "desktop_notification_level",
            |m: &CUserChatRoomGroupState| { &m.desktop_notification_level },
            |m: &mut CUserChatRoomGroupState| { &mut m.desktop_notification_level },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mobile_notification_level",
            |m: &CUserChatRoomGroupState| { &m.mobile_notification_level },
            |m: &mut CUserChatRoomGroupState| { &mut m.mobile_notification_level },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_last_group_ack",
            |m: &CUserChatRoomGroupState| { &m.time_last_group_ack },
            |m: &mut CUserChatRoomGroupState| { &mut m.time_last_group_ack },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unread_indicator_muted",
            |m: &CUserChatRoomGroupState| { &m.unread_indicator_muted },
            |m: &mut CUserChatRoomGroupState| { &mut m.unread_indicator_muted },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CUserChatRoomGroupState>(
            "CUserChatRoomGroupState",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CUserChatRoomGroupState {
    const NAME: &'static str = "CUserChatRoomGroupState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.time_joined = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.user_chat_room_state.push(is.read_message()?);
                },
                32 => {
                    self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.time_last_group_ack = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.time_joined {
            my_size += crate::rt::uint32_size(2, v);
        }
        for value in &self.user_chat_room_state {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.desktop_notification_level {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.mobile_notification_level {
            my_size += crate::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.time_last_group_ack {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.unread_indicator_muted {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.time_joined {
            os.write_uint32(2, v)?;
        }
        for v in &self.user_chat_room_state {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.desktop_notification_level {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mobile_notification_level {
            os.write_enum(5, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.time_last_group_ack {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.unread_indicator_muted {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserChatRoomGroupState {
        CUserChatRoomGroupState::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.time_joined = ::std::option::Option::None;
        self.user_chat_room_state.clear();
        self.desktop_notification_level = ::std::option::Option::None;
        self.mobile_notification_level = ::std::option::Option::None;
        self.time_last_group_ack = ::std::option::Option::None;
        self.unread_indicator_muted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserChatRoomGroupState {
        static instance: CUserChatRoomGroupState = CUserChatRoomGroupState {
            chat_group_id: ::std::option::Option::None,
            time_joined: ::std::option::Option::None,
            user_chat_room_state: ::std::vec::Vec::new(),
            desktop_notification_level: ::std::option::Option::None,
            mobile_notification_level: ::std::option::Option::None,
            time_last_group_ack: ::std::option::Option::None,
            unread_indicator_muted: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CUserChatRoomGroupState {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUserChatRoomGroupState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUserChatRoomGroupState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CUserChatRoomGroupState {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Response.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Response.state)
    pub state: crate::MessageField<CChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoomGroup_Response.user_chat_state)
    pub user_chat_state: crate::MessageField<CUserChatRoomGroupState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoomGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_CreateChatRoomGroup_Response {
        <CChatRoom_CreateChatRoomGroup_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoomGroup_Response {
    pub fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomGroupState state = 2;

    pub fn state(&self) -> &CChatRoomGroupState {
        self.state.as_ref().unwrap_or_else(|| <CChatRoomGroupState as crate::Message>::default_instance())
    }

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CChatRoomGroupState) {
        self.state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut CChatRoomGroupState {
        self.state.mut_or_insert_default()
    }

    // Take field
    pub fn take_state(&mut self) -> CChatRoomGroupState {
        self.state.take().unwrap_or_else(|| CChatRoomGroupState::new())
    }

    // optional .CUserChatRoomGroupState user_chat_state = 3;

    pub fn user_chat_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as crate::Message>::default_instance())
    }

    pub fn clear_user_chat_state(&mut self) {
        self.user_chat_state.clear();
    }

    pub fn has_user_chat_state(&self) -> bool {
        self.user_chat_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_state(&mut self) -> &mut CUserChatRoomGroupState {
        self.user_chat_state.mut_or_insert_default()
    }

    // Take field
    pub fn take_user_chat_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.chat_group_id },
            |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupState>(
            "state",
            |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.state },
            |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.state },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_state",
            |m: &CChatRoom_CreateChatRoomGroup_Response| { &m.user_chat_state },
            |m: &mut CChatRoom_CreateChatRoomGroup_Response| { &mut m.user_chat_state },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateChatRoomGroup_Response>(
            "CChatRoom_CreateChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_CreateChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_CreateChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.user_chat_state)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.state.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoomGroup_Response {
        CChatRoom_CreateChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.state.clear();
        self.user_chat_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoomGroup_Response {
        static instance: CChatRoom_CreateChatRoomGroup_Response = CChatRoom_CreateChatRoomGroup_Response {
            chat_group_id: ::std::option::Option::None,
            state: crate::MessageField::none(),
            user_chat_state: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_CreateChatRoomGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_CreateChatRoomGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SaveChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SaveChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SaveChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SaveChatRoomGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SaveChatRoomGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Request {
        <CChatRoom_SaveChatRoomGroup_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SaveChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SaveChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_SaveChatRoomGroup_Request| { &m.name },
            |m: &mut CChatRoom_SaveChatRoomGroup_Request| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SaveChatRoomGroup_Request>(
            "CChatRoom_SaveChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SaveChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_SaveChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Request {
        CChatRoom_SaveChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Request {
        static instance: CChatRoom_SaveChatRoomGroup_Request = CChatRoom_SaveChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SaveChatRoomGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SaveChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SaveChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SaveChatRoomGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SaveChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SaveChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SaveChatRoomGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_SaveChatRoomGroup_Response {
        <CChatRoom_SaveChatRoomGroup_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SaveChatRoomGroup_Response>(
            "CChatRoom_SaveChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SaveChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_SaveChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SaveChatRoomGroup_Response {
        CChatRoom_SaveChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SaveChatRoomGroup_Response {
        static instance: CChatRoom_SaveChatRoomGroup_Response = CChatRoom_SaveChatRoomGroup_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SaveChatRoomGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SaveChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SaveChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SaveChatRoomGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoomGroup_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoomGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Request {
        <CChatRoom_RenameChatRoomGroup_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Request {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_RenameChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_RenameChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_RenameChatRoomGroup_Request| { &m.name },
            |m: &mut CChatRoom_RenameChatRoomGroup_Request| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameChatRoomGroup_Request>(
            "CChatRoom_RenameChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_RenameChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_RenameChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Request {
        CChatRoom_RenameChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Request {
        static instance: CChatRoom_RenameChatRoomGroup_Request = CChatRoom_RenameChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_RenameChatRoomGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_RenameChatRoomGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoomGroup_Response.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoomGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_RenameChatRoomGroup_Response {
        <CChatRoom_RenameChatRoomGroup_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoomGroup_Response {
    pub fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_RenameChatRoomGroup_Response| { &m.name },
            |m: &mut CChatRoom_RenameChatRoomGroup_Response| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameChatRoomGroup_Response>(
            "CChatRoom_RenameChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_RenameChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_RenameChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoomGroup_Response {
        CChatRoom_RenameChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoomGroup_Response {
        static instance: CChatRoom_RenameChatRoomGroup_Response = CChatRoom_RenameChatRoomGroup_Response {
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_RenameChatRoomGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_RenameChatRoomGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupTagline_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupTagline_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupTagline_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupTagline_Request.tagline)
    pub tagline: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupTagline_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Request {
        <CChatRoom_SetChatRoomGroupTagline_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string tagline = 2;

    pub fn tagline(&self) -> &str {
        match self.tagline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tagline(&mut self) {
        self.tagline = ::std::option::Option::None;
    }

    pub fn has_tagline(&self) -> bool {
        self.tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagline(&mut self, v: ::std::string::String) {
        self.tagline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagline(&mut self) -> &mut ::std::string::String {
        if self.tagline.is_none() {
            self.tagline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagline(&mut self) -> ::std::string::String {
        self.tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetChatRoomGroupTagline_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetChatRoomGroupTagline_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tagline",
            |m: &CChatRoom_SetChatRoomGroupTagline_Request| { &m.tagline },
            |m: &mut CChatRoom_SetChatRoomGroupTagline_Request| { &mut m.tagline },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupTagline_Request>(
            "CChatRoom_SetChatRoomGroupTagline_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetChatRoomGroupTagline_Request {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupTagline_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.tagline = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.tagline.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.tagline.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Request {
        CChatRoom_SetChatRoomGroupTagline_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.tagline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Request {
        static instance: CChatRoom_SetChatRoomGroupTagline_Request = CChatRoom_SetChatRoomGroupTagline_Request {
            chat_group_id: ::std::option::Option::None,
            tagline: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetChatRoomGroupTagline_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupTagline_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupTagline_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupTagline_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupTagline_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupTagline_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupTagline_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupTagline_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupTagline_Response {
        <CChatRoom_SetChatRoomGroupTagline_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupTagline_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupTagline_Response>(
            "CChatRoom_SetChatRoomGroupTagline_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetChatRoomGroupTagline_Response {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupTagline_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupTagline_Response {
        CChatRoom_SetChatRoomGroupTagline_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupTagline_Response {
        static instance: CChatRoom_SetChatRoomGroupTagline_Response = CChatRoom_SetChatRoomGroupTagline_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetChatRoomGroupTagline_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupTagline_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupTagline_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupTagline_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupAvatar_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupAvatar_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupAvatar_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupAvatar_Request.avatar_sha)
    pub avatar_sha: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupAvatar_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Request {
        <CChatRoom_SetChatRoomGroupAvatar_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional bytes avatar_sha = 2;

    pub fn avatar_sha(&self) -> &[u8] {
        match self.avatar_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_avatar_sha(&mut self) {
        self.avatar_sha = ::std::option::Option::None;
    }

    pub fn has_avatar_sha(&self) -> bool {
        self.avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_sha(&mut self, v: ::bytes::Bytes) {
        self.avatar_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_sha(&mut self) -> &mut ::bytes::Bytes {
        if self.avatar_sha.is_none() {
            self.avatar_sha = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_sha(&mut self) -> ::bytes::Bytes {
        self.avatar_sha.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetChatRoomGroupAvatar_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetChatRoomGroupAvatar_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_sha",
            |m: &CChatRoom_SetChatRoomGroupAvatar_Request| { &m.avatar_sha },
            |m: &mut CChatRoom_SetChatRoomGroupAvatar_Request| { &mut m.avatar_sha },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupAvatar_Request>(
            "CChatRoom_SetChatRoomGroupAvatar_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetChatRoomGroupAvatar_Request {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupAvatar_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.avatar_sha = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.avatar_sha.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Request {
        CChatRoom_SetChatRoomGroupAvatar_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.avatar_sha = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Request {
        static instance: CChatRoom_SetChatRoomGroupAvatar_Request = CChatRoom_SetChatRoomGroupAvatar_Request {
            chat_group_id: ::std::option::Option::None,
            avatar_sha: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupAvatar_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupAvatar_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupAvatar_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupAvatar_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupAvatar_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupAvatar_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupAvatar_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupAvatar_Response {
        <CChatRoom_SetChatRoomGroupAvatar_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupAvatar_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupAvatar_Response>(
            "CChatRoom_SetChatRoomGroupAvatar_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetChatRoomGroupAvatar_Response {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupAvatar_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupAvatar_Response {
        CChatRoom_SetChatRoomGroupAvatar_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupAvatar_Response {
        static instance: CChatRoom_SetChatRoomGroupAvatar_Response = CChatRoom_SetChatRoomGroupAvatar_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupAvatar_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupAvatar_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupAvatar_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 2;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 watching_broadcast_channel_id = 3;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_accountid",
            |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.watching_broadcast_accountid },
            |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.watching_broadcast_accountid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_channel_id",
            |m: &CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &m.watching_broadcast_channel_id },
            |m: &mut CChatRoom_SetChatRoomGroupWatchingBroadcast_Request| { &mut m.watching_broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupWatchingBroadcast_Request>(
            "CChatRoom_SetChatRoomGroupWatchingBroadcast_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupWatchingBroadcast_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
        static instance: CChatRoom_SetChatRoomGroupWatchingBroadcast_Request = CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
            chat_group_id: ::std::option::Option::None,
            watching_broadcast_accountid: ::std::option::Option::None,
            watching_broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupWatchingBroadcast_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupWatchingBroadcast_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetChatRoomGroupWatchingBroadcast_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetChatRoomGroupWatchingBroadcast_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn default() -> &'a CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        <CChatRoom_SetChatRoomGroupWatchingBroadcast_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    pub fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetChatRoomGroupWatchingBroadcast_Response>(
            "CChatRoom_SetChatRoomGroupWatchingBroadcast_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    const NAME: &'static str = "CChatRoom_SetChatRoomGroupWatchingBroadcast_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        CChatRoom_SetChatRoomGroupWatchingBroadcast_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
        static instance: CChatRoom_SetChatRoomGroupWatchingBroadcast_Response = CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetChatRoomGroupWatchingBroadcast_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetChatRoomGroupWatchingBroadcast_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinMiniGameForChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinMiniGameForChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinMiniGameForChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinMiniGameForChatRoomGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        <CChatRoom_JoinMiniGameForChatRoomGroup_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    pub fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &m.chat_id },
            |m: &mut CChatRoom_JoinMiniGameForChatRoomGroup_Request| { &mut m.chat_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinMiniGameForChatRoomGroup_Request>(
            "CChatRoom_JoinMiniGameForChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_JoinMiniGameForChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        CChatRoom_JoinMiniGameForChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinMiniGameForChatRoomGroup_Request {
        static instance: CChatRoom_JoinMiniGameForChatRoomGroup_Request = CChatRoom_JoinMiniGameForChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinMiniGameForChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_JoinMiniGameForChatRoomGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinMiniGameForChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinMiniGameForChatRoomGroup_Response.minigame_id)
    pub minigame_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinMiniGameForChatRoomGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        <CChatRoom_JoinMiniGameForChatRoomGroup_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    pub fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional uint64 minigame_id = 1;

    pub fn minigame_id(&self) -> u64 {
        self.minigame_id.unwrap_or(0)
    }

    pub fn clear_minigame_id(&mut self) {
        self.minigame_id = ::std::option::Option::None;
    }

    pub fn has_minigame_id(&self) -> bool {
        self.minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minigame_id(&mut self, v: u64) {
        self.minigame_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "minigame_id",
            |m: &CChatRoom_JoinMiniGameForChatRoomGroup_Response| { &m.minigame_id },
            |m: &mut CChatRoom_JoinMiniGameForChatRoomGroup_Response| { &mut m.minigame_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinMiniGameForChatRoomGroup_Response>(
            "CChatRoom_JoinMiniGameForChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_JoinMiniGameForChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.minigame_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.minigame_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        CChatRoom_JoinMiniGameForChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.minigame_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinMiniGameForChatRoomGroup_Response {
        static instance: CChatRoom_JoinMiniGameForChatRoomGroup_Response = CChatRoom_JoinMiniGameForChatRoomGroup_Response {
            minigame_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinMiniGameForChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_JoinMiniGameForChatRoomGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_EndMiniGameForChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_EndMiniGameForChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_EndMiniGameForChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_EndMiniGameForChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_EndMiniGameForChatRoomGroup_Request.minigame_id)
    pub minigame_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_EndMiniGameForChatRoomGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_EndMiniGameForChatRoomGroup_Request {
        <CChatRoom_EndMiniGameForChatRoomGroup_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_EndMiniGameForChatRoomGroup_Request {
    pub fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 minigame_id = 3;

    pub fn minigame_id(&self) -> u64 {
        self.minigame_id.unwrap_or(0)
    }

    pub fn clear_minigame_id(&mut self) {
        self.minigame_id = ::std::option::Option::None;
    }

    pub fn has_minigame_id(&self) -> bool {
        self.minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minigame_id(&mut self, v: u64) {
        self.minigame_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_EndMiniGameForChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_EndMiniGameForChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_EndMiniGameForChatRoomGroup_Request| { &m.chat_id },
            |m: &mut CChatRoom_EndMiniGameForChatRoomGroup_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "minigame_id",
            |m: &CChatRoom_EndMiniGameForChatRoomGroup_Request| { &m.minigame_id },
            |m: &mut CChatRoom_EndMiniGameForChatRoomGroup_Request| { &mut m.minigame_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_EndMiniGameForChatRoomGroup_Request>(
            "CChatRoom_EndMiniGameForChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_EndMiniGameForChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.minigame_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.minigame_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Request {
        CChatRoom_EndMiniGameForChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.minigame_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_EndMiniGameForChatRoomGroup_Request {
        static instance: CChatRoom_EndMiniGameForChatRoomGroup_Request = CChatRoom_EndMiniGameForChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            minigame_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_EndMiniGameForChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_EndMiniGameForChatRoomGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_EndMiniGameForChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_EndMiniGameForChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_EndMiniGameForChatRoomGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_EndMiniGameForChatRoomGroup_Response {
        <CChatRoom_EndMiniGameForChatRoomGroup_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_EndMiniGameForChatRoomGroup_Response {
    pub fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_EndMiniGameForChatRoomGroup_Response>(
            "CChatRoom_EndMiniGameForChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_EndMiniGameForChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_EndMiniGameForChatRoomGroup_Response {
        CChatRoom_EndMiniGameForChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_EndMiniGameForChatRoomGroup_Response {
        static instance: CChatRoom_EndMiniGameForChatRoomGroup_Response = CChatRoom_EndMiniGameForChatRoomGroup_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_EndMiniGameForChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_EndMiniGameForChatRoomGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_MuteUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MuteUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_MuteUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MuteUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MuteUser_Request.expiration)
    pub expiration: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MuteUser_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Request {
    fn default() -> &'a CChatRoom_MuteUser_Request {
        <CChatRoom_MuteUser_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Request {
    pub fn new() -> CChatRoom_MuteUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;

    pub fn expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }

    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_MuteUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_MuteUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_MuteUser_Request| { &m.steamid },
            |m: &mut CChatRoom_MuteUser_Request| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration",
            |m: &CChatRoom_MuteUser_Request| { &m.expiration },
            |m: &mut CChatRoom_MuteUser_Request| { &mut m.expiration },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_MuteUser_Request>(
            "CChatRoom_MuteUser_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_MuteUser_Request {
    const NAME: &'static str = "CChatRoom_MuteUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.expiration = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expiration {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MuteUser_Request {
        CChatRoom_MuteUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Request {
        static instance: CChatRoom_MuteUser_Request = CChatRoom_MuteUser_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            expiration: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_MuteUser_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_MuteUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_MuteUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_MuteUser_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_MuteUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MuteUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MuteUser_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MuteUser_Response {
    fn default() -> &'a CChatRoom_MuteUser_Response {
        <CChatRoom_MuteUser_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_MuteUser_Response {
    pub fn new() -> CChatRoom_MuteUser_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_MuteUser_Response>(
            "CChatRoom_MuteUser_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_MuteUser_Response {
    const NAME: &'static str = "CChatRoom_MuteUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MuteUser_Response {
        CChatRoom_MuteUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MuteUser_Response {
        static instance: CChatRoom_MuteUser_Response = CChatRoom_MuteUser_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_MuteUser_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_MuteUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_MuteUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_MuteUser_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_KickUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_KickUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_KickUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_KickUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_KickUser_Request.expiration)
    pub expiration: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_KickUser_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Request {
    fn default() -> &'a CChatRoom_KickUser_Request {
        <CChatRoom_KickUser_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Request {
    pub fn new() -> CChatRoom_KickUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 expiration = 3;

    pub fn expiration(&self) -> i32 {
        self.expiration.unwrap_or(0)
    }

    pub fn clear_expiration(&mut self) {
        self.expiration = ::std::option::Option::None;
    }

    pub fn has_expiration(&self) -> bool {
        self.expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration(&mut self, v: i32) {
        self.expiration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_KickUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_KickUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_KickUser_Request| { &m.steamid },
            |m: &mut CChatRoom_KickUser_Request| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration",
            |m: &CChatRoom_KickUser_Request| { &m.expiration },
            |m: &mut CChatRoom_KickUser_Request| { &mut m.expiration },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_KickUser_Request>(
            "CChatRoom_KickUser_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_KickUser_Request {
    const NAME: &'static str = "CChatRoom_KickUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.expiration = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expiration {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expiration {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_KickUser_Request {
        CChatRoom_KickUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.expiration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Request {
        static instance: CChatRoom_KickUser_Request = CChatRoom_KickUser_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            expiration: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_KickUser_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_KickUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_KickUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_KickUser_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_KickUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_KickUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_KickUser_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_KickUser_Response {
    fn default() -> &'a CChatRoom_KickUser_Response {
        <CChatRoom_KickUser_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_KickUser_Response {
    pub fn new() -> CChatRoom_KickUser_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_KickUser_Response>(
            "CChatRoom_KickUser_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_KickUser_Response {
    const NAME: &'static str = "CChatRoom_KickUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_KickUser_Response {
        CChatRoom_KickUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_KickUser_Response {
        static instance: CChatRoom_KickUser_Response = CChatRoom_KickUser_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_KickUser_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_KickUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_KickUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_KickUser_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetUserBanState_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserBanState_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetUserBanState_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserBanState_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserBanState_Request.ban_state)
    pub ban_state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserBanState_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Request {
    fn default() -> &'a CChatRoom_SetUserBanState_Request {
        <CChatRoom_SetUserBanState_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Request {
    pub fn new() -> CChatRoom_SetUserBanState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool ban_state = 3;

    pub fn ban_state(&self) -> bool {
        self.ban_state.unwrap_or(false)
    }

    pub fn clear_ban_state(&mut self) {
        self.ban_state = ::std::option::Option::None;
    }

    pub fn has_ban_state(&self) -> bool {
        self.ban_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_state(&mut self, v: bool) {
        self.ban_state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetUserBanState_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_SetUserBanState_Request| { &m.steamid },
            |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ban_state",
            |m: &CChatRoom_SetUserBanState_Request| { &m.ban_state },
            |m: &mut CChatRoom_SetUserBanState_Request| { &mut m.ban_state },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetUserBanState_Request>(
            "CChatRoom_SetUserBanState_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetUserBanState_Request {
    const NAME: &'static str = "CChatRoom_SetUserBanState_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.ban_state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ban_state {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.ban_state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserBanState_Request {
        CChatRoom_SetUserBanState_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.ban_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Request {
        static instance: CChatRoom_SetUserBanState_Request = CChatRoom_SetUserBanState_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            ban_state: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetUserBanState_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetUserBanState_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetUserBanState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetUserBanState_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetUserBanState_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserBanState_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserBanState_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserBanState_Response {
    fn default() -> &'a CChatRoom_SetUserBanState_Response {
        <CChatRoom_SetUserBanState_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetUserBanState_Response {
    pub fn new() -> CChatRoom_SetUserBanState_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetUserBanState_Response>(
            "CChatRoom_SetUserBanState_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetUserBanState_Response {
    const NAME: &'static str = "CChatRoom_SetUserBanState_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserBanState_Response {
        CChatRoom_SetUserBanState_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserBanState_Response {
        static instance: CChatRoom_SetUserBanState_Response = CChatRoom_SetUserBanState_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetUserBanState_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetUserBanState_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetUserBanState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetUserBanState_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RevokeInvite_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RevokeInvite_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RevokeInvite_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RevokeInvite_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RevokeInvite_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Request {
    fn default() -> &'a CChatRoom_RevokeInvite_Request {
        <CChatRoom_RevokeInvite_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Request {
    pub fn new() -> CChatRoom_RevokeInvite_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_RevokeInvite_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_RevokeInvite_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_RevokeInvite_Request| { &m.steamid },
            |m: &mut CChatRoom_RevokeInvite_Request| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RevokeInvite_Request>(
            "CChatRoom_RevokeInvite_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_RevokeInvite_Request {
    const NAME: &'static str = "CChatRoom_RevokeInvite_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RevokeInvite_Request {
        CChatRoom_RevokeInvite_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Request {
        static instance: CChatRoom_RevokeInvite_Request = CChatRoom_RevokeInvite_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_RevokeInvite_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RevokeInvite_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RevokeInvite_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_RevokeInvite_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RevokeInvite_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RevokeInvite_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RevokeInvite_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RevokeInvite_Response {
    fn default() -> &'a CChatRoom_RevokeInvite_Response {
        <CChatRoom_RevokeInvite_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_RevokeInvite_Response {
    pub fn new() -> CChatRoom_RevokeInvite_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RevokeInvite_Response>(
            "CChatRoom_RevokeInvite_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_RevokeInvite_Response {
    const NAME: &'static str = "CChatRoom_RevokeInvite_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RevokeInvite_Response {
        CChatRoom_RevokeInvite_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RevokeInvite_Response {
        static instance: CChatRoom_RevokeInvite_Response = CChatRoom_RevokeInvite_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_RevokeInvite_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RevokeInvite_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RevokeInvite_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_RevokeInvite_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateRole_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateRole_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Request {
    fn default() -> &'a CChatRoom_CreateRole_Request {
        <CChatRoom_CreateRole_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Request {
    pub fn new() -> CChatRoom_CreateRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_CreateRole_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_CreateRole_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_CreateRole_Request| { &m.name },
            |m: &mut CChatRoom_CreateRole_Request| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateRole_Request>(
            "CChatRoom_CreateRole_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_CreateRole_Request {
    const NAME: &'static str = "CChatRoom_CreateRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateRole_Request {
        CChatRoom_CreateRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Request {
        static instance: CChatRoom_CreateRole_Request = CChatRoom_CreateRole_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_CreateRole_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateRole_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_CreateRole_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateRole_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateRole_Response.actions)
    pub actions: crate::MessageField<CChatRoleActions>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateRole_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateRole_Response {
    fn default() -> &'a CChatRoom_CreateRole_Response {
        <CChatRoom_CreateRole_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_CreateRole_Response {
    pub fn new() -> CChatRoom_CreateRole_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoleActions actions = 2;

    pub fn actions(&self) -> &CChatRoleActions {
        self.actions.as_ref().unwrap_or_else(|| <CChatRoleActions as crate::Message>::default_instance())
    }

    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    pub fn has_actions(&self) -> bool {
        self.actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: CChatRoleActions) {
        self.actions = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actions(&mut self) -> &mut CChatRoleActions {
        self.actions.mut_or_insert_default()
    }

    // Take field
    pub fn take_actions(&mut self) -> CChatRoleActions {
        self.actions.take().unwrap_or_else(|| CChatRoleActions::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoleActions>(
            "actions",
            |m: &CChatRoom_CreateRole_Response| { &m.actions },
            |m: &mut CChatRoom_CreateRole_Response| { &mut m.actions },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateRole_Response>(
            "CChatRoom_CreateRole_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_CreateRole_Response {
    const NAME: &'static str = "CChatRoom_CreateRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.actions)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.actions.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateRole_Response {
        CChatRoom_CreateRole_Response::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateRole_Response {
        static instance: CChatRoom_CreateRole_Response = CChatRoom_CreateRole_Response {
            actions: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_CreateRole_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateRole_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_CreateRole_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRoles_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoles_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoles_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoles_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Request {
    fn default() -> &'a CChatRoom_GetRoles_Request {
        <CChatRoom_GetRoles_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Request {
    pub fn new() -> CChatRoom_GetRoles_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetRoles_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetRoles_Request| { &mut m.chat_group_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRoles_Request>(
            "CChatRoom_GetRoles_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetRoles_Request {
    const NAME: &'static str = "CChatRoom_GetRoles_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoles_Request {
        CChatRoom_GetRoles_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Request {
        static instance: CChatRoom_GetRoles_Request = CChatRoom_GetRoles_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetRoles_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRoles_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRoles_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetRoles_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRoles_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoles_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoles_Response.roles)
    pub roles: ::std::vec::Vec<CChatRole>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoles_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoles_Response {
    fn default() -> &'a CChatRoom_GetRoles_Response {
        <CChatRoom_GetRoles_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetRoles_Response {
    pub fn new() -> CChatRoom_GetRoles_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRole roles = 1;

    pub fn roles(&self) -> &[CChatRole] {
        &self.roles
    }

    pub fn clear_roles(&mut self) {
        self.roles.clear();
    }

    // Param is passed by value, moved
    pub fn set_roles(&mut self, v: ::std::vec::Vec<CChatRole>) {
        self.roles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_roles(&mut self) -> &mut ::std::vec::Vec<CChatRole> {
        &mut self.roles
    }

    // Take field
    pub fn take_roles(&mut self) -> ::std::vec::Vec<CChatRole> {
        ::std::mem::replace(&mut self.roles, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "roles",
            |m: &CChatRoom_GetRoles_Response| { &m.roles },
            |m: &mut CChatRoom_GetRoles_Response| { &mut m.roles },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRoles_Response>(
            "CChatRoom_GetRoles_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetRoles_Response {
    const NAME: &'static str = "CChatRoom_GetRoles_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.roles.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.roles {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.roles {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoles_Response {
        CChatRoom_GetRoles_Response::new()
    }

    fn clear(&mut self) {
        self.roles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoles_Response {
        static instance: CChatRoom_GetRoles_Response = CChatRoom_GetRoles_Response {
            roles: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetRoles_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRoles_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRoles_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetRoles_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameRole_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameRole_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameRole_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Request {
    fn default() -> &'a CChatRoom_RenameRole_Request {
        <CChatRoom_RenameRole_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Request {
    pub fn new() -> CChatRoom_RenameRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_RenameRole_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_RenameRole_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_RenameRole_Request| { &m.role_id },
            |m: &mut CChatRoom_RenameRole_Request| { &mut m.role_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_RenameRole_Request| { &m.name },
            |m: &mut CChatRoom_RenameRole_Request| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameRole_Request>(
            "CChatRoom_RenameRole_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_RenameRole_Request {
    const NAME: &'static str = "CChatRoom_RenameRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameRole_Request {
        CChatRoom_RenameRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Request {
        static instance: CChatRoom_RenameRole_Request = CChatRoom_RenameRole_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_RenameRole_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameRole_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_RenameRole_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameRole_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameRole_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameRole_Response {
    fn default() -> &'a CChatRoom_RenameRole_Response {
        <CChatRoom_RenameRole_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_RenameRole_Response {
    pub fn new() -> CChatRoom_RenameRole_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameRole_Response>(
            "CChatRoom_RenameRole_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_RenameRole_Response {
    const NAME: &'static str = "CChatRoom_RenameRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameRole_Response {
        CChatRoom_RenameRole_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameRole_Response {
        static instance: CChatRoom_RenameRole_Response = CChatRoom_RenameRole_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_RenameRole_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameRole_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_RenameRole_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReorderRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ReorderRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderRole_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderRole_Request.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderRole_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Request {
    fn default() -> &'a CChatRoom_ReorderRole_Request {
        <CChatRoom_ReorderRole_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Request {
    pub fn new() -> CChatRoom_ReorderRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ReorderRole_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_ReorderRole_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_ReorderRole_Request| { &m.role_id },
            |m: &mut CChatRoom_ReorderRole_Request| { &mut m.role_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_ReorderRole_Request| { &m.ordinal },
            |m: &mut CChatRoom_ReorderRole_Request| { &mut m.ordinal },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReorderRole_Request>(
            "CChatRoom_ReorderRole_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_ReorderRole_Request {
    const NAME: &'static str = "CChatRoom_ReorderRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.ordinal {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderRole_Request {
        CChatRoom_ReorderRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Request {
        static instance: CChatRoom_ReorderRole_Request = CChatRoom_ReorderRole_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_ReorderRole_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReorderRole_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReorderRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_ReorderRole_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReorderRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderRole_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderRole_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderRole_Response {
    fn default() -> &'a CChatRoom_ReorderRole_Response {
        <CChatRoom_ReorderRole_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_ReorderRole_Response {
    pub fn new() -> CChatRoom_ReorderRole_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReorderRole_Response>(
            "CChatRoom_ReorderRole_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_ReorderRole_Response {
    const NAME: &'static str = "CChatRoom_ReorderRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderRole_Response {
        CChatRoom_ReorderRole_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderRole_Response {
        static instance: CChatRoom_ReorderRole_Response = CChatRoom_ReorderRole_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_ReorderRole_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReorderRole_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReorderRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_ReorderRole_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRole_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRole_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteRole_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteRole_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRole_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Request {
    fn default() -> &'a CChatRoom_DeleteRole_Request {
        <CChatRoom_DeleteRole_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Request {
    pub fn new() -> CChatRoom_DeleteRole_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteRole_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteRole_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_DeleteRole_Request| { &m.role_id },
            |m: &mut CChatRoom_DeleteRole_Request| { &mut m.role_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteRole_Request>(
            "CChatRoom_DeleteRole_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteRole_Request {
    const NAME: &'static str = "CChatRoom_DeleteRole_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRole_Request {
        CChatRoom_DeleteRole_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Request {
        static instance: CChatRoom_DeleteRole_Request = CChatRoom_DeleteRole_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteRole_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteRole_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteRole_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteRole_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRole_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRole_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRole_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRole_Response {
    fn default() -> &'a CChatRoom_DeleteRole_Response {
        <CChatRoom_DeleteRole_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRole_Response {
    pub fn new() -> CChatRoom_DeleteRole_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteRole_Response>(
            "CChatRoom_DeleteRole_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteRole_Response {
    const NAME: &'static str = "CChatRoom_DeleteRole_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRole_Response {
        CChatRoom_DeleteRole_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRole_Response {
        static instance: CChatRoom_DeleteRole_Response = CChatRoom_DeleteRole_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteRole_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteRole_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteRole_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteRole_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRoleActions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoleActions_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoleActions_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetRoleActions_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoleActions_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Request {
    fn default() -> &'a CChatRoom_GetRoleActions_Request {
        <CChatRoom_GetRoleActions_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Request {
    pub fn new() -> CChatRoom_GetRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetRoleActions_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetRoleActions_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_GetRoleActions_Request| { &m.role_id },
            |m: &mut CChatRoom_GetRoleActions_Request| { &mut m.role_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRoleActions_Request>(
            "CChatRoom_GetRoleActions_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetRoleActions_Request {
    const NAME: &'static str = "CChatRoom_GetRoleActions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoleActions_Request {
        CChatRoom_GetRoleActions_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Request {
        static instance: CChatRoom_GetRoleActions_Request = CChatRoom_GetRoleActions_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetRoleActions_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRoleActions_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRoleActions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetRoleActions_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRoleActions_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRoleActions_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRoleActions_Response.actions)
    pub actions: ::std::vec::Vec<CChatRoleActions>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRoleActions_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRoleActions_Response {
    fn default() -> &'a CChatRoom_GetRoleActions_Response {
        <CChatRoom_GetRoleActions_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetRoleActions_Response {
    pub fn new() -> CChatRoom_GetRoleActions_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoleActions actions = 1;

    pub fn actions(&self) -> &[CChatRoleActions] {
        &self.actions
    }

    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::std::vec::Vec<CChatRoleActions>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::std::vec::Vec<CChatRoleActions> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::std::vec::Vec<CChatRoleActions> {
        ::std::mem::replace(&mut self.actions, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "actions",
            |m: &CChatRoom_GetRoleActions_Response| { &m.actions },
            |m: &mut CChatRoom_GetRoleActions_Response| { &mut m.actions },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRoleActions_Response>(
            "CChatRoom_GetRoleActions_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetRoleActions_Response {
    const NAME: &'static str = "CChatRoom_GetRoleActions_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.actions.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.actions {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRoleActions_Response {
        CChatRoom_GetRoleActions_Response::new()
    }

    fn clear(&mut self) {
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRoleActions_Response {
        static instance: CChatRoom_GetRoleActions_Response = CChatRoom_GetRoleActions_Response {
            actions: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetRoleActions_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRoleActions_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRoleActions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetRoleActions_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReplaceRoleActions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReplaceRoleActions_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ReplaceRoleActions_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReplaceRoleActions_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReplaceRoleActions_Request.actions)
    pub actions: crate::MessageField<CChatRoleActions>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReplaceRoleActions_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Request {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Request {
        <CChatRoom_ReplaceRoleActions_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Request {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 2;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoleActions actions = 4;

    pub fn actions(&self) -> &CChatRoleActions {
        self.actions.as_ref().unwrap_or_else(|| <CChatRoleActions as crate::Message>::default_instance())
    }

    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    pub fn has_actions(&self) -> bool {
        self.actions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: CChatRoleActions) {
        self.actions = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actions(&mut self) -> &mut CChatRoleActions {
        self.actions.mut_or_insert_default()
    }

    // Take field
    pub fn take_actions(&mut self) -> CChatRoleActions {
        self.actions.take().unwrap_or_else(|| CChatRoleActions::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ReplaceRoleActions_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_ReplaceRoleActions_Request| { &m.role_id },
            |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.role_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoleActions>(
            "actions",
            |m: &CChatRoom_ReplaceRoleActions_Request| { &m.actions },
            |m: &mut CChatRoom_ReplaceRoleActions_Request| { &mut m.actions },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReplaceRoleActions_Request>(
            "CChatRoom_ReplaceRoleActions_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_ReplaceRoleActions_Request {
    const NAME: &'static str = "CChatRoom_ReplaceRoleActions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.actions)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.actions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.actions.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Request {
        CChatRoom_ReplaceRoleActions_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.actions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Request {
        static instance: CChatRoom_ReplaceRoleActions_Request = CChatRoom_ReplaceRoleActions_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            actions: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_ReplaceRoleActions_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReplaceRoleActions_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReplaceRoleActions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_ReplaceRoleActions_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReplaceRoleActions_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReplaceRoleActions_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReplaceRoleActions_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReplaceRoleActions_Response {
    fn default() -> &'a CChatRoom_ReplaceRoleActions_Response {
        <CChatRoom_ReplaceRoleActions_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_ReplaceRoleActions_Response {
    pub fn new() -> CChatRoom_ReplaceRoleActions_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReplaceRoleActions_Response>(
            "CChatRoom_ReplaceRoleActions_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_ReplaceRoleActions_Response {
    const NAME: &'static str = "CChatRoom_ReplaceRoleActions_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReplaceRoleActions_Response {
        CChatRoom_ReplaceRoleActions_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReplaceRoleActions_Response {
        static instance: CChatRoom_ReplaceRoleActions_Response = CChatRoom_ReplaceRoleActions_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_ReplaceRoleActions_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReplaceRoleActions_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReplaceRoleActions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_ReplaceRoleActions_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_AddRoleToUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_AddRoleToUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_AddRoleToUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AddRoleToUser_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AddRoleToUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_AddRoleToUser_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Request {
    fn default() -> &'a CChatRoom_AddRoleToUser_Request {
        <CChatRoom_AddRoleToUser_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Request {
    pub fn new() -> CChatRoom_AddRoleToUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_AddRoleToUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_AddRoleToUser_Request| { &m.role_id },
            |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.role_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_AddRoleToUser_Request| { &m.steamid },
            |m: &mut CChatRoom_AddRoleToUser_Request| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_AddRoleToUser_Request>(
            "CChatRoom_AddRoleToUser_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_AddRoleToUser_Request {
    const NAME: &'static str = "CChatRoom_AddRoleToUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_AddRoleToUser_Request {
        CChatRoom_AddRoleToUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Request {
        static instance: CChatRoom_AddRoleToUser_Request = CChatRoom_AddRoleToUser_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_AddRoleToUser_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_AddRoleToUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_AddRoleToUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_AddRoleToUser_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_AddRoleToUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_AddRoleToUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_AddRoleToUser_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AddRoleToUser_Response {
    fn default() -> &'a CChatRoom_AddRoleToUser_Response {
        <CChatRoom_AddRoleToUser_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_AddRoleToUser_Response {
    pub fn new() -> CChatRoom_AddRoleToUser_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_AddRoleToUser_Response>(
            "CChatRoom_AddRoleToUser_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_AddRoleToUser_Response {
    const NAME: &'static str = "CChatRoom_AddRoleToUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_AddRoleToUser_Response {
        CChatRoom_AddRoleToUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_AddRoleToUser_Response {
        static instance: CChatRoom_AddRoleToUser_Response = CChatRoom_AddRoleToUser_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_AddRoleToUser_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_AddRoleToUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_AddRoleToUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_AddRoleToUser_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRolesForUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRolesForUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRolesForUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetRolesForUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRolesForUser_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Request {
    fn default() -> &'a CChatRoom_GetRolesForUser_Request {
        <CChatRoom_GetRolesForUser_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Request {
    pub fn new() -> CChatRoom_GetRolesForUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetRolesForUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetRolesForUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_GetRolesForUser_Request| { &m.steamid },
            |m: &mut CChatRoom_GetRolesForUser_Request| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRolesForUser_Request>(
            "CChatRoom_GetRolesForUser_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetRolesForUser_Request {
    const NAME: &'static str = "CChatRoom_GetRolesForUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRolesForUser_Request {
        CChatRoom_GetRolesForUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Request {
        static instance: CChatRoom_GetRolesForUser_Request = CChatRoom_GetRolesForUser_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetRolesForUser_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRolesForUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRolesForUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetRolesForUser_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetRolesForUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetRolesForUser_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetRolesForUser_Response.role_ids)
    pub role_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetRolesForUser_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetRolesForUser_Response {
    fn default() -> &'a CChatRoom_GetRolesForUser_Response {
        <CChatRoom_GetRolesForUser_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetRolesForUser_Response {
    pub fn new() -> CChatRoom_GetRolesForUser_Response {
        ::std::default::Default::default()
    }

    // repeated uint64 role_ids = 1;

    pub fn role_ids(&self) -> &[u64] {
        &self.role_ids
    }

    pub fn clear_role_ids(&mut self) {
        self.role_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.role_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.role_ids
    }

    // Take field
    pub fn take_role_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.role_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_ids",
            |m: &CChatRoom_GetRolesForUser_Response| { &m.role_ids },
            |m: &mut CChatRoom_GetRolesForUser_Response| { &mut m.role_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetRolesForUser_Response>(
            "CChatRoom_GetRolesForUser_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetRolesForUser_Response {
    const NAME: &'static str = "CChatRoom_GetRolesForUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.role_ids)?;
                },
                8 => {
                    self.role_ids.push(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.role_ids {
            my_size += crate::rt::uint64_size(1, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.role_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetRolesForUser_Response {
        CChatRoom_GetRolesForUser_Response::new()
    }

    fn clear(&mut self) {
        self.role_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetRolesForUser_Response {
        static instance: CChatRoom_GetRolesForUser_Response = CChatRoom_GetRolesForUser_Response {
            role_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetRolesForUser_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetRolesForUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetRolesForUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetRolesForUser_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRoleFromUser_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRoleFromUser_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteRoleFromUser_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteRoleFromUser_Request.role_id)
    pub role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteRoleFromUser_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRoleFromUser_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Request {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Request {
        <CChatRoom_DeleteRoleFromUser_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Request {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 role_id = 3;

    pub fn role_id(&self) -> u64 {
        self.role_id.unwrap_or(0)
    }

    pub fn clear_role_id(&mut self) {
        self.role_id = ::std::option::Option::None;
    }

    pub fn has_role_id(&self) -> bool {
        self.role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role_id(&mut self, v: u64) {
        self.role_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "role_id",
            |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.role_id },
            |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.role_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_DeleteRoleFromUser_Request| { &m.steamid },
            |m: &mut CChatRoom_DeleteRoleFromUser_Request| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteRoleFromUser_Request>(
            "CChatRoom_DeleteRoleFromUser_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteRoleFromUser_Request {
    const NAME: &'static str = "CChatRoom_DeleteRoleFromUser_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                33 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.role_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.role_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Request {
        CChatRoom_DeleteRoleFromUser_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.role_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Request {
        static instance: CChatRoom_DeleteRoleFromUser_Request = CChatRoom_DeleteRoleFromUser_Request {
            chat_group_id: ::std::option::Option::None,
            role_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteRoleFromUser_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteRoleFromUser_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteRoleFromUser_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteRoleFromUser_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteRoleFromUser_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteRoleFromUser_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteRoleFromUser_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteRoleFromUser_Response {
    fn default() -> &'a CChatRoom_DeleteRoleFromUser_Response {
        <CChatRoom_DeleteRoleFromUser_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteRoleFromUser_Response {
    pub fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteRoleFromUser_Response>(
            "CChatRoom_DeleteRoleFromUser_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteRoleFromUser_Response {
    const NAME: &'static str = "CChatRoom_DeleteRoleFromUser_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteRoleFromUser_Response {
        CChatRoom_DeleteRoleFromUser_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteRoleFromUser_Response {
        static instance: CChatRoom_DeleteRoleFromUser_Response = CChatRoom_DeleteRoleFromUser_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteRoleFromUser_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteRoleFromUser_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteRoleFromUser_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteRoleFromUser_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinChatRoomGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Request {
        <CChatRoom_JoinChatRoomGroup_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Request {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.invite_code },
            |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.invite_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_JoinChatRoomGroup_Request| { &m.chat_id },
            |m: &mut CChatRoom_JoinChatRoomGroup_Request| { &mut m.chat_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinChatRoomGroup_Request>(
            "CChatRoom_JoinChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_JoinChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_JoinChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.invite_code.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Request {
        CChatRoom_JoinChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Request {
        static instance: CChatRoom_JoinChatRoomGroup_Request = CChatRoom_JoinChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            invite_code: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_JoinChatRoomGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_JoinChatRoomGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinChatRoomGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.state)
    pub state: crate::MessageField<CChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.user_chat_state)
    pub user_chat_state: crate::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.join_chat_id)
    pub join_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinChatRoomGroup_Response.time_expire)
    pub time_expire: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinChatRoomGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_JoinChatRoomGroup_Response {
        <CChatRoom_JoinChatRoomGroup_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_JoinChatRoomGroup_Response {
    pub fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupState state = 1;

    pub fn state(&self) -> &CChatRoomGroupState {
        self.state.as_ref().unwrap_or_else(|| <CChatRoomGroupState as crate::Message>::default_instance())
    }

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CChatRoomGroupState) {
        self.state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut CChatRoomGroupState {
        self.state.mut_or_insert_default()
    }

    // Take field
    pub fn take_state(&mut self) -> CChatRoomGroupState {
        self.state.take().unwrap_or_else(|| CChatRoomGroupState::new())
    }

    // optional .CUserChatRoomGroupState user_chat_state = 3;

    pub fn user_chat_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as crate::Message>::default_instance())
    }

    pub fn clear_user_chat_state(&mut self) {
        self.user_chat_state.clear();
    }

    pub fn has_user_chat_state(&self) -> bool {
        self.user_chat_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_state(&mut self) -> &mut CUserChatRoomGroupState {
        self.user_chat_state.mut_or_insert_default()
    }

    // Take field
    pub fn take_user_chat_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional uint64 join_chat_id = 4;

    pub fn join_chat_id(&self) -> u64 {
        self.join_chat_id.unwrap_or(0)
    }

    pub fn clear_join_chat_id(&mut self) {
        self.join_chat_id = ::std::option::Option::None;
    }

    pub fn has_join_chat_id(&self) -> bool {
        self.join_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_chat_id(&mut self, v: u64) {
        self.join_chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expire = 5;

    pub fn time_expire(&self) -> u32 {
        self.time_expire.unwrap_or(0)
    }

    pub fn clear_time_expire(&mut self) {
        self.time_expire = ::std::option::Option::None;
    }

    pub fn has_time_expire(&self) -> bool {
        self.time_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expire(&mut self, v: u32) {
        self.time_expire = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupState>(
            "state",
            |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.state },
            |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.state },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_state",
            |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.user_chat_state },
            |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.user_chat_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "join_chat_id",
            |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.join_chat_id },
            |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.join_chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_expire",
            |m: &CChatRoom_JoinChatRoomGroup_Response| { &m.time_expire },
            |m: &mut CChatRoom_JoinChatRoomGroup_Response| { &mut m.time_expire },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinChatRoomGroup_Response>(
            "CChatRoom_JoinChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_JoinChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_JoinChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.user_chat_state)?;
                },
                32 => {
                    self.join_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.time_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.join_chat_id {
            my_size += crate::rt::uint64_size(4, v);
        }
        if let Some(v) = self.time_expire {
            my_size += crate::rt::uint32_size(5, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.state.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.user_chat_state.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.join_chat_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.time_expire {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinChatRoomGroup_Response {
        CChatRoom_JoinChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.state.clear();
        self.user_chat_state.clear();
        self.join_chat_id = ::std::option::Option::None;
        self.time_expire = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinChatRoomGroup_Response {
        static instance: CChatRoom_JoinChatRoomGroup_Response = CChatRoom_JoinChatRoomGroup_Response {
            state: crate::MessageField::none(),
            user_chat_state: crate::MessageField::none(),
            join_chat_id: ::std::option::Option::None,
            time_expire: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_JoinChatRoomGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_JoinChatRoomGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_InviteFriendToChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_InviteFriendToChatRoomGroup_Request.skip_friendsui_check)
    pub skip_friendsui_check: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_InviteFriendToChatRoomGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Request {
        <CChatRoom_InviteFriendToChatRoomGroup_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Request {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional bool skip_friendsui_check = 4;

    pub fn skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.unwrap_or(false)
    }

    pub fn clear_skip_friendsui_check(&mut self) {
        self.skip_friendsui_check = ::std::option::Option::None;
    }

    pub fn has_skip_friendsui_check(&self) -> bool {
        self.skip_friendsui_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skip_friendsui_check(&mut self, v: bool) {
        self.skip_friendsui_check = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.steamid },
            |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.chat_id },
            |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "skip_friendsui_check",
            |m: &CChatRoom_InviteFriendToChatRoomGroup_Request| { &m.skip_friendsui_check },
            |m: &mut CChatRoom_InviteFriendToChatRoomGroup_Request| { &mut m.skip_friendsui_check },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_InviteFriendToChatRoomGroup_Request>(
            "CChatRoom_InviteFriendToChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_InviteFriendToChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_InviteFriendToChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.skip_friendsui_check = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.skip_friendsui_check {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.skip_friendsui_check {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Request {
        CChatRoom_InviteFriendToChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.skip_friendsui_check = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Request {
        static instance: CChatRoom_InviteFriendToChatRoomGroup_Request = CChatRoom_InviteFriendToChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            skip_friendsui_check: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_InviteFriendToChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_InviteFriendToChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_InviteFriendToChatRoomGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_InviteFriendToChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_InviteFriendToChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_InviteFriendToChatRoomGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_InviteFriendToChatRoomGroup_Response {
        <CChatRoom_InviteFriendToChatRoomGroup_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_InviteFriendToChatRoomGroup_Response {
    pub fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_InviteFriendToChatRoomGroup_Response>(
            "CChatRoom_InviteFriendToChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_InviteFriendToChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_InviteFriendToChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_InviteFriendToChatRoomGroup_Response {
        CChatRoom_InviteFriendToChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_InviteFriendToChatRoomGroup_Response {
        static instance: CChatRoom_InviteFriendToChatRoomGroup_Response = CChatRoom_InviteFriendToChatRoomGroup_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_InviteFriendToChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_InviteFriendToChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_InviteFriendToChatRoomGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_LeaveChatRoomGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveChatRoomGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_LeaveChatRoomGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveChatRoomGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Request {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Request {
        <CChatRoom_LeaveChatRoomGroup_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Request {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_LeaveChatRoomGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_LeaveChatRoomGroup_Request| { &mut m.chat_group_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_LeaveChatRoomGroup_Request>(
            "CChatRoom_LeaveChatRoomGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_LeaveChatRoomGroup_Request {
    const NAME: &'static str = "CChatRoom_LeaveChatRoomGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Request {
        CChatRoom_LeaveChatRoomGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Request {
        static instance: CChatRoom_LeaveChatRoomGroup_Request = CChatRoom_LeaveChatRoomGroup_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_LeaveChatRoomGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_LeaveChatRoomGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_LeaveChatRoomGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_LeaveChatRoomGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_LeaveChatRoomGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveChatRoomGroup_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveChatRoomGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveChatRoomGroup_Response {
    fn default() -> &'a CChatRoom_LeaveChatRoomGroup_Response {
        <CChatRoom_LeaveChatRoomGroup_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_LeaveChatRoomGroup_Response {
    pub fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_LeaveChatRoomGroup_Response>(
            "CChatRoom_LeaveChatRoomGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_LeaveChatRoomGroup_Response {
    const NAME: &'static str = "CChatRoom_LeaveChatRoomGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveChatRoomGroup_Response {
        CChatRoom_LeaveChatRoomGroup_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveChatRoomGroup_Response {
        static instance: CChatRoom_LeaveChatRoomGroup_Response = CChatRoom_LeaveChatRoomGroup_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_LeaveChatRoomGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_LeaveChatRoomGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_LeaveChatRoomGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_LeaveChatRoomGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Request.allow_voice)
    pub allow_voice: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoom_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Request {
    fn default() -> &'a CChatRoom_CreateChatRoom_Request {
        <CChatRoom_CreateChatRoom_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Request {
    pub fn new() -> CChatRoom_CreateChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allow_voice = 3;

    pub fn allow_voice(&self) -> bool {
        self.allow_voice.unwrap_or(false)
    }

    pub fn clear_allow_voice(&mut self) {
        self.allow_voice = ::std::option::Option::None;
    }

    pub fn has_allow_voice(&self) -> bool {
        self.allow_voice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_voice(&mut self, v: bool) {
        self.allow_voice = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_CreateChatRoom_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_CreateChatRoom_Request| { &m.name },
            |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_voice",
            |m: &CChatRoom_CreateChatRoom_Request| { &m.allow_voice },
            |m: &mut CChatRoom_CreateChatRoom_Request| { &mut m.allow_voice },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateChatRoom_Request>(
            "CChatRoom_CreateChatRoom_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_CreateChatRoom_Request {
    const NAME: &'static str = "CChatRoom_CreateChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.allow_voice = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.allow_voice {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.allow_voice {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoom_Request {
        CChatRoom_CreateChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.allow_voice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Request {
        static instance: CChatRoom_CreateChatRoom_Request = CChatRoom_CreateChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            allow_voice: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_CreateChatRoom_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateChatRoom_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_CreateChatRoom_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateChatRoom_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateChatRoom_Response.chat_room)
    pub chat_room: crate::MessageField<CChatRoomState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateChatRoom_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateChatRoom_Response {
    fn default() -> &'a CChatRoom_CreateChatRoom_Response {
        <CChatRoom_CreateChatRoom_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_CreateChatRoom_Response {
    pub fn new() -> CChatRoom_CreateChatRoom_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoomState chat_room = 1;

    pub fn chat_room(&self) -> &CChatRoomState {
        self.chat_room.as_ref().unwrap_or_else(|| <CChatRoomState as crate::Message>::default_instance())
    }

    pub fn clear_chat_room(&mut self) {
        self.chat_room.clear();
    }

    pub fn has_chat_room(&self) -> bool {
        self.chat_room.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room(&mut self, v: CChatRoomState) {
        self.chat_room = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_room(&mut self) -> &mut CChatRoomState {
        self.chat_room.mut_or_insert_default()
    }

    // Take field
    pub fn take_chat_room(&mut self) -> CChatRoomState {
        self.chat_room.take().unwrap_or_else(|| CChatRoomState::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomState>(
            "chat_room",
            |m: &CChatRoom_CreateChatRoom_Response| { &m.chat_room },
            |m: &mut CChatRoom_CreateChatRoom_Response| { &mut m.chat_room },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateChatRoom_Response>(
            "CChatRoom_CreateChatRoom_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_CreateChatRoom_Response {
    const NAME: &'static str = "CChatRoom_CreateChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.chat_room)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_room.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_room.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateChatRoom_Response {
        CChatRoom_CreateChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.chat_room.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateChatRoom_Response {
        static instance: CChatRoom_CreateChatRoom_Response = CChatRoom_CreateChatRoom_Response {
            chat_room: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_CreateChatRoom_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateChatRoom_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_CreateChatRoom_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatRoom_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatRoom_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Request {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Request {
        <CChatRoom_DeleteChatRoom_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Request {
    pub fn new() -> CChatRoom_DeleteChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteChatRoom_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteChatRoom_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_DeleteChatRoom_Request| { &m.chat_id },
            |m: &mut CChatRoom_DeleteChatRoom_Request| { &mut m.chat_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteChatRoom_Request>(
            "CChatRoom_DeleteChatRoom_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteChatRoom_Request {
    const NAME: &'static str = "CChatRoom_DeleteChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatRoom_Request {
        CChatRoom_DeleteChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Request {
        static instance: CChatRoom_DeleteChatRoom_Request = CChatRoom_DeleteChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteChatRoom_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatRoom_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteChatRoom_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatRoom_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatRoom_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatRoom_Response {
    fn default() -> &'a CChatRoom_DeleteChatRoom_Response {
        <CChatRoom_DeleteChatRoom_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatRoom_Response {
    pub fn new() -> CChatRoom_DeleteChatRoom_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteChatRoom_Response>(
            "CChatRoom_DeleteChatRoom_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteChatRoom_Response {
    const NAME: &'static str = "CChatRoom_DeleteChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatRoom_Response {
        CChatRoom_DeleteChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatRoom_Response {
        static instance: CChatRoom_DeleteChatRoom_Response = CChatRoom_DeleteChatRoom_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteChatRoom_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatRoom_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteChatRoom_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoom_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_RenameChatRoom_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoom_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Request {
    fn default() -> &'a CChatRoom_RenameChatRoom_Request {
        <CChatRoom_RenameChatRoom_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Request {
    pub fn new() -> CChatRoom_RenameChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_RenameChatRoom_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_RenameChatRoom_Request| { &m.chat_id },
            |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CChatRoom_RenameChatRoom_Request| { &m.name },
            |m: &mut CChatRoom_RenameChatRoom_Request| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameChatRoom_Request>(
            "CChatRoom_RenameChatRoom_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_RenameChatRoom_Request {
    const NAME: &'static str = "CChatRoom_RenameChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoom_Request {
        CChatRoom_RenameChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Request {
        static instance: CChatRoom_RenameChatRoom_Request = CChatRoom_RenameChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_RenameChatRoom_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameChatRoom_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_RenameChatRoom_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_RenameChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_RenameChatRoom_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_RenameChatRoom_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_RenameChatRoom_Response {
    fn default() -> &'a CChatRoom_RenameChatRoom_Response {
        <CChatRoom_RenameChatRoom_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_RenameChatRoom_Response {
    pub fn new() -> CChatRoom_RenameChatRoom_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_RenameChatRoom_Response>(
            "CChatRoom_RenameChatRoom_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_RenameChatRoom_Response {
    const NAME: &'static str = "CChatRoom_RenameChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_RenameChatRoom_Response {
        CChatRoom_RenameChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_RenameChatRoom_Response {
        static instance: CChatRoom_RenameChatRoom_Response = CChatRoom_RenameChatRoom_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_RenameChatRoom_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_RenameChatRoom_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_RenameChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_RenameChatRoom_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReorderChatRoom_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderChatRoom_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ReorderChatRoom_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderChatRoom_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ReorderChatRoom_Request.move_after_chat_id)
    pub move_after_chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderChatRoom_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Request {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Request {
        <CChatRoom_ReorderChatRoom_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Request {
    pub fn new() -> CChatRoom_ReorderChatRoom_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 move_after_chat_id = 3;

    pub fn move_after_chat_id(&self) -> u64 {
        self.move_after_chat_id.unwrap_or(0)
    }

    pub fn clear_move_after_chat_id(&mut self) {
        self.move_after_chat_id = ::std::option::Option::None;
    }

    pub fn has_move_after_chat_id(&self) -> bool {
        self.move_after_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_move_after_chat_id(&mut self, v: u64) {
        self.move_after_chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ReorderChatRoom_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_ReorderChatRoom_Request| { &m.chat_id },
            |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "move_after_chat_id",
            |m: &CChatRoom_ReorderChatRoom_Request| { &m.move_after_chat_id },
            |m: &mut CChatRoom_ReorderChatRoom_Request| { &mut m.move_after_chat_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReorderChatRoom_Request>(
            "CChatRoom_ReorderChatRoom_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_ReorderChatRoom_Request {
    const NAME: &'static str = "CChatRoom_ReorderChatRoom_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.move_after_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.move_after_chat_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.move_after_chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderChatRoom_Request {
        CChatRoom_ReorderChatRoom_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.move_after_chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Request {
        static instance: CChatRoom_ReorderChatRoom_Request = CChatRoom_ReorderChatRoom_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            move_after_chat_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_ReorderChatRoom_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReorderChatRoom_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReorderChatRoom_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_ReorderChatRoom_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ReorderChatRoom_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ReorderChatRoom_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ReorderChatRoom_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ReorderChatRoom_Response {
    fn default() -> &'a CChatRoom_ReorderChatRoom_Response {
        <CChatRoom_ReorderChatRoom_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_ReorderChatRoom_Response {
    pub fn new() -> CChatRoom_ReorderChatRoom_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ReorderChatRoom_Response>(
            "CChatRoom_ReorderChatRoom_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_ReorderChatRoom_Response {
    const NAME: &'static str = "CChatRoom_ReorderChatRoom_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ReorderChatRoom_Response {
        CChatRoom_ReorderChatRoom_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ReorderChatRoom_Response {
        static instance: CChatRoom_ReorderChatRoom_Response = CChatRoom_ReorderChatRoom_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_ReorderChatRoom_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ReorderChatRoom_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ReorderChatRoom_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_ReorderChatRoom_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SendChatMessage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SendChatMessage_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Request.echo_to_sender)
    pub echo_to_sender: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SendChatMessage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Request {
    fn default() -> &'a CChatRoom_SendChatMessage_Request {
        <CChatRoom_SendChatMessage_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Request {
    pub fn new() -> CChatRoom_SendChatMessage_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string message = 3;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool echo_to_sender = 4;

    pub fn echo_to_sender(&self) -> bool {
        self.echo_to_sender.unwrap_or(false)
    }

    pub fn clear_echo_to_sender(&mut self) {
        self.echo_to_sender = ::std::option::Option::None;
    }

    pub fn has_echo_to_sender(&self) -> bool {
        self.echo_to_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_echo_to_sender(&mut self, v: bool) {
        self.echo_to_sender = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SendChatMessage_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_SendChatMessage_Request| { &m.chat_id },
            |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CChatRoom_SendChatMessage_Request| { &m.message },
            |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "echo_to_sender",
            |m: &CChatRoom_SendChatMessage_Request| { &m.echo_to_sender },
            |m: &mut CChatRoom_SendChatMessage_Request| { &mut m.echo_to_sender },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SendChatMessage_Request>(
            "CChatRoom_SendChatMessage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SendChatMessage_Request {
    const NAME: &'static str = "CChatRoom_SendChatMessage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.echo_to_sender = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.echo_to_sender {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.echo_to_sender {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SendChatMessage_Request {
        CChatRoom_SendChatMessage_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.echo_to_sender = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Request {
        static instance: CChatRoom_SendChatMessage_Request = CChatRoom_SendChatMessage_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            message: ::std::option::Option::None,
            echo_to_sender: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SendChatMessage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SendChatMessage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SendChatMessage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SendChatMessage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SendChatMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SendChatMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.modified_message)
    pub modified_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SendChatMessage_Response.message_without_bb_code)
    pub message_without_bb_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SendChatMessage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SendChatMessage_Response {
    fn default() -> &'a CChatRoom_SendChatMessage_Response {
        <CChatRoom_SendChatMessage_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SendChatMessage_Response {
    pub fn new() -> CChatRoom_SendChatMessage_Response {
        ::std::default::Default::default()
    }

    // optional string modified_message = 1;

    pub fn modified_message(&self) -> &str {
        match self.modified_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_modified_message(&mut self) {
        self.modified_message = ::std::option::Option::None;
    }

    pub fn has_modified_message(&self) -> bool {
        self.modified_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modified_message(&mut self, v: ::std::string::String) {
        self.modified_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modified_message(&mut self) -> &mut ::std::string::String {
        if self.modified_message.is_none() {
            self.modified_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.modified_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_modified_message(&mut self) -> ::std::string::String {
        self.modified_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_timestamp = 2;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 3;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional string message_without_bb_code = 4;

    pub fn message_without_bb_code(&self) -> &str {
        match self.message_without_bb_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_without_bb_code(&mut self) {
        self.message_without_bb_code = ::std::option::Option::None;
    }

    pub fn has_message_without_bb_code(&self) -> bool {
        self.message_without_bb_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_without_bb_code(&mut self, v: ::std::string::String) {
        self.message_without_bb_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_without_bb_code(&mut self) -> &mut ::std::string::String {
        if self.message_without_bb_code.is_none() {
            self.message_without_bb_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_without_bb_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_without_bb_code(&mut self) -> ::std::string::String {
        self.message_without_bb_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "modified_message",
            |m: &CChatRoom_SendChatMessage_Response| { &m.modified_message },
            |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.modified_message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_timestamp",
            |m: &CChatRoom_SendChatMessage_Response| { &m.server_timestamp },
            |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.server_timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_SendChatMessage_Response| { &m.ordinal },
            |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.ordinal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_without_bb_code",
            |m: &CChatRoom_SendChatMessage_Response| { &m.message_without_bb_code },
            |m: &mut CChatRoom_SendChatMessage_Response| { &mut m.message_without_bb_code },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SendChatMessage_Response>(
            "CChatRoom_SendChatMessage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SendChatMessage_Response {
    const NAME: &'static str = "CChatRoom_SendChatMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.modified_message = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.message_without_bb_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modified_message.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ordinal {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.message_without_bb_code.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.modified_message.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.message_without_bb_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SendChatMessage_Response {
        CChatRoom_SendChatMessage_Response::new()
    }

    fn clear(&mut self) {
        self.modified_message = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.message_without_bb_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SendChatMessage_Response {
        static instance: CChatRoom_SendChatMessage_Response = CChatRoom_SendChatMessage_Response {
            modified_message: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            message_without_bb_code: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SendChatMessage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SendChatMessage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SendChatMessage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SendChatMessage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinVoiceChat_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinVoiceChat_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinVoiceChat_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_JoinVoiceChat_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinVoiceChat_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Request {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Request {
        <CChatRoom_JoinVoiceChat_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Request {
    pub fn new() -> CChatRoom_JoinVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_JoinVoiceChat_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_JoinVoiceChat_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_JoinVoiceChat_Request| { &m.chat_id },
            |m: &mut CChatRoom_JoinVoiceChat_Request| { &mut m.chat_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinVoiceChat_Request>(
            "CChatRoom_JoinVoiceChat_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_JoinVoiceChat_Request {
    const NAME: &'static str = "CChatRoom_JoinVoiceChat_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinVoiceChat_Request {
        CChatRoom_JoinVoiceChat_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Request {
        static instance: CChatRoom_JoinVoiceChat_Request = CChatRoom_JoinVoiceChat_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_JoinVoiceChat_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinVoiceChat_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinVoiceChat_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_JoinVoiceChat_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_JoinVoiceChat_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_JoinVoiceChat_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_JoinVoiceChat_Response.voice_chatid)
    pub voice_chatid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_JoinVoiceChat_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_JoinVoiceChat_Response {
    fn default() -> &'a CChatRoom_JoinVoiceChat_Response {
        <CChatRoom_JoinVoiceChat_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_JoinVoiceChat_Response {
    pub fn new() -> CChatRoom_JoinVoiceChat_Response {
        ::std::default::Default::default()
    }

    // optional uint64 voice_chatid = 1;

    pub fn voice_chatid(&self) -> u64 {
        self.voice_chatid.unwrap_or(0)
    }

    pub fn clear_voice_chatid(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
    }

    pub fn has_voice_chatid(&self) -> bool {
        self.voice_chatid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_chatid(&mut self, v: u64) {
        self.voice_chatid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_chatid",
            |m: &CChatRoom_JoinVoiceChat_Response| { &m.voice_chatid },
            |m: &mut CChatRoom_JoinVoiceChat_Response| { &mut m.voice_chatid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_JoinVoiceChat_Response>(
            "CChatRoom_JoinVoiceChat_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_JoinVoiceChat_Response {
    const NAME: &'static str = "CChatRoom_JoinVoiceChat_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.voice_chatid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.voice_chatid {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.voice_chatid {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_JoinVoiceChat_Response {
        CChatRoom_JoinVoiceChat_Response::new()
    }

    fn clear(&mut self) {
        self.voice_chatid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_JoinVoiceChat_Response {
        static instance: CChatRoom_JoinVoiceChat_Response = CChatRoom_JoinVoiceChat_Response {
            voice_chatid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_JoinVoiceChat_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_JoinVoiceChat_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_JoinVoiceChat_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_JoinVoiceChat_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_LeaveVoiceChat_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveVoiceChat_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_LeaveVoiceChat_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_LeaveVoiceChat_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveVoiceChat_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Request {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Request {
        <CChatRoom_LeaveVoiceChat_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Request {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_LeaveVoiceChat_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_LeaveVoiceChat_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_LeaveVoiceChat_Request| { &m.chat_id },
            |m: &mut CChatRoom_LeaveVoiceChat_Request| { &mut m.chat_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_LeaveVoiceChat_Request>(
            "CChatRoom_LeaveVoiceChat_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_LeaveVoiceChat_Request {
    const NAME: &'static str = "CChatRoom_LeaveVoiceChat_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Request {
        CChatRoom_LeaveVoiceChat_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Request {
        static instance: CChatRoom_LeaveVoiceChat_Request = CChatRoom_LeaveVoiceChat_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_LeaveVoiceChat_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_LeaveVoiceChat_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_LeaveVoiceChat_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_LeaveVoiceChat_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_LeaveVoiceChat_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_LeaveVoiceChat_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_LeaveVoiceChat_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_LeaveVoiceChat_Response {
    fn default() -> &'a CChatRoom_LeaveVoiceChat_Response {
        <CChatRoom_LeaveVoiceChat_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_LeaveVoiceChat_Response {
    pub fn new() -> CChatRoom_LeaveVoiceChat_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_LeaveVoiceChat_Response>(
            "CChatRoom_LeaveVoiceChat_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_LeaveVoiceChat_Response {
    const NAME: &'static str = "CChatRoom_LeaveVoiceChat_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_LeaveVoiceChat_Response {
        CChatRoom_LeaveVoiceChat_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_LeaveVoiceChat_Response {
        static instance: CChatRoom_LeaveVoiceChat_Response = CChatRoom_LeaveVoiceChat_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_LeaveVoiceChat_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_LeaveVoiceChat_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_LeaveVoiceChat_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_LeaveVoiceChat_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageHistory_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.last_time)
    pub last_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.last_ordinal)
    pub last_ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.start_time)
    pub start_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.start_ordinal)
    pub start_ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Request.max_count)
    pub max_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Request {
    fn default() -> &'a CChatRoom_GetMessageHistory_Request {
        <CChatRoom_GetMessageHistory_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Request {
    pub fn new() -> CChatRoom_GetMessageHistory_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time = 3;

    pub fn last_time(&self) -> u32 {
        self.last_time.unwrap_or(0)
    }

    pub fn clear_last_time(&mut self) {
        self.last_time = ::std::option::Option::None;
    }

    pub fn has_last_time(&self) -> bool {
        self.last_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time(&mut self, v: u32) {
        self.last_time = ::std::option::Option::Some(v);
    }

    // optional uint32 last_ordinal = 4;

    pub fn last_ordinal(&self) -> u32 {
        self.last_ordinal.unwrap_or(0)
    }

    pub fn clear_last_ordinal(&mut self) {
        self.last_ordinal = ::std::option::Option::None;
    }

    pub fn has_last_ordinal(&self) -> bool {
        self.last_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ordinal(&mut self, v: u32) {
        self.last_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 5;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 start_ordinal = 6;

    pub fn start_ordinal(&self) -> u32 {
        self.start_ordinal.unwrap_or(0)
    }

    pub fn clear_start_ordinal(&mut self) {
        self.start_ordinal = ::std::option::Option::None;
    }

    pub fn has_start_ordinal(&self) -> bool {
        self.start_ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_ordinal(&mut self, v: u32) {
        self.start_ordinal = ::std::option::Option::Some(v);
    }

    // optional uint32 max_count = 7;

    pub fn max_count(&self) -> u32 {
        self.max_count.unwrap_or(0)
    }

    pub fn clear_max_count(&mut self) {
        self.max_count = ::std::option::Option::None;
    }

    pub fn has_max_count(&self) -> bool {
        self.max_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_count(&mut self, v: u32) {
        self.max_count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.chat_id },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_time",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.last_time },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.last_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_ordinal",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.last_ordinal },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.last_ordinal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.start_time },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.start_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_ordinal",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.start_ordinal },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.start_ordinal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_count",
            |m: &CChatRoom_GetMessageHistory_Request| { &m.max_count },
            |m: &mut CChatRoom_GetMessageHistory_Request| { &mut m.max_count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMessageHistory_Request>(
            "CChatRoom_GetMessageHistory_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetMessageHistory_Request {
    const NAME: &'static str = "CChatRoom_GetMessageHistory_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.last_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.last_ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.start_ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.max_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.last_time {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.last_ordinal {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.start_time {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.start_ordinal {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.max_count {
            my_size += crate::rt::uint32_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.last_time {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.start_ordinal {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_count {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageHistory_Request {
        CChatRoom_GetMessageHistory_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.last_time = ::std::option::Option::None;
        self.last_ordinal = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.start_ordinal = ::std::option::Option::None;
        self.max_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Request {
        static instance: CChatRoom_GetMessageHistory_Request = CChatRoom_GetMessageHistory_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            last_time: ::std::option::Option::None,
            last_ordinal: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            start_ordinal: ::std::option::Option::None,
            max_count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetMessageHistory_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageHistory_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMessageHistory_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ServerMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerMessage {
    // message fields
    // @@protoc_insertion_point(field:ServerMessage.message)
    pub message: ::std::option::Option<crate::EnumOrUnknown<EChatRoomServerMessage>>,
    // @@protoc_insertion_point(field:ServerMessage.string_param)
    pub string_param: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServerMessage.accountid_param)
    pub accountid_param: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ServerMessage.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerMessage {
    fn default() -> &'a ServerMessage {
        <ServerMessage as crate::Message>::default_instance()
    }
}

impl ServerMessage {
    pub fn new() -> ServerMessage {
        ::std::default::Default::default()
    }

    // optional .EChatRoomServerMessage message = 1;

    pub fn message(&self) -> EChatRoomServerMessage {
        match self.message {
            Some(e) => e.enum_value_or(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            None => EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid,
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: EChatRoomServerMessage) {
        self.message = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string string_param = 2;

    pub fn string_param(&self) -> &str {
        match self.string_param.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string_param(&mut self) {
        self.string_param = ::std::option::Option::None;
    }

    pub fn has_string_param(&self) -> bool {
        self.string_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_param(&mut self, v: ::std::string::String) {
        self.string_param = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_param(&mut self) -> &mut ::std::string::String {
        if self.string_param.is_none() {
            self.string_param = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string_param.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_param(&mut self) -> ::std::string::String {
        self.string_param.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_param = 3;

    pub fn accountid_param(&self) -> u32 {
        self.accountid_param.unwrap_or(0)
    }

    pub fn clear_accountid_param(&mut self) {
        self.accountid_param = ::std::option::Option::None;
    }

    pub fn has_accountid_param(&self) -> bool {
        self.accountid_param.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_param(&mut self, v: u32) {
        self.accountid_param = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &ServerMessage| { &m.message },
            |m: &mut ServerMessage| { &mut m.message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_param",
            |m: &ServerMessage| { &m.string_param },
            |m: &mut ServerMessage| { &mut m.string_param },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_param",
            |m: &ServerMessage| { &m.accountid_param },
            |m: &mut ServerMessage| { &mut m.accountid_param },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ServerMessage>(
            "ServerMessage",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ServerMessage {
    const NAME: &'static str = "ServerMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.string_param = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.accountid_param = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.string_param.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.accountid_param {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.message {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.string_param.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.accountid_param {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerMessage {
        ServerMessage::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.string_param = ::std::option::Option::None;
        self.accountid_param = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerMessage {
        static instance: ServerMessage = ServerMessage {
            message: ::std::option::Option::None,
            string_param: ::std::option::Option::None,
            accountid_param: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ServerMessage {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ServerMessage {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageHistory_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.messages)
    pub messages: ::std::vec::Vec<cchat_room_get_message_history_response::ChatMessage>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.more_available)
    pub more_available: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageHistory_Response {
    fn default() -> &'a CChatRoom_GetMessageHistory_Response {
        <CChatRoom_GetMessageHistory_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageHistory_Response {
    pub fn new() -> CChatRoom_GetMessageHistory_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_GetMessageHistory_Response.ChatMessage messages = 1;

    pub fn messages(&self) -> &[cchat_room_get_message_history_response::ChatMessage] {
        &self.messages
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<cchat_room_get_message_history_response::ChatMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<cchat_room_get_message_history_response::ChatMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<cchat_room_get_message_history_response::ChatMessage> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    // optional bool more_available = 4;

    pub fn more_available(&self) -> bool {
        self.more_available.unwrap_or(false)
    }

    pub fn clear_more_available(&mut self) {
        self.more_available = ::std::option::Option::None;
    }

    pub fn has_more_available(&self) -> bool {
        self.more_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_more_available(&mut self, v: bool) {
        self.more_available = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CChatRoom_GetMessageHistory_Response| { &m.messages },
            |m: &mut CChatRoom_GetMessageHistory_Response| { &mut m.messages },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "more_available",
            |m: &CChatRoom_GetMessageHistory_Response| { &m.more_available },
            |m: &mut CChatRoom_GetMessageHistory_Response| { &mut m.more_available },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMessageHistory_Response>(
            "CChatRoom_GetMessageHistory_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetMessageHistory_Response {
    const NAME: &'static str = "CChatRoom_GetMessageHistory_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_message()?);
                },
                32 => {
                    self.more_available = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.more_available {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.messages {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.more_available {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageHistory_Response {
        CChatRoom_GetMessageHistory_Response::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.more_available = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageHistory_Response {
        static instance: CChatRoom_GetMessageHistory_Response = CChatRoom_GetMessageHistory_Response {
            messages: ::std::vec::Vec::new(),
            more_available: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetMessageHistory_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageHistory_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMessageHistory_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetMessageHistory_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_GetMessageHistory_Response`
pub mod cchat_room_get_message_history_response {
    // @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Response.ChatMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatMessage {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.sender)
        pub sender: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.server_timestamp)
        pub server_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.message)
        pub message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.ordinal)
        pub ordinal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.server_message)
        pub server_message: crate::MessageField<super::ServerMessage>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.deleted)
        pub deleted: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.reactions)
        pub reactions: ::std::vec::Vec<chat_message::MessageReaction>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Response.ChatMessage.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatMessage {
        fn default() -> &'a ChatMessage {
            <ChatMessage as crate::Message>::default_instance()
        }
    }

    impl ChatMessage {
        pub fn new() -> ChatMessage {
            ::std::default::Default::default()
        }

        // optional uint32 sender = 1;

        pub fn sender(&self) -> u32 {
            self.sender.unwrap_or(0)
        }

        pub fn clear_sender(&mut self) {
            self.sender = ::std::option::Option::None;
        }

        pub fn has_sender(&self) -> bool {
            self.sender.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sender(&mut self, v: u32) {
            self.sender = ::std::option::Option::Some(v);
        }

        // optional uint32 server_timestamp = 2;

        pub fn server_timestamp(&self) -> u32 {
            self.server_timestamp.unwrap_or(0)
        }

        pub fn clear_server_timestamp(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
        }

        pub fn has_server_timestamp(&self) -> bool {
            self.server_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_timestamp(&mut self, v: u32) {
            self.server_timestamp = ::std::option::Option::Some(v);
        }

        // optional string message = 3;

        pub fn message(&self) -> &str {
            match self.message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_message(&mut self) {
            self.message = ::std::option::Option::None;
        }

        pub fn has_message(&self) -> bool {
            self.message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_message(&mut self, v: ::std::string::String) {
            self.message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_message(&mut self) -> &mut ::std::string::String {
            if self.message.is_none() {
                self.message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.message.as_mut().unwrap()
        }

        // Take field
        pub fn take_message(&mut self) -> ::std::string::String {
            self.message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 ordinal = 4;

        pub fn ordinal(&self) -> u32 {
            self.ordinal.unwrap_or(0)
        }

        pub fn clear_ordinal(&mut self) {
            self.ordinal = ::std::option::Option::None;
        }

        pub fn has_ordinal(&self) -> bool {
            self.ordinal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ordinal(&mut self, v: u32) {
            self.ordinal = ::std::option::Option::Some(v);
        }

        // optional .ServerMessage server_message = 5;

        pub fn server_message(&self) -> &super::ServerMessage {
            self.server_message.as_ref().unwrap_or_else(|| <super::ServerMessage as crate::Message>::default_instance())
        }

        pub fn clear_server_message(&mut self) {
            self.server_message.clear();
        }

        pub fn has_server_message(&self) -> bool {
            self.server_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_message(&mut self, v: super::ServerMessage) {
            self.server_message = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_server_message(&mut self) -> &mut super::ServerMessage {
            self.server_message.mut_or_insert_default()
        }

        // Take field
        pub fn take_server_message(&mut self) -> super::ServerMessage {
            self.server_message.take().unwrap_or_else(|| super::ServerMessage::new())
        }

        // optional bool deleted = 6;

        pub fn deleted(&self) -> bool {
            self.deleted.unwrap_or(false)
        }

        pub fn clear_deleted(&mut self) {
            self.deleted = ::std::option::Option::None;
        }

        pub fn has_deleted(&self) -> bool {
            self.deleted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deleted(&mut self, v: bool) {
            self.deleted = ::std::option::Option::Some(v);
        }

        // repeated .CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction reactions = 7;

        pub fn reactions(&self) -> &[chat_message::MessageReaction] {
            &self.reactions
        }

        pub fn clear_reactions(&mut self) {
            self.reactions.clear();
        }

        // Param is passed by value, moved
        pub fn set_reactions(&mut self, v: ::std::vec::Vec<chat_message::MessageReaction>) {
            self.reactions = v;
        }

        // Mutable pointer to the field.
        pub fn mut_reactions(&mut self) -> &mut ::std::vec::Vec<chat_message::MessageReaction> {
            &mut self.reactions
        }

        // Take field
        pub fn take_reactions(&mut self) -> ::std::vec::Vec<chat_message::MessageReaction> {
            ::std::mem::replace(&mut self.reactions, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sender",
                |m: &ChatMessage| { &m.sender },
                |m: &mut ChatMessage| { &mut m.sender },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_timestamp",
                |m: &ChatMessage| { &m.server_timestamp },
                |m: &mut ChatMessage| { &mut m.server_timestamp },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "message",
                |m: &ChatMessage| { &m.message },
                |m: &mut ChatMessage| { &mut m.message },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "ordinal",
                |m: &ChatMessage| { &m.ordinal },
                |m: &mut ChatMessage| { &mut m.ordinal },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::ServerMessage>(
                "server_message",
                |m: &ChatMessage| { &m.server_message },
                |m: &mut ChatMessage| { &mut m.server_message },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "deleted",
                |m: &ChatMessage| { &m.deleted },
                |m: &mut ChatMessage| { &mut m.deleted },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "reactions",
                |m: &ChatMessage| { &m.reactions },
                |m: &mut ChatMessage| { &mut m.reactions },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ChatMessage>(
                "CChatRoom_GetMessageHistory_Response.ChatMessage",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ChatMessage {
        const NAME: &'static str = "ChatMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sender = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.message = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.server_message)?;
                    },
                    48 => {
                        self.deleted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    58 => {
                        self.reactions.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.sender {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.server_timestamp {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.message.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.ordinal {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.server_message.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.deleted {
                my_size += 1 + 1;
            }
            for value in &self.reactions {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.sender {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.message.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.ordinal {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.server_message.as_ref() {
                crate::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.deleted {
                os.write_bool(6, v)?;
            }
            for v in &self.reactions {
                crate::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatMessage {
            ChatMessage::new()
        }

        fn clear(&mut self) {
            self.sender = ::std::option::Option::None;
            self.server_timestamp = ::std::option::Option::None;
            self.message = ::std::option::Option::None;
            self.ordinal = ::std::option::Option::None;
            self.server_message.clear();
            self.deleted = ::std::option::Option::None;
            self.reactions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatMessage {
            static instance: ChatMessage = ChatMessage {
                sender: ::std::option::Option::None,
                server_timestamp: ::std::option::Option::None,
                message: ::std::option::Option::None,
                ordinal: ::std::option::Option::None,
                server_message: crate::MessageField::none(),
                deleted: ::std::option::Option::None,
                reactions: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ChatMessage {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageHistory_Response.ChatMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChatMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ChatMessage {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `ChatMessage`
    pub mod chat_message {
        // @@protoc_insertion_point(message:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct MessageReaction {
            // message fields
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.reaction_type)
            pub reaction_type: ::std::option::Option<crate::EnumOrUnknown<super::super::EChatRoomMessageReactionType>>,
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.reaction)
            pub reaction: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.num_reactors)
            pub num_reactors: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.has_user_reacted)
            pub has_user_reacted: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a MessageReaction {
            fn default() -> &'a MessageReaction {
                <MessageReaction as crate::Message>::default_instance()
            }
        }

        impl MessageReaction {
            pub fn new() -> MessageReaction {
                ::std::default::Default::default()
            }

            // optional .EChatRoomMessageReactionType reaction_type = 1;

            pub fn reaction_type(&self) -> super::super::EChatRoomMessageReactionType {
                match self.reaction_type {
                    Some(e) => e.enum_value_or(super::super::EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
                    None => super::super::EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
                }
            }

            pub fn clear_reaction_type(&mut self) {
                self.reaction_type = ::std::option::Option::None;
            }

            pub fn has_reaction_type(&self) -> bool {
                self.reaction_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_reaction_type(&mut self, v: super::super::EChatRoomMessageReactionType) {
                self.reaction_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
            }

            // optional string reaction = 2;

            pub fn reaction(&self) -> &str {
                match self.reaction.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_reaction(&mut self) {
                self.reaction = ::std::option::Option::None;
            }

            pub fn has_reaction(&self) -> bool {
                self.reaction.is_some()
            }

            // Param is passed by value, moved
            pub fn set_reaction(&mut self, v: ::std::string::String) {
                self.reaction = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
                if self.reaction.is_none() {
                    self.reaction = ::std::option::Option::Some(::std::string::String::new());
                }
                self.reaction.as_mut().unwrap()
            }

            // Take field
            pub fn take_reaction(&mut self) -> ::std::string::String {
                self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 num_reactors = 3;

            pub fn num_reactors(&self) -> u32 {
                self.num_reactors.unwrap_or(0)
            }

            pub fn clear_num_reactors(&mut self) {
                self.num_reactors = ::std::option::Option::None;
            }

            pub fn has_num_reactors(&self) -> bool {
                self.num_reactors.is_some()
            }

            // Param is passed by value, moved
            pub fn set_num_reactors(&mut self, v: u32) {
                self.num_reactors = ::std::option::Option::Some(v);
            }

            // optional bool has_user_reacted = 4;

            pub fn has_user_reacted(&self) -> bool {
                self.has_user_reacted.unwrap_or(false)
            }

            pub fn clear_has_user_reacted(&mut self) {
                self.has_user_reacted = ::std::option::Option::None;
            }

            pub fn has_has_user_reacted(&self) -> bool {
                self.has_user_reacted.is_some()
            }

            // Param is passed by value, moved
            pub fn set_has_user_reacted(&mut self, v: bool) {
                self.has_user_reacted = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "reaction_type",
                    |m: &MessageReaction| { &m.reaction_type },
                    |m: &mut MessageReaction| { &mut m.reaction_type },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "reaction",
                    |m: &MessageReaction| { &m.reaction },
                    |m: &mut MessageReaction| { &mut m.reaction },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "num_reactors",
                    |m: &MessageReaction| { &m.num_reactors },
                    |m: &mut MessageReaction| { &mut m.num_reactors },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "has_user_reacted",
                    |m: &MessageReaction| { &m.has_user_reacted },
                    |m: &mut MessageReaction| { &mut m.has_user_reacted },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<MessageReaction>(
                    "CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for MessageReaction {
            const NAME: &'static str = "MessageReaction";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        18 => {
                            self.reaction = ::std::option::Option::Some(is.read_string()?);
                        },
                        24 => {
                            self.num_reactors = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        32 => {
                            self.has_user_reacted = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.reaction_type {
                    my_size += crate::rt::int32_size(1, v.value());
                }
                if let Some(v) = self.reaction.as_ref() {
                    my_size += crate::rt::string_size(2, &v);
                }
                if let Some(v) = self.num_reactors {
                    my_size += crate::rt::uint32_size(3, v);
                }
                if let Some(v) = self.has_user_reacted {
                    my_size += 1 + 1;
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.reaction_type {
                    os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.reaction.as_ref() {
                    os.write_string(2, v)?;
                }
                if let Some(v) = self.num_reactors {
                    os.write_uint32(3, v)?;
                }
                if let Some(v) = self.has_user_reacted {
                    os.write_bool(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> MessageReaction {
                MessageReaction::new()
            }

            fn clear(&mut self) {
                self.reaction_type = ::std::option::Option::None;
                self.reaction = ::std::option::Option::None;
                self.num_reactors = ::std::option::Option::None;
                self.has_user_reacted = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static MessageReaction {
                static instance: MessageReaction = MessageReaction {
                    reaction_type: ::std::option::Option::None,
                    reaction: ::std::option::Option::None,
                    num_reactors: ::std::option::Option::None,
                    has_user_reacted: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for MessageReaction {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageHistory_Response.ChatMessage.MessageReaction").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for MessageReaction {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for MessageReaction {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetMyChatRoomGroups_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMyChatRoomGroups_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMyChatRoomGroups_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Request {
        <CChatRoom_GetMyChatRoomGroups_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Request {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMyChatRoomGroups_Request>(
            "CChatRoom_GetMyChatRoomGroups_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetMyChatRoomGroups_Request {
    const NAME: &'static str = "CChatRoom_GetMyChatRoomGroups_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Request {
        CChatRoom_GetMyChatRoomGroups_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Request {
        static instance: CChatRoom_GetMyChatRoomGroups_Request = CChatRoom_GetMyChatRoomGroups_Request {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetMyChatRoomGroups_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMyChatRoomGroups_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMyChatRoomGroups_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetMyChatRoomGroups_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupSummary_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupSummary_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_name)
    pub chat_group_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.active_member_count)
    pub active_member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.active_voice_member_count)
    pub active_voice_member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.default_chat_id)
    pub default_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_rooms)
    pub chat_rooms: ::std::vec::Vec<CChatRoomState>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.clanid)
    pub clanid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_tagline)
    pub chat_group_tagline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.accountid_owner)
    pub accountid_owner: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.top_members)
    pub top_members: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.chat_group_avatar_sha)
    pub chat_group_avatar_sha: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.rank)
    pub rank: ::std::option::Option<crate::EnumOrUnknown<EChatRoomGroupRank>>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.default_role_id)
    pub default_role_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.role_ids)
    pub role_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.role_actions)
    pub role_actions: ::std::vec::Vec<CChatRoleActions>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.watching_broadcast_accountid)
    pub watching_broadcast_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.party_beacons)
    pub party_beacons: ::std::vec::Vec<CChatPartyBeacon>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.watching_broadcast_channel_id)
    pub watching_broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.active_minigame_id)
    pub active_minigame_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.avatar_ugc_url)
    pub avatar_ugc_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Response.disabled)
    pub disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupSummary_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Response {
        <CChatRoom_GetChatRoomGroupSummary_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string chat_group_name = 2;

    pub fn chat_group_name(&self) -> &str {
        match self.chat_group_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_group_name(&mut self) {
        self.chat_group_name = ::std::option::Option::None;
    }

    pub fn has_chat_group_name(&self) -> bool {
        self.chat_group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_name(&mut self, v: ::std::string::String) {
        self.chat_group_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_name(&mut self) -> &mut ::std::string::String {
        if self.chat_group_name.is_none() {
            self.chat_group_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_name(&mut self) -> ::std::string::String {
        self.chat_group_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_member_count = 3;

    pub fn active_member_count(&self) -> u32 {
        self.active_member_count.unwrap_or(0)
    }

    pub fn clear_active_member_count(&mut self) {
        self.active_member_count = ::std::option::Option::None;
    }

    pub fn has_active_member_count(&self) -> bool {
        self.active_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_member_count(&mut self, v: u32) {
        self.active_member_count = ::std::option::Option::Some(v);
    }

    // optional uint32 active_voice_member_count = 4;

    pub fn active_voice_member_count(&self) -> u32 {
        self.active_voice_member_count.unwrap_or(0)
    }

    pub fn clear_active_voice_member_count(&mut self) {
        self.active_voice_member_count = ::std::option::Option::None;
    }

    pub fn has_active_voice_member_count(&self) -> bool {
        self.active_voice_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_voice_member_count(&mut self, v: u32) {
        self.active_voice_member_count = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 5;

    pub fn default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }

    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoomState chat_rooms = 6;

    pub fn chat_rooms(&self) -> &[CChatRoomState] {
        &self.chat_rooms
    }

    pub fn clear_chat_rooms(&mut self) {
        self.chat_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_rooms(&mut self, v: ::std::vec::Vec<CChatRoomState>) {
        self.chat_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_rooms(&mut self) -> &mut ::std::vec::Vec<CChatRoomState> {
        &mut self.chat_rooms
    }

    // Take field
    pub fn take_chat_rooms(&mut self) -> ::std::vec::Vec<CChatRoomState> {
        ::std::mem::replace(&mut self.chat_rooms, ::std::vec::Vec::new())
    }

    // optional uint32 clanid = 7;

    pub fn clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }

    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional string chat_group_tagline = 8;

    pub fn chat_group_tagline(&self) -> &str {
        match self.chat_group_tagline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_group_tagline(&mut self) {
        self.chat_group_tagline = ::std::option::Option::None;
    }

    pub fn has_chat_group_tagline(&self) -> bool {
        self.chat_group_tagline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_tagline(&mut self, v: ::std::string::String) {
        self.chat_group_tagline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_tagline(&mut self) -> &mut ::std::string::String {
        if self.chat_group_tagline.is_none() {
            self.chat_group_tagline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_group_tagline.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_tagline(&mut self) -> ::std::string::String {
        self.chat_group_tagline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 accountid_owner = 9;

    pub fn accountid_owner(&self) -> u32 {
        self.accountid_owner.unwrap_or(0)
    }

    pub fn clear_accountid_owner(&mut self) {
        self.accountid_owner = ::std::option::Option::None;
    }

    pub fn has_accountid_owner(&self) -> bool {
        self.accountid_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_owner(&mut self, v: u32) {
        self.accountid_owner = ::std::option::Option::Some(v);
    }

    // repeated uint32 top_members = 10;

    pub fn top_members(&self) -> &[u32] {
        &self.top_members
    }

    pub fn clear_top_members(&mut self) {
        self.top_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_top_members(&mut self, v: ::std::vec::Vec<u32>) {
        self.top_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_top_members(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.top_members
    }

    // Take field
    pub fn take_top_members(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.top_members, ::std::vec::Vec::new())
    }

    // optional bytes chat_group_avatar_sha = 11;

    pub fn chat_group_avatar_sha(&self) -> &[u8] {
        match self.chat_group_avatar_sha.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_chat_group_avatar_sha(&mut self) {
        self.chat_group_avatar_sha = ::std::option::Option::None;
    }

    pub fn has_chat_group_avatar_sha(&self) -> bool {
        self.chat_group_avatar_sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_avatar_sha(&mut self, v: ::bytes::Bytes) {
        self.chat_group_avatar_sha = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_avatar_sha(&mut self) -> &mut ::bytes::Bytes {
        if self.chat_group_avatar_sha.is_none() {
            self.chat_group_avatar_sha = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.chat_group_avatar_sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_group_avatar_sha(&mut self) -> ::bytes::Bytes {
        self.chat_group_avatar_sha.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional .EChatRoomGroupRank rank = 12;

    pub fn rank(&self) -> EChatRoomGroupRank {
        match self.rank {
            Some(e) => e.enum_value_or(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            None => EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
        }
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: EChatRoomGroupRank) {
        self.rank = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint64 default_role_id = 13;

    pub fn default_role_id(&self) -> u64 {
        self.default_role_id.unwrap_or(0)
    }

    pub fn clear_default_role_id(&mut self) {
        self.default_role_id = ::std::option::Option::None;
    }

    pub fn has_default_role_id(&self) -> bool {
        self.default_role_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_role_id(&mut self, v: u64) {
        self.default_role_id = ::std::option::Option::Some(v);
    }

    // repeated uint64 role_ids = 14;

    pub fn role_ids(&self) -> &[u64] {
        &self.role_ids
    }

    pub fn clear_role_ids(&mut self) {
        self.role_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.role_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.role_ids
    }

    // Take field
    pub fn take_role_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.role_ids, ::std::vec::Vec::new())
    }

    // repeated .CChatRoleActions role_actions = 15;

    pub fn role_actions(&self) -> &[CChatRoleActions] {
        &self.role_actions
    }

    pub fn clear_role_actions(&mut self) {
        self.role_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_role_actions(&mut self, v: ::std::vec::Vec<CChatRoleActions>) {
        self.role_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_role_actions(&mut self) -> &mut ::std::vec::Vec<CChatRoleActions> {
        &mut self.role_actions
    }

    // Take field
    pub fn take_role_actions(&mut self) -> ::std::vec::Vec<CChatRoleActions> {
        ::std::mem::replace(&mut self.role_actions, ::std::vec::Vec::new())
    }

    // optional uint32 watching_broadcast_accountid = 16;

    pub fn watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 17;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // repeated .CChatPartyBeacon party_beacons = 18;

    pub fn party_beacons(&self) -> &[CChatPartyBeacon] {
        &self.party_beacons
    }

    pub fn clear_party_beacons(&mut self) {
        self.party_beacons.clear();
    }

    // Param is passed by value, moved
    pub fn set_party_beacons(&mut self, v: ::std::vec::Vec<CChatPartyBeacon>) {
        self.party_beacons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_party_beacons(&mut self) -> &mut ::std::vec::Vec<CChatPartyBeacon> {
        &mut self.party_beacons
    }

    // Take field
    pub fn take_party_beacons(&mut self) -> ::std::vec::Vec<CChatPartyBeacon> {
        ::std::mem::replace(&mut self.party_beacons, ::std::vec::Vec::new())
    }

    // optional uint64 watching_broadcast_channel_id = 19;

    pub fn watching_broadcast_channel_id(&self) -> u64 {
        self.watching_broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_watching_broadcast_channel_id(&mut self) {
        self.watching_broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_channel_id(&self) -> bool {
        self.watching_broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_channel_id(&mut self, v: u64) {
        self.watching_broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional uint64 active_minigame_id = 20;

    pub fn active_minigame_id(&self) -> u64 {
        self.active_minigame_id.unwrap_or(0)
    }

    pub fn clear_active_minigame_id(&mut self) {
        self.active_minigame_id = ::std::option::Option::None;
    }

    pub fn has_active_minigame_id(&self) -> bool {
        self.active_minigame_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_minigame_id(&mut self, v: u64) {
        self.active_minigame_id = ::std::option::Option::Some(v);
    }

    // optional string avatar_ugc_url = 21;

    pub fn avatar_ugc_url(&self) -> &str {
        match self.avatar_ugc_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_ugc_url(&mut self) {
        self.avatar_ugc_url = ::std::option::Option::None;
    }

    pub fn has_avatar_ugc_url(&self) -> bool {
        self.avatar_ugc_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_ugc_url(&mut self, v: ::std::string::String) {
        self.avatar_ugc_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_ugc_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_ugc_url.is_none() {
            self.avatar_ugc_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_ugc_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_ugc_url(&mut self) -> ::std::string::String {
        self.avatar_ugc_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool disabled = 22;

    pub fn disabled(&self) -> bool {
        self.disabled.unwrap_or(false)
    }

    pub fn clear_disabled(&mut self) {
        self.disabled = ::std::option::Option::None;
    }

    pub fn has_disabled(&self) -> bool {
        self.disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_name",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_name },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_member_count",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_member_count },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_member_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_voice_member_count",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_voice_member_count },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_voice_member_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_chat_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.default_chat_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.default_chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_rooms",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_rooms },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_rooms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "clanid",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.clanid },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.clanid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_tagline",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_tagline },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_tagline },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_owner",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.accountid_owner },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.accountid_owner },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "top_members",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.top_members },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.top_members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_avatar_sha",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.chat_group_avatar_sha },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.chat_group_avatar_sha },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.rank },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.rank },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_role_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.default_role_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.default_role_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_ids",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.role_ids },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.role_ids },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "role_actions",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.role_actions },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.role_actions },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_accountid",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.watching_broadcast_accountid },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.watching_broadcast_accountid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.appid },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "party_beacons",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.party_beacons },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.party_beacons },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "watching_broadcast_channel_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.watching_broadcast_channel_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.watching_broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_minigame_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.active_minigame_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.active_minigame_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_ugc_url",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.avatar_ugc_url },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.avatar_ugc_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "disabled",
            |m: &CChatRoom_GetChatRoomGroupSummary_Response| { &m.disabled },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Response| { &mut m.disabled },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetChatRoomGroupSummary_Response>(
            "CChatRoom_GetChatRoomGroupSummary_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetChatRoomGroupSummary_Response {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupSummary_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.chat_group_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.active_member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.active_voice_member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.default_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.chat_rooms.push(is.read_message()?);
                },
                56 => {
                    self.clanid = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.chat_group_tagline = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.accountid_owner = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.top_members)?;
                },
                80 => {
                    self.top_members.push(is.read_uint32()?);
                },
                90 => {
                    self.chat_group_avatar_sha = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                96 => {
                    self.rank = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.default_role_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                114 => {
                    is.read_repeated_packed_uint64_into(&mut self.role_ids)?;
                },
                112 => {
                    self.role_ids.push(is.read_uint64()?);
                },
                122 => {
                    self.role_actions.push(is.read_message()?);
                },
                128 => {
                    self.watching_broadcast_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                146 => {
                    self.party_beacons.push(is.read_message()?);
                },
                152 => {
                    self.watching_broadcast_channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.active_minigame_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                170 => {
                    self.avatar_ugc_url = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_group_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.active_member_count {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.active_voice_member_count {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.default_chat_id {
            my_size += crate::rt::uint64_size(5, v);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.clanid {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.chat_group_tagline.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.accountid_owner {
            my_size += crate::rt::uint32_size(9, v);
        }
        for value in &self.top_members {
            my_size += crate::rt::uint32_size(10, *value);
        };
        if let Some(v) = self.chat_group_avatar_sha.as_ref() {
            my_size += crate::rt::bytes_size(11, &v);
        }
        if let Some(v) = self.rank {
            my_size += crate::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.default_role_id {
            my_size += crate::rt::uint64_size(13, v);
        }
        for value in &self.role_ids {
            my_size += crate::rt::uint64_size(14, *value);
        };
        for value in &self.role_actions {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += crate::rt::uint32_size(16, v);
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(17, v);
        }
        for value in &self.party_beacons {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            my_size += crate::rt::uint64_size(19, v);
        }
        if let Some(v) = self.active_minigame_id {
            my_size += crate::rt::uint64_size(20, v);
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            my_size += crate::rt::string_size(21, &v);
        }
        if let Some(v) = self.disabled {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.active_member_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active_voice_member_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(5, v)?;
        }
        for v in &self.chat_rooms {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.clanid {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.chat_group_tagline.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.accountid_owner {
            os.write_uint32(9, v)?;
        }
        for v in &self.top_members {
            os.write_uint32(10, *v)?;
        };
        if let Some(v) = self.chat_group_avatar_sha.as_ref() {
            os.write_bytes(11, v)?;
        }
        if let Some(v) = self.rank {
            os.write_enum(12, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.default_role_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.role_ids {
            os.write_uint64(14, *v)?;
        };
        for v in &self.role_actions {
            crate::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(17, v)?;
        }
        for v in &self.party_beacons {
            crate::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.watching_broadcast_channel_id {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.active_minigame_id {
            os.write_uint64(20, v)?;
        }
        if let Some(v) = self.avatar_ugc_url.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.disabled {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Response {
        CChatRoom_GetChatRoomGroupSummary_Response::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_name = ::std::option::Option::None;
        self.active_member_count = ::std::option::Option::None;
        self.active_voice_member_count = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.clanid = ::std::option::Option::None;
        self.chat_group_tagline = ::std::option::Option::None;
        self.accountid_owner = ::std::option::Option::None;
        self.top_members.clear();
        self.chat_group_avatar_sha = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.default_role_id = ::std::option::Option::None;
        self.role_ids.clear();
        self.role_actions.clear();
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.party_beacons.clear();
        self.watching_broadcast_channel_id = ::std::option::Option::None;
        self.active_minigame_id = ::std::option::Option::None;
        self.avatar_ugc_url = ::std::option::Option::None;
        self.disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Response {
        static instance: CChatRoom_GetChatRoomGroupSummary_Response = CChatRoom_GetChatRoomGroupSummary_Response {
            chat_group_id: ::std::option::Option::None,
            chat_group_name: ::std::option::Option::None,
            active_member_count: ::std::option::Option::None,
            active_voice_member_count: ::std::option::Option::None,
            default_chat_id: ::std::option::Option::None,
            chat_rooms: ::std::vec::Vec::new(),
            clanid: ::std::option::Option::None,
            chat_group_tagline: ::std::option::Option::None,
            accountid_owner: ::std::option::Option::None,
            top_members: ::std::vec::Vec::new(),
            chat_group_avatar_sha: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            default_role_id: ::std::option::Option::None,
            role_ids: ::std::vec::Vec::new(),
            role_actions: ::std::vec::Vec::new(),
            watching_broadcast_accountid: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            party_beacons: ::std::vec::Vec::new(),
            watching_broadcast_channel_id: ::std::option::Option::None,
            active_minigame_id: ::std::option::Option::None,
            avatar_ugc_url: ::std::option::Option::None,
            disabled: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetChatRoomGroupSummary_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetChatRoomGroupSummary_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetChatRoomGroupSummary_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupSummary_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomSummaryPair)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomSummaryPair {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomSummaryPair.user_chat_group_state)
    pub user_chat_group_state: crate::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoomSummaryPair.group_summary)
    pub group_summary: crate::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomSummaryPair.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomSummaryPair {
    fn default() -> &'a CChatRoomSummaryPair {
        <CChatRoomSummaryPair as crate::Message>::default_instance()
    }
}

impl CChatRoomSummaryPair {
    pub fn new() -> CChatRoomSummaryPair {
        ::std::default::Default::default()
    }

    // optional .CUserChatRoomGroupState user_chat_group_state = 1;

    pub fn user_chat_group_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_group_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as crate::Message>::default_instance())
    }

    pub fn clear_user_chat_group_state(&mut self) {
        self.user_chat_group_state.clear();
    }

    pub fn has_user_chat_group_state(&self) -> bool {
        self.user_chat_group_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_group_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_group_state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_group_state(&mut self) -> &mut CUserChatRoomGroupState {
        self.user_chat_group_state.mut_or_insert_default()
    }

    // Take field
    pub fn take_user_chat_group_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_group_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 2;

    pub fn group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as crate::Message>::default_instance())
    }

    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.mut_or_insert_default()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_group_state",
            |m: &CChatRoomSummaryPair| { &m.user_chat_group_state },
            |m: &mut CChatRoomSummaryPair| { &mut m.user_chat_group_state },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "group_summary",
            |m: &CChatRoomSummaryPair| { &m.group_summary },
            |m: &mut CChatRoomSummaryPair| { &mut m.group_summary },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomSummaryPair>(
            "CChatRoomSummaryPair",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoomSummaryPair {
    const NAME: &'static str = "CChatRoomSummaryPair";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.user_chat_group_state)?;
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.user_chat_group_state.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.group_summary.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomSummaryPair {
        CChatRoomSummaryPair::new()
    }

    fn clear(&mut self) {
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomSummaryPair {
        static instance: CChatRoomSummaryPair = CChatRoomSummaryPair {
            user_chat_group_state: crate::MessageField::none(),
            group_summary: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoomSummaryPair {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomSummaryPair").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomSummaryPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoomSummaryPair {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMyChatRoomGroups_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMyChatRoomGroups_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMyChatRoomGroups_Response.chat_room_groups)
    pub chat_room_groups: ::std::vec::Vec<CChatRoomSummaryPair>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMyChatRoomGroups_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMyChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_GetMyChatRoomGroups_Response {
        <CChatRoom_GetMyChatRoomGroups_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetMyChatRoomGroups_Response {
    pub fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoomSummaryPair chat_room_groups = 1;

    pub fn chat_room_groups(&self) -> &[CChatRoomSummaryPair] {
        &self.chat_room_groups
    }

    pub fn clear_chat_room_groups(&mut self) {
        self.chat_room_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_room_groups(&mut self, v: ::std::vec::Vec<CChatRoomSummaryPair>) {
        self.chat_room_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_room_groups(&mut self) -> &mut ::std::vec::Vec<CChatRoomSummaryPair> {
        &mut self.chat_room_groups
    }

    // Take field
    pub fn take_chat_room_groups(&mut self) -> ::std::vec::Vec<CChatRoomSummaryPair> {
        ::std::mem::replace(&mut self.chat_room_groups, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_room_groups",
            |m: &CChatRoom_GetMyChatRoomGroups_Response| { &m.chat_room_groups },
            |m: &mut CChatRoom_GetMyChatRoomGroups_Response| { &mut m.chat_room_groups },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMyChatRoomGroups_Response>(
            "CChatRoom_GetMyChatRoomGroups_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetMyChatRoomGroups_Response {
    const NAME: &'static str = "CChatRoom_GetMyChatRoomGroups_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chat_room_groups.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_room_groups {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.chat_room_groups {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMyChatRoomGroups_Response {
        CChatRoom_GetMyChatRoomGroups_Response::new()
    }

    fn clear(&mut self) {
        self.chat_room_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMyChatRoomGroups_Response {
        static instance: CChatRoom_GetMyChatRoomGroups_Response = CChatRoom_GetMyChatRoomGroups_Response {
            chat_room_groups: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetMyChatRoomGroups_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMyChatRoomGroups_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMyChatRoomGroups_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetMyChatRoomGroups_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupState_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupState_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupState_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupState_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Request {
        <CChatRoom_GetChatRoomGroupState_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetChatRoomGroupState_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetChatRoomGroupState_Request| { &mut m.chat_group_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetChatRoomGroupState_Request>(
            "CChatRoom_GetChatRoomGroupState_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetChatRoomGroupState_Request {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupState_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Request {
        CChatRoom_GetChatRoomGroupState_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Request {
        static instance: CChatRoom_GetChatRoomGroupState_Request = CChatRoom_GetChatRoomGroupState_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetChatRoomGroupState_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetChatRoomGroupState_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetChatRoomGroupState_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupState_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupState_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupState_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupState_Response.state)
    pub state: crate::MessageField<CChatRoomGroupState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupState_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupState_Response {
    fn default() -> &'a CChatRoom_GetChatRoomGroupState_Response {
        <CChatRoom_GetChatRoomGroupState_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupState_Response {
    pub fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupState state = 1;

    pub fn state(&self) -> &CChatRoomGroupState {
        self.state.as_ref().unwrap_or_else(|| <CChatRoomGroupState as crate::Message>::default_instance())
    }

    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: CChatRoomGroupState) {
        self.state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut CChatRoomGroupState {
        self.state.mut_or_insert_default()
    }

    // Take field
    pub fn take_state(&mut self) -> CChatRoomGroupState {
        self.state.take().unwrap_or_else(|| CChatRoomGroupState::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupState>(
            "state",
            |m: &CChatRoom_GetChatRoomGroupState_Response| { &m.state },
            |m: &mut CChatRoom_GetChatRoomGroupState_Response| { &mut m.state },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetChatRoomGroupState_Response>(
            "CChatRoom_GetChatRoomGroupState_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetChatRoomGroupState_Response {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupState_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.state)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.state.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupState_Response {
        CChatRoom_GetChatRoomGroupState_Response::new()
    }

    fn clear(&mut self) {
        self.state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupState_Response {
        static instance: CChatRoom_GetChatRoomGroupState_Response = CChatRoom_GetChatRoomGroupState_Response {
            state: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetChatRoomGroupState_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetChatRoomGroupState_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetChatRoomGroupState_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupState_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetChatRoomGroupSummary_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetChatRoomGroupSummary_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetChatRoomGroupSummary_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetChatRoomGroupSummary_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetChatRoomGroupSummary_Request {
    fn default() -> &'a CChatRoom_GetChatRoomGroupSummary_Request {
        <CChatRoom_GetChatRoomGroupSummary_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetChatRoomGroupSummary_Request {
    pub fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetChatRoomGroupSummary_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetChatRoomGroupSummary_Request| { &mut m.chat_group_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetChatRoomGroupSummary_Request>(
            "CChatRoom_GetChatRoomGroupSummary_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetChatRoomGroupSummary_Request {
    const NAME: &'static str = "CChatRoom_GetChatRoomGroupSummary_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetChatRoomGroupSummary_Request {
        CChatRoom_GetChatRoomGroupSummary_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetChatRoomGroupSummary_Request {
        static instance: CChatRoom_GetChatRoomGroupSummary_Request = CChatRoom_GetChatRoomGroupSummary_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetChatRoomGroupSummary_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetChatRoomGroupSummary_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetChatRoomGroupSummary_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetChatRoomGroupSummary_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetAppChatRoomGroupForceActive_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetAppChatRoomGroupForceActive_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Request.requesting_app_id)
    pub requesting_app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetAppChatRoomGroupForceActive_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupForceActive_Request {
        <CChatRoom_SetAppChatRoomGroupForceActive_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupForceActive_Request {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requesting_app_id = 2;

    pub fn requesting_app_id(&self) -> u32 {
        self.requesting_app_id.unwrap_or(0)
    }

    pub fn clear_requesting_app_id(&mut self) {
        self.requesting_app_id = ::std::option::Option::None;
    }

    pub fn has_requesting_app_id(&self) -> bool {
        self.requesting_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_app_id(&mut self, v: u32) {
        self.requesting_app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetAppChatRoomGroupForceActive_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "requesting_app_id",
            |m: &CChatRoom_SetAppChatRoomGroupForceActive_Request| { &m.requesting_app_id },
            |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Request| { &mut m.requesting_app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetAppChatRoomGroupForceActive_Request>(
            "CChatRoom_SetAppChatRoomGroupForceActive_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    const NAME: &'static str = "CChatRoom_SetAppChatRoomGroupForceActive_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.requesting_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.requesting_app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.requesting_app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Request {
        CChatRoom_SetAppChatRoomGroupForceActive_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.requesting_app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupForceActive_Request {
        static instance: CChatRoom_SetAppChatRoomGroupForceActive_Request = CChatRoom_SetAppChatRoomGroupForceActive_Request {
            chat_group_id: ::std::option::Option::None,
            requesting_app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetAppChatRoomGroupForceActive_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetAppChatRoomGroupForceActive_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetAppChatRoomGroupForceActive_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetAppChatRoomGroupForceActive_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Response.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupForceActive_Response.accounts_in_channel)
    pub accounts_in_channel: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetAppChatRoomGroupForceActive_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupForceActive_Response {
        <CChatRoom_SetAppChatRoomGroupForceActive_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupForceActive_Response {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Response {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // repeated uint32 accounts_in_channel = 2;

    pub fn accounts_in_channel(&self) -> &[u32] {
        &self.accounts_in_channel
    }

    pub fn clear_accounts_in_channel(&mut self) {
        self.accounts_in_channel.clear();
    }

    // Param is passed by value, moved
    pub fn set_accounts_in_channel(&mut self, v: ::std::vec::Vec<u32>) {
        self.accounts_in_channel = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accounts_in_channel(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.accounts_in_channel
    }

    // Take field
    pub fn take_accounts_in_channel(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.accounts_in_channel, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CChatRoom_SetAppChatRoomGroupForceActive_Response| { &m.result },
            |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Response| { &mut m.result },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accounts_in_channel",
            |m: &CChatRoom_SetAppChatRoomGroupForceActive_Response| { &m.accounts_in_channel },
            |m: &mut CChatRoom_SetAppChatRoomGroupForceActive_Response| { &mut m.accounts_in_channel },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetAppChatRoomGroupForceActive_Response>(
            "CChatRoom_SetAppChatRoomGroupForceActive_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    const NAME: &'static str = "CChatRoom_SetAppChatRoomGroupForceActive_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.accounts_in_channel)?;
                },
                16 => {
                    self.accounts_in_channel.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.accounts_in_channel {
            my_size += crate::rt::uint32_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.accounts_in_channel {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupForceActive_Response {
        CChatRoom_SetAppChatRoomGroupForceActive_Response::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.accounts_in_channel.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupForceActive_Response {
        static instance: CChatRoom_SetAppChatRoomGroupForceActive_Response = CChatRoom_SetAppChatRoomGroupForceActive_Response {
            result: ::std::option::Option::None,
            accounts_in_channel: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetAppChatRoomGroupForceActive_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetAppChatRoomGroupForceActive_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification.requesting_app_id)
    pub requesting_app_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetAppChatRoomGroupStopForceActive_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn default() -> &'a CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        <CChatRoom_SetAppChatRoomGroupStopForceActive_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    pub fn new() -> CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 requesting_app_id = 2;

    pub fn requesting_app_id(&self) -> u32 {
        self.requesting_app_id.unwrap_or(0)
    }

    pub fn clear_requesting_app_id(&mut self) {
        self.requesting_app_id = ::std::option::Option::None;
    }

    pub fn has_requesting_app_id(&self) -> bool {
        self.requesting_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requesting_app_id(&mut self, v: u32) {
        self.requesting_app_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "requesting_app_id",
            |m: &CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &m.requesting_app_id },
            |m: &mut CChatRoom_SetAppChatRoomGroupStopForceActive_Notification| { &mut m.requesting_app_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetAppChatRoomGroupStopForceActive_Notification>(
            "CChatRoom_SetAppChatRoomGroupStopForceActive_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    const NAME: &'static str = "CChatRoom_SetAppChatRoomGroupStopForceActive_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.requesting_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.requesting_app_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.requesting_app_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        CChatRoom_SetAppChatRoomGroupStopForceActive_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.requesting_app_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
        static instance: CChatRoom_SetAppChatRoomGroupStopForceActive_Notification = CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
            chat_group_id: ::std::option::Option::None,
            requesting_app_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetAppChatRoomGroupStopForceActive_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetAppChatRoomGroupStopForceActive_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_AckChatMessage_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_AckChatMessage_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_AckChatMessage_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AckChatMessage_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_AckChatMessage_Notification.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_AckChatMessage_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_AckChatMessage_Notification {
    fn default() -> &'a CChatRoom_AckChatMessage_Notification {
        <CChatRoom_AckChatMessage_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_AckChatMessage_Notification {
    pub fn new() -> CChatRoom_AckChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_AckChatMessage_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_AckChatMessage_Notification| { &m.chat_id },
            |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CChatRoom_AckChatMessage_Notification| { &m.timestamp },
            |m: &mut CChatRoom_AckChatMessage_Notification| { &mut m.timestamp },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_AckChatMessage_Notification>(
            "CChatRoom_AckChatMessage_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_AckChatMessage_Notification {
    const NAME: &'static str = "CChatRoom_AckChatMessage_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.timestamp {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_AckChatMessage_Notification {
        CChatRoom_AckChatMessage_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_AckChatMessage_Notification {
        static instance: CChatRoom_AckChatMessage_Notification = CChatRoom_AckChatMessage_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_AckChatMessage_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_AckChatMessage_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_AckChatMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_AckChatMessage_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateInviteLink_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateInviteLink_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Request.seconds_valid)
    pub seconds_valid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateInviteLink_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Request {
    fn default() -> &'a CChatRoom_CreateInviteLink_Request {
        <CChatRoom_CreateInviteLink_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Request {
    pub fn new() -> CChatRoom_CreateInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_valid = 2;

    pub fn seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }

    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_CreateInviteLink_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_valid",
            |m: &CChatRoom_CreateInviteLink_Request| { &m.seconds_valid },
            |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.seconds_valid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_CreateInviteLink_Request| { &m.chat_id },
            |m: &mut CChatRoom_CreateInviteLink_Request| { &mut m.chat_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateInviteLink_Request>(
            "CChatRoom_CreateInviteLink_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_CreateInviteLink_Request {
    const NAME: &'static str = "CChatRoom_CreateInviteLink_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.seconds_valid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.seconds_valid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateInviteLink_Request {
        CChatRoom_CreateInviteLink_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.seconds_valid = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Request {
        static instance: CChatRoom_CreateInviteLink_Request = CChatRoom_CreateInviteLink_Request {
            chat_group_id: ::std::option::Option::None,
            seconds_valid: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_CreateInviteLink_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateInviteLink_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateInviteLink_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_CreateInviteLink_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_CreateInviteLink_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_CreateInviteLink_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Response.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_CreateInviteLink_Response.seconds_valid)
    pub seconds_valid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_CreateInviteLink_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_CreateInviteLink_Response {
    fn default() -> &'a CChatRoom_CreateInviteLink_Response {
        <CChatRoom_CreateInviteLink_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_CreateInviteLink_Response {
    pub fn new() -> CChatRoom_CreateInviteLink_Response {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 seconds_valid = 2;

    pub fn seconds_valid(&self) -> u32 {
        self.seconds_valid.unwrap_or(0)
    }

    pub fn clear_seconds_valid(&mut self) {
        self.seconds_valid = ::std::option::Option::None;
    }

    pub fn has_seconds_valid(&self) -> bool {
        self.seconds_valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_valid(&mut self, v: u32) {
        self.seconds_valid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_CreateInviteLink_Response| { &m.invite_code },
            |m: &mut CChatRoom_CreateInviteLink_Response| { &mut m.invite_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_valid",
            |m: &CChatRoom_CreateInviteLink_Response| { &m.seconds_valid },
            |m: &mut CChatRoom_CreateInviteLink_Response| { &mut m.seconds_valid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_CreateInviteLink_Response>(
            "CChatRoom_CreateInviteLink_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_CreateInviteLink_Response {
    const NAME: &'static str = "CChatRoom_CreateInviteLink_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.seconds_valid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invite_code.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.seconds_valid {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.seconds_valid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_CreateInviteLink_Response {
        CChatRoom_CreateInviteLink_Response::new()
    }

    fn clear(&mut self) {
        self.invite_code = ::std::option::Option::None;
        self.seconds_valid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_CreateInviteLink_Response {
        static instance: CChatRoom_CreateInviteLink_Response = CChatRoom_CreateInviteLink_Response {
            invite_code: ::std::option::Option::None,
            seconds_valid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_CreateInviteLink_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_CreateInviteLink_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_CreateInviteLink_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_CreateInviteLink_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinkInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinkInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinkInfo_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Request {
        <CChatRoom_GetInviteLinkInfo_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Request {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        ::std::default::Default::default()
    }

    // optional string invite_code = 1;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_GetInviteLinkInfo_Request| { &m.invite_code },
            |m: &mut CChatRoom_GetInviteLinkInfo_Request| { &mut m.invite_code },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteLinkInfo_Request>(
            "CChatRoom_GetInviteLinkInfo_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetInviteLinkInfo_Request {
    const NAME: &'static str = "CChatRoom_GetInviteLinkInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invite_code.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Request {
        CChatRoom_GetInviteLinkInfo_Request::new()
    }

    fn clear(&mut self) {
        self.invite_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Request {
        static instance: CChatRoom_GetInviteLinkInfo_Request = CChatRoom_GetInviteLinkInfo_Request {
            invite_code: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetInviteLinkInfo_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinkInfo_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteLinkInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetInviteLinkInfo_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinkInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinkInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.steamid_sender)
    pub steamid_sender: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.time_expires)
    pub time_expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.group_summary)
    pub group_summary: crate::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.user_chat_group_state)
    pub user_chat_group_state: crate::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.time_kick_expire)
    pub time_kick_expire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinkInfo_Response.banned)
    pub banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinkInfo_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinkInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteLinkInfo_Response {
        <CChatRoom_GetInviteLinkInfo_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinkInfo_Response {
    pub fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_sender = 3;

    pub fn steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }

    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 4;

    pub fn time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }

    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 6;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 8;

    pub fn group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as crate::Message>::default_instance())
    }

    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.mut_or_insert_default()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    // optional .CUserChatRoomGroupState user_chat_group_state = 9;

    pub fn user_chat_group_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_group_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as crate::Message>::default_instance())
    }

    pub fn clear_user_chat_group_state(&mut self) {
        self.user_chat_group_state.clear();
    }

    pub fn has_user_chat_group_state(&self) -> bool {
        self.user_chat_group_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_group_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_group_state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_group_state(&mut self) -> &mut CUserChatRoomGroupState {
        self.user_chat_group_state.mut_or_insert_default()
    }

    // Take field
    pub fn take_user_chat_group_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_group_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional uint32 time_kick_expire = 10;

    pub fn time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }

    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 11;

    pub fn banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_sender",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.steamid_sender },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.steamid_sender },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_expires",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.time_expires },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.time_expires },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.chat_id },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "group_summary",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.group_summary },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.group_summary },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_group_state",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.user_chat_group_state },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.user_chat_group_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_kick_expire",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.time_kick_expire },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.time_kick_expire },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "banned",
            |m: &CChatRoom_GetInviteLinkInfo_Response| { &m.banned },
            |m: &mut CChatRoom_GetInviteLinkInfo_Response| { &mut m.banned },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteLinkInfo_Response>(
            "CChatRoom_GetInviteLinkInfo_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetInviteLinkInfo_Response {
    const NAME: &'static str = "CChatRoom_GetInviteLinkInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                25 => {
                    self.steamid_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                74 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.user_chat_group_state)?;
                },
                80 => {
                    self.time_kick_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_sender {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_expires {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(6, v);
        }
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.banned {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.group_summary.as_ref() {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinkInfo_Response {
        CChatRoom_GetInviteLinkInfo_Response::new()
    }

    fn clear(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.group_summary.clear();
        self.user_chat_group_state.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinkInfo_Response {
        static instance: CChatRoom_GetInviteLinkInfo_Response = CChatRoom_GetInviteLinkInfo_Response {
            steamid_sender: ::std::option::Option::None,
            time_expires: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            group_summary: crate::MessageField::none(),
            user_chat_group_state: crate::MessageField::none(),
            time_kick_expire: ::std::option::Option::None,
            banned: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetInviteLinkInfo_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinkInfo_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteLinkInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetInviteLinkInfo_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.steamid_invitee)
    pub steamid_invitee: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteInfo_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Request {
    fn default() -> &'a CChatRoom_GetInviteInfo_Request {
        <CChatRoom_GetInviteInfo_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Request {
    pub fn new() -> CChatRoom_GetInviteInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_invitee = 1;

    pub fn steamid_invitee(&self) -> u64 {
        self.steamid_invitee.unwrap_or(0)
    }

    pub fn clear_steamid_invitee(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
    }

    pub fn has_steamid_invitee(&self) -> bool {
        self.steamid_invitee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_invitee(&mut self, v: u64) {
        self.steamid_invitee = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 3;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 4;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_invitee",
            |m: &CChatRoom_GetInviteInfo_Request| { &m.steamid_invitee },
            |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.steamid_invitee },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetInviteInfo_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_GetInviteInfo_Request| { &m.chat_id },
            |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_GetInviteInfo_Request| { &m.invite_code },
            |m: &mut CChatRoom_GetInviteInfo_Request| { &mut m.invite_code },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteInfo_Request>(
            "CChatRoom_GetInviteInfo_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetInviteInfo_Request {
    const NAME: &'static str = "CChatRoom_GetInviteInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid_invitee = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_invitee {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.invite_code.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid_invitee {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteInfo_Request {
        CChatRoom_GetInviteInfo_Request::new()
    }

    fn clear(&mut self) {
        self.steamid_invitee = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.invite_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Request {
        static instance: CChatRoom_GetInviteInfo_Request = CChatRoom_GetInviteInfo_Request {
            steamid_invitee: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            invite_code: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetInviteInfo_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteInfo_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetInviteInfo_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Response.group_summary)
    pub group_summary: crate::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Response.time_kick_expire)
    pub time_kick_expire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetInviteInfo_Response.banned)
    pub banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteInfo_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteInfo_Response {
    fn default() -> &'a CChatRoom_GetInviteInfo_Response {
        <CChatRoom_GetInviteInfo_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteInfo_Response {
    pub fn new() -> CChatRoom_GetInviteInfo_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 1;

    pub fn group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as crate::Message>::default_instance())
    }

    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.mut_or_insert_default()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    // optional uint32 time_kick_expire = 2;

    pub fn time_kick_expire(&self) -> u32 {
        self.time_kick_expire.unwrap_or(0)
    }

    pub fn clear_time_kick_expire(&mut self) {
        self.time_kick_expire = ::std::option::Option::None;
    }

    pub fn has_time_kick_expire(&self) -> bool {
        self.time_kick_expire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_kick_expire(&mut self, v: u32) {
        self.time_kick_expire = ::std::option::Option::Some(v);
    }

    // optional bool banned = 3;

    pub fn banned(&self) -> bool {
        self.banned.unwrap_or(false)
    }

    pub fn clear_banned(&mut self) {
        self.banned = ::std::option::Option::None;
    }

    pub fn has_banned(&self) -> bool {
        self.banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned(&mut self, v: bool) {
        self.banned = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "group_summary",
            |m: &CChatRoom_GetInviteInfo_Response| { &m.group_summary },
            |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.group_summary },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_kick_expire",
            |m: &CChatRoom_GetInviteInfo_Response| { &m.time_kick_expire },
            |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.time_kick_expire },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "banned",
            |m: &CChatRoom_GetInviteInfo_Response| { &m.banned },
            |m: &mut CChatRoom_GetInviteInfo_Response| { &mut m.banned },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteInfo_Response>(
            "CChatRoom_GetInviteInfo_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetInviteInfo_Response {
    const NAME: &'static str = "CChatRoom_GetInviteInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                16 => {
                    self.time_kick_expire = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.time_kick_expire {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.banned {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.group_summary.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.time_kick_expire {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.banned {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteInfo_Response {
        CChatRoom_GetInviteInfo_Response::new()
    }

    fn clear(&mut self) {
        self.group_summary.clear();
        self.time_kick_expire = ::std::option::Option::None;
        self.banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteInfo_Response {
        static instance: CChatRoom_GetInviteInfo_Response = CChatRoom_GetInviteInfo_Response {
            group_summary: crate::MessageField::none(),
            time_kick_expire: ::std::option::Option::None,
            banned: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetInviteInfo_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteInfo_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetInviteInfo_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinksForGroup_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinksForGroup_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinksForGroup_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Request {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Request {
        <CChatRoom_GetInviteLinksForGroup_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Request {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetInviteLinksForGroup_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetInviteLinksForGroup_Request| { &mut m.chat_group_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteLinksForGroup_Request>(
            "CChatRoom_GetInviteLinksForGroup_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetInviteLinksForGroup_Request {
    const NAME: &'static str = "CChatRoom_GetInviteLinksForGroup_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Request {
        CChatRoom_GetInviteLinksForGroup_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Request {
        static instance: CChatRoom_GetInviteLinksForGroup_Request = CChatRoom_GetInviteLinksForGroup_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetInviteLinksForGroup_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinksForGroup_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteLinksForGroup_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteLinksForGroup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteLinksForGroup_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.invite_links)
    pub invite_links: ::std::vec::Vec<cchat_room_get_invite_links_for_group_response::LinkInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinksForGroup_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteLinksForGroup_Response {
    fn default() -> &'a CChatRoom_GetInviteLinksForGroup_Response {
        <CChatRoom_GetInviteLinksForGroup_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteLinksForGroup_Response {
    pub fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_GetInviteLinksForGroup_Response.LinkInfo invite_links = 1;

    pub fn invite_links(&self) -> &[cchat_room_get_invite_links_for_group_response::LinkInfo] {
        &self.invite_links
    }

    pub fn clear_invite_links(&mut self) {
        self.invite_links.clear();
    }

    // Param is passed by value, moved
    pub fn set_invite_links(&mut self, v: ::std::vec::Vec<cchat_room_get_invite_links_for_group_response::LinkInfo>) {
        self.invite_links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invite_links(&mut self) -> &mut ::std::vec::Vec<cchat_room_get_invite_links_for_group_response::LinkInfo> {
        &mut self.invite_links
    }

    // Take field
    pub fn take_invite_links(&mut self) -> ::std::vec::Vec<cchat_room_get_invite_links_for_group_response::LinkInfo> {
        ::std::mem::replace(&mut self.invite_links, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "invite_links",
            |m: &CChatRoom_GetInviteLinksForGroup_Response| { &m.invite_links },
            |m: &mut CChatRoom_GetInviteLinksForGroup_Response| { &mut m.invite_links },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteLinksForGroup_Response>(
            "CChatRoom_GetInviteLinksForGroup_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetInviteLinksForGroup_Response {
    const NAME: &'static str = "CChatRoom_GetInviteLinksForGroup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invite_links.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.invite_links {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.invite_links {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteLinksForGroup_Response {
        CChatRoom_GetInviteLinksForGroup_Response::new()
    }

    fn clear(&mut self) {
        self.invite_links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteLinksForGroup_Response {
        static instance: CChatRoom_GetInviteLinksForGroup_Response = CChatRoom_GetInviteLinksForGroup_Response {
            invite_links: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetInviteLinksForGroup_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinksForGroup_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteLinksForGroup_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetInviteLinksForGroup_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_GetInviteLinksForGroup_Response`
pub mod cchat_room_get_invite_links_for_group_response {
    // @@protoc_insertion_point(message:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LinkInfo {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.invite_code)
        pub invite_code: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.steamid_creator)
        pub steamid_creator: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.time_expires)
        pub time_expires: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.chat_id)
        pub chat_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_GetInviteLinksForGroup_Response.LinkInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LinkInfo {
        fn default() -> &'a LinkInfo {
            <LinkInfo as crate::Message>::default_instance()
        }
    }

    impl LinkInfo {
        pub fn new() -> LinkInfo {
            ::std::default::Default::default()
        }

        // optional string invite_code = 1;

        pub fn invite_code(&self) -> &str {
            match self.invite_code.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_invite_code(&mut self) {
            self.invite_code = ::std::option::Option::None;
        }

        pub fn has_invite_code(&self) -> bool {
            self.invite_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_invite_code(&mut self, v: ::std::string::String) {
            self.invite_code = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
            if self.invite_code.is_none() {
                self.invite_code = ::std::option::Option::Some(::std::string::String::new());
            }
            self.invite_code.as_mut().unwrap()
        }

        // Take field
        pub fn take_invite_code(&mut self) -> ::std::string::String {
            self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 steamid_creator = 2;

        pub fn steamid_creator(&self) -> u64 {
            self.steamid_creator.unwrap_or(0)
        }

        pub fn clear_steamid_creator(&mut self) {
            self.steamid_creator = ::std::option::Option::None;
        }

        pub fn has_steamid_creator(&self) -> bool {
            self.steamid_creator.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid_creator(&mut self, v: u64) {
            self.steamid_creator = ::std::option::Option::Some(v);
        }

        // optional uint32 time_expires = 3;

        pub fn time_expires(&self) -> u32 {
            self.time_expires.unwrap_or(0)
        }

        pub fn clear_time_expires(&mut self) {
            self.time_expires = ::std::option::Option::None;
        }

        pub fn has_time_expires(&self) -> bool {
            self.time_expires.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_expires(&mut self, v: u32) {
            self.time_expires = ::std::option::Option::Some(v);
        }

        // optional uint64 chat_id = 4;

        pub fn chat_id(&self) -> u64 {
            self.chat_id.unwrap_or(0)
        }

        pub fn clear_chat_id(&mut self) {
            self.chat_id = ::std::option::Option::None;
        }

        pub fn has_chat_id(&self) -> bool {
            self.chat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_id(&mut self, v: u64) {
            self.chat_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "invite_code",
                |m: &LinkInfo| { &m.invite_code },
                |m: &mut LinkInfo| { &mut m.invite_code },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid_creator",
                |m: &LinkInfo| { &m.steamid_creator },
                |m: &mut LinkInfo| { &mut m.steamid_creator },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_expires",
                |m: &LinkInfo| { &m.time_expires },
                |m: &mut LinkInfo| { &mut m.time_expires },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_id",
                |m: &LinkInfo| { &m.chat_id },
                |m: &mut LinkInfo| { &mut m.chat_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<LinkInfo>(
                "CChatRoom_GetInviteLinksForGroup_Response.LinkInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for LinkInfo {
        const NAME: &'static str = "LinkInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.invite_code = ::std::option::Option::Some(is.read_string()?);
                    },
                    17 => {
                        self.steamid_creator = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.invite_code.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.steamid_creator {
                my_size += 1 + 8;
            }
            if let Some(v) = self.time_expires {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.chat_id {
                my_size += crate::rt::uint64_size(4, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.invite_code.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.steamid_creator {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.time_expires {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.chat_id {
                os.write_uint64(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LinkInfo {
            LinkInfo::new()
        }

        fn clear(&mut self) {
            self.invite_code = ::std::option::Option::None;
            self.steamid_creator = ::std::option::Option::None;
            self.time_expires = ::std::option::Option::None;
            self.chat_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LinkInfo {
            static instance: LinkInfo = LinkInfo {
                invite_code: ::std::option::Option::None,
                steamid_creator: ::std::option::Option::None,
                time_expires: ::std::option::Option::None,
                chat_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for LinkInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteLinksForGroup_Response.LinkInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for LinkInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for LinkInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetBanList_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetBanList_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetBanList_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetBanList_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Request {
    fn default() -> &'a CChatRoom_GetBanList_Request {
        <CChatRoom_GetBanList_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Request {
    pub fn new() -> CChatRoom_GetBanList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetBanList_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetBanList_Request| { &mut m.chat_group_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetBanList_Request>(
            "CChatRoom_GetBanList_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetBanList_Request {
    const NAME: &'static str = "CChatRoom_GetBanList_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetBanList_Request {
        CChatRoom_GetBanList_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Request {
        static instance: CChatRoom_GetBanList_Request = CChatRoom_GetBanList_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetBanList_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetBanList_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetBanList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetBanList_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetBanList_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetBanList_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.bans)
    pub bans: ::std::vec::Vec<cchat_room_get_ban_list_response::BanInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetBanList_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetBanList_Response {
    fn default() -> &'a CChatRoom_GetBanList_Response {
        <CChatRoom_GetBanList_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetBanList_Response {
    pub fn new() -> CChatRoom_GetBanList_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_GetBanList_Response.BanInfo bans = 1;

    pub fn bans(&self) -> &[cchat_room_get_ban_list_response::BanInfo] {
        &self.bans
    }

    pub fn clear_bans(&mut self) {
        self.bans.clear();
    }

    // Param is passed by value, moved
    pub fn set_bans(&mut self, v: ::std::vec::Vec<cchat_room_get_ban_list_response::BanInfo>) {
        self.bans = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bans(&mut self) -> &mut ::std::vec::Vec<cchat_room_get_ban_list_response::BanInfo> {
        &mut self.bans
    }

    // Take field
    pub fn take_bans(&mut self) -> ::std::vec::Vec<cchat_room_get_ban_list_response::BanInfo> {
        ::std::mem::replace(&mut self.bans, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bans",
            |m: &CChatRoom_GetBanList_Response| { &m.bans },
            |m: &mut CChatRoom_GetBanList_Response| { &mut m.bans },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetBanList_Response>(
            "CChatRoom_GetBanList_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetBanList_Response {
    const NAME: &'static str = "CChatRoom_GetBanList_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bans.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bans {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.bans {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetBanList_Response {
        CChatRoom_GetBanList_Response::new()
    }

    fn clear(&mut self) {
        self.bans.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetBanList_Response {
        static instance: CChatRoom_GetBanList_Response = CChatRoom_GetBanList_Response {
            bans: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetBanList_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetBanList_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetBanList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetBanList_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_GetBanList_Response`
pub mod cchat_room_get_ban_list_response {
    // @@protoc_insertion_point(message:CChatRoom_GetBanList_Response.BanInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BanInfo {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.accountid_actor)
        pub accountid_actor: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.time_banned)
        pub time_banned: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_GetBanList_Response.BanInfo.ban_reason)
        pub ban_reason: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_GetBanList_Response.BanInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BanInfo {
        fn default() -> &'a BanInfo {
            <BanInfo as crate::Message>::default_instance()
        }
    }

    impl BanInfo {
        pub fn new() -> BanInfo {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 accountid_actor = 2;

        pub fn accountid_actor(&self) -> u32 {
            self.accountid_actor.unwrap_or(0)
        }

        pub fn clear_accountid_actor(&mut self) {
            self.accountid_actor = ::std::option::Option::None;
        }

        pub fn has_accountid_actor(&self) -> bool {
            self.accountid_actor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid_actor(&mut self, v: u32) {
            self.accountid_actor = ::std::option::Option::Some(v);
        }

        // optional uint32 time_banned = 3;

        pub fn time_banned(&self) -> u32 {
            self.time_banned.unwrap_or(0)
        }

        pub fn clear_time_banned(&mut self) {
            self.time_banned = ::std::option::Option::None;
        }

        pub fn has_time_banned(&self) -> bool {
            self.time_banned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_banned(&mut self, v: u32) {
            self.time_banned = ::std::option::Option::Some(v);
        }

        // optional string ban_reason = 4;

        pub fn ban_reason(&self) -> &str {
            match self.ban_reason.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_ban_reason(&mut self) {
            self.ban_reason = ::std::option::Option::None;
        }

        pub fn has_ban_reason(&self) -> bool {
            self.ban_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_reason(&mut self, v: ::std::string::String) {
            self.ban_reason = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_ban_reason(&mut self) -> &mut ::std::string::String {
            if self.ban_reason.is_none() {
                self.ban_reason = ::std::option::Option::Some(::std::string::String::new());
            }
            self.ban_reason.as_mut().unwrap()
        }

        // Take field
        pub fn take_ban_reason(&mut self) -> ::std::string::String {
            self.ban_reason.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &BanInfo| { &m.accountid },
                |m: &mut BanInfo| { &mut m.accountid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid_actor",
                |m: &BanInfo| { &m.accountid_actor },
                |m: &mut BanInfo| { &mut m.accountid_actor },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "time_banned",
                |m: &BanInfo| { &m.time_banned },
                |m: &mut BanInfo| { &mut m.time_banned },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "ban_reason",
                |m: &BanInfo| { &m.ban_reason },
                |m: &mut BanInfo| { &mut m.ban_reason },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<BanInfo>(
                "CChatRoom_GetBanList_Response.BanInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for BanInfo {
        const NAME: &'static str = "BanInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.accountid_actor = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.time_banned = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    34 => {
                        self.ban_reason = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.accountid_actor {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.time_banned {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.ban_reason.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.accountid_actor {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.time_banned {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.ban_reason.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BanInfo {
            BanInfo::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.accountid_actor = ::std::option::Option::None;
            self.time_banned = ::std::option::Option::None;
            self.ban_reason = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BanInfo {
            static instance: BanInfo = BanInfo {
                accountid: ::std::option::Option::None,
                accountid_actor: ::std::option::Option::None,
                time_banned: ::std::option::Option::None,
                ban_reason: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for BanInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_GetBanList_Response.BanInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BanInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for BanInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteList_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteList_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteList_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteList_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Request {
    fn default() -> &'a CChatRoom_GetInviteList_Request {
        <CChatRoom_GetInviteList_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Request {
    pub fn new() -> CChatRoom_GetInviteList_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetInviteList_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetInviteList_Request| { &mut m.chat_group_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteList_Request>(
            "CChatRoom_GetInviteList_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetInviteList_Request {
    const NAME: &'static str = "CChatRoom_GetInviteList_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteList_Request {
        CChatRoom_GetInviteList_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Request {
        static instance: CChatRoom_GetInviteList_Request = CChatRoom_GetInviteList_Request {
            chat_group_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetInviteList_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteList_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteList_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetInviteList_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomGroupInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomGroupInvite {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomGroupInvite.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupInvite.accountid_actor)
    pub accountid_actor: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomGroupInvite.time_invited)
    pub time_invited: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomGroupInvite.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomGroupInvite {
    fn default() -> &'a CChatRoomGroupInvite {
        <CChatRoomGroupInvite as crate::Message>::default_instance()
    }
}

impl CChatRoomGroupInvite {
    pub fn new() -> CChatRoomGroupInvite {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid_actor = 2;

    pub fn accountid_actor(&self) -> u32 {
        self.accountid_actor.unwrap_or(0)
    }

    pub fn clear_accountid_actor(&mut self) {
        self.accountid_actor = ::std::option::Option::None;
    }

    pub fn has_accountid_actor(&self) -> bool {
        self.accountid_actor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid_actor(&mut self, v: u32) {
        self.accountid_actor = ::std::option::Option::Some(v);
    }

    // optional uint32 time_invited = 3;

    pub fn time_invited(&self) -> u32 {
        self.time_invited.unwrap_or(0)
    }

    pub fn clear_time_invited(&mut self) {
        self.time_invited = ::std::option::Option::None;
    }

    pub fn has_time_invited(&self) -> bool {
        self.time_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_invited(&mut self, v: u32) {
        self.time_invited = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CChatRoomGroupInvite| { &m.accountid },
            |m: &mut CChatRoomGroupInvite| { &mut m.accountid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid_actor",
            |m: &CChatRoomGroupInvite| { &m.accountid_actor },
            |m: &mut CChatRoomGroupInvite| { &mut m.accountid_actor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_invited",
            |m: &CChatRoomGroupInvite| { &m.time_invited },
            |m: &mut CChatRoomGroupInvite| { &mut m.time_invited },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomGroupInvite>(
            "CChatRoomGroupInvite",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoomGroupInvite {
    const NAME: &'static str = "CChatRoomGroupInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.accountid_actor = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.time_invited = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.accountid_actor {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.time_invited {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid_actor {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.time_invited {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomGroupInvite {
        CChatRoomGroupInvite::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.accountid_actor = ::std::option::Option::None;
        self.time_invited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomGroupInvite {
        static instance: CChatRoomGroupInvite = CChatRoomGroupInvite {
            accountid: ::std::option::Option::None,
            accountid_actor: ::std::option::Option::None,
            time_invited: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoomGroupInvite {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomGroupInvite").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomGroupInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoomGroupInvite {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetInviteList_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetInviteList_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetInviteList_Response.invites)
    pub invites: ::std::vec::Vec<CChatRoomGroupInvite>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetInviteList_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetInviteList_Response {
    fn default() -> &'a CChatRoom_GetInviteList_Response {
        <CChatRoom_GetInviteList_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetInviteList_Response {
    pub fn new() -> CChatRoom_GetInviteList_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoomGroupInvite invites = 1;

    pub fn invites(&self) -> &[CChatRoomGroupInvite] {
        &self.invites
    }

    pub fn clear_invites(&mut self) {
        self.invites.clear();
    }

    // Param is passed by value, moved
    pub fn set_invites(&mut self, v: ::std::vec::Vec<CChatRoomGroupInvite>) {
        self.invites = v;
    }

    // Mutable pointer to the field.
    pub fn mut_invites(&mut self) -> &mut ::std::vec::Vec<CChatRoomGroupInvite> {
        &mut self.invites
    }

    // Take field
    pub fn take_invites(&mut self) -> ::std::vec::Vec<CChatRoomGroupInvite> {
        ::std::mem::replace(&mut self.invites, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "invites",
            |m: &CChatRoom_GetInviteList_Response| { &m.invites },
            |m: &mut CChatRoom_GetInviteList_Response| { &mut m.invites },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetInviteList_Response>(
            "CChatRoom_GetInviteList_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetInviteList_Response {
    const NAME: &'static str = "CChatRoom_GetInviteList_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invites.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.invites {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.invites {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetInviteList_Response {
        CChatRoom_GetInviteList_Response::new()
    }

    fn clear(&mut self) {
        self.invites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetInviteList_Response {
        static instance: CChatRoom_GetInviteList_Response = CChatRoom_GetInviteList_Response {
            invites: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetInviteList_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetInviteList_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetInviteList_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetInviteList_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteInviteLink_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteInviteLink_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteInviteLink_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteInviteLink_Request.invite_code)
    pub invite_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteInviteLink_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Request {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Request {
        <CChatRoom_DeleteInviteLink_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Request {
    pub fn new() -> CChatRoom_DeleteInviteLink_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional string invite_code = 2;

    pub fn invite_code(&self) -> &str {
        match self.invite_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_invite_code(&mut self) {
        self.invite_code = ::std::option::Option::None;
    }

    pub fn has_invite_code(&self) -> bool {
        self.invite_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_code(&mut self, v: ::std::string::String) {
        self.invite_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_invite_code(&mut self) -> &mut ::std::string::String {
        if self.invite_code.is_none() {
            self.invite_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.invite_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_invite_code(&mut self) -> ::std::string::String {
        self.invite_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteInviteLink_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteInviteLink_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "invite_code",
            |m: &CChatRoom_DeleteInviteLink_Request| { &m.invite_code },
            |m: &mut CChatRoom_DeleteInviteLink_Request| { &mut m.invite_code },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteInviteLink_Request>(
            "CChatRoom_DeleteInviteLink_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteInviteLink_Request {
    const NAME: &'static str = "CChatRoom_DeleteInviteLink_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.invite_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.invite_code.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.invite_code.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteInviteLink_Request {
        CChatRoom_DeleteInviteLink_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.invite_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Request {
        static instance: CChatRoom_DeleteInviteLink_Request = CChatRoom_DeleteInviteLink_Request {
            chat_group_id: ::std::option::Option::None,
            invite_code: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteInviteLink_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteInviteLink_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteInviteLink_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteInviteLink_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteInviteLink_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteInviteLink_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteInviteLink_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteInviteLink_Response {
    fn default() -> &'a CChatRoom_DeleteInviteLink_Response {
        <CChatRoom_DeleteInviteLink_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteInviteLink_Response {
    pub fn new() -> CChatRoom_DeleteInviteLink_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteInviteLink_Response>(
            "CChatRoom_DeleteInviteLink_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteInviteLink_Response {
    const NAME: &'static str = "CChatRoom_DeleteInviteLink_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteInviteLink_Response {
        CChatRoom_DeleteInviteLink_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteInviteLink_Response {
        static instance: CChatRoom_DeleteInviteLink_Response = CChatRoom_DeleteInviteLink_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteInviteLink_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteInviteLink_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteInviteLink_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteInviteLink_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetSessionActiveChatRoomGroups_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Request.chat_group_ids)
    pub chat_group_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Request.chat_groups_data_requested)
    pub chat_groups_data_requested: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Request.virtualize_members_threshold)
    pub virtualize_members_threshold: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetSessionActiveChatRoomGroups_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Request {
        <CChatRoom_SetSessionActiveChatRoomGroups_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Request {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        ::std::default::Default::default()
    }

    // repeated uint64 chat_group_ids = 1;

    pub fn chat_group_ids(&self) -> &[u64] {
        &self.chat_group_ids
    }

    pub fn clear_chat_group_ids(&mut self) {
        self.chat_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_group_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.chat_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_group_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.chat_group_ids
    }

    // Take field
    pub fn take_chat_group_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.chat_group_ids, ::std::vec::Vec::new())
    }

    // repeated uint64 chat_groups_data_requested = 2;

    pub fn chat_groups_data_requested(&self) -> &[u64] {
        &self.chat_groups_data_requested
    }

    pub fn clear_chat_groups_data_requested(&mut self) {
        self.chat_groups_data_requested.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_groups_data_requested(&mut self, v: ::std::vec::Vec<u64>) {
        self.chat_groups_data_requested = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_groups_data_requested(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.chat_groups_data_requested
    }

    // Take field
    pub fn take_chat_groups_data_requested(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.chat_groups_data_requested, ::std::vec::Vec::new())
    }

    // optional int32 virtualize_members_threshold = 3;

    pub fn virtualize_members_threshold(&self) -> i32 {
        self.virtualize_members_threshold.unwrap_or(0)
    }

    pub fn clear_virtualize_members_threshold(&mut self) {
        self.virtualize_members_threshold = ::std::option::Option::None;
    }

    pub fn has_virtualize_members_threshold(&self) -> bool {
        self.virtualize_members_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualize_members_threshold(&mut self, v: i32) {
        self.virtualize_members_threshold = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_group_ids",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.chat_group_ids },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.chat_group_ids },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_groups_data_requested",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.chat_groups_data_requested },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.chat_groups_data_requested },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "virtualize_members_threshold",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Request| { &m.virtualize_members_threshold },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Request| { &mut m.virtualize_members_threshold },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetSessionActiveChatRoomGroups_Request>(
            "CChatRoom_SetSessionActiveChatRoomGroups_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    const NAME: &'static str = "CChatRoom_SetSessionActiveChatRoomGroups_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.chat_group_ids)?;
                },
                8 => {
                    self.chat_group_ids.push(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.chat_groups_data_requested)?;
                },
                16 => {
                    self.chat_groups_data_requested.push(is.read_uint64()?);
                },
                24 => {
                    self.virtualize_members_threshold = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_group_ids {
            my_size += crate::rt::uint64_size(1, *value);
        };
        for value in &self.chat_groups_data_requested {
            my_size += crate::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.virtualize_members_threshold {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.chat_group_ids {
            os.write_uint64(1, *v)?;
        };
        for v in &self.chat_groups_data_requested {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.virtualize_members_threshold {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Request {
        CChatRoom_SetSessionActiveChatRoomGroups_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_ids.clear();
        self.chat_groups_data_requested.clear();
        self.virtualize_members_threshold = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Request {
        static instance: CChatRoom_SetSessionActiveChatRoomGroups_Request = CChatRoom_SetSessionActiveChatRoomGroups_Request {
            chat_group_ids: ::std::vec::Vec::new(),
            chat_groups_data_requested: ::std::vec::Vec::new(),
            virtualize_members_threshold: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetSessionActiveChatRoomGroups_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetSessionActiveChatRoomGroups_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetSessionActiveChatRoomGroups_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetSessionActiveChatRoomGroups_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Response.chat_states)
    pub chat_states: ::std::vec::Vec<CChatRoomGroupState>,
    // @@protoc_insertion_point(field:CChatRoom_SetSessionActiveChatRoomGroups_Response.virtualize_members_chat_group_ids)
    pub virtualize_members_chat_group_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetSessionActiveChatRoomGroups_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn default() -> &'a CChatRoom_SetSessionActiveChatRoomGroups_Response {
        <CChatRoom_SetSessionActiveChatRoomGroups_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetSessionActiveChatRoomGroups_Response {
    pub fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoomGroupState chat_states = 1;

    pub fn chat_states(&self) -> &[CChatRoomGroupState] {
        &self.chat_states
    }

    pub fn clear_chat_states(&mut self) {
        self.chat_states.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_states(&mut self, v: ::std::vec::Vec<CChatRoomGroupState>) {
        self.chat_states = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_states(&mut self) -> &mut ::std::vec::Vec<CChatRoomGroupState> {
        &mut self.chat_states
    }

    // Take field
    pub fn take_chat_states(&mut self) -> ::std::vec::Vec<CChatRoomGroupState> {
        ::std::mem::replace(&mut self.chat_states, ::std::vec::Vec::new())
    }

    // repeated uint64 virtualize_members_chat_group_ids = 2;

    pub fn virtualize_members_chat_group_ids(&self) -> &[u64] {
        &self.virtualize_members_chat_group_ids
    }

    pub fn clear_virtualize_members_chat_group_ids(&mut self) {
        self.virtualize_members_chat_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualize_members_chat_group_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.virtualize_members_chat_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualize_members_chat_group_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.virtualize_members_chat_group_ids
    }

    // Take field
    pub fn take_virtualize_members_chat_group_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.virtualize_members_chat_group_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_states",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Response| { &m.chat_states },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Response| { &mut m.chat_states },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "virtualize_members_chat_group_ids",
            |m: &CChatRoom_SetSessionActiveChatRoomGroups_Response| { &m.virtualize_members_chat_group_ids },
            |m: &mut CChatRoom_SetSessionActiveChatRoomGroups_Response| { &mut m.virtualize_members_chat_group_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetSessionActiveChatRoomGroups_Response>(
            "CChatRoom_SetSessionActiveChatRoomGroups_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    const NAME: &'static str = "CChatRoom_SetSessionActiveChatRoomGroups_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chat_states.push(is.read_message()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.virtualize_members_chat_group_ids)?;
                },
                16 => {
                    self.virtualize_members_chat_group_ids.push(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_states {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.virtualize_members_chat_group_ids {
            my_size += crate::rt::uint64_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.chat_states {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.virtualize_members_chat_group_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetSessionActiveChatRoomGroups_Response {
        CChatRoom_SetSessionActiveChatRoomGroups_Response::new()
    }

    fn clear(&mut self) {
        self.chat_states.clear();
        self.virtualize_members_chat_group_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetSessionActiveChatRoomGroups_Response {
        static instance: CChatRoom_SetSessionActiveChatRoomGroups_Response = CChatRoom_SetSessionActiveChatRoomGroups_Response {
            chat_states: ::std::vec::Vec::new(),
            virtualize_members_chat_group_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetSessionActiveChatRoomGroups_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetSessionActiveChatRoomGroups_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserChatGroupPreferences_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.chat_group_preferences)
    pub chat_group_preferences: crate::MessageField<cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences>,
    // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.chat_room_preferences)
    pub chat_room_preferences: ::std::vec::Vec<cchat_room_set_user_chat_group_preferences_request::ChatRoomPreferences>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Request {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Request {
        <CChatRoom_SetUserChatGroupPreferences_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Request {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences chat_group_preferences = 2;

    pub fn chat_group_preferences(&self) -> &cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences {
        self.chat_group_preferences.as_ref().unwrap_or_else(|| <cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences as crate::Message>::default_instance())
    }

    pub fn clear_chat_group_preferences(&mut self) {
        self.chat_group_preferences.clear();
    }

    pub fn has_chat_group_preferences(&self) -> bool {
        self.chat_group_preferences.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_preferences(&mut self, v: cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences) {
        self.chat_group_preferences = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_preferences(&mut self) -> &mut cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences {
        self.chat_group_preferences.mut_or_insert_default()
    }

    // Take field
    pub fn take_chat_group_preferences(&mut self) -> cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences {
        self.chat_group_preferences.take().unwrap_or_else(|| cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences::new())
    }

    // repeated .CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences chat_room_preferences = 3;

    pub fn chat_room_preferences(&self) -> &[cchat_room_set_user_chat_group_preferences_request::ChatRoomPreferences] {
        &self.chat_room_preferences
    }

    pub fn clear_chat_room_preferences(&mut self) {
        self.chat_room_preferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_room_preferences(&mut self, v: ::std::vec::Vec<cchat_room_set_user_chat_group_preferences_request::ChatRoomPreferences>) {
        self.chat_room_preferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_room_preferences(&mut self) -> &mut ::std::vec::Vec<cchat_room_set_user_chat_group_preferences_request::ChatRoomPreferences> {
        &mut self.chat_room_preferences
    }

    // Take field
    pub fn take_chat_room_preferences(&mut self) -> ::std::vec::Vec<cchat_room_set_user_chat_group_preferences_request::ChatRoomPreferences> {
        ::std::mem::replace(&mut self.chat_room_preferences, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences>(
            "chat_group_preferences",
            |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_group_preferences },
            |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_group_preferences },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_room_preferences",
            |m: &CChatRoom_SetUserChatGroupPreferences_Request| { &m.chat_room_preferences },
            |m: &mut CChatRoom_SetUserChatGroupPreferences_Request| { &mut m.chat_room_preferences },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetUserChatGroupPreferences_Request>(
            "CChatRoom_SetUserChatGroupPreferences_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetUserChatGroupPreferences_Request {
    const NAME: &'static str = "CChatRoom_SetUserChatGroupPreferences_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.chat_group_preferences)?;
                },
                26 => {
                    self.chat_room_preferences.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_group_preferences.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.chat_room_preferences {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_preferences.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.chat_room_preferences {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Request {
        CChatRoom_SetUserChatGroupPreferences_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_group_preferences.clear();
        self.chat_room_preferences.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Request {
        static instance: CChatRoom_SetUserChatGroupPreferences_Request = CChatRoom_SetUserChatGroupPreferences_Request {
            chat_group_id: ::std::option::Option::None,
            chat_group_preferences: crate::MessageField::none(),
            chat_room_preferences: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetUserChatGroupPreferences_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetUserChatGroupPreferences_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetUserChatGroupPreferences_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_SetUserChatGroupPreferences_Request`
pub mod cchat_room_set_user_chat_group_preferences_request {
    // @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatGroupPreferences {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.desktop_notification_level)
        pub desktop_notification_level: ::std::option::Option<crate::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.mobile_notification_level)
        pub mobile_notification_level: ::std::option::Option<crate::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.unread_indicator_muted)
        pub unread_indicator_muted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatGroupPreferences {
        fn default() -> &'a ChatGroupPreferences {
            <ChatGroupPreferences as crate::Message>::default_instance()
        }
    }

    impl ChatGroupPreferences {
        pub fn new() -> ChatGroupPreferences {
            ::std::default::Default::default()
        }

        // optional .EChatRoomNotificationLevel desktop_notification_level = 1;

        pub fn desktop_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.desktop_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_desktop_notification_level(&mut self) {
            self.desktop_notification_level = ::std::option::Option::None;
        }

        pub fn has_desktop_notification_level(&self) -> bool {
            self.desktop_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desktop_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.desktop_notification_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional .EChatRoomNotificationLevel mobile_notification_level = 2;

        pub fn mobile_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.mobile_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_mobile_notification_level(&mut self) {
            self.mobile_notification_level = ::std::option::Option::None;
        }

        pub fn has_mobile_notification_level(&self) -> bool {
            self.mobile_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mobile_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.mobile_notification_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional bool unread_indicator_muted = 3;

        pub fn unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.unwrap_or(false)
        }

        pub fn clear_unread_indicator_muted(&mut self) {
            self.unread_indicator_muted = ::std::option::Option::None;
        }

        pub fn has_unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread_indicator_muted(&mut self, v: bool) {
            self.unread_indicator_muted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "desktop_notification_level",
                |m: &ChatGroupPreferences| { &m.desktop_notification_level },
                |m: &mut ChatGroupPreferences| { &mut m.desktop_notification_level },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "mobile_notification_level",
                |m: &ChatGroupPreferences| { &m.mobile_notification_level },
                |m: &mut ChatGroupPreferences| { &mut m.mobile_notification_level },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "unread_indicator_muted",
                |m: &ChatGroupPreferences| { &m.unread_indicator_muted },
                |m: &mut ChatGroupPreferences| { &mut m.unread_indicator_muted },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ChatGroupPreferences>(
                "CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ChatGroupPreferences {
        const NAME: &'static str = "ChatGroupPreferences";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.desktop_notification_level {
                my_size += crate::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.mobile_notification_level {
                my_size += crate::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.unread_indicator_muted {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.desktop_notification_level {
                os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mobile_notification_level {
                os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.unread_indicator_muted {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatGroupPreferences {
            ChatGroupPreferences::new()
        }

        fn clear(&mut self) {
            self.desktop_notification_level = ::std::option::Option::None;
            self.mobile_notification_level = ::std::option::Option::None;
            self.unread_indicator_muted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatGroupPreferences {
            static instance: ChatGroupPreferences = ChatGroupPreferences {
                desktop_notification_level: ::std::option::Option::None,
                mobile_notification_level: ::std::option::Option::None,
                unread_indicator_muted: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ChatGroupPreferences {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_SetUserChatGroupPreferences_Request.ChatGroupPreferences").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChatGroupPreferences {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ChatGroupPreferences {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatRoomPreferences {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.chat_id)
        pub chat_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.desktop_notification_level)
        pub desktop_notification_level: ::std::option::Option<crate::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.mobile_notification_level)
        pub mobile_notification_level: ::std::option::Option<crate::EnumOrUnknown<super::EChatRoomNotificationLevel>>,
        // @@protoc_insertion_point(field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.unread_indicator_muted)
        pub unread_indicator_muted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatRoomPreferences {
        fn default() -> &'a ChatRoomPreferences {
            <ChatRoomPreferences as crate::Message>::default_instance()
        }
    }

    impl ChatRoomPreferences {
        pub fn new() -> ChatRoomPreferences {
            ::std::default::Default::default()
        }

        // optional uint64 chat_id = 1;

        pub fn chat_id(&self) -> u64 {
            self.chat_id.unwrap_or(0)
        }

        pub fn clear_chat_id(&mut self) {
            self.chat_id = ::std::option::Option::None;
        }

        pub fn has_chat_id(&self) -> bool {
            self.chat_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_id(&mut self, v: u64) {
            self.chat_id = ::std::option::Option::Some(v);
        }

        // optional .EChatRoomNotificationLevel desktop_notification_level = 2;

        pub fn desktop_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.desktop_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_desktop_notification_level(&mut self) {
            self.desktop_notification_level = ::std::option::Option::None;
        }

        pub fn has_desktop_notification_level(&self) -> bool {
            self.desktop_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desktop_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.desktop_notification_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional .EChatRoomNotificationLevel mobile_notification_level = 3;

        pub fn mobile_notification_level(&self) -> super::EChatRoomNotificationLevel {
            match self.mobile_notification_level {
                Some(e) => e.enum_value_or(super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
                None => super::EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
            }
        }

        pub fn clear_mobile_notification_level(&mut self) {
            self.mobile_notification_level = ::std::option::Option::None;
        }

        pub fn has_mobile_notification_level(&self) -> bool {
            self.mobile_notification_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mobile_notification_level(&mut self, v: super::EChatRoomNotificationLevel) {
            self.mobile_notification_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional bool unread_indicator_muted = 4;

        pub fn unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.unwrap_or(false)
        }

        pub fn clear_unread_indicator_muted(&mut self) {
            self.unread_indicator_muted = ::std::option::Option::None;
        }

        pub fn has_unread_indicator_muted(&self) -> bool {
            self.unread_indicator_muted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unread_indicator_muted(&mut self, v: bool) {
            self.unread_indicator_muted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_id",
                |m: &ChatRoomPreferences| { &m.chat_id },
                |m: &mut ChatRoomPreferences| { &mut m.chat_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "desktop_notification_level",
                |m: &ChatRoomPreferences| { &m.desktop_notification_level },
                |m: &mut ChatRoomPreferences| { &mut m.desktop_notification_level },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "mobile_notification_level",
                |m: &ChatRoomPreferences| { &m.mobile_notification_level },
                |m: &mut ChatRoomPreferences| { &mut m.mobile_notification_level },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "unread_indicator_muted",
                |m: &ChatRoomPreferences| { &m.unread_indicator_muted },
                |m: &mut ChatRoomPreferences| { &mut m.unread_indicator_muted },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ChatRoomPreferences>(
                "CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ChatRoomPreferences {
        const NAME: &'static str = "ChatRoomPreferences";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.desktop_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.mobile_notification_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.unread_indicator_muted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.chat_id {
                my_size += crate::rt::uint64_size(1, v);
            }
            if let Some(v) = self.desktop_notification_level {
                my_size += crate::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.mobile_notification_level {
                my_size += crate::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.unread_indicator_muted {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.chat_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.desktop_notification_level {
                os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.mobile_notification_level {
                os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.unread_indicator_muted {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatRoomPreferences {
            ChatRoomPreferences::new()
        }

        fn clear(&mut self) {
            self.chat_id = ::std::option::Option::None;
            self.desktop_notification_level = ::std::option::Option::None;
            self.mobile_notification_level = ::std::option::Option::None;
            self.unread_indicator_muted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatRoomPreferences {
            static instance: ChatRoomPreferences = ChatRoomPreferences {
                chat_id: ::std::option::Option::None,
                desktop_notification_level: ::std::option::Option::None,
                mobile_notification_level: ::std::option::Option::None,
                unread_indicator_muted: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ChatRoomPreferences {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_SetUserChatGroupPreferences_Request.ChatRoomPreferences").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChatRoomPreferences {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ChatRoomPreferences {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_SetUserChatGroupPreferences_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SetUserChatGroupPreferences_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SetUserChatGroupPreferences_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SetUserChatGroupPreferences_Response {
    fn default() -> &'a CChatRoom_SetUserChatGroupPreferences_Response {
        <CChatRoom_SetUserChatGroupPreferences_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SetUserChatGroupPreferences_Response {
    pub fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SetUserChatGroupPreferences_Response>(
            "CChatRoom_SetUserChatGroupPreferences_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SetUserChatGroupPreferences_Response {
    const NAME: &'static str = "CChatRoom_SetUserChatGroupPreferences_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SetUserChatGroupPreferences_Response {
        CChatRoom_SetUserChatGroupPreferences_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SetUserChatGroupPreferences_Response {
        static instance: CChatRoom_SetUserChatGroupPreferences_Response = CChatRoom_SetUserChatGroupPreferences_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SetUserChatGroupPreferences_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SetUserChatGroupPreferences_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SetUserChatGroupPreferences_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SetUserChatGroupPreferences_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatMessages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatMessages_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.messages)
    pub messages: ::std::vec::Vec<cchat_room_delete_chat_messages_request::Message>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatMessages_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Request {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Request {
        <CChatRoom_DeleteChatMessages_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Request {
    pub fn new() -> CChatRoom_DeleteChatMessages_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoom_DeleteChatMessages_Request.Message messages = 3;

    pub fn messages(&self) -> &[cchat_room_delete_chat_messages_request::Message] {
        &self.messages
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<cchat_room_delete_chat_messages_request::Message>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<cchat_room_delete_chat_messages_request::Message> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<cchat_room_delete_chat_messages_request::Message> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_DeleteChatMessages_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_DeleteChatMessages_Request| { &m.chat_id },
            |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CChatRoom_DeleteChatMessages_Request| { &m.messages },
            |m: &mut CChatRoom_DeleteChatMessages_Request| { &mut m.messages },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteChatMessages_Request>(
            "CChatRoom_DeleteChatMessages_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteChatMessages_Request {
    const NAME: &'static str = "CChatRoom_DeleteChatMessages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatMessages_Request {
        CChatRoom_DeleteChatMessages_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Request {
        static instance: CChatRoom_DeleteChatMessages_Request = CChatRoom_DeleteChatMessages_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteChatMessages_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatMessages_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteChatMessages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_DeleteChatMessages_Request`
pub mod cchat_room_delete_chat_messages_request {
    // @@protoc_insertion_point(message:CChatRoom_DeleteChatMessages_Request.Message)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Message {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.Message.server_timestamp)
        pub server_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_DeleteChatMessages_Request.Message.ordinal)
        pub ordinal: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatMessages_Request.Message.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Message {
        fn default() -> &'a Message {
            <Message as crate::Message>::default_instance()
        }
    }

    impl Message {
        pub fn new() -> Message {
            ::std::default::Default::default()
        }

        // optional uint32 server_timestamp = 1;

        pub fn server_timestamp(&self) -> u32 {
            self.server_timestamp.unwrap_or(0)
        }

        pub fn clear_server_timestamp(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
        }

        pub fn has_server_timestamp(&self) -> bool {
            self.server_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_timestamp(&mut self, v: u32) {
            self.server_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 ordinal = 2;

        pub fn ordinal(&self) -> u32 {
            self.ordinal.unwrap_or(0)
        }

        pub fn clear_ordinal(&mut self) {
            self.ordinal = ::std::option::Option::None;
        }

        pub fn has_ordinal(&self) -> bool {
            self.ordinal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ordinal(&mut self, v: u32) {
            self.ordinal = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_timestamp",
                |m: &Message| { &m.server_timestamp },
                |m: &mut Message| { &mut m.server_timestamp },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "ordinal",
                |m: &Message| { &m.ordinal },
                |m: &mut Message| { &mut m.ordinal },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Message>(
                "CChatRoom_DeleteChatMessages_Request.Message",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Message {
        const NAME: &'static str = "Message";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_timestamp {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ordinal {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.server_timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ordinal {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Message {
            Message::new()
        }

        fn clear(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
            self.ordinal = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Message {
            static instance: Message = Message {
                server_timestamp: ::std::option::Option::None,
                ordinal: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Message {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatMessages_Request.Message").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Message {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Message {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_DeleteChatMessages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_DeleteChatMessages_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_DeleteChatMessages_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_DeleteChatMessages_Response {
    fn default() -> &'a CChatRoom_DeleteChatMessages_Response {
        <CChatRoom_DeleteChatMessages_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_DeleteChatMessages_Response {
    pub fn new() -> CChatRoom_DeleteChatMessages_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_DeleteChatMessages_Response>(
            "CChatRoom_DeleteChatMessages_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_DeleteChatMessages_Response {
    const NAME: &'static str = "CChatRoom_DeleteChatMessages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_DeleteChatMessages_Response {
        CChatRoom_DeleteChatMessages_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_DeleteChatMessages_Response {
        static instance: CChatRoom_DeleteChatMessages_Response = CChatRoom_DeleteChatMessages_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_DeleteChatMessages_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_DeleteChatMessages_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_DeleteChatMessages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_DeleteChatMessages_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_UpdateMemberListView_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_UpdateMemberListView_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.view_id)
    pub view_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.end)
    pub end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.client_changenumber)
    pub client_changenumber: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.delete_view)
    pub delete_view: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.persona_subscribe_accountids)
    pub persona_subscribe_accountids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMemberListView_Notification.persona_unsubscribe_accountids)
    pub persona_unsubscribe_accountids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_UpdateMemberListView_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMemberListView_Notification {
    fn default() -> &'a CChatRoom_UpdateMemberListView_Notification {
        <CChatRoom_UpdateMemberListView_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMemberListView_Notification {
    pub fn new() -> CChatRoom_UpdateMemberListView_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 view_id = 2;

    pub fn view_id(&self) -> u64 {
        self.view_id.unwrap_or(0)
    }

    pub fn clear_view_id(&mut self) {
        self.view_id = ::std::option::Option::None;
    }

    pub fn has_view_id(&self) -> bool {
        self.view_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_id(&mut self, v: u64) {
        self.view_id = ::std::option::Option::Some(v);
    }

    // optional int32 start = 3;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 end = 4;

    pub fn end(&self) -> i32 {
        self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = ::std::option::Option::Some(v);
    }

    // optional int32 client_changenumber = 5;

    pub fn client_changenumber(&self) -> i32 {
        self.client_changenumber.unwrap_or(0)
    }

    pub fn clear_client_changenumber(&mut self) {
        self.client_changenumber = ::std::option::Option::None;
    }

    pub fn has_client_changenumber(&self) -> bool {
        self.client_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_changenumber(&mut self, v: i32) {
        self.client_changenumber = ::std::option::Option::Some(v);
    }

    // optional bool delete_view = 6;

    pub fn delete_view(&self) -> bool {
        self.delete_view.unwrap_or(false)
    }

    pub fn clear_delete_view(&mut self) {
        self.delete_view = ::std::option::Option::None;
    }

    pub fn has_delete_view(&self) -> bool {
        self.delete_view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delete_view(&mut self, v: bool) {
        self.delete_view = ::std::option::Option::Some(v);
    }

    // repeated int32 persona_subscribe_accountids = 7;

    pub fn persona_subscribe_accountids(&self) -> &[i32] {
        &self.persona_subscribe_accountids
    }

    pub fn clear_persona_subscribe_accountids(&mut self) {
        self.persona_subscribe_accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_persona_subscribe_accountids(&mut self, v: ::std::vec::Vec<i32>) {
        self.persona_subscribe_accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_persona_subscribe_accountids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.persona_subscribe_accountids
    }

    // Take field
    pub fn take_persona_subscribe_accountids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.persona_subscribe_accountids, ::std::vec::Vec::new())
    }

    // repeated int32 persona_unsubscribe_accountids = 8;

    pub fn persona_unsubscribe_accountids(&self) -> &[i32] {
        &self.persona_unsubscribe_accountids
    }

    pub fn clear_persona_unsubscribe_accountids(&mut self) {
        self.persona_unsubscribe_accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_persona_unsubscribe_accountids(&mut self, v: ::std::vec::Vec<i32>) {
        self.persona_unsubscribe_accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_persona_unsubscribe_accountids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.persona_unsubscribe_accountids
    }

    // Take field
    pub fn take_persona_unsubscribe_accountids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.persona_unsubscribe_accountids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_id",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.view_id },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.view_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.start },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.start },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "end",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.end },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.end },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_changenumber",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.client_changenumber },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.client_changenumber },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "delete_view",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.delete_view },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.delete_view },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "persona_subscribe_accountids",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.persona_subscribe_accountids },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.persona_subscribe_accountids },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "persona_unsubscribe_accountids",
            |m: &CChatRoom_UpdateMemberListView_Notification| { &m.persona_unsubscribe_accountids },
            |m: &mut CChatRoom_UpdateMemberListView_Notification| { &mut m.persona_unsubscribe_accountids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_UpdateMemberListView_Notification>(
            "CChatRoom_UpdateMemberListView_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_UpdateMemberListView_Notification {
    const NAME: &'static str = "CChatRoom_UpdateMemberListView_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.view_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.end = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.client_changenumber = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.delete_view = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.persona_subscribe_accountids)?;
                },
                56 => {
                    self.persona_subscribe_accountids.push(is.read_int32()?);
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.persona_unsubscribe_accountids)?;
                },
                64 => {
                    self.persona_unsubscribe_accountids.push(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.view_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.start {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.end {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.client_changenumber {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.delete_view {
            my_size += 1 + 1;
        }
        for value in &self.persona_subscribe_accountids {
            my_size += crate::rt::int32_size(7, *value);
        };
        for value in &self.persona_unsubscribe_accountids {
            my_size += crate::rt::int32_size(8, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.view_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.client_changenumber {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.delete_view {
            os.write_bool(6, v)?;
        }
        for v in &self.persona_subscribe_accountids {
            os.write_int32(7, *v)?;
        };
        for v in &self.persona_unsubscribe_accountids {
            os.write_int32(8, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_UpdateMemberListView_Notification {
        CChatRoom_UpdateMemberListView_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.view_id = ::std::option::Option::None;
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.client_changenumber = ::std::option::Option::None;
        self.delete_view = ::std::option::Option::None;
        self.persona_subscribe_accountids.clear();
        self.persona_unsubscribe_accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_UpdateMemberListView_Notification {
        static instance: CChatRoom_UpdateMemberListView_Notification = CChatRoom_UpdateMemberListView_Notification {
            chat_group_id: ::std::option::Option::None,
            view_id: ::std::option::Option::None,
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            client_changenumber: ::std::option::Option::None,
            delete_view: ::std::option::Option::None,
            persona_subscribe_accountids: ::std::vec::Vec::new(),
            persona_unsubscribe_accountids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_UpdateMemberListView_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_UpdateMemberListView_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_UpdateMemberListView_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_UpdateMemberListView_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SearchMembers_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SearchMembers_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.search_id)
    pub search_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.search_text)
    pub search_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Request.max_results)
    pub max_results: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SearchMembers_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SearchMembers_Request {
    fn default() -> &'a CChatRoom_SearchMembers_Request {
        <CChatRoom_SearchMembers_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_SearchMembers_Request {
    pub fn new() -> CChatRoom_SearchMembers_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 search_id = 2;

    pub fn search_id(&self) -> u64 {
        self.search_id.unwrap_or(0)
    }

    pub fn clear_search_id(&mut self) {
        self.search_id = ::std::option::Option::None;
    }

    pub fn has_search_id(&self) -> bool {
        self.search_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_id(&mut self, v: u64) {
        self.search_id = ::std::option::Option::Some(v);
    }

    // optional string search_text = 3;

    pub fn search_text(&self) -> &str {
        match self.search_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search_text(&mut self) {
        self.search_text = ::std::option::Option::None;
    }

    pub fn has_search_text(&self) -> bool {
        self.search_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_text(&mut self, v: ::std::string::String) {
        self.search_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_text(&mut self) -> &mut ::std::string::String {
        if self.search_text.is_none() {
            self.search_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.search_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_text(&mut self) -> ::std::string::String {
        self.search_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 max_results = 4;

    pub fn max_results(&self) -> i32 {
        self.max_results.unwrap_or(0)
    }

    pub fn clear_max_results(&mut self) {
        self.max_results = ::std::option::Option::None;
    }

    pub fn has_max_results(&self) -> bool {
        self.max_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_results(&mut self, v: i32) {
        self.max_results = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_SearchMembers_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_SearchMembers_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_id",
            |m: &CChatRoom_SearchMembers_Request| { &m.search_id },
            |m: &mut CChatRoom_SearchMembers_Request| { &mut m.search_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_text",
            |m: &CChatRoom_SearchMembers_Request| { &m.search_text },
            |m: &mut CChatRoom_SearchMembers_Request| { &mut m.search_text },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_results",
            |m: &CChatRoom_SearchMembers_Request| { &m.max_results },
            |m: &mut CChatRoom_SearchMembers_Request| { &mut m.max_results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SearchMembers_Request>(
            "CChatRoom_SearchMembers_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SearchMembers_Request {
    const NAME: &'static str = "CChatRoom_SearchMembers_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.search_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.search_text = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.max_results = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.search_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.search_text.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.max_results {
            my_size += crate::rt::int32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.search_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.search_text.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.max_results {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SearchMembers_Request {
        CChatRoom_SearchMembers_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.search_id = ::std::option::Option::None;
        self.search_text = ::std::option::Option::None;
        self.max_results = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SearchMembers_Request {
        static instance: CChatRoom_SearchMembers_Request = CChatRoom_SearchMembers_Request {
            chat_group_id: ::std::option::Option::None,
            search_id: ::std::option::Option::None,
            search_text: ::std::option::Option::None,
            max_results: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SearchMembers_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SearchMembers_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SearchMembers_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SearchMembers_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_SearchMembers_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_SearchMembers_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.matching_members)
    pub matching_members: ::std::vec::Vec<cchat_room_search_members_response::MemberMatch>,
    // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.status_flags)
    pub status_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_SearchMembers_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_SearchMembers_Response {
    fn default() -> &'a CChatRoom_SearchMembers_Response {
        <CChatRoom_SearchMembers_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_SearchMembers_Response {
    pub fn new() -> CChatRoom_SearchMembers_Response {
        ::std::default::Default::default()
    }

    // repeated .CChatRoom_SearchMembers_Response.MemberMatch matching_members = 1;

    pub fn matching_members(&self) -> &[cchat_room_search_members_response::MemberMatch] {
        &self.matching_members
    }

    pub fn clear_matching_members(&mut self) {
        self.matching_members.clear();
    }

    // Param is passed by value, moved
    pub fn set_matching_members(&mut self, v: ::std::vec::Vec<cchat_room_search_members_response::MemberMatch>) {
        self.matching_members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matching_members(&mut self) -> &mut ::std::vec::Vec<cchat_room_search_members_response::MemberMatch> {
        &mut self.matching_members
    }

    // Take field
    pub fn take_matching_members(&mut self) -> ::std::vec::Vec<cchat_room_search_members_response::MemberMatch> {
        ::std::mem::replace(&mut self.matching_members, ::std::vec::Vec::new())
    }

    // optional uint32 status_flags = 2;

    pub fn status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matching_members",
            |m: &CChatRoom_SearchMembers_Response| { &m.matching_members },
            |m: &mut CChatRoom_SearchMembers_Response| { &mut m.matching_members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_flags",
            |m: &CChatRoom_SearchMembers_Response| { &m.status_flags },
            |m: &mut CChatRoom_SearchMembers_Response| { &mut m.status_flags },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_SearchMembers_Response>(
            "CChatRoom_SearchMembers_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_SearchMembers_Response {
    const NAME: &'static str = "CChatRoom_SearchMembers_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matching_members.push(is.read_message()?);
                },
                16 => {
                    self.status_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matching_members {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.status_flags {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.matching_members {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.status_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_SearchMembers_Response {
        CChatRoom_SearchMembers_Response::new()
    }

    fn clear(&mut self) {
        self.matching_members.clear();
        self.status_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_SearchMembers_Response {
        static instance: CChatRoom_SearchMembers_Response = CChatRoom_SearchMembers_Response {
            matching_members: ::std::vec::Vec::new(),
            status_flags: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_SearchMembers_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_SearchMembers_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_SearchMembers_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_SearchMembers_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_SearchMembers_Response`
pub mod cchat_room_search_members_response {
    // @@protoc_insertion_point(message:CChatRoom_SearchMembers_Response.MemberMatch)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MemberMatch {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.MemberMatch.accountid)
        pub accountid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatRoom_SearchMembers_Response.MemberMatch.persona)
        pub persona: crate::MessageField<super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_SearchMembers_Response.MemberMatch.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MemberMatch {
        fn default() -> &'a MemberMatch {
            <MemberMatch as crate::Message>::default_instance()
        }
    }

    impl MemberMatch {
        pub fn new() -> MemberMatch {
            ::std::default::Default::default()
        }

        // optional int32 accountid = 1;

        pub fn accountid(&self) -> i32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: i32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional .CMsgClientPersonaState.Friend persona = 2;

        pub fn persona(&self) -> &super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend {
            self.persona.as_ref().unwrap_or_else(|| <super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend as crate::Message>::default_instance())
        }

        pub fn clear_persona(&mut self) {
            self.persona.clear();
        }

        pub fn has_persona(&self) -> bool {
            self.persona.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona(&mut self, v: super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend) {
            self.persona = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona(&mut self) -> &mut super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend {
            self.persona.mut_or_insert_default()
        }

        // Take field
        pub fn take_persona(&mut self) -> super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend {
            self.persona.take().unwrap_or_else(|| super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &MemberMatch| { &m.accountid },
                |m: &mut MemberMatch| { &mut m.accountid },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>(
                "persona",
                |m: &MemberMatch| { &m.persona },
                |m: &mut MemberMatch| { &mut m.persona },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<MemberMatch>(
                "CChatRoom_SearchMembers_Response.MemberMatch",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for MemberMatch {
        const NAME: &'static str = "MemberMatch";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.persona)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.persona.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.accountid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                crate::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MemberMatch {
            MemberMatch::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.persona.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MemberMatch {
            static instance: MemberMatch = MemberMatch {
                accountid: ::std::option::Option::None,
                persona: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for MemberMatch {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_SearchMembers_Response.MemberMatch").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MemberMatch {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for MemberMatch {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_UpdateMessageReaction_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_UpdateMessageReaction_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.reaction_type)
    pub reaction_type: ::std::option::Option<crate::EnumOrUnknown<EChatRoomMessageReactionType>>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.reaction)
    pub reaction: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Request.is_add)
    pub is_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_UpdateMessageReaction_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMessageReaction_Request {
    fn default() -> &'a CChatRoom_UpdateMessageReaction_Request {
        <CChatRoom_UpdateMessageReaction_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMessageReaction_Request {
    pub fn new() -> CChatRoom_UpdateMessageReaction_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 5;

    pub fn reaction_type(&self) -> EChatRoomMessageReactionType {
        match self.reaction_type {
            Some(e) => e.enum_value_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            None => EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        }
    }

    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string reaction = 6;

    pub fn reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 7;

    pub fn is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }

    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.chat_id },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_timestamp",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.server_timestamp },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.server_timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.ordinal },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.ordinal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction_type",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.reaction_type },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.reaction_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.reaction },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.reaction },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_add",
            |m: &CChatRoom_UpdateMessageReaction_Request| { &m.is_add },
            |m: &mut CChatRoom_UpdateMessageReaction_Request| { &mut m.is_add },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_UpdateMessageReaction_Request>(
            "CChatRoom_UpdateMessageReaction_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_UpdateMessageReaction_Request {
    const NAME: &'static str = "CChatRoom_UpdateMessageReaction_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.reaction = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.is_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ordinal {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reaction_type {
            my_size += crate::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.reaction.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(5, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reaction.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_UpdateMessageReaction_Request {
        CChatRoom_UpdateMessageReaction_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.is_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_UpdateMessageReaction_Request {
        static instance: CChatRoom_UpdateMessageReaction_Request = CChatRoom_UpdateMessageReaction_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            reaction_type: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            is_add: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_UpdateMessageReaction_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_UpdateMessageReaction_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_UpdateMessageReaction_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_UpdateMessageReaction_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_UpdateMessageReaction_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_UpdateMessageReaction_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_UpdateMessageReaction_Response.num_reactors)
    pub num_reactors: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_UpdateMessageReaction_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_UpdateMessageReaction_Response {
    fn default() -> &'a CChatRoom_UpdateMessageReaction_Response {
        <CChatRoom_UpdateMessageReaction_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_UpdateMessageReaction_Response {
    pub fn new() -> CChatRoom_UpdateMessageReaction_Response {
        ::std::default::Default::default()
    }

    // optional uint32 num_reactors = 1;

    pub fn num_reactors(&self) -> u32 {
        self.num_reactors.unwrap_or(0)
    }

    pub fn clear_num_reactors(&mut self) {
        self.num_reactors = ::std::option::Option::None;
    }

    pub fn has_num_reactors(&self) -> bool {
        self.num_reactors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_reactors(&mut self, v: u32) {
        self.num_reactors = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_reactors",
            |m: &CChatRoom_UpdateMessageReaction_Response| { &m.num_reactors },
            |m: &mut CChatRoom_UpdateMessageReaction_Response| { &mut m.num_reactors },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_UpdateMessageReaction_Response>(
            "CChatRoom_UpdateMessageReaction_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_UpdateMessageReaction_Response {
    const NAME: &'static str = "CChatRoom_UpdateMessageReaction_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_reactors = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_reactors {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.num_reactors {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_UpdateMessageReaction_Response {
        CChatRoom_UpdateMessageReaction_Response::new()
    }

    fn clear(&mut self) {
        self.num_reactors = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_UpdateMessageReaction_Response {
        static instance: CChatRoom_UpdateMessageReaction_Response = CChatRoom_UpdateMessageReaction_Response {
            num_reactors: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_UpdateMessageReaction_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_UpdateMessageReaction_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_UpdateMessageReaction_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_UpdateMessageReaction_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageReactionReactors_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageReactionReactors_Request {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.reaction_type)
    pub reaction_type: ::std::option::Option<crate::EnumOrUnknown<EChatRoomMessageReactionType>>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.reaction)
    pub reaction: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Request.limit)
    pub limit: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageReactionReactors_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageReactionReactors_Request {
    fn default() -> &'a CChatRoom_GetMessageReactionReactors_Request {
        <CChatRoom_GetMessageReactionReactors_Request as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageReactionReactors_Request {
    pub fn new() -> CChatRoom_GetMessageReactionReactors_Request {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 5;

    pub fn reaction_type(&self) -> EChatRoomMessageReactionType {
        match self.reaction_type {
            Some(e) => e.enum_value_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            None => EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        }
    }

    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string reaction = 6;

    pub fn reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 limit = 7;

    pub fn limit(&self) -> u32 {
        self.limit.unwrap_or(0)
    }

    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: u32) {
        self.limit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.chat_group_id },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.chat_id },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_timestamp",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.server_timestamp },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.server_timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.ordinal },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.ordinal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction_type",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.reaction_type },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.reaction_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.reaction },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.reaction },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "limit",
            |m: &CChatRoom_GetMessageReactionReactors_Request| { &m.limit },
            |m: &mut CChatRoom_GetMessageReactionReactors_Request| { &mut m.limit },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMessageReactionReactors_Request>(
            "CChatRoom_GetMessageReactionReactors_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetMessageReactionReactors_Request {
    const NAME: &'static str = "CChatRoom_GetMessageReactionReactors_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.reaction = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.limit = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ordinal {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reaction_type {
            my_size += crate::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.reaction.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.limit {
            my_size += crate::rt::uint32_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(5, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reaction.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.limit {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageReactionReactors_Request {
        CChatRoom_GetMessageReactionReactors_Request::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageReactionReactors_Request {
        static instance: CChatRoom_GetMessageReactionReactors_Request = CChatRoom_GetMessageReactionReactors_Request {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            reaction_type: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            limit: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetMessageReactionReactors_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageReactionReactors_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMessageReactionReactors_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetMessageReactionReactors_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_GetMessageReactionReactors_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_GetMessageReactionReactors_Response {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_GetMessageReactionReactors_Response.reactors)
    pub reactors: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_GetMessageReactionReactors_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_GetMessageReactionReactors_Response {
    fn default() -> &'a CChatRoom_GetMessageReactionReactors_Response {
        <CChatRoom_GetMessageReactionReactors_Response as crate::Message>::default_instance()
    }
}

impl CChatRoom_GetMessageReactionReactors_Response {
    pub fn new() -> CChatRoom_GetMessageReactionReactors_Response {
        ::std::default::Default::default()
    }

    // repeated uint32 reactors = 1;

    pub fn reactors(&self) -> &[u32] {
        &self.reactors
    }

    pub fn clear_reactors(&mut self) {
        self.reactors.clear();
    }

    // Param is passed by value, moved
    pub fn set_reactors(&mut self, v: ::std::vec::Vec<u32>) {
        self.reactors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reactors(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.reactors
    }

    // Take field
    pub fn take_reactors(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.reactors, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reactors",
            |m: &CChatRoom_GetMessageReactionReactors_Response| { &m.reactors },
            |m: &mut CChatRoom_GetMessageReactionReactors_Response| { &mut m.reactors },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_GetMessageReactionReactors_Response>(
            "CChatRoom_GetMessageReactionReactors_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_GetMessageReactionReactors_Response {
    const NAME: &'static str = "CChatRoom_GetMessageReactionReactors_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.reactors)?;
                },
                8 => {
                    self.reactors.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reactors {
            my_size += crate::rt::uint32_size(1, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.reactors {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_GetMessageReactionReactors_Response {
        CChatRoom_GetMessageReactionReactors_Response::new()
    }

    fn clear(&mut self) {
        self.reactors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_GetMessageReactionReactors_Response {
        static instance: CChatRoom_GetMessageReactionReactors_Response = CChatRoom_GetMessageReactionReactors_Response {
            reactors: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_GetMessageReactionReactors_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_GetMessageReactionReactors_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_GetMessageReactionReactors_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_GetMessageReactionReactors_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanChatRooms_GetClanChatRoomInfo_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_GetClanChatRoomInfo_Request {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_GetClanChatRoomInfo_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanChatRooms_GetClanChatRoomInfo_Request.autocreate)
    pub autocreate: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_GetClanChatRoomInfo_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Request {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Request {
        <CClanChatRooms_GetClanChatRoomInfo_Request as crate::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Request {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool autocreate = 2;

    pub fn autocreate(&self) -> bool {
        self.autocreate.unwrap_or(true)
    }

    pub fn clear_autocreate(&mut self) {
        self.autocreate = ::std::option::Option::None;
    }

    pub fn has_autocreate(&self) -> bool {
        self.autocreate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autocreate(&mut self, v: bool) {
        self.autocreate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CClanChatRooms_GetClanChatRoomInfo_Request| { &m.steamid },
            |m: &mut CClanChatRooms_GetClanChatRoomInfo_Request| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "autocreate",
            |m: &CClanChatRooms_GetClanChatRoomInfo_Request| { &m.autocreate },
            |m: &mut CClanChatRooms_GetClanChatRoomInfo_Request| { &mut m.autocreate },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClanChatRooms_GetClanChatRoomInfo_Request>(
            "CClanChatRooms_GetClanChatRoomInfo_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClanChatRooms_GetClanChatRoomInfo_Request {
    const NAME: &'static str = "CClanChatRooms_GetClanChatRoomInfo_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.autocreate = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.autocreate {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.autocreate {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Request {
        CClanChatRooms_GetClanChatRoomInfo_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.autocreate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Request {
        static instance: CClanChatRooms_GetClanChatRoomInfo_Request = CClanChatRooms_GetClanChatRoomInfo_Request {
            steamid: ::std::option::Option::None,
            autocreate: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanChatRooms_GetClanChatRoomInfo_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanChatRooms_GetClanChatRoomInfo_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClanChatRooms_GetClanChatRoomInfo_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanChatRooms_GetClanChatRoomInfo_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_GetClanChatRoomInfo_Response {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_GetClanChatRoomInfo_Response.chat_group_summary)
    pub chat_group_summary: crate::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_GetClanChatRoomInfo_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_GetClanChatRoomInfo_Response {
    fn default() -> &'a CClanChatRooms_GetClanChatRoomInfo_Response {
        <CClanChatRooms_GetClanChatRoomInfo_Response as crate::Message>::default_instance()
    }
}

impl CClanChatRooms_GetClanChatRoomInfo_Response {
    pub fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        ::std::default::Default::default()
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response chat_group_summary = 1;

    pub fn chat_group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.chat_group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as crate::Message>::default_instance())
    }

    pub fn clear_chat_group_summary(&mut self) {
        self.chat_group_summary.clear();
    }

    pub fn has_chat_group_summary(&self) -> bool {
        self.chat_group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.chat_group_summary = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        self.chat_group_summary.mut_or_insert_default()
    }

    // Take field
    pub fn take_chat_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.chat_group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "chat_group_summary",
            |m: &CClanChatRooms_GetClanChatRoomInfo_Response| { &m.chat_group_summary },
            |m: &mut CClanChatRooms_GetClanChatRoomInfo_Response| { &mut m.chat_group_summary },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClanChatRooms_GetClanChatRoomInfo_Response>(
            "CClanChatRooms_GetClanChatRoomInfo_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClanChatRooms_GetClanChatRoomInfo_Response {
    const NAME: &'static str = "CClanChatRooms_GetClanChatRoomInfo_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.chat_group_summary)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_summary.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_GetClanChatRoomInfo_Response {
        CClanChatRooms_GetClanChatRoomInfo_Response::new()
    }

    fn clear(&mut self) {
        self.chat_group_summary.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_GetClanChatRoomInfo_Response {
        static instance: CClanChatRooms_GetClanChatRoomInfo_Response = CClanChatRooms_GetClanChatRoomInfo_Response {
            chat_group_summary: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanChatRooms_GetClanChatRoomInfo_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanChatRooms_GetClanChatRoomInfo_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClanChatRooms_GetClanChatRoomInfo_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanChatRooms_SetClanChatRoomPrivate_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Request {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_SetClanChatRoomPrivate_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CClanChatRooms_SetClanChatRoomPrivate_Request.chat_room_private)
    pub chat_room_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_SetClanChatRoomPrivate_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Request {
        <CClanChatRooms_SetClanChatRoomPrivate_Request as crate::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Request {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bool chat_room_private = 2;

    pub fn chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CClanChatRooms_SetClanChatRoomPrivate_Request| { &m.steamid },
            |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Request| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_room_private",
            |m: &CClanChatRooms_SetClanChatRoomPrivate_Request| { &m.chat_room_private },
            |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Request| { &mut m.chat_room_private },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClanChatRooms_SetClanChatRoomPrivate_Request>(
            "CClanChatRooms_SetClanChatRoomPrivate_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClanChatRooms_SetClanChatRoomPrivate_Request {
    const NAME: &'static str = "CClanChatRooms_SetClanChatRoomPrivate_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chat_room_private {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_room_private {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Request {
        CClanChatRooms_SetClanChatRoomPrivate_Request::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_room_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Request {
        static instance: CClanChatRooms_SetClanChatRoomPrivate_Request = CClanChatRooms_SetClanChatRoomPrivate_Request {
            steamid: ::std::option::Option::None,
            chat_room_private: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanChatRooms_SetClanChatRoomPrivate_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanChatRooms_SetClanChatRoomPrivate_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClanChatRooms_SetClanChatRoomPrivate_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CClanChatRooms_SetClanChatRoomPrivate_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CClanChatRooms_SetClanChatRoomPrivate_Response {
    // message fields
    // @@protoc_insertion_point(field:CClanChatRooms_SetClanChatRoomPrivate_Response.chat_room_private)
    pub chat_room_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CClanChatRooms_SetClanChatRoomPrivate_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn default() -> &'a CClanChatRooms_SetClanChatRoomPrivate_Response {
        <CClanChatRooms_SetClanChatRoomPrivate_Response as crate::Message>::default_instance()
    }
}

impl CClanChatRooms_SetClanChatRoomPrivate_Response {
    pub fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        ::std::default::Default::default()
    }

    // optional bool chat_room_private = 1;

    pub fn chat_room_private(&self) -> bool {
        self.chat_room_private.unwrap_or(false)
    }

    pub fn clear_chat_room_private(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
    }

    pub fn has_chat_room_private(&self) -> bool {
        self.chat_room_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_private(&mut self, v: bool) {
        self.chat_room_private = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_room_private",
            |m: &CClanChatRooms_SetClanChatRoomPrivate_Response| { &m.chat_room_private },
            |m: &mut CClanChatRooms_SetClanChatRoomPrivate_Response| { &mut m.chat_room_private },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CClanChatRooms_SetClanChatRoomPrivate_Response>(
            "CClanChatRooms_SetClanChatRoomPrivate_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CClanChatRooms_SetClanChatRoomPrivate_Response {
    const NAME: &'static str = "CClanChatRooms_SetClanChatRoomPrivate_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_room_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_room_private {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_room_private {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClanChatRooms_SetClanChatRoomPrivate_Response {
        CClanChatRooms_SetClanChatRoomPrivate_Response::new()
    }

    fn clear(&mut self) {
        self.chat_room_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClanChatRooms_SetClanChatRoomPrivate_Response {
        static instance: CClanChatRooms_SetClanChatRoomPrivate_Response = CClanChatRooms_SetClanChatRoomPrivate_Response {
            chat_room_private: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClanChatRooms_SetClanChatRoomPrivate_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClanChatRooms_SetClanChatRoomPrivate_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CClanChatRooms_SetClanChatRoomPrivate_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatMentions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatMentions {
    // message fields
    // @@protoc_insertion_point(field:CChatMentions.mention_all)
    pub mention_all: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatMentions.mention_here)
    pub mention_here: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatMentions.mention_accountids)
    pub mention_accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatMentions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatMentions {
    fn default() -> &'a CChatMentions {
        <CChatMentions as crate::Message>::default_instance()
    }
}

impl CChatMentions {
    pub fn new() -> CChatMentions {
        ::std::default::Default::default()
    }

    // optional bool mention_all = 1;

    pub fn mention_all(&self) -> bool {
        self.mention_all.unwrap_or(false)
    }

    pub fn clear_mention_all(&mut self) {
        self.mention_all = ::std::option::Option::None;
    }

    pub fn has_mention_all(&self) -> bool {
        self.mention_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_all(&mut self, v: bool) {
        self.mention_all = ::std::option::Option::Some(v);
    }

    // optional bool mention_here = 2;

    pub fn mention_here(&self) -> bool {
        self.mention_here.unwrap_or(false)
    }

    pub fn clear_mention_here(&mut self) {
        self.mention_here = ::std::option::Option::None;
    }

    pub fn has_mention_here(&self) -> bool {
        self.mention_here.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mention_here(&mut self, v: bool) {
        self.mention_here = ::std::option::Option::Some(v);
    }

    // repeated uint32 mention_accountids = 3;

    pub fn mention_accountids(&self) -> &[u32] {
        &self.mention_accountids
    }

    pub fn clear_mention_accountids(&mut self) {
        self.mention_accountids.clear();
    }

    // Param is passed by value, moved
    pub fn set_mention_accountids(&mut self, v: ::std::vec::Vec<u32>) {
        self.mention_accountids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mention_accountids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.mention_accountids
    }

    // Take field
    pub fn take_mention_accountids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.mention_accountids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mention_all",
            |m: &CChatMentions| { &m.mention_all },
            |m: &mut CChatMentions| { &mut m.mention_all },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "mention_here",
            |m: &CChatMentions| { &m.mention_here },
            |m: &mut CChatMentions| { &mut m.mention_here },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mention_accountids",
            |m: &CChatMentions| { &m.mention_accountids },
            |m: &mut CChatMentions| { &mut m.mention_accountids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatMentions>(
            "CChatMentions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatMentions {
    const NAME: &'static str = "CChatMentions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mention_all = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.mention_here = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.mention_accountids)?;
                },
                24 => {
                    self.mention_accountids.push(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mention_all {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mention_here {
            my_size += 1 + 1;
        }
        for value in &self.mention_accountids {
            my_size += crate::rt::uint32_size(3, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.mention_all {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.mention_here {
            os.write_bool(2, v)?;
        }
        for v in &self.mention_accountids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatMentions {
        CChatMentions::new()
    }

    fn clear(&mut self) {
        self.mention_all = ::std::option::Option::None;
        self.mention_here = ::std::option::Option::None;
        self.mention_accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatMentions {
        static instance: CChatMentions = CChatMentions {
            mention_all: ::std::option::Option::None,
            mention_here: ::std::option::Option::None,
            mention_accountids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatMentions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatMentions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatMentions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatMentions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_IncomingChatMessage_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_IncomingChatMessage_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.steamid_sender)
    pub steamid_sender: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.mentions)
    pub mentions: crate::MessageField<CChatMentions>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.server_message)
    pub server_message: crate::MessageField<ServerMessage>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.message_no_bbcode)
    pub message_no_bbcode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_IncomingChatMessage_Notification.chat_name)
    pub chat_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_IncomingChatMessage_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_IncomingChatMessage_Notification {
    fn default() -> &'a CChatRoom_IncomingChatMessage_Notification {
        <CChatRoom_IncomingChatMessage_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_IncomingChatMessage_Notification {
    pub fn new() -> CChatRoom_IncomingChatMessage_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_sender = 3;

    pub fn steamid_sender(&self) -> u64 {
        self.steamid_sender.unwrap_or(0)
    }

    pub fn clear_steamid_sender(&mut self) {
        self.steamid_sender = ::std::option::Option::None;
    }

    pub fn has_steamid_sender(&self) -> bool {
        self.steamid_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_sender(&mut self, v: u64) {
        self.steamid_sender = ::std::option::Option::Some(v);
    }

    // optional string message = 4;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 timestamp = 5;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional .CChatMentions mentions = 6;

    pub fn mentions(&self) -> &CChatMentions {
        self.mentions.as_ref().unwrap_or_else(|| <CChatMentions as crate::Message>::default_instance())
    }

    pub fn clear_mentions(&mut self) {
        self.mentions.clear();
    }

    pub fn has_mentions(&self) -> bool {
        self.mentions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mentions(&mut self, v: CChatMentions) {
        self.mentions = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mentions(&mut self) -> &mut CChatMentions {
        self.mentions.mut_or_insert_default()
    }

    // Take field
    pub fn take_mentions(&mut self) -> CChatMentions {
        self.mentions.take().unwrap_or_else(|| CChatMentions::new())
    }

    // optional uint32 ordinal = 7;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional .ServerMessage server_message = 8;

    pub fn server_message(&self) -> &ServerMessage {
        self.server_message.as_ref().unwrap_or_else(|| <ServerMessage as crate::Message>::default_instance())
    }

    pub fn clear_server_message(&mut self) {
        self.server_message.clear();
    }

    pub fn has_server_message(&self) -> bool {
        self.server_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_message(&mut self, v: ServerMessage) {
        self.server_message = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_message(&mut self) -> &mut ServerMessage {
        self.server_message.mut_or_insert_default()
    }

    // Take field
    pub fn take_server_message(&mut self) -> ServerMessage {
        self.server_message.take().unwrap_or_else(|| ServerMessage::new())
    }

    // optional string message_no_bbcode = 9;

    pub fn message_no_bbcode(&self) -> &str {
        match self.message_no_bbcode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message_no_bbcode(&mut self) {
        self.message_no_bbcode = ::std::option::Option::None;
    }

    pub fn has_message_no_bbcode(&self) -> bool {
        self.message_no_bbcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_no_bbcode(&mut self, v: ::std::string::String) {
        self.message_no_bbcode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_no_bbcode(&mut self) -> &mut ::std::string::String {
        if self.message_no_bbcode.is_none() {
            self.message_no_bbcode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message_no_bbcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_no_bbcode(&mut self) -> ::std::string::String {
        self.message_no_bbcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string chat_name = 10;

    pub fn chat_name(&self) -> &str {
        match self.chat_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_chat_name(&mut self) {
        self.chat_name = ::std::option::Option::None;
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name(&mut self) -> &mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_id },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid_sender",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.steamid_sender },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.steamid_sender },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.message },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.timestamp },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatMentions>(
            "mentions",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.mentions },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.mentions },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.ordinal },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.ordinal },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, ServerMessage>(
            "server_message",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.server_message },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.server_message },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_no_bbcode",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.message_no_bbcode },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.message_no_bbcode },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_name",
            |m: &CChatRoom_IncomingChatMessage_Notification| { &m.chat_name },
            |m: &mut CChatRoom_IncomingChatMessage_Notification| { &mut m.chat_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_IncomingChatMessage_Notification>(
            "CChatRoom_IncomingChatMessage_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_IncomingChatMessage_Notification {
    const NAME: &'static str = "CChatRoom_IncomingChatMessage_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.steamid_sender = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.mentions)?;
                },
                56 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.server_message)?;
                },
                74 => {
                    self.message_no_bbcode = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.chat_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.steamid_sender {
            my_size += 1 + 8;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.mentions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ordinal {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.server_message.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.message_no_bbcode.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        if let Some(v) = self.chat_name.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.steamid_sender {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.mentions.as_ref() {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.server_message.as_ref() {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.message_no_bbcode.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.chat_name.as_ref() {
            os.write_string(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_IncomingChatMessage_Notification {
        CChatRoom_IncomingChatMessage_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.steamid_sender = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.mentions.clear();
        self.ordinal = ::std::option::Option::None;
        self.server_message.clear();
        self.message_no_bbcode = ::std::option::Option::None;
        self.chat_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_IncomingChatMessage_Notification {
        static instance: CChatRoom_IncomingChatMessage_Notification = CChatRoom_IncomingChatMessage_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            steamid_sender: ::std::option::Option::None,
            message: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            mentions: crate::MessageField::none(),
            ordinal: ::std::option::Option::None,
            server_message: crate::MessageField::none(),
            message_no_bbcode: ::std::option::Option::None,
            chat_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_IncomingChatMessage_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_IncomingChatMessage_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_IncomingChatMessage_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_IncomingChatMessage_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ChatMessageModified_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ChatMessageModified_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.messages)
    pub messages: ::std::vec::Vec<cchat_room_chat_message_modified_notification::ChatMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ChatMessageModified_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatMessageModified_Notification {
    fn default() -> &'a CChatRoom_ChatMessageModified_Notification {
        <CChatRoom_ChatMessageModified_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_ChatMessageModified_Notification {
    pub fn new() -> CChatRoom_ChatMessageModified_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoom_ChatMessageModified_Notification.ChatMessage messages = 3;

    pub fn messages(&self) -> &[cchat_room_chat_message_modified_notification::ChatMessage] {
        &self.messages
    }

    pub fn clear_messages(&mut self) {
        self.messages.clear();
    }

    // Param is passed by value, moved
    pub fn set_messages(&mut self, v: ::std::vec::Vec<cchat_room_chat_message_modified_notification::ChatMessage>) {
        self.messages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_messages(&mut self) -> &mut ::std::vec::Vec<cchat_room_chat_message_modified_notification::ChatMessage> {
        &mut self.messages
    }

    // Take field
    pub fn take_messages(&mut self) -> ::std::vec::Vec<cchat_room_chat_message_modified_notification::ChatMessage> {
        ::std::mem::replace(&mut self.messages, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ChatMessageModified_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_ChatMessageModified_Notification| { &m.chat_id },
            |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "messages",
            |m: &CChatRoom_ChatMessageModified_Notification| { &m.messages },
            |m: &mut CChatRoom_ChatMessageModified_Notification| { &mut m.messages },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ChatMessageModified_Notification>(
            "CChatRoom_ChatMessageModified_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_ChatMessageModified_Notification {
    const NAME: &'static str = "CChatRoom_ChatMessageModified_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.messages.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        for value in &self.messages {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.messages {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ChatMessageModified_Notification {
        CChatRoom_ChatMessageModified_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ChatMessageModified_Notification {
        static instance: CChatRoom_ChatMessageModified_Notification = CChatRoom_ChatMessageModified_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            messages: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_ChatMessageModified_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ChatMessageModified_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ChatMessageModified_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_ChatMessageModified_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoom_ChatMessageModified_Notification`
pub mod cchat_room_chat_message_modified_notification {
    // @@protoc_insertion_point(message:CChatRoom_ChatMessageModified_Notification.ChatMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChatMessage {
        // message fields
        // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.ChatMessage.server_timestamp)
        pub server_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.ChatMessage.ordinal)
        pub ordinal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoom_ChatMessageModified_Notification.ChatMessage.deleted)
        pub deleted: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoom_ChatMessageModified_Notification.ChatMessage.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChatMessage {
        fn default() -> &'a ChatMessage {
            <ChatMessage as crate::Message>::default_instance()
        }
    }

    impl ChatMessage {
        pub fn new() -> ChatMessage {
            ::std::default::Default::default()
        }

        // optional uint32 server_timestamp = 1;

        pub fn server_timestamp(&self) -> u32 {
            self.server_timestamp.unwrap_or(0)
        }

        pub fn clear_server_timestamp(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
        }

        pub fn has_server_timestamp(&self) -> bool {
            self.server_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_timestamp(&mut self, v: u32) {
            self.server_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 ordinal = 2;

        pub fn ordinal(&self) -> u32 {
            self.ordinal.unwrap_or(0)
        }

        pub fn clear_ordinal(&mut self) {
            self.ordinal = ::std::option::Option::None;
        }

        pub fn has_ordinal(&self) -> bool {
            self.ordinal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ordinal(&mut self, v: u32) {
            self.ordinal = ::std::option::Option::Some(v);
        }

        // optional bool deleted = 3;

        pub fn deleted(&self) -> bool {
            self.deleted.unwrap_or(false)
        }

        pub fn clear_deleted(&mut self) {
            self.deleted = ::std::option::Option::None;
        }

        pub fn has_deleted(&self) -> bool {
            self.deleted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deleted(&mut self, v: bool) {
            self.deleted = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "server_timestamp",
                |m: &ChatMessage| { &m.server_timestamp },
                |m: &mut ChatMessage| { &mut m.server_timestamp },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "ordinal",
                |m: &ChatMessage| { &m.ordinal },
                |m: &mut ChatMessage| { &mut m.ordinal },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "deleted",
                |m: &ChatMessage| { &m.deleted },
                |m: &mut ChatMessage| { &mut m.deleted },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ChatMessage>(
                "CChatRoom_ChatMessageModified_Notification.ChatMessage",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ChatMessage {
        const NAME: &'static str = "ChatMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.deleted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_timestamp {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ordinal {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.deleted {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.server_timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ordinal {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.deleted {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChatMessage {
            ChatMessage::new()
        }

        fn clear(&mut self) {
            self.server_timestamp = ::std::option::Option::None;
            self.ordinal = ::std::option::Option::None;
            self.deleted = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChatMessage {
            static instance: ChatMessage = ChatMessage {
                server_timestamp: ::std::option::Option::None,
                ordinal: ::std::option::Option::None,
                deleted: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ChatMessage {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoom_ChatMessageModified_Notification.ChatMessage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ChatMessage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ChatMessage {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_MemberStateChange_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MemberStateChange_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_MemberStateChange_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MemberStateChange_Notification.member)
    pub member: crate::MessageField<CChatRoomMember>,
    // @@protoc_insertion_point(field:CChatRoom_MemberStateChange_Notification.change)
    pub change: ::std::option::Option<crate::EnumOrUnknown<EChatRoomMemberStateChange>>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MemberStateChange_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MemberStateChange_Notification {
    fn default() -> &'a CChatRoom_MemberStateChange_Notification {
        <CChatRoom_MemberStateChange_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_MemberStateChange_Notification {
    pub fn new() -> CChatRoom_MemberStateChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomMember member = 2;

    pub fn member(&self) -> &CChatRoomMember {
        self.member.as_ref().unwrap_or_else(|| <CChatRoomMember as crate::Message>::default_instance())
    }

    pub fn clear_member(&mut self) {
        self.member.clear();
    }

    pub fn has_member(&self) -> bool {
        self.member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member(&mut self, v: CChatRoomMember) {
        self.member = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_member(&mut self) -> &mut CChatRoomMember {
        self.member.mut_or_insert_default()
    }

    // Take field
    pub fn take_member(&mut self) -> CChatRoomMember {
        self.member.take().unwrap_or_else(|| CChatRoomMember::new())
    }

    // optional .EChatRoomMemberStateChange change = 3;

    pub fn change(&self) -> EChatRoomMemberStateChange {
        match self.change {
            Some(e) => e.enum_value_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            None => EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
        }
    }

    pub fn clear_change(&mut self) {
        self.change = ::std::option::Option::None;
    }

    pub fn has_change(&self) -> bool {
        self.change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change(&mut self, v: EChatRoomMemberStateChange) {
        self.change = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_MemberStateChange_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomMember>(
            "member",
            |m: &CChatRoom_MemberStateChange_Notification| { &m.member },
            |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.member },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "change",
            |m: &CChatRoom_MemberStateChange_Notification| { &m.change },
            |m: &mut CChatRoom_MemberStateChange_Notification| { &mut m.change },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_MemberStateChange_Notification>(
            "CChatRoom_MemberStateChange_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_MemberStateChange_Notification {
    const NAME: &'static str = "CChatRoom_MemberStateChange_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.member)?;
                },
                24 => {
                    self.change = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.member.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.change {
            my_size += crate::rt::int32_size(3, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.member.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.change {
            os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MemberStateChange_Notification {
        CChatRoom_MemberStateChange_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.member.clear();
        self.change = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MemberStateChange_Notification {
        static instance: CChatRoom_MemberStateChange_Notification = CChatRoom_MemberStateChange_Notification {
            chat_group_id: ::std::option::Option::None,
            member: crate::MessageField::none(),
            change: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_MemberStateChange_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_MemberStateChange_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_MemberStateChange_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_MemberStateChange_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ChatRoomHeaderState_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ChatRoomHeaderState_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomHeaderState_Notification.header_state)
    pub header_state: crate::MessageField<CChatRoomGroupHeaderState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ChatRoomHeaderState_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomHeaderState_Notification {
    fn default() -> &'a CChatRoom_ChatRoomHeaderState_Notification {
        <CChatRoom_ChatRoomHeaderState_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomHeaderState_Notification {
    pub fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        ::std::default::Default::default()
    }

    // optional .CChatRoomGroupHeaderState header_state = 1;

    pub fn header_state(&self) -> &CChatRoomGroupHeaderState {
        self.header_state.as_ref().unwrap_or_else(|| <CChatRoomGroupHeaderState as crate::Message>::default_instance())
    }

    pub fn clear_header_state(&mut self) {
        self.header_state.clear();
    }

    pub fn has_header_state(&self) -> bool {
        self.header_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_state(&mut self, v: CChatRoomGroupHeaderState) {
        self.header_state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_state(&mut self) -> &mut CChatRoomGroupHeaderState {
        self.header_state.mut_or_insert_default()
    }

    // Take field
    pub fn take_header_state(&mut self) -> CChatRoomGroupHeaderState {
        self.header_state.take().unwrap_or_else(|| CChatRoomGroupHeaderState::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomGroupHeaderState>(
            "header_state",
            |m: &CChatRoom_ChatRoomHeaderState_Notification| { &m.header_state },
            |m: &mut CChatRoom_ChatRoomHeaderState_Notification| { &mut m.header_state },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ChatRoomHeaderState_Notification>(
            "CChatRoom_ChatRoomHeaderState_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_ChatRoomHeaderState_Notification {
    const NAME: &'static str = "CChatRoom_ChatRoomHeaderState_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.header_state)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.header_state.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ChatRoomHeaderState_Notification {
        CChatRoom_ChatRoomHeaderState_Notification::new()
    }

    fn clear(&mut self) {
        self.header_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomHeaderState_Notification {
        static instance: CChatRoom_ChatRoomHeaderState_Notification = CChatRoom_ChatRoomHeaderState_Notification {
            header_state: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_ChatRoomHeaderState_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ChatRoomHeaderState_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ChatRoomHeaderState_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_ChatRoomHeaderState_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_ChatRoomGroupRoomsChange_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_ChatRoomGroupRoomsChange_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomGroupRoomsChange_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomGroupRoomsChange_Notification.default_chat_id)
    pub default_chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_ChatRoomGroupRoomsChange_Notification.chat_rooms)
    pub chat_rooms: ::std::vec::Vec<CChatRoomState>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_ChatRoomGroupRoomsChange_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn default() -> &'a CChatRoom_ChatRoomGroupRoomsChange_Notification {
        <CChatRoom_ChatRoomGroupRoomsChange_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_ChatRoomGroupRoomsChange_Notification {
    pub fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 default_chat_id = 2;

    pub fn default_chat_id(&self) -> u64 {
        self.default_chat_id.unwrap_or(0)
    }

    pub fn clear_default_chat_id(&mut self) {
        self.default_chat_id = ::std::option::Option::None;
    }

    pub fn has_default_chat_id(&self) -> bool {
        self.default_chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_chat_id(&mut self, v: u64) {
        self.default_chat_id = ::std::option::Option::Some(v);
    }

    // repeated .CChatRoomState chat_rooms = 3;

    pub fn chat_rooms(&self) -> &[CChatRoomState] {
        &self.chat_rooms
    }

    pub fn clear_chat_rooms(&mut self) {
        self.chat_rooms.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_rooms(&mut self, v: ::std::vec::Vec<CChatRoomState>) {
        self.chat_rooms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_rooms(&mut self) -> &mut ::std::vec::Vec<CChatRoomState> {
        &mut self.chat_rooms
    }

    // Take field
    pub fn take_chat_rooms(&mut self) -> ::std::vec::Vec<CChatRoomState> {
        ::std::mem::replace(&mut self.chat_rooms, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_chat_id",
            |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.default_chat_id },
            |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.default_chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_rooms",
            |m: &CChatRoom_ChatRoomGroupRoomsChange_Notification| { &m.chat_rooms },
            |m: &mut CChatRoom_ChatRoomGroupRoomsChange_Notification| { &mut m.chat_rooms },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_ChatRoomGroupRoomsChange_Notification>(
            "CChatRoom_ChatRoomGroupRoomsChange_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    const NAME: &'static str = "CChatRoom_ChatRoomGroupRoomsChange_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.default_chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.chat_rooms.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.default_chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        for value in &self.chat_rooms {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.default_chat_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.chat_rooms {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_ChatRoomGroupRoomsChange_Notification {
        CChatRoom_ChatRoomGroupRoomsChange_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.default_chat_id = ::std::option::Option::None;
        self.chat_rooms.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_ChatRoomGroupRoomsChange_Notification {
        static instance: CChatRoom_ChatRoomGroupRoomsChange_Notification = CChatRoom_ChatRoomGroupRoomsChange_Notification {
            chat_group_id: ::std::option::Option::None,
            default_chat_id: ::std::option::Option::None,
            chat_rooms: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_ChatRoomGroupRoomsChange_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_ChatRoomGroupRoomsChange_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn default() -> &'a CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        <CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    pub fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &m.chat_id },
            |m: &mut CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification| { &mut m.chat_group_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification>(
            "CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    const NAME: &'static str = "CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
        static instance: CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification = CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
            chat_id: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    // message fields
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.user_chat_group_state)
    pub user_chat_group_state: crate::MessageField<CUserChatRoomGroupState>,
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.group_summary)
    pub group_summary: crate::MessageField<CChatRoom_GetChatRoomGroupSummary_Response>,
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.user_action)
    pub user_action: ::std::option::Option<crate::EnumOrUnknown<EChatRoomMemberStateChange>>,
    // special fields
    // @@protoc_insertion_point(special_field:ChatRoomClient_NotifyChatGroupUserStateChanged_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn default() -> &'a ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        <ChatRoomClient_NotifyChatGroupUserStateChanged_Notification as crate::Message>::default_instance()
    }
}

impl ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    pub fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional .CUserChatRoomGroupState user_chat_group_state = 2;

    pub fn user_chat_group_state(&self) -> &CUserChatRoomGroupState {
        self.user_chat_group_state.as_ref().unwrap_or_else(|| <CUserChatRoomGroupState as crate::Message>::default_instance())
    }

    pub fn clear_user_chat_group_state(&mut self) {
        self.user_chat_group_state.clear();
    }

    pub fn has_user_chat_group_state(&self) -> bool {
        self.user_chat_group_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_chat_group_state(&mut self, v: CUserChatRoomGroupState) {
        self.user_chat_group_state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_chat_group_state(&mut self) -> &mut CUserChatRoomGroupState {
        self.user_chat_group_state.mut_or_insert_default()
    }

    // Take field
    pub fn take_user_chat_group_state(&mut self) -> CUserChatRoomGroupState {
        self.user_chat_group_state.take().unwrap_or_else(|| CUserChatRoomGroupState::new())
    }

    // optional .CChatRoom_GetChatRoomGroupSummary_Response group_summary = 3;

    pub fn group_summary(&self) -> &CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.as_ref().unwrap_or_else(|| <CChatRoom_GetChatRoomGroupSummary_Response as crate::Message>::default_instance())
    }

    pub fn clear_group_summary(&mut self) {
        self.group_summary.clear();
    }

    pub fn has_group_summary(&self) -> bool {
        self.group_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_summary(&mut self, v: CChatRoom_GetChatRoomGroupSummary_Response) {
        self.group_summary = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_summary(&mut self) -> &mut CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.mut_or_insert_default()
    }

    // Take field
    pub fn take_group_summary(&mut self) -> CChatRoom_GetChatRoomGroupSummary_Response {
        self.group_summary.take().unwrap_or_else(|| CChatRoom_GetChatRoomGroupSummary_Response::new())
    }

    // optional .EChatRoomMemberStateChange user_action = 4;

    pub fn user_action(&self) -> EChatRoomMemberStateChange {
        match self.user_action {
            Some(e) => e.enum_value_or(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            None => EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
        }
    }

    pub fn clear_user_action(&mut self) {
        self.user_action = ::std::option::Option::None;
    }

    pub fn has_user_action(&self) -> bool {
        self.user_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_action(&mut self, v: EChatRoomMemberStateChange) {
        self.user_action = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.chat_group_id },
            |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CUserChatRoomGroupState>(
            "user_chat_group_state",
            |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.user_chat_group_state },
            |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.user_chat_group_state },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoom_GetChatRoomGroupSummary_Response>(
            "group_summary",
            |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.group_summary },
            |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.group_summary },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_action",
            |m: &ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &m.user_action },
            |m: &mut ChatRoomClient_NotifyChatGroupUserStateChanged_Notification| { &mut m.user_action },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ChatRoomClient_NotifyChatGroupUserStateChanged_Notification>(
            "ChatRoomClient_NotifyChatGroupUserStateChanged_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    const NAME: &'static str = "ChatRoomClient_NotifyChatGroupUserStateChanged_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.user_chat_group_state)?;
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.group_summary)?;
                },
                32 => {
                    self.user_action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.group_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.user_action {
            my_size += crate::rt::int32_size(4, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.user_chat_group_state.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.group_summary.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.user_action {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        ChatRoomClient_NotifyChatGroupUserStateChanged_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.user_chat_group_state.clear();
        self.group_summary.clear();
        self.user_action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
        static instance: ChatRoomClient_NotifyChatGroupUserStateChanged_Notification = ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
            chat_group_id: ::std::option::Option::None,
            user_chat_group_state: crate::MessageField::none(),
            group_summary: crate::MessageField::none(),
            user_action: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatRoomClient_NotifyChatGroupUserStateChanged_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ChatRoomClient_NotifyChatGroupUserStateChanged_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ChatRoomClient_NotifyChatRoomDisconnect_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    // message fields
    // @@protoc_insertion_point(field:ChatRoomClient_NotifyChatRoomDisconnect_Notification.chat_group_ids)
    pub chat_group_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ChatRoomClient_NotifyChatRoomDisconnect_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn default() -> &'a ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        <ChatRoomClient_NotifyChatRoomDisconnect_Notification as crate::Message>::default_instance()
    }
}

impl ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    pub fn new() -> ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        ::std::default::Default::default()
    }

    // repeated uint64 chat_group_ids = 1;

    pub fn chat_group_ids(&self) -> &[u64] {
        &self.chat_group_ids
    }

    pub fn clear_chat_group_ids(&mut self) {
        self.chat_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_chat_group_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.chat_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_chat_group_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.chat_group_ids
    }

    // Take field
    pub fn take_chat_group_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.chat_group_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chat_group_ids",
            |m: &ChatRoomClient_NotifyChatRoomDisconnect_Notification| { &m.chat_group_ids },
            |m: &mut ChatRoomClient_NotifyChatRoomDisconnect_Notification| { &mut m.chat_group_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ChatRoomClient_NotifyChatRoomDisconnect_Notification>(
            "ChatRoomClient_NotifyChatRoomDisconnect_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    const NAME: &'static str = "ChatRoomClient_NotifyChatRoomDisconnect_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.chat_group_ids)?;
                },
                8 => {
                    self.chat_group_ids.push(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chat_group_ids {
            my_size += crate::rt::uint64_size(1, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.chat_group_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        ChatRoomClient_NotifyChatRoomDisconnect_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatRoomClient_NotifyChatRoomDisconnect_Notification {
        static instance: ChatRoomClient_NotifyChatRoomDisconnect_Notification = ChatRoomClient_NotifyChatRoomDisconnect_Notification {
            chat_group_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatRoomClient_NotifyChatRoomDisconnect_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ChatRoomClient_NotifyChatRoomDisconnect_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomMemberListView)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomMemberListView {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomMemberListView.start)
    pub start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.end)
    pub end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.total_count)
    pub total_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.client_changenumber)
    pub client_changenumber: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberListView.server_changenumber)
    pub server_changenumber: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomMemberListView.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomMemberListView {
    fn default() -> &'a CChatRoomMemberListView {
        <CChatRoomMemberListView as crate::Message>::default_instance()
    }
}

impl CChatRoomMemberListView {
    pub fn new() -> CChatRoomMemberListView {
        ::std::default::Default::default()
    }

    // optional int32 start = 3;

    pub fn start(&self) -> i32 {
        self.start.unwrap_or(0)
    }

    pub fn clear_start(&mut self) {
        self.start = ::std::option::Option::None;
    }

    pub fn has_start(&self) -> bool {
        self.start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i32) {
        self.start = ::std::option::Option::Some(v);
    }

    // optional int32 end = 4;

    pub fn end(&self) -> i32 {
        self.end.unwrap_or(0)
    }

    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i32) {
        self.end = ::std::option::Option::Some(v);
    }

    // optional int32 total_count = 5;

    pub fn total_count(&self) -> i32 {
        self.total_count.unwrap_or(0)
    }

    pub fn clear_total_count(&mut self) {
        self.total_count = ::std::option::Option::None;
    }

    pub fn has_total_count(&self) -> bool {
        self.total_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i32) {
        self.total_count = ::std::option::Option::Some(v);
    }

    // optional int32 client_changenumber = 6;

    pub fn client_changenumber(&self) -> i32 {
        self.client_changenumber.unwrap_or(0)
    }

    pub fn clear_client_changenumber(&mut self) {
        self.client_changenumber = ::std::option::Option::None;
    }

    pub fn has_client_changenumber(&self) -> bool {
        self.client_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_changenumber(&mut self, v: i32) {
        self.client_changenumber = ::std::option::Option::Some(v);
    }

    // optional int32 server_changenumber = 7;

    pub fn server_changenumber(&self) -> i32 {
        self.server_changenumber.unwrap_or(0)
    }

    pub fn clear_server_changenumber(&mut self) {
        self.server_changenumber = ::std::option::Option::None;
    }

    pub fn has_server_changenumber(&self) -> bool {
        self.server_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_changenumber(&mut self, v: i32) {
        self.server_changenumber = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "start",
            |m: &CChatRoomMemberListView| { &m.start },
            |m: &mut CChatRoomMemberListView| { &mut m.start },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "end",
            |m: &CChatRoomMemberListView| { &m.end },
            |m: &mut CChatRoomMemberListView| { &mut m.end },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_count",
            |m: &CChatRoomMemberListView| { &m.total_count },
            |m: &mut CChatRoomMemberListView| { &mut m.total_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_changenumber",
            |m: &CChatRoomMemberListView| { &m.client_changenumber },
            |m: &mut CChatRoomMemberListView| { &mut m.client_changenumber },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_changenumber",
            |m: &CChatRoomMemberListView| { &m.server_changenumber },
            |m: &mut CChatRoomMemberListView| { &mut m.server_changenumber },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomMemberListView>(
            "CChatRoomMemberListView",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoomMemberListView {
    const NAME: &'static str = "CChatRoomMemberListView";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.start = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.end = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.total_count = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.client_changenumber = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.server_changenumber = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.end {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.total_count {
            my_size += crate::rt::int32_size(5, v);
        }
        if let Some(v) = self.client_changenumber {
            my_size += crate::rt::int32_size(6, v);
        }
        if let Some(v) = self.server_changenumber {
            my_size += crate::rt::int32_size(7, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.start {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.end {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.total_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.client_changenumber {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.server_changenumber {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomMemberListView {
        CChatRoomMemberListView::new()
    }

    fn clear(&mut self) {
        self.start = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.total_count = ::std::option::Option::None;
        self.client_changenumber = ::std::option::Option::None;
        self.server_changenumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomMemberListView {
        static instance: CChatRoomMemberListView = CChatRoomMemberListView {
            start: ::std::option::Option::None,
            end: ::std::option::Option::None,
            total_count: ::std::option::Option::None,
            client_changenumber: ::std::option::Option::None,
            server_changenumber: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoomMemberListView {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomMemberListView").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomMemberListView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoomMemberListView {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomMemberSummaryCounts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomMemberSummaryCounts {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomMemberSummaryCounts.ingame)
    pub ingame: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberSummaryCounts.online)
    pub online: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CChatRoomMemberSummaryCounts.offline)
    pub offline: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomMemberSummaryCounts.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomMemberSummaryCounts {
    fn default() -> &'a CChatRoomMemberSummaryCounts {
        <CChatRoomMemberSummaryCounts as crate::Message>::default_instance()
    }
}

impl CChatRoomMemberSummaryCounts {
    pub fn new() -> CChatRoomMemberSummaryCounts {
        ::std::default::Default::default()
    }

    // optional int32 ingame = 1;

    pub fn ingame(&self) -> i32 {
        self.ingame.unwrap_or(0)
    }

    pub fn clear_ingame(&mut self) {
        self.ingame = ::std::option::Option::None;
    }

    pub fn has_ingame(&self) -> bool {
        self.ingame.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingame(&mut self, v: i32) {
        self.ingame = ::std::option::Option::Some(v);
    }

    // optional int32 online = 2;

    pub fn online(&self) -> i32 {
        self.online.unwrap_or(0)
    }

    pub fn clear_online(&mut self) {
        self.online = ::std::option::Option::None;
    }

    pub fn has_online(&self) -> bool {
        self.online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: i32) {
        self.online = ::std::option::Option::Some(v);
    }

    // optional int32 offline = 3;

    pub fn offline(&self) -> i32 {
        self.offline.unwrap_or(0)
    }

    pub fn clear_offline(&mut self) {
        self.offline = ::std::option::Option::None;
    }

    pub fn has_offline(&self) -> bool {
        self.offline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offline(&mut self, v: i32) {
        self.offline = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ingame",
            |m: &CChatRoomMemberSummaryCounts| { &m.ingame },
            |m: &mut CChatRoomMemberSummaryCounts| { &mut m.ingame },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "online",
            |m: &CChatRoomMemberSummaryCounts| { &m.online },
            |m: &mut CChatRoomMemberSummaryCounts| { &mut m.online },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "offline",
            |m: &CChatRoomMemberSummaryCounts| { &m.offline },
            |m: &mut CChatRoomMemberSummaryCounts| { &mut m.offline },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomMemberSummaryCounts>(
            "CChatRoomMemberSummaryCounts",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoomMemberSummaryCounts {
    const NAME: &'static str = "CChatRoomMemberSummaryCounts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ingame = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.online = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.offline = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ingame {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.online {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.offline {
            my_size += crate::rt::int32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.ingame {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.online {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.offline {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomMemberSummaryCounts {
        CChatRoomMemberSummaryCounts::new()
    }

    fn clear(&mut self) {
        self.ingame = ::std::option::Option::None;
        self.online = ::std::option::Option::None;
        self.offline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomMemberSummaryCounts {
        static instance: CChatRoomMemberSummaryCounts = CChatRoomMemberSummaryCounts {
            ingame: ::std::option::Option::None,
            online: ::std::option::Option::None,
            offline: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoomMemberSummaryCounts {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomMemberSummaryCounts").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomMemberSummaryCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoomMemberSummaryCounts {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatRoomClient_MemberListViewUpdated_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoomClient_MemberListViewUpdated_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.view_id)
    pub view_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.view)
    pub view: crate::MessageField<CChatRoomMemberListView>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.members)
    pub members: ::std::vec::Vec<cchat_room_client_member_list_view_updated_notification::MemberListViewEntry>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.status_flags)
    pub status_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.member_summary)
    pub member_summary: crate::MessageField<CChatRoomMemberSummaryCounts>,
    // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.subscribed_personas)
    pub subscribed_personas: ::std::vec::Vec<super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoomClient_MemberListViewUpdated_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoomClient_MemberListViewUpdated_Notification {
    fn default() -> &'a CChatRoomClient_MemberListViewUpdated_Notification {
        <CChatRoomClient_MemberListViewUpdated_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoomClient_MemberListViewUpdated_Notification {
    pub fn new() -> CChatRoomClient_MemberListViewUpdated_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 view_id = 2;

    pub fn view_id(&self) -> u64 {
        self.view_id.unwrap_or(0)
    }

    pub fn clear_view_id(&mut self) {
        self.view_id = ::std::option::Option::None;
    }

    pub fn has_view_id(&self) -> bool {
        self.view_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_id(&mut self, v: u64) {
        self.view_id = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomMemberListView view = 3;

    pub fn view(&self) -> &CChatRoomMemberListView {
        self.view.as_ref().unwrap_or_else(|| <CChatRoomMemberListView as crate::Message>::default_instance())
    }

    pub fn clear_view(&mut self) {
        self.view.clear();
    }

    pub fn has_view(&self) -> bool {
        self.view.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view(&mut self, v: CChatRoomMemberListView) {
        self.view = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view(&mut self) -> &mut CChatRoomMemberListView {
        self.view.mut_or_insert_default()
    }

    // Take field
    pub fn take_view(&mut self) -> CChatRoomMemberListView {
        self.view.take().unwrap_or_else(|| CChatRoomMemberListView::new())
    }

    // repeated .CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry members = 4;

    pub fn members(&self) -> &[cchat_room_client_member_list_view_updated_notification::MemberListViewEntry] {
        &self.members
    }

    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::std::vec::Vec<cchat_room_client_member_list_view_updated_notification::MemberListViewEntry>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members(&mut self) -> &mut ::std::vec::Vec<cchat_room_client_member_list_view_updated_notification::MemberListViewEntry> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::std::vec::Vec<cchat_room_client_member_list_view_updated_notification::MemberListViewEntry> {
        ::std::mem::replace(&mut self.members, ::std::vec::Vec::new())
    }

    // optional uint32 status_flags = 5;

    pub fn status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }

    // optional .CChatRoomMemberSummaryCounts member_summary = 6;

    pub fn member_summary(&self) -> &CChatRoomMemberSummaryCounts {
        self.member_summary.as_ref().unwrap_or_else(|| <CChatRoomMemberSummaryCounts as crate::Message>::default_instance())
    }

    pub fn clear_member_summary(&mut self) {
        self.member_summary.clear();
    }

    pub fn has_member_summary(&self) -> bool {
        self.member_summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_summary(&mut self, v: CChatRoomMemberSummaryCounts) {
        self.member_summary = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_member_summary(&mut self) -> &mut CChatRoomMemberSummaryCounts {
        self.member_summary.mut_or_insert_default()
    }

    // Take field
    pub fn take_member_summary(&mut self) -> CChatRoomMemberSummaryCounts {
        self.member_summary.take().unwrap_or_else(|| CChatRoomMemberSummaryCounts::new())
    }

    // repeated .CMsgClientPersonaState.Friend subscribed_personas = 7;

    pub fn subscribed_personas(&self) -> &[super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend] {
        &self.subscribed_personas
    }

    pub fn clear_subscribed_personas(&mut self) {
        self.subscribed_personas.clear();
    }

    // Param is passed by value, moved
    pub fn set_subscribed_personas(&mut self, v: ::std::vec::Vec<super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>) {
        self.subscribed_personas = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subscribed_personas(&mut self) -> &mut ::std::vec::Vec<super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend> {
        &mut self.subscribed_personas
    }

    // Take field
    pub fn take_subscribed_personas(&mut self) -> ::std::vec::Vec<super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend> {
        ::std::mem::replace(&mut self.subscribed_personas, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.chat_group_id },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_id",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.view_id },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.view_id },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomMemberListView>(
            "view",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.view },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.view },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "members",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.members },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.members },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_flags",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.status_flags },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.status_flags },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CChatRoomMemberSummaryCounts>(
            "member_summary",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.member_summary },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.member_summary },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subscribed_personas",
            |m: &CChatRoomClient_MemberListViewUpdated_Notification| { &m.subscribed_personas },
            |m: &mut CChatRoomClient_MemberListViewUpdated_Notification| { &mut m.subscribed_personas },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoomClient_MemberListViewUpdated_Notification>(
            "CChatRoomClient_MemberListViewUpdated_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoomClient_MemberListViewUpdated_Notification {
    const NAME: &'static str = "CChatRoomClient_MemberListViewUpdated_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.view_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.view)?;
                },
                34 => {
                    self.members.push(is.read_message()?);
                },
                40 => {
                    self.status_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.member_summary)?;
                },
                58 => {
                    self.subscribed_personas.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.view_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.view.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.status_flags {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.member_summary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.subscribed_personas {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.view_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.view.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.members {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.status_flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.member_summary.as_ref() {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.subscribed_personas {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoomClient_MemberListViewUpdated_Notification {
        CChatRoomClient_MemberListViewUpdated_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.view_id = ::std::option::Option::None;
        self.view.clear();
        self.members.clear();
        self.status_flags = ::std::option::Option::None;
        self.member_summary.clear();
        self.subscribed_personas.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoomClient_MemberListViewUpdated_Notification {
        static instance: CChatRoomClient_MemberListViewUpdated_Notification = CChatRoomClient_MemberListViewUpdated_Notification {
            chat_group_id: ::std::option::Option::None,
            view_id: ::std::option::Option::None,
            view: crate::MessageField::none(),
            members: ::std::vec::Vec::new(),
            status_flags: ::std::option::Option::None,
            member_summary: crate::MessageField::none(),
            subscribed_personas: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoomClient_MemberListViewUpdated_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoomClient_MemberListViewUpdated_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoomClient_MemberListViewUpdated_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoomClient_MemberListViewUpdated_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatRoomClient_MemberListViewUpdated_Notification`
pub mod cchat_room_client_member_list_view_updated_notification {
    // @@protoc_insertion_point(message:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MemberListViewEntry {
        // message fields
        // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.rank)
        pub rank: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.persona)
        pub persona: crate::MessageField<super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MemberListViewEntry {
        fn default() -> &'a MemberListViewEntry {
            <MemberListViewEntry as crate::Message>::default_instance()
        }
    }

    impl MemberListViewEntry {
        pub fn new() -> MemberListViewEntry {
            ::std::default::Default::default()
        }

        // optional int32 rank = 1;

        pub fn rank(&self) -> i32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: i32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional uint32 accountid = 2;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional .CMsgClientPersonaState.Friend persona = 3;

        pub fn persona(&self) -> &super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend {
            self.persona.as_ref().unwrap_or_else(|| <super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend as crate::Message>::default_instance())
        }

        pub fn clear_persona(&mut self) {
            self.persona.clear();
        }

        pub fn has_persona(&self) -> bool {
            self.persona.is_some()
        }

        // Param is passed by value, moved
        pub fn set_persona(&mut self, v: super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend) {
            self.persona = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_persona(&mut self) -> &mut super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend {
            self.persona.mut_or_insert_default()
        }

        // Take field
        pub fn take_persona(&mut self) -> super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend {
            self.persona.take().unwrap_or_else(|| super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank",
                |m: &MemberListViewEntry| { &m.rank },
                |m: &mut MemberListViewEntry| { &mut m.rank },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &MemberListViewEntry| { &m.accountid },
                |m: &mut MemberListViewEntry| { &mut m.accountid },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::super::steammessages_clientserver_friends::cmsg_client_persona_state::Friend>(
                "persona",
                |m: &MemberListViewEntry| { &m.persona },
                |m: &mut MemberListViewEntry| { &mut m.persona },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<MemberListViewEntry>(
                "CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for MemberListViewEntry {
        const NAME: &'static str = "MemberListViewEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rank = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.persona)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.rank {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.accountid {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.persona.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.rank {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.accountid {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.persona.as_ref() {
                crate::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MemberListViewEntry {
            MemberListViewEntry::new()
        }

        fn clear(&mut self) {
            self.rank = ::std::option::Option::None;
            self.accountid = ::std::option::Option::None;
            self.persona.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MemberListViewEntry {
            static instance: MemberListViewEntry = MemberListViewEntry {
                rank: ::std::option::Option::None,
                accountid: ::std::option::Option::None,
                persona: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for MemberListViewEntry {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatRoomClient_MemberListViewUpdated_Notification.MemberListViewEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for MemberListViewEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for MemberListViewEntry {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatRoom_MessageReaction_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatRoom_MessageReaction_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.server_timestamp)
    pub server_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.ordinal)
    pub ordinal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.reactor)
    pub reactor: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.reaction_type)
    pub reaction_type: ::std::option::Option<crate::EnumOrUnknown<EChatRoomMessageReactionType>>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.reaction)
    pub reaction: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CChatRoom_MessageReaction_Notification.is_add)
    pub is_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatRoom_MessageReaction_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatRoom_MessageReaction_Notification {
    fn default() -> &'a CChatRoom_MessageReaction_Notification {
        <CChatRoom_MessageReaction_Notification as crate::Message>::default_instance()
    }
}

impl CChatRoom_MessageReaction_Notification {
    pub fn new() -> CChatRoom_MessageReaction_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 chat_group_id = 1;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_id = 2;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_timestamp = 3;

    pub fn server_timestamp(&self) -> u32 {
        self.server_timestamp.unwrap_or(0)
    }

    pub fn clear_server_timestamp(&mut self) {
        self.server_timestamp = ::std::option::Option::None;
    }

    pub fn has_server_timestamp(&self) -> bool {
        self.server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_timestamp(&mut self, v: u32) {
        self.server_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 ordinal = 4;

    pub fn ordinal(&self) -> u32 {
        self.ordinal.unwrap_or(0)
    }

    pub fn clear_ordinal(&mut self) {
        self.ordinal = ::std::option::Option::None;
    }

    pub fn has_ordinal(&self) -> bool {
        self.ordinal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ordinal(&mut self, v: u32) {
        self.ordinal = ::std::option::Option::Some(v);
    }

    // optional fixed64 reactor = 5;

    pub fn reactor(&self) -> u64 {
        self.reactor.unwrap_or(0)
    }

    pub fn clear_reactor(&mut self) {
        self.reactor = ::std::option::Option::None;
    }

    pub fn has_reactor(&self) -> bool {
        self.reactor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reactor(&mut self, v: u64) {
        self.reactor = ::std::option::Option::Some(v);
    }

    // optional .EChatRoomMessageReactionType reaction_type = 6;

    pub fn reaction_type(&self) -> EChatRoomMessageReactionType {
        match self.reaction_type {
            Some(e) => e.enum_value_or(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            None => EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        }
    }

    pub fn clear_reaction_type(&mut self) {
        self.reaction_type = ::std::option::Option::None;
    }

    pub fn has_reaction_type(&self) -> bool {
        self.reaction_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction_type(&mut self, v: EChatRoomMessageReactionType) {
        self.reaction_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string reaction = 7;

    pub fn reaction(&self) -> &str {
        match self.reaction.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reaction(&mut self) {
        self.reaction = ::std::option::Option::None;
    }

    pub fn has_reaction(&self) -> bool {
        self.reaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reaction(&mut self, v: ::std::string::String) {
        self.reaction = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reaction(&mut self) -> &mut ::std::string::String {
        if self.reaction.is_none() {
            self.reaction = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_reaction(&mut self) -> ::std::string::String {
        self.reaction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 8;

    pub fn is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }

    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CChatRoom_MessageReaction_Notification| { &m.chat_group_id },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.chat_group_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CChatRoom_MessageReaction_Notification| { &m.chat_id },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_timestamp",
            |m: &CChatRoom_MessageReaction_Notification| { &m.server_timestamp },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.server_timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ordinal",
            |m: &CChatRoom_MessageReaction_Notification| { &m.ordinal },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.ordinal },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reactor",
            |m: &CChatRoom_MessageReaction_Notification| { &m.reactor },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.reactor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction_type",
            |m: &CChatRoom_MessageReaction_Notification| { &m.reaction_type },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.reaction_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reaction",
            |m: &CChatRoom_MessageReaction_Notification| { &m.reaction },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.reaction },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_add",
            |m: &CChatRoom_MessageReaction_Notification| { &m.is_add },
            |m: &mut CChatRoom_MessageReaction_Notification| { &mut m.is_add },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatRoom_MessageReaction_Notification>(
            "CChatRoom_MessageReaction_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatRoom_MessageReaction_Notification {
    const NAME: &'static str = "CChatRoom_MessageReaction_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.chat_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.server_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ordinal = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.reactor = ::std::option::Option::Some(is.read_fixed64()?);
                },
                48 => {
                    self.reaction_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    self.reaction = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.is_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.chat_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_timestamp {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ordinal {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reactor {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reaction_type {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.reaction.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.chat_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ordinal {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reactor {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.reaction_type {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reaction.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatRoom_MessageReaction_Notification {
        CChatRoom_MessageReaction_Notification::new()
    }

    fn clear(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
        self.chat_id = ::std::option::Option::None;
        self.server_timestamp = ::std::option::Option::None;
        self.ordinal = ::std::option::Option::None;
        self.reactor = ::std::option::Option::None;
        self.reaction_type = ::std::option::Option::None;
        self.reaction = ::std::option::Option::None;
        self.is_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatRoom_MessageReaction_Notification {
        static instance: CChatRoom_MessageReaction_Notification = CChatRoom_MessageReaction_Notification {
            chat_group_id: ::std::option::Option::None,
            chat_id: ::std::option::Option::None,
            server_timestamp: ::std::option::Option::None,
            ordinal: ::std::option::Option::None,
            reactor: ::std::option::Option::None,
            reaction_type: ::std::option::Option::None,
            reaction: ::std::option::Option::None,
            is_add: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatRoom_MessageReaction_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatRoom_MessageReaction_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatRoom_MessageReaction_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatRoom_MessageReaction_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatUsability_ClientUsabilityMetrics_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.metrics_run_id)
    pub metrics_run_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.client_build)
    pub client_build: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.metrics_version)
    pub metrics_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.in_web)
    pub in_web: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.settings)
    pub settings: crate::MessageField<cchat_usability_client_usability_metrics_notification::Settings>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.voice_settings)
    pub voice_settings: crate::MessageField<cchat_usability_client_usability_metrics_notification::VoiceSettings>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.ui_state)
    pub ui_state: crate::MessageField<cchat_usability_client_usability_metrics_notification::UIState>,
    // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.metrics)
    pub metrics: crate::MessageField<cchat_usability_client_usability_metrics_notification::Metrics>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatUsability_ClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_ClientUsabilityMetrics_Notification {
        <CChatUsability_ClientUsabilityMetrics_Notification as crate::Message>::default_instance()
    }
}

impl CChatUsability_ClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;

    pub fn metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }

    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_build = 2;

    pub fn client_build(&self) -> u32 {
        self.client_build.unwrap_or(0)
    }

    pub fn clear_client_build(&mut self) {
        self.client_build = ::std::option::Option::None;
    }

    pub fn has_client_build(&self) -> bool {
        self.client_build.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_build(&mut self, v: u32) {
        self.client_build = ::std::option::Option::Some(v);
    }

    // optional uint32 metrics_version = 3;

    pub fn metrics_version(&self) -> u32 {
        self.metrics_version.unwrap_or(0)
    }

    pub fn clear_metrics_version(&mut self) {
        self.metrics_version = ::std::option::Option::None;
    }

    pub fn has_metrics_version(&self) -> bool {
        self.metrics_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_version(&mut self, v: u32) {
        self.metrics_version = ::std::option::Option::Some(v);
    }

    // optional bool in_web = 4;

    pub fn in_web(&self) -> bool {
        self.in_web.unwrap_or(false)
    }

    pub fn clear_in_web(&mut self) {
        self.in_web = ::std::option::Option::None;
    }

    pub fn has_in_web(&self) -> bool {
        self.in_web.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_web(&mut self, v: bool) {
        self.in_web = ::std::option::Option::Some(v);
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.Settings settings = 10;

    pub fn settings(&self) -> &cchat_usability_client_usability_metrics_notification::Settings {
        self.settings.as_ref().unwrap_or_else(|| <cchat_usability_client_usability_metrics_notification::Settings as crate::Message>::default_instance())
    }

    pub fn clear_settings(&mut self) {
        self.settings.clear();
    }

    pub fn has_settings(&self) -> bool {
        self.settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settings(&mut self, v: cchat_usability_client_usability_metrics_notification::Settings) {
        self.settings = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_settings(&mut self) -> &mut cchat_usability_client_usability_metrics_notification::Settings {
        self.settings.mut_or_insert_default()
    }

    // Take field
    pub fn take_settings(&mut self) -> cchat_usability_client_usability_metrics_notification::Settings {
        self.settings.take().unwrap_or_else(|| cchat_usability_client_usability_metrics_notification::Settings::new())
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings voice_settings = 11;

    pub fn voice_settings(&self) -> &cchat_usability_client_usability_metrics_notification::VoiceSettings {
        self.voice_settings.as_ref().unwrap_or_else(|| <cchat_usability_client_usability_metrics_notification::VoiceSettings as crate::Message>::default_instance())
    }

    pub fn clear_voice_settings(&mut self) {
        self.voice_settings.clear();
    }

    pub fn has_voice_settings(&self) -> bool {
        self.voice_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_settings(&mut self, v: cchat_usability_client_usability_metrics_notification::VoiceSettings) {
        self.voice_settings = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_settings(&mut self) -> &mut cchat_usability_client_usability_metrics_notification::VoiceSettings {
        self.voice_settings.mut_or_insert_default()
    }

    // Take field
    pub fn take_voice_settings(&mut self) -> cchat_usability_client_usability_metrics_notification::VoiceSettings {
        self.voice_settings.take().unwrap_or_else(|| cchat_usability_client_usability_metrics_notification::VoiceSettings::new())
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.UIState ui_state = 12;

    pub fn ui_state(&self) -> &cchat_usability_client_usability_metrics_notification::UIState {
        self.ui_state.as_ref().unwrap_or_else(|| <cchat_usability_client_usability_metrics_notification::UIState as crate::Message>::default_instance())
    }

    pub fn clear_ui_state(&mut self) {
        self.ui_state.clear();
    }

    pub fn has_ui_state(&self) -> bool {
        self.ui_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_state(&mut self, v: cchat_usability_client_usability_metrics_notification::UIState) {
        self.ui_state = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ui_state(&mut self) -> &mut cchat_usability_client_usability_metrics_notification::UIState {
        self.ui_state.mut_or_insert_default()
    }

    // Take field
    pub fn take_ui_state(&mut self) -> cchat_usability_client_usability_metrics_notification::UIState {
        self.ui_state.take().unwrap_or_else(|| cchat_usability_client_usability_metrics_notification::UIState::new())
    }

    // optional .CChatUsability_ClientUsabilityMetrics_Notification.Metrics metrics = 13;

    pub fn metrics(&self) -> &cchat_usability_client_usability_metrics_notification::Metrics {
        self.metrics.as_ref().unwrap_or_else(|| <cchat_usability_client_usability_metrics_notification::Metrics as crate::Message>::default_instance())
    }

    pub fn clear_metrics(&mut self) {
        self.metrics.clear();
    }

    pub fn has_metrics(&self) -> bool {
        self.metrics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics(&mut self, v: cchat_usability_client_usability_metrics_notification::Metrics) {
        self.metrics = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metrics(&mut self) -> &mut cchat_usability_client_usability_metrics_notification::Metrics {
        self.metrics.mut_or_insert_default()
    }

    // Take field
    pub fn take_metrics(&mut self) -> cchat_usability_client_usability_metrics_notification::Metrics {
        self.metrics.take().unwrap_or_else(|| cchat_usability_client_usability_metrics_notification::Metrics::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "metrics_run_id",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics_run_id },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics_run_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_build",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.client_build },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.client_build },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "metrics_version",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics_version },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics_version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "in_web",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.in_web },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.in_web },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cchat_usability_client_usability_metrics_notification::Settings>(
            "settings",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.settings },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.settings },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cchat_usability_client_usability_metrics_notification::VoiceSettings>(
            "voice_settings",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.voice_settings },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.voice_settings },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cchat_usability_client_usability_metrics_notification::UIState>(
            "ui_state",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.ui_state },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.ui_state },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, cchat_usability_client_usability_metrics_notification::Metrics>(
            "metrics",
            |m: &CChatUsability_ClientUsabilityMetrics_Notification| { &m.metrics },
            |m: &mut CChatUsability_ClientUsabilityMetrics_Notification| { &mut m.metrics },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatUsability_ClientUsabilityMetrics_Notification>(
            "CChatUsability_ClientUsabilityMetrics_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatUsability_ClientUsabilityMetrics_Notification {
    const NAME: &'static str = "CChatUsability_ClientUsabilityMetrics_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.metrics_run_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.client_build = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.metrics_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.in_web = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.settings)?;
                },
                90 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.voice_settings)?;
                },
                98 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.ui_state)?;
                },
                106 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.client_build {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.metrics_version {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.in_web {
            my_size += 1 + 1;
        }
        if let Some(v) = self.settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.voice_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ui_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.client_build {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.metrics_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.in_web {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.settings.as_ref() {
            crate::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.voice_settings.as_ref() {
            crate::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.ui_state.as_ref() {
            crate::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.metrics.as_ref() {
            crate::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatUsability_ClientUsabilityMetrics_Notification {
        CChatUsability_ClientUsabilityMetrics_Notification::new()
    }

    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.client_build = ::std::option::Option::None;
        self.metrics_version = ::std::option::Option::None;
        self.in_web = ::std::option::Option::None;
        self.settings.clear();
        self.voice_settings.clear();
        self.ui_state.clear();
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatUsability_ClientUsabilityMetrics_Notification {
        static instance: CChatUsability_ClientUsabilityMetrics_Notification = CChatUsability_ClientUsabilityMetrics_Notification {
            metrics_run_id: ::std::option::Option::None,
            client_build: ::std::option::Option::None,
            metrics_version: ::std::option::Option::None,
            in_web: ::std::option::Option::None,
            settings: crate::MessageField::none(),
            voice_settings: crate::MessageField::none(),
            ui_state: crate::MessageField::none(),
            metrics: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatUsability_ClientUsabilityMetrics_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatUsability_ClientUsabilityMetrics_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatUsability_ClientUsabilityMetrics_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CChatUsability_ClientUsabilityMetrics_Notification`
pub mod cchat_usability_client_usability_metrics_notification {
    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.Settings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Settings {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_ingame)
        pub notifications_show_ingame: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_online)
        pub notifications_show_online: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_message)
        pub notifications_show_message: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_events_and_announcements)
        pub notifications_events_and_announcements: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_ingame)
        pub sounds_play_ingame: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_online)
        pub sounds_play_online: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_message)
        pub sounds_play_message: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_events_and_announcements)
        pub sounds_events_and_announcements: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.always_new_chat_window)
        pub always_new_chat_window: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.force_alphabetic_friend_sorting)
        pub force_alphabetic_friend_sorting: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.chat_flash_mode)
        pub chat_flash_mode: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.remember_open_chats)
        pub remember_open_chats: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.compact_quick_access)
        pub compact_quick_access: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.compact_friends_list)
        pub compact_friends_list: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.notifications_show_chat_room_notification)
        pub notifications_show_chat_room_notification: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sounds_play_chat_room_notification)
        pub sounds_play_chat_room_notification: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.hide_offline_friends_in_tag_groups)
        pub hide_offline_friends_in_tag_groups: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.hide_categorized_friends)
        pub hide_categorized_friends: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.categorize_in_game_friends_by_game)
        pub categorize_in_game_friends_by_game: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.chat_font_size)
        pub chat_font_size: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.use24hour_clock)
        pub use24hour_clock: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.do_not_disturb_mode)
        pub do_not_disturb_mode: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.disable_embed_inlining)
        pub disable_embed_inlining: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.sign_into_friends)
        pub sign_into_friends: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.animated_avatars)
        pub animated_avatars: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.Settings.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Settings {
        fn default() -> &'a Settings {
            <Settings as crate::Message>::default_instance()
        }
    }

    impl Settings {
        pub fn new() -> Settings {
            ::std::default::Default::default()
        }

        // optional bool notifications_show_ingame = 1;

        pub fn notifications_show_ingame(&self) -> bool {
            self.notifications_show_ingame.unwrap_or(false)
        }

        pub fn clear_notifications_show_ingame(&mut self) {
            self.notifications_show_ingame = ::std::option::Option::None;
        }

        pub fn has_notifications_show_ingame(&self) -> bool {
            self.notifications_show_ingame.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_ingame(&mut self, v: bool) {
            self.notifications_show_ingame = ::std::option::Option::Some(v);
        }

        // optional bool notifications_show_online = 2;

        pub fn notifications_show_online(&self) -> bool {
            self.notifications_show_online.unwrap_or(false)
        }

        pub fn clear_notifications_show_online(&mut self) {
            self.notifications_show_online = ::std::option::Option::None;
        }

        pub fn has_notifications_show_online(&self) -> bool {
            self.notifications_show_online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_online(&mut self, v: bool) {
            self.notifications_show_online = ::std::option::Option::Some(v);
        }

        // optional bool notifications_show_message = 3;

        pub fn notifications_show_message(&self) -> bool {
            self.notifications_show_message.unwrap_or(false)
        }

        pub fn clear_notifications_show_message(&mut self) {
            self.notifications_show_message = ::std::option::Option::None;
        }

        pub fn has_notifications_show_message(&self) -> bool {
            self.notifications_show_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_message(&mut self, v: bool) {
            self.notifications_show_message = ::std::option::Option::Some(v);
        }

        // optional bool notifications_events_and_announcements = 4;

        pub fn notifications_events_and_announcements(&self) -> bool {
            self.notifications_events_and_announcements.unwrap_or(false)
        }

        pub fn clear_notifications_events_and_announcements(&mut self) {
            self.notifications_events_and_announcements = ::std::option::Option::None;
        }

        pub fn has_notifications_events_and_announcements(&self) -> bool {
            self.notifications_events_and_announcements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_events_and_announcements(&mut self, v: bool) {
            self.notifications_events_and_announcements = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_ingame = 5;

        pub fn sounds_play_ingame(&self) -> bool {
            self.sounds_play_ingame.unwrap_or(false)
        }

        pub fn clear_sounds_play_ingame(&mut self) {
            self.sounds_play_ingame = ::std::option::Option::None;
        }

        pub fn has_sounds_play_ingame(&self) -> bool {
            self.sounds_play_ingame.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_ingame(&mut self, v: bool) {
            self.sounds_play_ingame = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_online = 6;

        pub fn sounds_play_online(&self) -> bool {
            self.sounds_play_online.unwrap_or(false)
        }

        pub fn clear_sounds_play_online(&mut self) {
            self.sounds_play_online = ::std::option::Option::None;
        }

        pub fn has_sounds_play_online(&self) -> bool {
            self.sounds_play_online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_online(&mut self, v: bool) {
            self.sounds_play_online = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_message = 7;

        pub fn sounds_play_message(&self) -> bool {
            self.sounds_play_message.unwrap_or(false)
        }

        pub fn clear_sounds_play_message(&mut self) {
            self.sounds_play_message = ::std::option::Option::None;
        }

        pub fn has_sounds_play_message(&self) -> bool {
            self.sounds_play_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_message(&mut self, v: bool) {
            self.sounds_play_message = ::std::option::Option::Some(v);
        }

        // optional bool sounds_events_and_announcements = 8;

        pub fn sounds_events_and_announcements(&self) -> bool {
            self.sounds_events_and_announcements.unwrap_or(false)
        }

        pub fn clear_sounds_events_and_announcements(&mut self) {
            self.sounds_events_and_announcements = ::std::option::Option::None;
        }

        pub fn has_sounds_events_and_announcements(&self) -> bool {
            self.sounds_events_and_announcements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_events_and_announcements(&mut self, v: bool) {
            self.sounds_events_and_announcements = ::std::option::Option::Some(v);
        }

        // optional bool always_new_chat_window = 9;

        pub fn always_new_chat_window(&self) -> bool {
            self.always_new_chat_window.unwrap_or(false)
        }

        pub fn clear_always_new_chat_window(&mut self) {
            self.always_new_chat_window = ::std::option::Option::None;
        }

        pub fn has_always_new_chat_window(&self) -> bool {
            self.always_new_chat_window.is_some()
        }

        // Param is passed by value, moved
        pub fn set_always_new_chat_window(&mut self, v: bool) {
            self.always_new_chat_window = ::std::option::Option::Some(v);
        }

        // optional bool force_alphabetic_friend_sorting = 10;

        pub fn force_alphabetic_friend_sorting(&self) -> bool {
            self.force_alphabetic_friend_sorting.unwrap_or(false)
        }

        pub fn clear_force_alphabetic_friend_sorting(&mut self) {
            self.force_alphabetic_friend_sorting = ::std::option::Option::None;
        }

        pub fn has_force_alphabetic_friend_sorting(&self) -> bool {
            self.force_alphabetic_friend_sorting.is_some()
        }

        // Param is passed by value, moved
        pub fn set_force_alphabetic_friend_sorting(&mut self, v: bool) {
            self.force_alphabetic_friend_sorting = ::std::option::Option::Some(v);
        }

        // optional int32 chat_flash_mode = 11;

        pub fn chat_flash_mode(&self) -> i32 {
            self.chat_flash_mode.unwrap_or(0)
        }

        pub fn clear_chat_flash_mode(&mut self) {
            self.chat_flash_mode = ::std::option::Option::None;
        }

        pub fn has_chat_flash_mode(&self) -> bool {
            self.chat_flash_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_flash_mode(&mut self, v: i32) {
            self.chat_flash_mode = ::std::option::Option::Some(v);
        }

        // optional bool remember_open_chats = 12;

        pub fn remember_open_chats(&self) -> bool {
            self.remember_open_chats.unwrap_or(false)
        }

        pub fn clear_remember_open_chats(&mut self) {
            self.remember_open_chats = ::std::option::Option::None;
        }

        pub fn has_remember_open_chats(&self) -> bool {
            self.remember_open_chats.is_some()
        }

        // Param is passed by value, moved
        pub fn set_remember_open_chats(&mut self, v: bool) {
            self.remember_open_chats = ::std::option::Option::Some(v);
        }

        // optional bool compact_quick_access = 13;

        pub fn compact_quick_access(&self) -> bool {
            self.compact_quick_access.unwrap_or(false)
        }

        pub fn clear_compact_quick_access(&mut self) {
            self.compact_quick_access = ::std::option::Option::None;
        }

        pub fn has_compact_quick_access(&self) -> bool {
            self.compact_quick_access.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compact_quick_access(&mut self, v: bool) {
            self.compact_quick_access = ::std::option::Option::Some(v);
        }

        // optional bool compact_friends_list = 14;

        pub fn compact_friends_list(&self) -> bool {
            self.compact_friends_list.unwrap_or(false)
        }

        pub fn clear_compact_friends_list(&mut self) {
            self.compact_friends_list = ::std::option::Option::None;
        }

        pub fn has_compact_friends_list(&self) -> bool {
            self.compact_friends_list.is_some()
        }

        // Param is passed by value, moved
        pub fn set_compact_friends_list(&mut self, v: bool) {
            self.compact_friends_list = ::std::option::Option::Some(v);
        }

        // optional bool notifications_show_chat_room_notification = 15;

        pub fn notifications_show_chat_room_notification(&self) -> bool {
            self.notifications_show_chat_room_notification.unwrap_or(false)
        }

        pub fn clear_notifications_show_chat_room_notification(&mut self) {
            self.notifications_show_chat_room_notification = ::std::option::Option::None;
        }

        pub fn has_notifications_show_chat_room_notification(&self) -> bool {
            self.notifications_show_chat_room_notification.is_some()
        }

        // Param is passed by value, moved
        pub fn set_notifications_show_chat_room_notification(&mut self, v: bool) {
            self.notifications_show_chat_room_notification = ::std::option::Option::Some(v);
        }

        // optional bool sounds_play_chat_room_notification = 16;

        pub fn sounds_play_chat_room_notification(&self) -> bool {
            self.sounds_play_chat_room_notification.unwrap_or(false)
        }

        pub fn clear_sounds_play_chat_room_notification(&mut self) {
            self.sounds_play_chat_room_notification = ::std::option::Option::None;
        }

        pub fn has_sounds_play_chat_room_notification(&self) -> bool {
            self.sounds_play_chat_room_notification.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sounds_play_chat_room_notification(&mut self, v: bool) {
            self.sounds_play_chat_room_notification = ::std::option::Option::Some(v);
        }

        // optional bool hide_offline_friends_in_tag_groups = 17;

        pub fn hide_offline_friends_in_tag_groups(&self) -> bool {
            self.hide_offline_friends_in_tag_groups.unwrap_or(false)
        }

        pub fn clear_hide_offline_friends_in_tag_groups(&mut self) {
            self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
        }

        pub fn has_hide_offline_friends_in_tag_groups(&self) -> bool {
            self.hide_offline_friends_in_tag_groups.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hide_offline_friends_in_tag_groups(&mut self, v: bool) {
            self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(v);
        }

        // optional bool hide_categorized_friends = 18;

        pub fn hide_categorized_friends(&self) -> bool {
            self.hide_categorized_friends.unwrap_or(false)
        }

        pub fn clear_hide_categorized_friends(&mut self) {
            self.hide_categorized_friends = ::std::option::Option::None;
        }

        pub fn has_hide_categorized_friends(&self) -> bool {
            self.hide_categorized_friends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hide_categorized_friends(&mut self, v: bool) {
            self.hide_categorized_friends = ::std::option::Option::Some(v);
        }

        // optional bool categorize_in_game_friends_by_game = 19;

        pub fn categorize_in_game_friends_by_game(&self) -> bool {
            self.categorize_in_game_friends_by_game.unwrap_or(false)
        }

        pub fn clear_categorize_in_game_friends_by_game(&mut self) {
            self.categorize_in_game_friends_by_game = ::std::option::Option::None;
        }

        pub fn has_categorize_in_game_friends_by_game(&self) -> bool {
            self.categorize_in_game_friends_by_game.is_some()
        }

        // Param is passed by value, moved
        pub fn set_categorize_in_game_friends_by_game(&mut self, v: bool) {
            self.categorize_in_game_friends_by_game = ::std::option::Option::Some(v);
        }

        // optional int32 chat_font_size = 20;

        pub fn chat_font_size(&self) -> i32 {
            self.chat_font_size.unwrap_or(0)
        }

        pub fn clear_chat_font_size(&mut self) {
            self.chat_font_size = ::std::option::Option::None;
        }

        pub fn has_chat_font_size(&self) -> bool {
            self.chat_font_size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_font_size(&mut self, v: i32) {
            self.chat_font_size = ::std::option::Option::Some(v);
        }

        // optional bool use24hour_clock = 21;

        pub fn use24hour_clock(&self) -> bool {
            self.use24hour_clock.unwrap_or(false)
        }

        pub fn clear_use24hour_clock(&mut self) {
            self.use24hour_clock = ::std::option::Option::None;
        }

        pub fn has_use24hour_clock(&self) -> bool {
            self.use24hour_clock.is_some()
        }

        // Param is passed by value, moved
        pub fn set_use24hour_clock(&mut self, v: bool) {
            self.use24hour_clock = ::std::option::Option::Some(v);
        }

        // optional bool do_not_disturb_mode = 22;

        pub fn do_not_disturb_mode(&self) -> bool {
            self.do_not_disturb_mode.unwrap_or(false)
        }

        pub fn clear_do_not_disturb_mode(&mut self) {
            self.do_not_disturb_mode = ::std::option::Option::None;
        }

        pub fn has_do_not_disturb_mode(&self) -> bool {
            self.do_not_disturb_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_do_not_disturb_mode(&mut self, v: bool) {
            self.do_not_disturb_mode = ::std::option::Option::Some(v);
        }

        // optional bool disable_embed_inlining = 23;

        pub fn disable_embed_inlining(&self) -> bool {
            self.disable_embed_inlining.unwrap_or(false)
        }

        pub fn clear_disable_embed_inlining(&mut self) {
            self.disable_embed_inlining = ::std::option::Option::None;
        }

        pub fn has_disable_embed_inlining(&self) -> bool {
            self.disable_embed_inlining.is_some()
        }

        // Param is passed by value, moved
        pub fn set_disable_embed_inlining(&mut self, v: bool) {
            self.disable_embed_inlining = ::std::option::Option::Some(v);
        }

        // optional bool sign_into_friends = 24;

        pub fn sign_into_friends(&self) -> bool {
            self.sign_into_friends.unwrap_or(false)
        }

        pub fn clear_sign_into_friends(&mut self) {
            self.sign_into_friends = ::std::option::Option::None;
        }

        pub fn has_sign_into_friends(&self) -> bool {
            self.sign_into_friends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sign_into_friends(&mut self, v: bool) {
            self.sign_into_friends = ::std::option::Option::Some(v);
        }

        // optional bool animated_avatars = 25;

        pub fn animated_avatars(&self) -> bool {
            self.animated_avatars.unwrap_or(false)
        }

        pub fn clear_animated_avatars(&mut self) {
            self.animated_avatars = ::std::option::Option::None;
        }

        pub fn has_animated_avatars(&self) -> bool {
            self.animated_avatars.is_some()
        }

        // Param is passed by value, moved
        pub fn set_animated_avatars(&mut self, v: bool) {
            self.animated_avatars = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(25);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_show_ingame",
                |m: &Settings| { &m.notifications_show_ingame },
                |m: &mut Settings| { &mut m.notifications_show_ingame },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_show_online",
                |m: &Settings| { &m.notifications_show_online },
                |m: &mut Settings| { &mut m.notifications_show_online },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_show_message",
                |m: &Settings| { &m.notifications_show_message },
                |m: &mut Settings| { &mut m.notifications_show_message },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_events_and_announcements",
                |m: &Settings| { &m.notifications_events_and_announcements },
                |m: &mut Settings| { &mut m.notifications_events_and_announcements },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_play_ingame",
                |m: &Settings| { &m.sounds_play_ingame },
                |m: &mut Settings| { &mut m.sounds_play_ingame },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_play_online",
                |m: &Settings| { &m.sounds_play_online },
                |m: &mut Settings| { &mut m.sounds_play_online },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_play_message",
                |m: &Settings| { &m.sounds_play_message },
                |m: &mut Settings| { &mut m.sounds_play_message },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_events_and_announcements",
                |m: &Settings| { &m.sounds_events_and_announcements },
                |m: &mut Settings| { &mut m.sounds_events_and_announcements },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "always_new_chat_window",
                |m: &Settings| { &m.always_new_chat_window },
                |m: &mut Settings| { &mut m.always_new_chat_window },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "force_alphabetic_friend_sorting",
                |m: &Settings| { &m.force_alphabetic_friend_sorting },
                |m: &mut Settings| { &mut m.force_alphabetic_friend_sorting },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_flash_mode",
                |m: &Settings| { &m.chat_flash_mode },
                |m: &mut Settings| { &mut m.chat_flash_mode },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "remember_open_chats",
                |m: &Settings| { &m.remember_open_chats },
                |m: &mut Settings| { &mut m.remember_open_chats },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "compact_quick_access",
                |m: &Settings| { &m.compact_quick_access },
                |m: &mut Settings| { &mut m.compact_quick_access },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "compact_friends_list",
                |m: &Settings| { &m.compact_friends_list },
                |m: &mut Settings| { &mut m.compact_friends_list },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "notifications_show_chat_room_notification",
                |m: &Settings| { &m.notifications_show_chat_room_notification },
                |m: &mut Settings| { &mut m.notifications_show_chat_room_notification },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sounds_play_chat_room_notification",
                |m: &Settings| { &m.sounds_play_chat_room_notification },
                |m: &mut Settings| { &mut m.sounds_play_chat_room_notification },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "hide_offline_friends_in_tag_groups",
                |m: &Settings| { &m.hide_offline_friends_in_tag_groups },
                |m: &mut Settings| { &mut m.hide_offline_friends_in_tag_groups },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "hide_categorized_friends",
                |m: &Settings| { &m.hide_categorized_friends },
                |m: &mut Settings| { &mut m.hide_categorized_friends },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "categorize_in_game_friends_by_game",
                |m: &Settings| { &m.categorize_in_game_friends_by_game },
                |m: &mut Settings| { &mut m.categorize_in_game_friends_by_game },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_font_size",
                |m: &Settings| { &m.chat_font_size },
                |m: &mut Settings| { &mut m.chat_font_size },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "use24hour_clock",
                |m: &Settings| { &m.use24hour_clock },
                |m: &mut Settings| { &mut m.use24hour_clock },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "do_not_disturb_mode",
                |m: &Settings| { &m.do_not_disturb_mode },
                |m: &mut Settings| { &mut m.do_not_disturb_mode },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "disable_embed_inlining",
                |m: &Settings| { &m.disable_embed_inlining },
                |m: &mut Settings| { &mut m.disable_embed_inlining },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "sign_into_friends",
                |m: &Settings| { &m.sign_into_friends },
                |m: &mut Settings| { &mut m.sign_into_friends },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "animated_avatars",
                |m: &Settings| { &m.animated_avatars },
                |m: &mut Settings| { &mut m.animated_avatars },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Settings>(
                "CChatUsability_ClientUsabilityMetrics_Notification.Settings",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Settings {
        const NAME: &'static str = "Settings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.notifications_show_ingame = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.notifications_show_online = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.notifications_show_message = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.notifications_events_and_announcements = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.sounds_play_ingame = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.sounds_play_online = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.sounds_play_message = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.sounds_events_and_announcements = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.always_new_chat_window = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.force_alphabetic_friend_sorting = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.chat_flash_mode = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.remember_open_chats = ::std::option::Option::Some(is.read_bool()?);
                    },
                    104 => {
                        self.compact_quick_access = ::std::option::Option::Some(is.read_bool()?);
                    },
                    112 => {
                        self.compact_friends_list = ::std::option::Option::Some(is.read_bool()?);
                    },
                    120 => {
                        self.notifications_show_chat_room_notification = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.sounds_play_chat_room_notification = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.hide_offline_friends_in_tag_groups = ::std::option::Option::Some(is.read_bool()?);
                    },
                    144 => {
                        self.hide_categorized_friends = ::std::option::Option::Some(is.read_bool()?);
                    },
                    152 => {
                        self.categorize_in_game_friends_by_game = ::std::option::Option::Some(is.read_bool()?);
                    },
                    160 => {
                        self.chat_font_size = ::std::option::Option::Some(is.read_int32()?);
                    },
                    168 => {
                        self.use24hour_clock = ::std::option::Option::Some(is.read_bool()?);
                    },
                    176 => {
                        self.do_not_disturb_mode = ::std::option::Option::Some(is.read_bool()?);
                    },
                    184 => {
                        self.disable_embed_inlining = ::std::option::Option::Some(is.read_bool()?);
                    },
                    192 => {
                        self.sign_into_friends = ::std::option::Option::Some(is.read_bool()?);
                    },
                    200 => {
                        self.animated_avatars = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.notifications_show_ingame {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_show_online {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_show_message {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_events_and_announcements {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_ingame {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_online {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_message {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_events_and_announcements {
                my_size += 1 + 1;
            }
            if let Some(v) = self.always_new_chat_window {
                my_size += 1 + 1;
            }
            if let Some(v) = self.force_alphabetic_friend_sorting {
                my_size += 1 + 1;
            }
            if let Some(v) = self.chat_flash_mode {
                my_size += crate::rt::int32_size(11, v);
            }
            if let Some(v) = self.remember_open_chats {
                my_size += 1 + 1;
            }
            if let Some(v) = self.compact_quick_access {
                my_size += 1 + 1;
            }
            if let Some(v) = self.compact_friends_list {
                my_size += 1 + 1;
            }
            if let Some(v) = self.notifications_show_chat_room_notification {
                my_size += 1 + 1;
            }
            if let Some(v) = self.sounds_play_chat_room_notification {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hide_offline_friends_in_tag_groups {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hide_categorized_friends {
                my_size += 2 + 1;
            }
            if let Some(v) = self.categorize_in_game_friends_by_game {
                my_size += 2 + 1;
            }
            if let Some(v) = self.chat_font_size {
                my_size += crate::rt::int32_size(20, v);
            }
            if let Some(v) = self.use24hour_clock {
                my_size += 2 + 1;
            }
            if let Some(v) = self.do_not_disturb_mode {
                my_size += 2 + 1;
            }
            if let Some(v) = self.disable_embed_inlining {
                my_size += 2 + 1;
            }
            if let Some(v) = self.sign_into_friends {
                my_size += 2 + 1;
            }
            if let Some(v) = self.animated_avatars {
                my_size += 2 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.notifications_show_ingame {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.notifications_show_online {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.notifications_show_message {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.notifications_events_and_announcements {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.sounds_play_ingame {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.sounds_play_online {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.sounds_play_message {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.sounds_events_and_announcements {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.always_new_chat_window {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.force_alphabetic_friend_sorting {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.chat_flash_mode {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.remember_open_chats {
                os.write_bool(12, v)?;
            }
            if let Some(v) = self.compact_quick_access {
                os.write_bool(13, v)?;
            }
            if let Some(v) = self.compact_friends_list {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.notifications_show_chat_room_notification {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.sounds_play_chat_room_notification {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.hide_offline_friends_in_tag_groups {
                os.write_bool(17, v)?;
            }
            if let Some(v) = self.hide_categorized_friends {
                os.write_bool(18, v)?;
            }
            if let Some(v) = self.categorize_in_game_friends_by_game {
                os.write_bool(19, v)?;
            }
            if let Some(v) = self.chat_font_size {
                os.write_int32(20, v)?;
            }
            if let Some(v) = self.use24hour_clock {
                os.write_bool(21, v)?;
            }
            if let Some(v) = self.do_not_disturb_mode {
                os.write_bool(22, v)?;
            }
            if let Some(v) = self.disable_embed_inlining {
                os.write_bool(23, v)?;
            }
            if let Some(v) = self.sign_into_friends {
                os.write_bool(24, v)?;
            }
            if let Some(v) = self.animated_avatars {
                os.write_bool(25, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Settings {
            Settings::new()
        }

        fn clear(&mut self) {
            self.notifications_show_ingame = ::std::option::Option::None;
            self.notifications_show_online = ::std::option::Option::None;
            self.notifications_show_message = ::std::option::Option::None;
            self.notifications_events_and_announcements = ::std::option::Option::None;
            self.sounds_play_ingame = ::std::option::Option::None;
            self.sounds_play_online = ::std::option::Option::None;
            self.sounds_play_message = ::std::option::Option::None;
            self.sounds_events_and_announcements = ::std::option::Option::None;
            self.always_new_chat_window = ::std::option::Option::None;
            self.force_alphabetic_friend_sorting = ::std::option::Option::None;
            self.chat_flash_mode = ::std::option::Option::None;
            self.remember_open_chats = ::std::option::Option::None;
            self.compact_quick_access = ::std::option::Option::None;
            self.compact_friends_list = ::std::option::Option::None;
            self.notifications_show_chat_room_notification = ::std::option::Option::None;
            self.sounds_play_chat_room_notification = ::std::option::Option::None;
            self.hide_offline_friends_in_tag_groups = ::std::option::Option::None;
            self.hide_categorized_friends = ::std::option::Option::None;
            self.categorize_in_game_friends_by_game = ::std::option::Option::None;
            self.chat_font_size = ::std::option::Option::None;
            self.use24hour_clock = ::std::option::Option::None;
            self.do_not_disturb_mode = ::std::option::Option::None;
            self.disable_embed_inlining = ::std::option::Option::None;
            self.sign_into_friends = ::std::option::Option::None;
            self.animated_avatars = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Settings {
            static instance: Settings = Settings {
                notifications_show_ingame: ::std::option::Option::None,
                notifications_show_online: ::std::option::Option::None,
                notifications_show_message: ::std::option::Option::None,
                notifications_events_and_announcements: ::std::option::Option::None,
                sounds_play_ingame: ::std::option::Option::None,
                sounds_play_online: ::std::option::Option::None,
                sounds_play_message: ::std::option::Option::None,
                sounds_events_and_announcements: ::std::option::Option::None,
                always_new_chat_window: ::std::option::Option::None,
                force_alphabetic_friend_sorting: ::std::option::Option::None,
                chat_flash_mode: ::std::option::Option::None,
                remember_open_chats: ::std::option::Option::None,
                compact_quick_access: ::std::option::Option::None,
                compact_friends_list: ::std::option::Option::None,
                notifications_show_chat_room_notification: ::std::option::Option::None,
                sounds_play_chat_room_notification: ::std::option::Option::None,
                hide_offline_friends_in_tag_groups: ::std::option::Option::None,
                hide_categorized_friends: ::std::option::Option::None,
                categorize_in_game_friends_by_game: ::std::option::Option::None,
                chat_font_size: ::std::option::Option::None,
                use24hour_clock: ::std::option::Option::None,
                do_not_disturb_mode: ::std::option::Option::None,
                disable_embed_inlining: ::std::option::Option::None,
                sign_into_friends: ::std::option::Option::None,
                animated_avatars: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Settings {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.Settings").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Settings {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Settings {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct VoiceSettings {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_input_gain)
        pub voice_input_gain: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_output_gain)
        pub voice_output_gain: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.noise_gate_level)
        pub noise_gate_level: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_use_echo_cancellation)
        pub voice_use_echo_cancellation: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_use_noise_cancellation)
        pub voice_use_noise_cancellation: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.voice_use_auto_gain_control)
        pub voice_use_auto_gain_control: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.selected_non_default_mic)
        pub selected_non_default_mic: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.selected_non_default_output)
        pub selected_non_default_output: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.push_to_talk_enabled)
        pub push_to_talk_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.push_to_mute_enabled)
        pub push_to_mute_enabled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.play_ptt_sounds)
        pub play_ptt_sounds: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a VoiceSettings {
        fn default() -> &'a VoiceSettings {
            <VoiceSettings as crate::Message>::default_instance()
        }
    }

    impl VoiceSettings {
        pub fn new() -> VoiceSettings {
            ::std::default::Default::default()
        }

        // optional float voice_input_gain = 1;

        pub fn voice_input_gain(&self) -> f32 {
            self.voice_input_gain.unwrap_or(0.)
        }

        pub fn clear_voice_input_gain(&mut self) {
            self.voice_input_gain = ::std::option::Option::None;
        }

        pub fn has_voice_input_gain(&self) -> bool {
            self.voice_input_gain.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_input_gain(&mut self, v: f32) {
            self.voice_input_gain = ::std::option::Option::Some(v);
        }

        // optional float voice_output_gain = 2;

        pub fn voice_output_gain(&self) -> f32 {
            self.voice_output_gain.unwrap_or(0.)
        }

        pub fn clear_voice_output_gain(&mut self) {
            self.voice_output_gain = ::std::option::Option::None;
        }

        pub fn has_voice_output_gain(&self) -> bool {
            self.voice_output_gain.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_output_gain(&mut self, v: f32) {
            self.voice_output_gain = ::std::option::Option::Some(v);
        }

        // optional int32 noise_gate_level = 3;

        pub fn noise_gate_level(&self) -> i32 {
            self.noise_gate_level.unwrap_or(0)
        }

        pub fn clear_noise_gate_level(&mut self) {
            self.noise_gate_level = ::std::option::Option::None;
        }

        pub fn has_noise_gate_level(&self) -> bool {
            self.noise_gate_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_noise_gate_level(&mut self, v: i32) {
            self.noise_gate_level = ::std::option::Option::Some(v);
        }

        // optional bool voice_use_echo_cancellation = 4;

        pub fn voice_use_echo_cancellation(&self) -> bool {
            self.voice_use_echo_cancellation.unwrap_or(false)
        }

        pub fn clear_voice_use_echo_cancellation(&mut self) {
            self.voice_use_echo_cancellation = ::std::option::Option::None;
        }

        pub fn has_voice_use_echo_cancellation(&self) -> bool {
            self.voice_use_echo_cancellation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_use_echo_cancellation(&mut self, v: bool) {
            self.voice_use_echo_cancellation = ::std::option::Option::Some(v);
        }

        // optional bool voice_use_noise_cancellation = 5;

        pub fn voice_use_noise_cancellation(&self) -> bool {
            self.voice_use_noise_cancellation.unwrap_or(false)
        }

        pub fn clear_voice_use_noise_cancellation(&mut self) {
            self.voice_use_noise_cancellation = ::std::option::Option::None;
        }

        pub fn has_voice_use_noise_cancellation(&self) -> bool {
            self.voice_use_noise_cancellation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_use_noise_cancellation(&mut self, v: bool) {
            self.voice_use_noise_cancellation = ::std::option::Option::Some(v);
        }

        // optional bool voice_use_auto_gain_control = 6;

        pub fn voice_use_auto_gain_control(&self) -> bool {
            self.voice_use_auto_gain_control.unwrap_or(false)
        }

        pub fn clear_voice_use_auto_gain_control(&mut self) {
            self.voice_use_auto_gain_control = ::std::option::Option::None;
        }

        pub fn has_voice_use_auto_gain_control(&self) -> bool {
            self.voice_use_auto_gain_control.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_use_auto_gain_control(&mut self, v: bool) {
            self.voice_use_auto_gain_control = ::std::option::Option::Some(v);
        }

        // optional bool selected_non_default_mic = 7;

        pub fn selected_non_default_mic(&self) -> bool {
            self.selected_non_default_mic.unwrap_or(false)
        }

        pub fn clear_selected_non_default_mic(&mut self) {
            self.selected_non_default_mic = ::std::option::Option::None;
        }

        pub fn has_selected_non_default_mic(&self) -> bool {
            self.selected_non_default_mic.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selected_non_default_mic(&mut self, v: bool) {
            self.selected_non_default_mic = ::std::option::Option::Some(v);
        }

        // optional bool selected_non_default_output = 8;

        pub fn selected_non_default_output(&self) -> bool {
            self.selected_non_default_output.unwrap_or(false)
        }

        pub fn clear_selected_non_default_output(&mut self) {
            self.selected_non_default_output = ::std::option::Option::None;
        }

        pub fn has_selected_non_default_output(&self) -> bool {
            self.selected_non_default_output.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selected_non_default_output(&mut self, v: bool) {
            self.selected_non_default_output = ::std::option::Option::Some(v);
        }

        // optional bool push_to_talk_enabled = 9;

        pub fn push_to_talk_enabled(&self) -> bool {
            self.push_to_talk_enabled.unwrap_or(false)
        }

        pub fn clear_push_to_talk_enabled(&mut self) {
            self.push_to_talk_enabled = ::std::option::Option::None;
        }

        pub fn has_push_to_talk_enabled(&self) -> bool {
            self.push_to_talk_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_push_to_talk_enabled(&mut self, v: bool) {
            self.push_to_talk_enabled = ::std::option::Option::Some(v);
        }

        // optional bool push_to_mute_enabled = 10;

        pub fn push_to_mute_enabled(&self) -> bool {
            self.push_to_mute_enabled.unwrap_or(false)
        }

        pub fn clear_push_to_mute_enabled(&mut self) {
            self.push_to_mute_enabled = ::std::option::Option::None;
        }

        pub fn has_push_to_mute_enabled(&self) -> bool {
            self.push_to_mute_enabled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_push_to_mute_enabled(&mut self, v: bool) {
            self.push_to_mute_enabled = ::std::option::Option::Some(v);
        }

        // optional bool play_ptt_sounds = 11;

        pub fn play_ptt_sounds(&self) -> bool {
            self.play_ptt_sounds.unwrap_or(false)
        }

        pub fn clear_play_ptt_sounds(&mut self) {
            self.play_ptt_sounds = ::std::option::Option::None;
        }

        pub fn has_play_ptt_sounds(&self) -> bool {
            self.play_ptt_sounds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_play_ptt_sounds(&mut self, v: bool) {
            self.play_ptt_sounds = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_input_gain",
                |m: &VoiceSettings| { &m.voice_input_gain },
                |m: &mut VoiceSettings| { &mut m.voice_input_gain },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_output_gain",
                |m: &VoiceSettings| { &m.voice_output_gain },
                |m: &mut VoiceSettings| { &mut m.voice_output_gain },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "noise_gate_level",
                |m: &VoiceSettings| { &m.noise_gate_level },
                |m: &mut VoiceSettings| { &mut m.noise_gate_level },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_use_echo_cancellation",
                |m: &VoiceSettings| { &m.voice_use_echo_cancellation },
                |m: &mut VoiceSettings| { &mut m.voice_use_echo_cancellation },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_use_noise_cancellation",
                |m: &VoiceSettings| { &m.voice_use_noise_cancellation },
                |m: &mut VoiceSettings| { &mut m.voice_use_noise_cancellation },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "voice_use_auto_gain_control",
                |m: &VoiceSettings| { &m.voice_use_auto_gain_control },
                |m: &mut VoiceSettings| { &mut m.voice_use_auto_gain_control },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "selected_non_default_mic",
                |m: &VoiceSettings| { &m.selected_non_default_mic },
                |m: &mut VoiceSettings| { &mut m.selected_non_default_mic },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "selected_non_default_output",
                |m: &VoiceSettings| { &m.selected_non_default_output },
                |m: &mut VoiceSettings| { &mut m.selected_non_default_output },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "push_to_talk_enabled",
                |m: &VoiceSettings| { &m.push_to_talk_enabled },
                |m: &mut VoiceSettings| { &mut m.push_to_talk_enabled },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "push_to_mute_enabled",
                |m: &VoiceSettings| { &m.push_to_mute_enabled },
                |m: &mut VoiceSettings| { &mut m.push_to_mute_enabled },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "play_ptt_sounds",
                |m: &VoiceSettings| { &m.play_ptt_sounds },
                |m: &mut VoiceSettings| { &mut m.play_ptt_sounds },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<VoiceSettings>(
                "CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for VoiceSettings {
        const NAME: &'static str = "VoiceSettings";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.voice_input_gain = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.voice_output_gain = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.noise_gate_level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.voice_use_echo_cancellation = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.voice_use_noise_cancellation = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.voice_use_auto_gain_control = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.selected_non_default_mic = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.selected_non_default_output = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.push_to_talk_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.push_to_mute_enabled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.play_ptt_sounds = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.voice_input_gain {
                my_size += 1 + 4;
            }
            if let Some(v) = self.voice_output_gain {
                my_size += 1 + 4;
            }
            if let Some(v) = self.noise_gate_level {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.voice_use_echo_cancellation {
                my_size += 1 + 1;
            }
            if let Some(v) = self.voice_use_noise_cancellation {
                my_size += 1 + 1;
            }
            if let Some(v) = self.voice_use_auto_gain_control {
                my_size += 1 + 1;
            }
            if let Some(v) = self.selected_non_default_mic {
                my_size += 1 + 1;
            }
            if let Some(v) = self.selected_non_default_output {
                my_size += 1 + 1;
            }
            if let Some(v) = self.push_to_talk_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.push_to_mute_enabled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.play_ptt_sounds {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.voice_input_gain {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.voice_output_gain {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.noise_gate_level {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.voice_use_echo_cancellation {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.voice_use_noise_cancellation {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.voice_use_auto_gain_control {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.selected_non_default_mic {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.selected_non_default_output {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.push_to_talk_enabled {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.push_to_mute_enabled {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.play_ptt_sounds {
                os.write_bool(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> VoiceSettings {
            VoiceSettings::new()
        }

        fn clear(&mut self) {
            self.voice_input_gain = ::std::option::Option::None;
            self.voice_output_gain = ::std::option::Option::None;
            self.noise_gate_level = ::std::option::Option::None;
            self.voice_use_echo_cancellation = ::std::option::Option::None;
            self.voice_use_noise_cancellation = ::std::option::Option::None;
            self.voice_use_auto_gain_control = ::std::option::Option::None;
            self.selected_non_default_mic = ::std::option::Option::None;
            self.selected_non_default_output = ::std::option::Option::None;
            self.push_to_talk_enabled = ::std::option::Option::None;
            self.push_to_mute_enabled = ::std::option::Option::None;
            self.play_ptt_sounds = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static VoiceSettings {
            static instance: VoiceSettings = VoiceSettings {
                voice_input_gain: ::std::option::Option::None,
                voice_output_gain: ::std::option::Option::None,
                noise_gate_level: ::std::option::Option::None,
                voice_use_echo_cancellation: ::std::option::Option::None,
                voice_use_noise_cancellation: ::std::option::Option::None,
                voice_use_auto_gain_control: ::std::option::Option::None,
                selected_non_default_mic: ::std::option::Option::None,
                selected_non_default_output: ::std::option::Option::None,
                push_to_talk_enabled: ::std::option::Option::None,
                push_to_mute_enabled: ::std::option::Option::None,
                play_ptt_sounds: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for VoiceSettings {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.VoiceSettings").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for VoiceSettings {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for VoiceSettings {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.UIState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UIState {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_height)
        pub friends_list_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_width)
        pub friends_list_width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_docked)
        pub friends_list_docked: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_collapsed)
        pub friends_list_collapsed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_group_chats_height)
        pub friends_list_group_chats_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friends_list_visible)
        pub friends_list_visible: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.chat_popups_opened)
        pub chat_popups_opened: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.group_chat_tabs_opened)
        pub group_chat_tabs_opened: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.friend_chat_tabs_opened)
        pub friend_chat_tabs_opened: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.chat_window_width)
        pub chat_window_width: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.chat_window_height)
        pub chat_window_height: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.category_collapse)
        pub category_collapse: crate::MessageField<uistate::CategoryCollapseState>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.group_chat_left_col_collapsed)
        pub group_chat_left_col_collapsed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.group_chat_right_col_collapsed)
        pub group_chat_right_col_collapsed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.in_one_on_one_voice_chat)
        pub in_one_on_one_voice_chat: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.in_group_voice_chat)
        pub in_group_voice_chat: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UIState {
        fn default() -> &'a UIState {
            <UIState as crate::Message>::default_instance()
        }
    }

    impl UIState {
        pub fn new() -> UIState {
            ::std::default::Default::default()
        }

        // optional int32 friends_list_height = 1;

        pub fn friends_list_height(&self) -> i32 {
            self.friends_list_height.unwrap_or(0)
        }

        pub fn clear_friends_list_height(&mut self) {
            self.friends_list_height = ::std::option::Option::None;
        }

        pub fn has_friends_list_height(&self) -> bool {
            self.friends_list_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_height(&mut self, v: i32) {
            self.friends_list_height = ::std::option::Option::Some(v);
        }

        // optional int32 friends_list_width = 2;

        pub fn friends_list_width(&self) -> i32 {
            self.friends_list_width.unwrap_or(0)
        }

        pub fn clear_friends_list_width(&mut self) {
            self.friends_list_width = ::std::option::Option::None;
        }

        pub fn has_friends_list_width(&self) -> bool {
            self.friends_list_width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_width(&mut self, v: i32) {
            self.friends_list_width = ::std::option::Option::Some(v);
        }

        // optional bool friends_list_docked = 3;

        pub fn friends_list_docked(&self) -> bool {
            self.friends_list_docked.unwrap_or(false)
        }

        pub fn clear_friends_list_docked(&mut self) {
            self.friends_list_docked = ::std::option::Option::None;
        }

        pub fn has_friends_list_docked(&self) -> bool {
            self.friends_list_docked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_docked(&mut self, v: bool) {
            self.friends_list_docked = ::std::option::Option::Some(v);
        }

        // optional bool friends_list_collapsed = 4;

        pub fn friends_list_collapsed(&self) -> bool {
            self.friends_list_collapsed.unwrap_or(false)
        }

        pub fn clear_friends_list_collapsed(&mut self) {
            self.friends_list_collapsed = ::std::option::Option::None;
        }

        pub fn has_friends_list_collapsed(&self) -> bool {
            self.friends_list_collapsed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_collapsed(&mut self, v: bool) {
            self.friends_list_collapsed = ::std::option::Option::Some(v);
        }

        // optional int32 friends_list_group_chats_height = 5;

        pub fn friends_list_group_chats_height(&self) -> i32 {
            self.friends_list_group_chats_height.unwrap_or(0)
        }

        pub fn clear_friends_list_group_chats_height(&mut self) {
            self.friends_list_group_chats_height = ::std::option::Option::None;
        }

        pub fn has_friends_list_group_chats_height(&self) -> bool {
            self.friends_list_group_chats_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_group_chats_height(&mut self, v: i32) {
            self.friends_list_group_chats_height = ::std::option::Option::Some(v);
        }

        // optional bool friends_list_visible = 6;

        pub fn friends_list_visible(&self) -> bool {
            self.friends_list_visible.unwrap_or(false)
        }

        pub fn clear_friends_list_visible(&mut self) {
            self.friends_list_visible = ::std::option::Option::None;
        }

        pub fn has_friends_list_visible(&self) -> bool {
            self.friends_list_visible.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_list_visible(&mut self, v: bool) {
            self.friends_list_visible = ::std::option::Option::Some(v);
        }

        // optional int32 chat_popups_opened = 7;

        pub fn chat_popups_opened(&self) -> i32 {
            self.chat_popups_opened.unwrap_or(0)
        }

        pub fn clear_chat_popups_opened(&mut self) {
            self.chat_popups_opened = ::std::option::Option::None;
        }

        pub fn has_chat_popups_opened(&self) -> bool {
            self.chat_popups_opened.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_popups_opened(&mut self, v: i32) {
            self.chat_popups_opened = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_tabs_opened = 8;

        pub fn group_chat_tabs_opened(&self) -> i32 {
            self.group_chat_tabs_opened.unwrap_or(0)
        }

        pub fn clear_group_chat_tabs_opened(&mut self) {
            self.group_chat_tabs_opened = ::std::option::Option::None;
        }

        pub fn has_group_chat_tabs_opened(&self) -> bool {
            self.group_chat_tabs_opened.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_tabs_opened(&mut self, v: i32) {
            self.group_chat_tabs_opened = ::std::option::Option::Some(v);
        }

        // optional int32 friend_chat_tabs_opened = 9;

        pub fn friend_chat_tabs_opened(&self) -> i32 {
            self.friend_chat_tabs_opened.unwrap_or(0)
        }

        pub fn clear_friend_chat_tabs_opened(&mut self) {
            self.friend_chat_tabs_opened = ::std::option::Option::None;
        }

        pub fn has_friend_chat_tabs_opened(&self) -> bool {
            self.friend_chat_tabs_opened.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friend_chat_tabs_opened(&mut self, v: i32) {
            self.friend_chat_tabs_opened = ::std::option::Option::Some(v);
        }

        // optional int32 chat_window_width = 10;

        pub fn chat_window_width(&self) -> i32 {
            self.chat_window_width.unwrap_or(0)
        }

        pub fn clear_chat_window_width(&mut self) {
            self.chat_window_width = ::std::option::Option::None;
        }

        pub fn has_chat_window_width(&self) -> bool {
            self.chat_window_width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_window_width(&mut self, v: i32) {
            self.chat_window_width = ::std::option::Option::Some(v);
        }

        // optional int32 chat_window_height = 11;

        pub fn chat_window_height(&self) -> i32 {
            self.chat_window_height.unwrap_or(0)
        }

        pub fn clear_chat_window_height(&mut self) {
            self.chat_window_height = ::std::option::Option::None;
        }

        pub fn has_chat_window_height(&self) -> bool {
            self.chat_window_height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_window_height(&mut self, v: i32) {
            self.chat_window_height = ::std::option::Option::Some(v);
        }

        // optional .CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState category_collapse = 12;

        pub fn category_collapse(&self) -> &uistate::CategoryCollapseState {
            self.category_collapse.as_ref().unwrap_or_else(|| <uistate::CategoryCollapseState as crate::Message>::default_instance())
        }

        pub fn clear_category_collapse(&mut self) {
            self.category_collapse.clear();
        }

        pub fn has_category_collapse(&self) -> bool {
            self.category_collapse.is_some()
        }

        // Param is passed by value, moved
        pub fn set_category_collapse(&mut self, v: uistate::CategoryCollapseState) {
            self.category_collapse = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_category_collapse(&mut self) -> &mut uistate::CategoryCollapseState {
            self.category_collapse.mut_or_insert_default()
        }

        // Take field
        pub fn take_category_collapse(&mut self) -> uistate::CategoryCollapseState {
            self.category_collapse.take().unwrap_or_else(|| uistate::CategoryCollapseState::new())
        }

        // optional int32 group_chat_left_col_collapsed = 13;

        pub fn group_chat_left_col_collapsed(&self) -> i32 {
            self.group_chat_left_col_collapsed.unwrap_or(0)
        }

        pub fn clear_group_chat_left_col_collapsed(&mut self) {
            self.group_chat_left_col_collapsed = ::std::option::Option::None;
        }

        pub fn has_group_chat_left_col_collapsed(&self) -> bool {
            self.group_chat_left_col_collapsed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_left_col_collapsed(&mut self, v: i32) {
            self.group_chat_left_col_collapsed = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_right_col_collapsed = 14;

        pub fn group_chat_right_col_collapsed(&self) -> i32 {
            self.group_chat_right_col_collapsed.unwrap_or(0)
        }

        pub fn clear_group_chat_right_col_collapsed(&mut self) {
            self.group_chat_right_col_collapsed = ::std::option::Option::None;
        }

        pub fn has_group_chat_right_col_collapsed(&self) -> bool {
            self.group_chat_right_col_collapsed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_right_col_collapsed(&mut self, v: i32) {
            self.group_chat_right_col_collapsed = ::std::option::Option::Some(v);
        }

        // optional bool in_one_on_one_voice_chat = 15;

        pub fn in_one_on_one_voice_chat(&self) -> bool {
            self.in_one_on_one_voice_chat.unwrap_or(false)
        }

        pub fn clear_in_one_on_one_voice_chat(&mut self) {
            self.in_one_on_one_voice_chat = ::std::option::Option::None;
        }

        pub fn has_in_one_on_one_voice_chat(&self) -> bool {
            self.in_one_on_one_voice_chat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_one_on_one_voice_chat(&mut self, v: bool) {
            self.in_one_on_one_voice_chat = ::std::option::Option::Some(v);
        }

        // optional bool in_group_voice_chat = 16;

        pub fn in_group_voice_chat(&self) -> bool {
            self.in_group_voice_chat.unwrap_or(false)
        }

        pub fn clear_in_group_voice_chat(&mut self) {
            self.in_group_voice_chat = ::std::option::Option::None;
        }

        pub fn has_in_group_voice_chat(&self) -> bool {
            self.in_group_voice_chat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_in_group_voice_chat(&mut self, v: bool) {
            self.in_group_voice_chat = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(16);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_height",
                |m: &UIState| { &m.friends_list_height },
                |m: &mut UIState| { &mut m.friends_list_height },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_width",
                |m: &UIState| { &m.friends_list_width },
                |m: &mut UIState| { &mut m.friends_list_width },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_docked",
                |m: &UIState| { &m.friends_list_docked },
                |m: &mut UIState| { &mut m.friends_list_docked },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_collapsed",
                |m: &UIState| { &m.friends_list_collapsed },
                |m: &mut UIState| { &mut m.friends_list_collapsed },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_group_chats_height",
                |m: &UIState| { &m.friends_list_group_chats_height },
                |m: &mut UIState| { &mut m.friends_list_group_chats_height },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_list_visible",
                |m: &UIState| { &m.friends_list_visible },
                |m: &mut UIState| { &mut m.friends_list_visible },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_popups_opened",
                |m: &UIState| { &m.chat_popups_opened },
                |m: &mut UIState| { &mut m.chat_popups_opened },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_tabs_opened",
                |m: &UIState| { &m.group_chat_tabs_opened },
                |m: &mut UIState| { &mut m.group_chat_tabs_opened },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friend_chat_tabs_opened",
                |m: &UIState| { &m.friend_chat_tabs_opened },
                |m: &mut UIState| { &mut m.friend_chat_tabs_opened },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_window_width",
                |m: &UIState| { &m.chat_window_width },
                |m: &mut UIState| { &mut m.chat_window_width },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "chat_window_height",
                |m: &UIState| { &m.chat_window_height },
                |m: &mut UIState| { &mut m.chat_window_height },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, uistate::CategoryCollapseState>(
                "category_collapse",
                |m: &UIState| { &m.category_collapse },
                |m: &mut UIState| { &mut m.category_collapse },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_left_col_collapsed",
                |m: &UIState| { &m.group_chat_left_col_collapsed },
                |m: &mut UIState| { &mut m.group_chat_left_col_collapsed },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_right_col_collapsed",
                |m: &UIState| { &m.group_chat_right_col_collapsed },
                |m: &mut UIState| { &mut m.group_chat_right_col_collapsed },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "in_one_on_one_voice_chat",
                |m: &UIState| { &m.in_one_on_one_voice_chat },
                |m: &mut UIState| { &mut m.in_one_on_one_voice_chat },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "in_group_voice_chat",
                |m: &UIState| { &m.in_group_voice_chat },
                |m: &mut UIState| { &mut m.in_group_voice_chat },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<UIState>(
                "CChatUsability_ClientUsabilityMetrics_Notification.UIState",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for UIState {
        const NAME: &'static str = "UIState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.friends_list_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.friends_list_width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.friends_list_docked = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.friends_list_collapsed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.friends_list_group_chats_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.friends_list_visible = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.chat_popups_opened = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.group_chat_tabs_opened = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.friend_chat_tabs_opened = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.chat_window_width = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.chat_window_height = ::std::option::Option::Some(is.read_int32()?);
                    },
                    98 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.category_collapse)?;
                    },
                    104 => {
                        self.group_chat_left_col_collapsed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.group_chat_right_col_collapsed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.in_one_on_one_voice_chat = ::std::option::Option::Some(is.read_bool()?);
                    },
                    128 => {
                        self.in_group_voice_chat = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.friends_list_height {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.friends_list_width {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.friends_list_docked {
                my_size += 1 + 1;
            }
            if let Some(v) = self.friends_list_collapsed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.friends_list_group_chats_height {
                my_size += crate::rt::int32_size(5, v);
            }
            if let Some(v) = self.friends_list_visible {
                my_size += 1 + 1;
            }
            if let Some(v) = self.chat_popups_opened {
                my_size += crate::rt::int32_size(7, v);
            }
            if let Some(v) = self.group_chat_tabs_opened {
                my_size += crate::rt::int32_size(8, v);
            }
            if let Some(v) = self.friend_chat_tabs_opened {
                my_size += crate::rt::int32_size(9, v);
            }
            if let Some(v) = self.chat_window_width {
                my_size += crate::rt::int32_size(10, v);
            }
            if let Some(v) = self.chat_window_height {
                my_size += crate::rt::int32_size(11, v);
            }
            if let Some(v) = self.category_collapse.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.group_chat_left_col_collapsed {
                my_size += crate::rt::int32_size(13, v);
            }
            if let Some(v) = self.group_chat_right_col_collapsed {
                my_size += crate::rt::int32_size(14, v);
            }
            if let Some(v) = self.in_one_on_one_voice_chat {
                my_size += 1 + 1;
            }
            if let Some(v) = self.in_group_voice_chat {
                my_size += 2 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.friends_list_height {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.friends_list_width {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.friends_list_docked {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.friends_list_collapsed {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.friends_list_group_chats_height {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.friends_list_visible {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.chat_popups_opened {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.group_chat_tabs_opened {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.friend_chat_tabs_opened {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.chat_window_width {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.chat_window_height {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.category_collapse.as_ref() {
                crate::rt::write_message_field_with_cached_size(12, v, os)?;
            }
            if let Some(v) = self.group_chat_left_col_collapsed {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.group_chat_right_col_collapsed {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.in_one_on_one_voice_chat {
                os.write_bool(15, v)?;
            }
            if let Some(v) = self.in_group_voice_chat {
                os.write_bool(16, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UIState {
            UIState::new()
        }

        fn clear(&mut self) {
            self.friends_list_height = ::std::option::Option::None;
            self.friends_list_width = ::std::option::Option::None;
            self.friends_list_docked = ::std::option::Option::None;
            self.friends_list_collapsed = ::std::option::Option::None;
            self.friends_list_group_chats_height = ::std::option::Option::None;
            self.friends_list_visible = ::std::option::Option::None;
            self.chat_popups_opened = ::std::option::Option::None;
            self.group_chat_tabs_opened = ::std::option::Option::None;
            self.friend_chat_tabs_opened = ::std::option::Option::None;
            self.chat_window_width = ::std::option::Option::None;
            self.chat_window_height = ::std::option::Option::None;
            self.category_collapse.clear();
            self.group_chat_left_col_collapsed = ::std::option::Option::None;
            self.group_chat_right_col_collapsed = ::std::option::Option::None;
            self.in_one_on_one_voice_chat = ::std::option::Option::None;
            self.in_group_voice_chat = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UIState {
            static instance: UIState = UIState {
                friends_list_height: ::std::option::Option::None,
                friends_list_width: ::std::option::Option::None,
                friends_list_docked: ::std::option::Option::None,
                friends_list_collapsed: ::std::option::Option::None,
                friends_list_group_chats_height: ::std::option::Option::None,
                friends_list_visible: ::std::option::Option::None,
                chat_popups_opened: ::std::option::Option::None,
                group_chat_tabs_opened: ::std::option::Option::None,
                friend_chat_tabs_opened: ::std::option::Option::None,
                chat_window_width: ::std::option::Option::None,
                chat_window_height: ::std::option::Option::None,
                category_collapse: crate::MessageField::none(),
                group_chat_left_col_collapsed: ::std::option::Option::None,
                group_chat_right_col_collapsed: ::std::option::Option::None,
                in_one_on_one_voice_chat: ::std::option::Option::None,
                in_group_voice_chat: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for UIState {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.UIState").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UIState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for UIState {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `UIState`
    pub mod uistate {
        // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CategoryCollapseState {
            // message fields
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.in_game_collapsed)
            pub in_game_collapsed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.online_collapsed)
            pub online_collapsed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.offline_collapsed)
            pub offline_collapsed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.game_groups_collapsed)
            pub game_groups_collapsed: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.categories_collapsed)
            pub categories_collapsed: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CategoryCollapseState {
            fn default() -> &'a CategoryCollapseState {
                <CategoryCollapseState as crate::Message>::default_instance()
            }
        }

        impl CategoryCollapseState {
            pub fn new() -> CategoryCollapseState {
                ::std::default::Default::default()
            }

            // optional bool in_game_collapsed = 1;

            pub fn in_game_collapsed(&self) -> bool {
                self.in_game_collapsed.unwrap_or(false)
            }

            pub fn clear_in_game_collapsed(&mut self) {
                self.in_game_collapsed = ::std::option::Option::None;
            }

            pub fn has_in_game_collapsed(&self) -> bool {
                self.in_game_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_in_game_collapsed(&mut self, v: bool) {
                self.in_game_collapsed = ::std::option::Option::Some(v);
            }

            // optional bool online_collapsed = 2;

            pub fn online_collapsed(&self) -> bool {
                self.online_collapsed.unwrap_or(false)
            }

            pub fn clear_online_collapsed(&mut self) {
                self.online_collapsed = ::std::option::Option::None;
            }

            pub fn has_online_collapsed(&self) -> bool {
                self.online_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_online_collapsed(&mut self, v: bool) {
                self.online_collapsed = ::std::option::Option::Some(v);
            }

            // optional bool offline_collapsed = 3;

            pub fn offline_collapsed(&self) -> bool {
                self.offline_collapsed.unwrap_or(false)
            }

            pub fn clear_offline_collapsed(&mut self) {
                self.offline_collapsed = ::std::option::Option::None;
            }

            pub fn has_offline_collapsed(&self) -> bool {
                self.offline_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_offline_collapsed(&mut self, v: bool) {
                self.offline_collapsed = ::std::option::Option::Some(v);
            }

            // optional int32 game_groups_collapsed = 4;

            pub fn game_groups_collapsed(&self) -> i32 {
                self.game_groups_collapsed.unwrap_or(0)
            }

            pub fn clear_game_groups_collapsed(&mut self) {
                self.game_groups_collapsed = ::std::option::Option::None;
            }

            pub fn has_game_groups_collapsed(&self) -> bool {
                self.game_groups_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_game_groups_collapsed(&mut self, v: i32) {
                self.game_groups_collapsed = ::std::option::Option::Some(v);
            }

            // optional int32 categories_collapsed = 5;

            pub fn categories_collapsed(&self) -> i32 {
                self.categories_collapsed.unwrap_or(0)
            }

            pub fn clear_categories_collapsed(&mut self) {
                self.categories_collapsed = ::std::option::Option::None;
            }

            pub fn has_categories_collapsed(&self) -> bool {
                self.categories_collapsed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_categories_collapsed(&mut self, v: i32) {
                self.categories_collapsed = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(5);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "in_game_collapsed",
                    |m: &CategoryCollapseState| { &m.in_game_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.in_game_collapsed },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "online_collapsed",
                    |m: &CategoryCollapseState| { &m.online_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.online_collapsed },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "offline_collapsed",
                    |m: &CategoryCollapseState| { &m.offline_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.offline_collapsed },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "game_groups_collapsed",
                    |m: &CategoryCollapseState| { &m.game_groups_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.game_groups_collapsed },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "categories_collapsed",
                    |m: &CategoryCollapseState| { &m.categories_collapsed },
                    |m: &mut CategoryCollapseState| { &mut m.categories_collapsed },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<CategoryCollapseState>(
                    "CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for CategoryCollapseState {
            const NAME: &'static str = "CategoryCollapseState";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.in_game_collapsed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        16 => {
                            self.online_collapsed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        24 => {
                            self.offline_collapsed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        32 => {
                            self.game_groups_collapsed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.categories_collapsed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.in_game_collapsed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.online_collapsed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.offline_collapsed {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.game_groups_collapsed {
                    my_size += crate::rt::int32_size(4, v);
                }
                if let Some(v) = self.categories_collapsed {
                    my_size += crate::rt::int32_size(5, v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.in_game_collapsed {
                    os.write_bool(1, v)?;
                }
                if let Some(v) = self.online_collapsed {
                    os.write_bool(2, v)?;
                }
                if let Some(v) = self.offline_collapsed {
                    os.write_bool(3, v)?;
                }
                if let Some(v) = self.game_groups_collapsed {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.categories_collapsed {
                    os.write_int32(5, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CategoryCollapseState {
                CategoryCollapseState::new()
            }

            fn clear(&mut self) {
                self.in_game_collapsed = ::std::option::Option::None;
                self.online_collapsed = ::std::option::Option::None;
                self.offline_collapsed = ::std::option::Option::None;
                self.game_groups_collapsed = ::std::option::Option::None;
                self.categories_collapsed = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CategoryCollapseState {
                static instance: CategoryCollapseState = CategoryCollapseState {
                    in_game_collapsed: ::std::option::Option::None,
                    online_collapsed: ::std::option::Option::None,
                    offline_collapsed: ::std::option::Option::None,
                    game_groups_collapsed: ::std::option::Option::None,
                    categories_collapsed: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for CategoryCollapseState {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseState").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CategoryCollapseState {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for CategoryCollapseState {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:CChatUsability_ClientUsabilityMetrics_Notification.Metrics)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Metrics {
        // message fields
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_count)
        pub friends_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_category_count)
        pub friends_category_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_categorized_count)
        pub friends_categorized_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_online_count)
        pub friends_online_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_in_game_count)
        pub friends_in_game_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_in_game_singleton_count)
        pub friends_in_game_singleton_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.game_group_count)
        pub game_group_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.friends_favorite_count)
        pub friends_favorite_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.group_chat_count)
        pub group_chat_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.group_chat_favorite_count)
        pub group_chat_favorite_count: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CChatUsability_ClientUsabilityMetrics_Notification.Metrics.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Metrics {
        fn default() -> &'a Metrics {
            <Metrics as crate::Message>::default_instance()
        }
    }

    impl Metrics {
        pub fn new() -> Metrics {
            ::std::default::Default::default()
        }

        // optional int32 friends_count = 1;

        pub fn friends_count(&self) -> i32 {
            self.friends_count.unwrap_or(0)
        }

        pub fn clear_friends_count(&mut self) {
            self.friends_count = ::std::option::Option::None;
        }

        pub fn has_friends_count(&self) -> bool {
            self.friends_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_count(&mut self, v: i32) {
            self.friends_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_category_count = 2;

        pub fn friends_category_count(&self) -> i32 {
            self.friends_category_count.unwrap_or(0)
        }

        pub fn clear_friends_category_count(&mut self) {
            self.friends_category_count = ::std::option::Option::None;
        }

        pub fn has_friends_category_count(&self) -> bool {
            self.friends_category_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_category_count(&mut self, v: i32) {
            self.friends_category_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_categorized_count = 3;

        pub fn friends_categorized_count(&self) -> i32 {
            self.friends_categorized_count.unwrap_or(0)
        }

        pub fn clear_friends_categorized_count(&mut self) {
            self.friends_categorized_count = ::std::option::Option::None;
        }

        pub fn has_friends_categorized_count(&self) -> bool {
            self.friends_categorized_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_categorized_count(&mut self, v: i32) {
            self.friends_categorized_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_online_count = 4;

        pub fn friends_online_count(&self) -> i32 {
            self.friends_online_count.unwrap_or(0)
        }

        pub fn clear_friends_online_count(&mut self) {
            self.friends_online_count = ::std::option::Option::None;
        }

        pub fn has_friends_online_count(&self) -> bool {
            self.friends_online_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_online_count(&mut self, v: i32) {
            self.friends_online_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_in_game_count = 5;

        pub fn friends_in_game_count(&self) -> i32 {
            self.friends_in_game_count.unwrap_or(0)
        }

        pub fn clear_friends_in_game_count(&mut self) {
            self.friends_in_game_count = ::std::option::Option::None;
        }

        pub fn has_friends_in_game_count(&self) -> bool {
            self.friends_in_game_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_in_game_count(&mut self, v: i32) {
            self.friends_in_game_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_in_game_singleton_count = 6;

        pub fn friends_in_game_singleton_count(&self) -> i32 {
            self.friends_in_game_singleton_count.unwrap_or(0)
        }

        pub fn clear_friends_in_game_singleton_count(&mut self) {
            self.friends_in_game_singleton_count = ::std::option::Option::None;
        }

        pub fn has_friends_in_game_singleton_count(&self) -> bool {
            self.friends_in_game_singleton_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_in_game_singleton_count(&mut self, v: i32) {
            self.friends_in_game_singleton_count = ::std::option::Option::Some(v);
        }

        // optional int32 game_group_count = 7;

        pub fn game_group_count(&self) -> i32 {
            self.game_group_count.unwrap_or(0)
        }

        pub fn clear_game_group_count(&mut self) {
            self.game_group_count = ::std::option::Option::None;
        }

        pub fn has_game_group_count(&self) -> bool {
            self.game_group_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_group_count(&mut self, v: i32) {
            self.game_group_count = ::std::option::Option::Some(v);
        }

        // optional int32 friends_favorite_count = 8;

        pub fn friends_favorite_count(&self) -> i32 {
            self.friends_favorite_count.unwrap_or(0)
        }

        pub fn clear_friends_favorite_count(&mut self) {
            self.friends_favorite_count = ::std::option::Option::None;
        }

        pub fn has_friends_favorite_count(&self) -> bool {
            self.friends_favorite_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_friends_favorite_count(&mut self, v: i32) {
            self.friends_favorite_count = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_count = 9;

        pub fn group_chat_count(&self) -> i32 {
            self.group_chat_count.unwrap_or(0)
        }

        pub fn clear_group_chat_count(&mut self) {
            self.group_chat_count = ::std::option::Option::None;
        }

        pub fn has_group_chat_count(&self) -> bool {
            self.group_chat_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_count(&mut self, v: i32) {
            self.group_chat_count = ::std::option::Option::Some(v);
        }

        // optional int32 group_chat_favorite_count = 10;

        pub fn group_chat_favorite_count(&self) -> i32 {
            self.group_chat_favorite_count.unwrap_or(0)
        }

        pub fn clear_group_chat_favorite_count(&mut self) {
            self.group_chat_favorite_count = ::std::option::Option::None;
        }

        pub fn has_group_chat_favorite_count(&self) -> bool {
            self.group_chat_favorite_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_group_chat_favorite_count(&mut self, v: i32) {
            self.group_chat_favorite_count = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(10);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_count",
                |m: &Metrics| { &m.friends_count },
                |m: &mut Metrics| { &mut m.friends_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_category_count",
                |m: &Metrics| { &m.friends_category_count },
                |m: &mut Metrics| { &mut m.friends_category_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_categorized_count",
                |m: &Metrics| { &m.friends_categorized_count },
                |m: &mut Metrics| { &mut m.friends_categorized_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_online_count",
                |m: &Metrics| { &m.friends_online_count },
                |m: &mut Metrics| { &mut m.friends_online_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_in_game_count",
                |m: &Metrics| { &m.friends_in_game_count },
                |m: &mut Metrics| { &mut m.friends_in_game_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_in_game_singleton_count",
                |m: &Metrics| { &m.friends_in_game_singleton_count },
                |m: &mut Metrics| { &mut m.friends_in_game_singleton_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_group_count",
                |m: &Metrics| { &m.game_group_count },
                |m: &mut Metrics| { &mut m.game_group_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "friends_favorite_count",
                |m: &Metrics| { &m.friends_favorite_count },
                |m: &mut Metrics| { &mut m.friends_favorite_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_count",
                |m: &Metrics| { &m.group_chat_count },
                |m: &mut Metrics| { &mut m.group_chat_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "group_chat_favorite_count",
                |m: &Metrics| { &m.group_chat_favorite_count },
                |m: &mut Metrics| { &mut m.group_chat_favorite_count },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Metrics>(
                "CChatUsability_ClientUsabilityMetrics_Notification.Metrics",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Metrics {
        const NAME: &'static str = "Metrics";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.friends_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.friends_category_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.friends_categorized_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.friends_online_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.friends_in_game_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.friends_in_game_singleton_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.game_group_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.friends_favorite_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.group_chat_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.group_chat_favorite_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.friends_count {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.friends_category_count {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.friends_categorized_count {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.friends_online_count {
                my_size += crate::rt::int32_size(4, v);
            }
            if let Some(v) = self.friends_in_game_count {
                my_size += crate::rt::int32_size(5, v);
            }
            if let Some(v) = self.friends_in_game_singleton_count {
                my_size += crate::rt::int32_size(6, v);
            }
            if let Some(v) = self.game_group_count {
                my_size += crate::rt::int32_size(7, v);
            }
            if let Some(v) = self.friends_favorite_count {
                my_size += crate::rt::int32_size(8, v);
            }
            if let Some(v) = self.group_chat_count {
                my_size += crate::rt::int32_size(9, v);
            }
            if let Some(v) = self.group_chat_favorite_count {
                my_size += crate::rt::int32_size(10, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.friends_count {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.friends_category_count {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.friends_categorized_count {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.friends_online_count {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.friends_in_game_count {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.friends_in_game_singleton_count {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.game_group_count {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.friends_favorite_count {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.group_chat_count {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.group_chat_favorite_count {
                os.write_int32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Metrics {
            Metrics::new()
        }

        fn clear(&mut self) {
            self.friends_count = ::std::option::Option::None;
            self.friends_category_count = ::std::option::Option::None;
            self.friends_categorized_count = ::std::option::Option::None;
            self.friends_online_count = ::std::option::Option::None;
            self.friends_in_game_count = ::std::option::Option::None;
            self.friends_in_game_singleton_count = ::std::option::Option::None;
            self.game_group_count = ::std::option::Option::None;
            self.friends_favorite_count = ::std::option::Option::None;
            self.group_chat_count = ::std::option::Option::None;
            self.group_chat_favorite_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Metrics {
            static instance: Metrics = Metrics {
                friends_count: ::std::option::Option::None,
                friends_category_count: ::std::option::Option::None,
                friends_categorized_count: ::std::option::Option::None,
                friends_online_count: ::std::option::Option::None,
                friends_in_game_count: ::std::option::Option::None,
                friends_in_game_singleton_count: ::std::option::Option::None,
                game_group_count: ::std::option::Option::None,
                friends_favorite_count: ::std::option::Option::None,
                group_chat_count: ::std::option::Option::None,
                group_chat_favorite_count: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Metrics {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CChatUsability_ClientUsabilityMetrics_Notification.Metrics").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Metrics {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Metrics {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CChatUsability_RequestClientUsabilityMetrics_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CChatUsability_RequestClientUsabilityMetrics_Notification {
    // message fields
    // @@protoc_insertion_point(field:CChatUsability_RequestClientUsabilityMetrics_Notification.metrics_run_id)
    pub metrics_run_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CChatUsability_RequestClientUsabilityMetrics_Notification.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn default() -> &'a CChatUsability_RequestClientUsabilityMetrics_Notification {
        <CChatUsability_RequestClientUsabilityMetrics_Notification as crate::Message>::default_instance()
    }
}

impl CChatUsability_RequestClientUsabilityMetrics_Notification {
    pub fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        ::std::default::Default::default()
    }

    // optional uint32 metrics_run_id = 1;

    pub fn metrics_run_id(&self) -> u32 {
        self.metrics_run_id.unwrap_or(0)
    }

    pub fn clear_metrics_run_id(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
    }

    pub fn has_metrics_run_id(&self) -> bool {
        self.metrics_run_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metrics_run_id(&mut self, v: u32) {
        self.metrics_run_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "metrics_run_id",
            |m: &CChatUsability_RequestClientUsabilityMetrics_Notification| { &m.metrics_run_id },
            |m: &mut CChatUsability_RequestClientUsabilityMetrics_Notification| { &mut m.metrics_run_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CChatUsability_RequestClientUsabilityMetrics_Notification>(
            "CChatUsability_RequestClientUsabilityMetrics_Notification",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CChatUsability_RequestClientUsabilityMetrics_Notification {
    const NAME: &'static str = "CChatUsability_RequestClientUsabilityMetrics_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.metrics_run_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.metrics_run_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.metrics_run_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CChatUsability_RequestClientUsabilityMetrics_Notification {
        CChatUsability_RequestClientUsabilityMetrics_Notification::new()
    }

    fn clear(&mut self) {
        self.metrics_run_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CChatUsability_RequestClientUsabilityMetrics_Notification {
        static instance: CChatUsability_RequestClientUsabilityMetrics_Notification = CChatUsability_RequestClientUsabilityMetrics_Notification {
            metrics_run_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CChatUsability_RequestClientUsabilityMetrics_Notification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CChatUsability_RequestClientUsabilityMetrics_Notification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CChatUsability_RequestClientUsabilityMetrics_Notification {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomJoinState)
pub enum EChatRoomJoinState {
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_Default)
    k_EChatRoomJoinState_Default = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_None)
    k_EChatRoomJoinState_None = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_Joined)
    k_EChatRoomJoinState_Joined = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomJoinState.k_EChatRoomJoinState_TestInvalid)
    k_EChatRoomJoinState_TestInvalid = 99,
}

impl crate::Enum for EChatRoomJoinState {
    const NAME: &'static str = "EChatRoomJoinState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomJoinState> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            1 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_None),
            2 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Joined),
            99 => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomJoinState> {
        match str {
            "k_EChatRoomJoinState_Default" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Default),
            "k_EChatRoomJoinState_None" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_None),
            "k_EChatRoomJoinState_Joined" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_Joined),
            "k_EChatRoomJoinState_TestInvalid" => ::std::option::Option::Some(EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomJoinState] = &[
        EChatRoomJoinState::k_EChatRoomJoinState_Default,
        EChatRoomJoinState::k_EChatRoomJoinState_None,
        EChatRoomJoinState::k_EChatRoomJoinState_Joined,
        EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid,
    ];
}

impl crate::EnumFull for EChatRoomJoinState {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomJoinState").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EChatRoomJoinState::k_EChatRoomJoinState_Default => 0,
            EChatRoomJoinState::k_EChatRoomJoinState_None => 1,
            EChatRoomJoinState::k_EChatRoomJoinState_Joined => 2,
            EChatRoomJoinState::k_EChatRoomJoinState_TestInvalid => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomJoinState {
    fn default() -> Self {
        EChatRoomJoinState::k_EChatRoomJoinState_Default
    }
}

impl EChatRoomJoinState {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EChatRoomJoinState>("EChatRoomJoinState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomGroupRank)
pub enum EChatRoomGroupRank {
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Default)
    k_EChatRoomGroupRank_Default = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Viewer)
    k_EChatRoomGroupRank_Viewer = 10,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Guest)
    k_EChatRoomGroupRank_Guest = 15,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Member)
    k_EChatRoomGroupRank_Member = 20,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Moderator)
    k_EChatRoomGroupRank_Moderator = 30,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Officer)
    k_EChatRoomGroupRank_Officer = 40,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_Owner)
    k_EChatRoomGroupRank_Owner = 50,
    // @@protoc_insertion_point(enum_value:EChatRoomGroupRank.k_EChatRoomGroupRank_TestInvalid)
    k_EChatRoomGroupRank_TestInvalid = 99,
}

impl crate::Enum for EChatRoomGroupRank {
    const NAME: &'static str = "EChatRoomGroupRank";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomGroupRank> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            10 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer),
            15 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Guest),
            20 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Member),
            30 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator),
            40 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Officer),
            50 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Owner),
            99 => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomGroupRank> {
        match str {
            "k_EChatRoomGroupRank_Default" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Default),
            "k_EChatRoomGroupRank_Viewer" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer),
            "k_EChatRoomGroupRank_Guest" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Guest),
            "k_EChatRoomGroupRank_Member" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Member),
            "k_EChatRoomGroupRank_Moderator" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator),
            "k_EChatRoomGroupRank_Officer" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Officer),
            "k_EChatRoomGroupRank_Owner" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_Owner),
            "k_EChatRoomGroupRank_TestInvalid" => ::std::option::Option::Some(EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomGroupRank] = &[
        EChatRoomGroupRank::k_EChatRoomGroupRank_Default,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Guest,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Member,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Officer,
        EChatRoomGroupRank::k_EChatRoomGroupRank_Owner,
        EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid,
    ];
}

impl crate::EnumFull for EChatRoomGroupRank {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomGroupRank").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EChatRoomGroupRank::k_EChatRoomGroupRank_Default => 0,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Viewer => 1,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Guest => 2,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Member => 3,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Moderator => 4,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Officer => 5,
            EChatRoomGroupRank::k_EChatRoomGroupRank_Owner => 6,
            EChatRoomGroupRank::k_EChatRoomGroupRank_TestInvalid => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomGroupRank {
    fn default() -> Self {
        EChatRoomGroupRank::k_EChatRoomGroupRank_Default
    }
}

impl EChatRoomGroupRank {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EChatRoomGroupRank>("EChatRoomGroupRank")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomNotificationLevel)
pub enum EChatRoomNotificationLevel {
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_Invalid)
    k_EChatroomNotificationLevel_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_None)
    k_EChatroomNotificationLevel_None = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_MentionMe)
    k_EChatroomNotificationLevel_MentionMe = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_MentionAll)
    k_EChatroomNotificationLevel_MentionAll = 3,
    // @@protoc_insertion_point(enum_value:EChatRoomNotificationLevel.k_EChatroomNotificationLevel_AllMessages)
    k_EChatroomNotificationLevel_AllMessages = 4,
}

impl crate::Enum for EChatRoomNotificationLevel {
    const NAME: &'static str = "EChatRoomNotificationLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomNotificationLevel> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            1 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None),
            2 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe),
            3 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll),
            4 => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomNotificationLevel> {
        match str {
            "k_EChatroomNotificationLevel_Invalid" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid),
            "k_EChatroomNotificationLevel_None" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None),
            "k_EChatroomNotificationLevel_MentionMe" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe),
            "k_EChatroomNotificationLevel_MentionAll" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll),
            "k_EChatroomNotificationLevel_AllMessages" => ::std::option::Option::Some(EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomNotificationLevel] = &[
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_None,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionMe,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_MentionAll,
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_AllMessages,
    ];
}

impl crate::EnumFull for EChatRoomNotificationLevel {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomNotificationLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomNotificationLevel {
    fn default() -> Self {
        EChatRoomNotificationLevel::k_EChatroomNotificationLevel_Invalid
    }
}

impl EChatRoomNotificationLevel {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EChatRoomNotificationLevel>("EChatRoomNotificationLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomServerMessage)
pub enum EChatRoomServerMessage {
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Invalid)
    k_EChatRoomServerMsg_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_RenameChatRoom)
    k_EChatRoomServerMsg_RenameChatRoom = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Joined)
    k_EChatRoomServerMsg_Joined = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Parted)
    k_EChatRoomServerMsg_Parted = 3,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Kicked)
    k_EChatRoomServerMsg_Kicked = 4,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_Invited)
    k_EChatRoomServerMsg_Invited = 5,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_InviteDismissed)
    k_EChatRoomServerMsg_InviteDismissed = 8,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_ChatRoomTaglineChanged)
    k_EChatRoomServerMsg_ChatRoomTaglineChanged = 9,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_ChatRoomAvatarChanged)
    k_EChatRoomServerMsg_ChatRoomAvatarChanged = 10,
    // @@protoc_insertion_point(enum_value:EChatRoomServerMessage.k_EChatRoomServerMsg_AppCustom)
    k_EChatRoomServerMsg_AppCustom = 11,
}

impl crate::Enum for EChatRoomServerMessage {
    const NAME: &'static str = "EChatRoomServerMessage";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomServerMessage> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            1 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom),
            2 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Joined),
            3 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Parted),
            4 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked),
            5 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invited),
            8 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged),
            10 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged),
            11 => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomServerMessage> {
        match str {
            "k_EChatRoomServerMsg_Invalid" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid),
            "k_EChatRoomServerMsg_RenameChatRoom" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom),
            "k_EChatRoomServerMsg_Joined" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Joined),
            "k_EChatRoomServerMsg_Parted" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Parted),
            "k_EChatRoomServerMsg_Kicked" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked),
            "k_EChatRoomServerMsg_Invited" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_Invited),
            "k_EChatRoomServerMsg_InviteDismissed" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed),
            "k_EChatRoomServerMsg_ChatRoomTaglineChanged" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged),
            "k_EChatRoomServerMsg_ChatRoomAvatarChanged" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged),
            "k_EChatRoomServerMsg_AppCustom" => ::std::option::Option::Some(EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomServerMessage] = &[
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid,
        EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Joined,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Parted,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked,
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invited,
        EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed,
        EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged,
        EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged,
        EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom,
    ];
}

impl crate::EnumFull for EChatRoomServerMessage {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomServerMessage").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid => 0,
            EChatRoomServerMessage::k_EChatRoomServerMsg_RenameChatRoom => 1,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Joined => 2,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Parted => 3,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Kicked => 4,
            EChatRoomServerMessage::k_EChatRoomServerMsg_Invited => 5,
            EChatRoomServerMessage::k_EChatRoomServerMsg_InviteDismissed => 6,
            EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomTaglineChanged => 7,
            EChatRoomServerMessage::k_EChatRoomServerMsg_ChatRoomAvatarChanged => 8,
            EChatRoomServerMessage::k_EChatRoomServerMsg_AppCustom => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomServerMessage {
    fn default() -> Self {
        EChatRoomServerMessage::k_EChatRoomServerMsg_Invalid
    }
}

impl EChatRoomServerMessage {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EChatRoomServerMessage>("EChatRoomServerMessage")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomMessageReactionType)
pub enum EChatRoomMessageReactionType {
    // @@protoc_insertion_point(enum_value:EChatRoomMessageReactionType.k_EChatRoomMessageReactionType_Invalid)
    k_EChatRoomMessageReactionType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomMessageReactionType.k_EChatRoomMessageReactionType_Emoticon)
    k_EChatRoomMessageReactionType_Emoticon = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomMessageReactionType.k_EChatRoomMessageReactionType_Sticker)
    k_EChatRoomMessageReactionType_Sticker = 2,
}

impl crate::Enum for EChatRoomMessageReactionType {
    const NAME: &'static str = "EChatRoomMessageReactionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomMessageReactionType> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            1 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon),
            2 => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Sticker),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomMessageReactionType> {
        match str {
            "k_EChatRoomMessageReactionType_Invalid" => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid),
            "k_EChatRoomMessageReactionType_Emoticon" => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon),
            "k_EChatRoomMessageReactionType_Sticker" => ::std::option::Option::Some(EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Sticker),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomMessageReactionType] = &[
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid,
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Emoticon,
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Sticker,
    ];
}

impl crate::EnumFull for EChatRoomMessageReactionType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomMessageReactionType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomMessageReactionType {
    fn default() -> Self {
        EChatRoomMessageReactionType::k_EChatRoomMessageReactionType_Invalid
    }
}

impl EChatRoomMessageReactionType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EChatRoomMessageReactionType>("EChatRoomMessageReactionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EChatRoomMemberStateChange)
pub enum EChatRoomMemberStateChange {
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Invalid)
    k_EChatRoomMemberStateChange_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Joined)
    k_EChatRoomMemberStateChange_Joined = 1,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Parted)
    k_EChatRoomMemberStateChange_Parted = 2,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Kicked)
    k_EChatRoomMemberStateChange_Kicked = 3,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Invited)
    k_EChatRoomMemberStateChange_Invited = 4,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_RankChanged)
    k_EChatRoomMemberStateChange_RankChanged = 7,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_InviteDismissed)
    k_EChatRoomMemberStateChange_InviteDismissed = 8,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Muted)
    k_EChatRoomMemberStateChange_Muted = 9,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_Banned)
    k_EChatRoomMemberStateChange_Banned = 10,
    // @@protoc_insertion_point(enum_value:EChatRoomMemberStateChange.k_EChatRoomMemberStateChange_RolesChanged)
    k_EChatRoomMemberStateChange_RolesChanged = 12,
}

impl crate::Enum for EChatRoomMemberStateChange {
    const NAME: &'static str = "EChatRoomMemberStateChange";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EChatRoomMemberStateChange> {
        match value {
            0 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            1 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined),
            2 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted),
            3 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked),
            4 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited),
            7 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged),
            8 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed),
            9 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted),
            10 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned),
            12 => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EChatRoomMemberStateChange> {
        match str {
            "k_EChatRoomMemberStateChange_Invalid" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid),
            "k_EChatRoomMemberStateChange_Joined" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined),
            "k_EChatRoomMemberStateChange_Parted" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted),
            "k_EChatRoomMemberStateChange_Kicked" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked),
            "k_EChatRoomMemberStateChange_Invited" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited),
            "k_EChatRoomMemberStateChange_RankChanged" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged),
            "k_EChatRoomMemberStateChange_InviteDismissed" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed),
            "k_EChatRoomMemberStateChange_Muted" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted),
            "k_EChatRoomMemberStateChange_Banned" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned),
            "k_EChatRoomMemberStateChange_RolesChanged" => ::std::option::Option::Some(EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EChatRoomMemberStateChange] = &[
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned,
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged,
    ];
}

impl crate::EnumFull for EChatRoomMemberStateChange {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EChatRoomMemberStateChange").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid => 0,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Joined => 1,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Parted => 2,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Kicked => 3,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invited => 4,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RankChanged => 5,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_InviteDismissed => 6,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Muted => 7,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Banned => 8,
            EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_RolesChanged => 9,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EChatRoomMemberStateChange {
    fn default() -> Self {
        EChatRoomMemberStateChange::k_EChatRoomMemberStateChange_Invalid
    }
}

impl EChatRoomMemberStateChange {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EChatRoomMemberStateChange>("EChatRoomMemberStateChange")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$steammessages_chat.steamclient.proto\x1a\x18steammessages_base.proto\
    \x1a,steammessages_unified_base.steamclient.proto\x1a(steammessages_clie\
    ntserver_friends.proto\"*\n(CChat_RequestFriendPersonaStates_Request\"+\
    \n)CChat_RequestFriendPersonaStates_Response\"\xbd\x02\n%CChatRoom_Creat\
    eChatRoomGroup_Request\x12'\n\x0fsteamid_partner\x18\x01\x20\x01(\x06R\
    \x0esteamidPartner\x12'\n\x0fsteamid_invited\x18\x02\x20\x01(\x06R\x0est\
    eamidInvited\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12)\n\x10ste\
    amid_invitees\x18\x04\x20\x03(\x06R\x0fsteamidInvitees\x12@\n\x1cwatchin\
    g_broadcast_accountid\x18\x06\x20\x01(\rR\x1awatchingBroadcastAccountid\
    \x12A\n\x1dwatching_broadcast_channel_id\x18\x07\x20\x01(\x04R\x1awatchi\
    ngBroadcastChannelId\"R\n\tCChatRole\x12\x17\n\x07role_id\x18\x01\x20\
    \x01(\x04R\x06roleId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x18\n\x07ordinal\x18\x03\x20\x01(\rR\x07ordinal\"\x9c\x04\n\x10CChatRol\
    eActions\x12\x17\n\x07role_id\x18\x01\x20\x01(\x04R\x06roleId\x12F\n\x20\
    can_create_rename_delete_channel\x18\x02\x20\x01(\x08R\x1ccanCreateRenam\
    eDeleteChannel\x12\x19\n\x08can_kick\x18\x03\x20\x01(\x08R\x07canKick\
    \x12\x17\n\x07can_ban\x18\x04\x20\x01(\x08R\x06canBan\x12\x1d\n\ncan_inv\
    ite\x18\x05\x20\x01(\x08R\tcanInvite\x12B\n\x1ecan_change_tagline_avatar\
    _name\x18\x06\x20\x01(\x08R\x1acanChangeTaglineAvatarName\x12\x19\n\x08c\
    an_chat\x18\x07\x20\x01(\x08R\x07canChat\x12(\n\x10can_view_history\x18\
    \x08\x20\x01(\x08R\x0ecanViewHistory\x123\n\x16can_change_group_roles\
    \x18\t\x20\x01(\x08R\x13canChangeGroupRoles\x121\n\x15can_change_user_ro\
    les\x18\n\x20\x01(\x08R\x12canChangeUserRoles\x12&\n\x0fcan_mention_all\
    \x18\x0b\x20\x01(\x08R\rcanMentionAll\x12;\n\x1acan_set_watching_broadca\
    st\x18\x0c\x20\x01(\x08R\x17canSetWatchingBroadcast\"\x90\x01\n\x10CChat\
    PartyBeacon\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12#\n\rste\
    amid_owner\x18\x02\x20\x01(\x06R\x0csteamidOwner\x12\x1b\n\tbeacon_id\
    \x18\x03\x20\x01(\x06R\x08beaconId\x12#\n\rgame_metadata\x18\x04\x20\x01\
    (\tR\x0cgameMetadata\"\x99\x05\n\x19CChatRoomGroupHeaderState\x12\"\n\rc\
    hat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x1b\n\tchat_name\
    \x18\x02\x20\x01(\tR\x08chatName\x12\x16\n\x06clanid\x18\r\x20\x01(\rR\
    \x06clanid\x12'\n\x0faccountid_owner\x18\x0e\x20\x01(\rR\x0eaccountidOwn\
    er\x12\x14\n\x05appid\x18\x15\x20\x01(\rR\x05appid\x12\x18\n\x07tagline\
    \x18\x0f\x20\x01(\tR\x07tagline\x12\x1d\n\navatar_sha\x18\x10\x20\x01(\
    \x0cR\tavatarSha\x12&\n\x0fdefault_role_id\x18\x11\x20\x01(\x04R\rdefaul\
    tRoleId\x12\x20\n\x05roles\x18\x12\x20\x03(\x0b2\n.CChatRoleR\x05roles\
    \x124\n\x0crole_actions\x18\x13\x20\x03(\x0b2\x11.CChatRoleActionsR\x0br\
    oleActions\x12@\n\x1cwatching_broadcast_accountid\x18\x14\x20\x01(\rR\
    \x1awatchingBroadcastAccountid\x126\n\rparty_beacons\x18\x16\x20\x03(\
    \x0b2\x11.CChatPartyBeaconR\x0cpartyBeacons\x12A\n\x1dwatching_broadcast\
    _channel_id\x18\x17\x20\x01(\x04R\x1awatchingBroadcastChannelId\x12,\n\
    \x12active_minigame_id\x18\x18\x20\x01(\x04R\x10activeMinigameId\x12$\n\
    \x0eavatar_ugc_url\x18\x19\x20\x01(\tR\x0cavatarUgcUrl\x12\x1a\n\x08disa\
    bled\x18\x1a\x20\x01(\x08R\x08disabled\"\x84\x02\n\x0fCChatRoomMember\
    \x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12G\n\x05state\x18\
    \x03\x20\x01(\x0e2\x13.EChatRoomJoinState:\x1ck_EChatRoomJoinState_Defau\
    ltR\x05state\x12E\n\x04rank\x18\x04\x20\x01(\x0e2\x13.EChatRoomGroupRank\
    :\x1ck_EChatRoomGroupRank_DefaultR\x04rank\x12(\n\x10time_kick_expire\
    \x18\x06\x20\x01(\rR\x0etimeKickExpire\x12\x19\n\x08role_ids\x18\x07\x20\
    \x03(\x04R\x07roleIds\"\xb9\x02\n\x0eCChatRoomState\x12\x17\n\x07chat_id\
    \x18\x01\x20\x01(\x04R\x06chatId\x12\x1b\n\tchat_name\x18\x02\x20\x01(\t\
    R\x08chatName\x12#\n\rvoice_allowed\x18\x03\x20\x01(\x08R\x0cvoiceAllowe\
    d\x12(\n\x10members_in_voice\x18\x04\x20\x03(\rR\x0emembersInVoice\x12*\
    \n\x11time_last_message\x18\x05\x20\x01(\rR\x0ftimeLastMessage\x12\x1d\n\
    \nsort_order\x18\x06\x20\x01(\rR\tsortOrder\x12!\n\x0clast_message\x18\
    \x07\x20\x01(\tR\x0blastMessage\x124\n\x16accountid_last_message\x18\x08\
    \x20\x01(\rR\x14accountidLastMessage\"\x82\x02\n\x13CChatRoomGroupState\
    \x12=\n\x0cheader_state\x18\x01\x20\x01(\x0b2\x1a.CChatRoomGroupHeaderSt\
    ateR\x0bheaderState\x12*\n\x07members\x18\x02\x20\x03(\x0b2\x10.CChatRoo\
    mMemberR\x07members\x12&\n\x0fdefault_chat_id\x18\x04\x20\x01(\x04R\rdef\
    aultChatId\x12.\n\nchat_rooms\x18\x05\x20\x03(\x0b2\x0f.CChatRoomStateR\
    \tchatRooms\x12(\n\x06kicked\x18\x07\x20\x03(\x0b2\x10.CChatRoomMemberR\
    \x06kicked\"\x87\x04\n\x12CUserChatRoomState\x12\x17\n\x07chat_id\x18\
    \x01\x20\x01(\x04R\x06chatId\x12\x1f\n\x0btime_joined\x18\x02\x20\x01(\r\
    R\ntimeJoined\x12\"\n\rtime_last_ack\x18\x03\x20\x01(\rR\x0btimeLastAck\
    \x12\x7f\n\x1adesktop_notification_level\x18\x04\x20\x01(\x0e2\x1b.EChat\
    RoomNotificationLevel:$k_EChatroomNotificationLevel_InvalidR\x18desktopN\
    otificationLevel\x12}\n\x19mobile_notification_level\x18\x05\x20\x01(\
    \x0e2\x1b.EChatRoomNotificationLevel:$k_EChatroomNotificationLevel_Inval\
    idR\x17mobileNotificationLevel\x12*\n\x11time_last_mention\x18\x06\x20\
    \x01(\rR\x0ftimeLastMention\x12;\n\x16unread_indicator_muted\x18\x07\x20\
    \x01(\x08:\x05falseR\x14unreadIndicatorMuted\x12*\n\x11time_first_unread\
    \x18\x08\x20\x01(\rR\x0ftimeFirstUnread\"\x90\x04\n\x17CUserChatRoomGrou\
    pState\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x1f\n\x0btime_joined\x18\x02\x20\x01(\rR\ntimeJoined\x12D\n\x14user_cha\
    t_room_state\x18\x03\x20\x03(\x0b2\x13.CUserChatRoomStateR\x11userChatRo\
    omState\x12\x7f\n\x1adesktop_notification_level\x18\x04\x20\x01(\x0e2\
    \x1b.EChatRoomNotificationLevel:$k_EChatroomNotificationLevel_InvalidR\
    \x18desktopNotificationLevel\x12}\n\x19mobile_notification_level\x18\x05\
    \x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_EChatroomNotificationLe\
    vel_InvalidR\x17mobileNotificationLevel\x12-\n\x13time_last_group_ack\
    \x18\x06\x20\x01(\rR\x10timeLastGroupAck\x12;\n\x16unread_indicator_mute\
    d\x18\x07\x20\x01(\x08:\x05falseR\x14unreadIndicatorMuted\"\xba\x01\n&CC\
    hatRoom_CreateChatRoomGroup_Response\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12*\n\x05state\x18\x02\x20\x01(\x0b2\x14.CCha\
    tRoomGroupStateR\x05state\x12@\n\x0fuser_chat_state\x18\x03\x20\x01(\x0b\
    2\x18.CUserChatRoomGroupStateR\ruserChatState\"]\n#CChatRoom_SaveChatRoo\
    mGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroup\
    Id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"&\n$CChatRoom_SaveChat\
    RoomGroup_Response\"_\n%CChatRoom_RenameChatRoomGroup_Request\x12\"\n\rc\
    hat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\"<\n&CChatRoom_RenameChatRoomGroup_Response\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"i\n)CChatRoom_SetChatRoomGro\
    upTagline_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGr\
    oupId\x12\x18\n\x07tagline\x18\x02\x20\x01(\tR\x07tagline\",\n*CChatRoom\
    _SetChatRoomGroupTagline_Response\"m\n(CChatRoom_SetChatRoomGroupAvatar_\
    Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x1d\n\navatar_sha\x18\x02\x20\x01(\x0cR\tavatarSha\"+\n)CChatRoom_SetCh\
    atRoomGroupAvatar_Response\"\xde\x01\n3CChatRoom_SetChatRoomGroupWatchin\
    gBroadcast_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatG\
    roupId\x12@\n\x1cwatching_broadcast_accountid\x18\x02\x20\x01(\rR\x1awat\
    chingBroadcastAccountid\x12A\n\x1dwatching_broadcast_channel_id\x18\x03\
    \x20\x01(\x04R\x1awatchingBroadcastChannelId\"6\n4CChatRoom_SetChatRoomG\
    roupWatchingBroadcast_Response\"m\n.CChatRoom_JoinMiniGameForChatRoomGro\
    up_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\"R\n/CChatRoom_Joi\
    nMiniGameForChatRoomGroup_Response\x12\x1f\n\x0bminigame_id\x18\x01\x20\
    \x01(\x04R\nminigameId\"\x8d\x01\n-CChatRoom_EndMiniGameForChatRoomGroup\
    _Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\x1f\n\x0bminigame_\
    id\x18\x03\x20\x01(\x04R\nminigameId\"0\n.CChatRoom_EndMiniGameForChatRo\
    omGroup_Response\"z\n\x1aCChatRoom_MuteUser_Request\x12\"\n\rchat_group_\
    id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07steamid\x18\x02\x20\
    \x01(\x06R\x07steamid\x12\x1e\n\nexpiration\x18\x03\x20\x01(\x05R\nexpir\
    ation\"\x1d\n\x1bCChatRoom_MuteUser_Response\"z\n\x1aCChatRoom_KickUser_\
    Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x18\n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\x12\x1e\n\nexpiration\
    \x18\x03\x20\x01(\x05R\nexpiration\"\x1d\n\x1bCChatRoom_KickUser_Respons\
    e\"~\n!CChatRoom_SetUserBanState_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\
    \x07steamid\x12\x1b\n\tban_state\x18\x03\x20\x01(\x08R\x08banState\"$\n\
    \"CChatRoom_SetUserBanState_Response\"^\n\x1eCChatRoom_RevokeInvite_Requ\
    est\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\
    \n\x07steamid\x18\x02\x20\x01(\x06R\x07steamid\"!\n\x1fCChatRoom_RevokeI\
    nvite_Response\"V\n\x1cCChatRoom_CreateRole_Request\x12\"\n\rchat_group_\
    id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\"L\n\x1dCChatRoom_CreateRole_Response\x12+\n\x07actions\
    \x18\x02\x20\x01(\x0b2\x11.CChatRoleActionsR\x07actions\"@\n\x1aCChatRoo\
    m_GetRoles_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatG\
    roupId\"?\n\x1bCChatRoom_GetRoles_Response\x12\x20\n\x05roles\x18\x01\
    \x20\x03(\x0b2\n.CChatRoleR\x05roles\"o\n\x1cCChatRoom_RenameRole_Reques\
    t\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\
    \x07role_id\x18\x02\x20\x01(\x04R\x06roleId\x12\x12\n\x04name\x18\x03\
    \x20\x01(\tR\x04name\"\x1f\n\x1dCChatRoom_RenameRole_Response\"v\n\x1dCC\
    hatRoom_ReorderRole_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\x12\
    \x18\n\x07ordinal\x18\x03\x20\x01(\rR\x07ordinal\"\x20\n\x1eCChatRoom_Re\
    orderRole_Response\"[\n\x1cCChatRoom_DeleteRole_Request\x12\"\n\rchat_gr\
    oup_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\
    \x20\x01(\x04R\x06roleId\"\x1f\n\x1dCChatRoom_DeleteRole_Response\"_\n\
    \x20CChatRoom_GetRoleActions_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06\
    roleId\"P\n!CChatRoom_GetRoleActions_Response\x12+\n\x07actions\x18\x01\
    \x20\x03(\x0b2\x11.CChatRoleActionsR\x07actions\"\x90\x01\n$CChatRoom_Re\
    placeRoleActions_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x17\n\x07role_id\x18\x02\x20\x01(\x04R\x06roleId\x12\
    +\n\x07actions\x18\x04\x20\x01(\x0b2\x11.CChatRoleActionsR\x07actions\"'\
    \n%CChatRoom_ReplaceRoleActions_Response\"x\n\x1fCChatRoom_AddRoleToUser\
    _Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07role_id\x18\x03\x20\x01(\x04R\x06roleId\x12\x18\n\x07steamid\
    \x18\x04\x20\x01(\x06R\x07steamid\"\"\n\x20CChatRoom_AddRoleToUser_Respo\
    nse\"a\n!CChatRoom_GetRolesForUser_Request\x12\"\n\rchat_group_id\x18\
    \x01\x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07steamid\x18\x03\x20\x01(\
    \x06R\x07steamid\"?\n\"CChatRoom_GetRolesForUser_Response\x12\x19\n\x08r\
    ole_ids\x18\x01\x20\x03(\x04R\x07roleIds\"}\n$CChatRoom_DeleteRoleFromUs\
    er_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12\x17\n\x07role_id\x18\x03\x20\x01(\x04R\x06roleId\x12\x18\n\x07steam\
    id\x18\x04\x20\x01(\x06R\x07steamid\"'\n%CChatRoom_DeleteRoleFromUser_Re\
    sponse\"\x83\x01\n#CChatRoom_JoinChatRoomGroup_Request\x12\"\n\rchat_gro\
    up_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x1f\n\x0binvite_code\x18\
    \x02\x20\x01(\tR\ninviteCode\x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\
    \x06chatId\"\xd7\x01\n$CChatRoom_JoinChatRoomGroup_Response\x12*\n\x05st\
    ate\x18\x01\x20\x01(\x0b2\x14.CChatRoomGroupStateR\x05state\x12@\n\x0fus\
    er_chat_state\x18\x03\x20\x01(\x0b2\x18.CUserChatRoomGroupStateR\ruserCh\
    atState\x12\x20\n\x0cjoin_chat_id\x18\x04\x20\x01(\x04R\njoinChatId\x12\
    \x1f\n\x0btime_expire\x18\x05\x20\x01(\rR\ntimeExpire\"\xb8\x01\n-CChatR\
    oom_InviteFriendToChatRoomGroup_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x18\n\x07steamid\x18\x02\x20\x01(\x06R\
    \x07steamid\x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\x120\n\
    \x14skip_friendsui_check\x18\x04\x20\x01(\x08R\x12skipFriendsuiCheck\"0\
    \n.CChatRoom_InviteFriendToChatRoomGroup_Response\"J\n$CChatRoom_LeaveCh\
    atRoomGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchat\
    GroupId\"'\n%CChatRoom_LeaveChatRoomGroup_Response\"{\n\x20CChatRoom_Cre\
    ateChatRoom_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchat\
    GroupId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x1f\n\x0ballow\
    _voice\x18\x03\x20\x01(\x08R\nallowVoice\"Q\n!CChatRoom_CreateChatRoom_R\
    esponse\x12,\n\tchat_room\x18\x01\x20\x01(\x0b2\x0f.CChatRoomStateR\x08c\
    hatRoom\"_\n\x20CChatRoom_DeleteChatRoom_Request\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\
    \x01(\x04R\x06chatId\"#\n!CChatRoom_DeleteChatRoom_Response\"s\n\x20CCha\
    tRoom_RenameChatRoom_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04\
    R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"#\n!CChatRoom_RenameChat\
    Room_Response\"\x8d\x01\n!CChatRoom_ReorderChatRoom_Request\x12\"\n\rcha\
    t_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\
    \x02\x20\x01(\x04R\x06chatId\x12+\n\x12move_after_chat_id\x18\x03\x20\
    \x01(\x04R\x0fmoveAfterChatId\"$\n\"CChatRoom_ReorderChatRoom_Response\"\
    \xa0\x01\n!CChatRoom_SendChatMessage_Request\x12\"\n\rchat_group_id\x18\
    \x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\
    \x04R\x06chatId\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12$\
    \n\x0eecho_to_sender\x18\x04\x20\x01(\x08R\x0cechoToSender\"\xcb\x01\n\"\
    CChatRoom_SendChatMessage_Response\x12)\n\x10modified_message\x18\x01\
    \x20\x01(\tR\x0fmodifiedMessage\x12)\n\x10server_timestamp\x18\x02\x20\
    \x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x03\x20\x01(\rR\x07\
    ordinal\x125\n\x17message_without_bb_code\x18\x04\x20\x01(\tR\x14message\
    WithoutBbCode\"^\n\x1fCChatRoom_JoinVoiceChat_Request\x12\"\n\rchat_grou\
    p_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\
    \x20\x01(\x04R\x06chatId\"E\n\x20CChatRoom_JoinVoiceChat_Response\x12!\n\
    \x0cvoice_chatid\x18\x01\x20\x01(\x04R\x0bvoiceChatid\"_\n\x20CChatRoom_\
    LeaveVoiceChat_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bc\
    hatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\"#\n!CCh\
    atRoom_LeaveVoiceChat_Response\"\x83\x02\n#CChatRoom_GetMessageHistory_R\
    equest\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\
    \x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\x1b\n\tlast_time\
    \x18\x03\x20\x01(\rR\x08lastTime\x12!\n\x0clast_ordinal\x18\x04\x20\x01(\
    \rR\x0blastOrdinal\x12\x1d\n\nstart_time\x18\x05\x20\x01(\rR\tstartTime\
    \x12#\n\rstart_ordinal\x18\x06\x20\x01(\rR\x0cstartOrdinal\x12\x1b\n\tma\
    x_count\x18\x07\x20\x01(\rR\x08maxCount\"\xac\x01\n\rServerMessage\x12O\
    \n\x07message\x18\x01\x20\x01(\x0e2\x17.EChatRoomServerMessage:\x1ck_ECh\
    atRoomServerMsg_InvalidR\x07message\x12!\n\x0cstring_param\x18\x02\x20\
    \x01(\tR\x0bstringParam\x12'\n\x0faccountid_param\x18\x03\x20\x01(\rR\
    \x0eaccountidParam\"\xbe\x05\n$CChatRoom_GetMessageHistory_Response\x12M\
    \n\x08messages\x18\x01\x20\x03(\x0b21.CChatRoom_GetMessageHistory_Respon\
    se.ChatMessageR\x08messages\x12%\n\x0emore_available\x18\x04\x20\x01(\
    \x08R\rmoreAvailable\x1a\x9f\x04\n\x0bChatMessage\x12\x16\n\x06sender\
    \x18\x01\x20\x01(\rR\x06sender\x12)\n\x10server_timestamp\x18\x02\x20\
    \x01(\rR\x0fserverTimestamp\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07\
    message\x12\x18\n\x07ordinal\x18\x04\x20\x01(\rR\x07ordinal\x125\n\x0ese\
    rver_message\x18\x05\x20\x01(\x0b2\x0e.ServerMessageR\rserverMessage\x12\
    \x18\n\x07deleted\x18\x06\x20\x01(\x08R\x07deleted\x12_\n\treactions\x18\
    \x07\x20\x03(\x0b2A.CChatRoom_GetMessageHistory_Response.ChatMessage.Mes\
    sageReactionR\treactions\x1a\xe6\x01\n\x0fMessageReaction\x12j\n\rreacti\
    on_type\x18\x01\x20\x01(\x0e2\x1d.EChatRoomMessageReactionType:&k_EChatR\
    oomMessageReactionType_InvalidR\x0creactionType\x12\x1a\n\x08reaction\
    \x18\x02\x20\x01(\tR\x08reaction\x12!\n\x0cnum_reactors\x18\x03\x20\x01(\
    \rR\x0bnumReactors\x12(\n\x10has_user_reacted\x18\x04\x20\x01(\x08R\x0eh\
    asUserReacted\"'\n%CChatRoom_GetMyChatRoomGroups_Request\"\x81\x08\n*CCh\
    atRoom_GetChatRoomGroupSummary_Response\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12&\n\x0fchat_group_name\x18\x02\x20\x01(\
    \tR\rchatGroupName\x12.\n\x13active_member_count\x18\x03\x20\x01(\rR\x11\
    activeMemberCount\x129\n\x19active_voice_member_count\x18\x04\x20\x01(\r\
    R\x16activeVoiceMemberCount\x12&\n\x0fdefault_chat_id\x18\x05\x20\x01(\
    \x04R\rdefaultChatId\x12.\n\nchat_rooms\x18\x06\x20\x03(\x0b2\x0f.CChatR\
    oomStateR\tchatRooms\x12\x16\n\x06clanid\x18\x07\x20\x01(\rR\x06clanid\
    \x12,\n\x12chat_group_tagline\x18\x08\x20\x01(\tR\x10chatGroupTagline\
    \x12'\n\x0faccountid_owner\x18\t\x20\x01(\rR\x0eaccountidOwner\x12\x1f\n\
    \x0btop_members\x18\n\x20\x03(\rR\ntopMembers\x121\n\x15chat_group_avata\
    r_sha\x18\x0b\x20\x01(\x0cR\x12chatGroupAvatarSha\x12E\n\x04rank\x18\x0c\
    \x20\x01(\x0e2\x13.EChatRoomGroupRank:\x1ck_EChatRoomGroupRank_DefaultR\
    \x04rank\x12&\n\x0fdefault_role_id\x18\r\x20\x01(\x04R\rdefaultRoleId\
    \x12\x19\n\x08role_ids\x18\x0e\x20\x03(\x04R\x07roleIds\x124\n\x0crole_a\
    ctions\x18\x0f\x20\x03(\x0b2\x11.CChatRoleActionsR\x0broleActions\x12@\n\
    \x1cwatching_broadcast_accountid\x18\x10\x20\x01(\rR\x1awatchingBroadcas\
    tAccountid\x12\x14\n\x05appid\x18\x11\x20\x01(\rR\x05appid\x126\n\rparty\
    _beacons\x18\x12\x20\x03(\x0b2\x11.CChatPartyBeaconR\x0cpartyBeacons\x12\
    A\n\x1dwatching_broadcast_channel_id\x18\x13\x20\x01(\x04R\x1awatchingBr\
    oadcastChannelId\x12,\n\x12active_minigame_id\x18\x14\x20\x01(\x04R\x10a\
    ctiveMinigameId\x12$\n\x0eavatar_ugc_url\x18\x15\x20\x01(\tR\x0cavatarUg\
    cUrl\x12\x1a\n\x08disabled\x18\x16\x20\x01(\x08R\x08disabled\"\xb5\x01\n\
    \x14CChatRoomSummaryPair\x12K\n\x15user_chat_group_state\x18\x01\x20\x01\
    (\x0b2\x18.CUserChatRoomGroupStateR\x12userChatGroupState\x12P\n\rgroup_\
    summary\x18\x02\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroupSummary_Respons\
    eR\x0cgroupSummary\"i\n&CChatRoom_GetMyChatRoomGroups_Response\x12?\n\
    \x10chat_room_groups\x18\x01\x20\x03(\x0b2\x15.CChatRoomSummaryPairR\x0e\
    chatRoomGroups\"M\n'CChatRoom_GetChatRoomGroupState_Request\x12\"\n\rcha\
    t_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"V\n(CChatRoom_GetChatRo\
    omGroupState_Response\x12*\n\x05state\x18\x01\x20\x01(\x0b2\x14.CChatRoo\
    mGroupStateR\x05state\"O\n)CChatRoom_GetChatRoomGroupSummary_Request\x12\
    \"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"\x82\x01\n0CCh\
    atRoom_SetAppChatRoomGroupForceActive_Request\x12\"\n\rchat_group_id\x18\
    \x01\x20\x01(\x04R\x0bchatGroupId\x12*\n\x11requesting_app_id\x18\x02\
    \x20\x01(\rR\x0frequestingAppId\"{\n1CChatRoom_SetAppChatRoomGroupForceA\
    ctive_Response\x12\x16\n\x06result\x18\x01\x20\x01(\rR\x06result\x12.\n\
    \x13accounts_in_channel\x18\x02\x20\x03(\rR\x11accountsInChannel\"\x8b\
    \x01\n9CChatRoom_SetAppChatRoomGroupStopForceActive_Notification\x12\"\n\
    \rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12*\n\x11requestin\
    g_app_id\x18\x02\x20\x01(\rR\x0frequestingAppId\"\x82\x01\n%CChatRoom_Ac\
    kChatMessage_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12\
    \x1c\n\ttimestamp\x18\x03\x20\x01(\rR\ttimestamp\"\x86\x01\n\"CChatRoom_\
    CreateInviteLink_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12#\n\rseconds_valid\x18\x02\x20\x01(\rR\x0csecondsVali\
    d\x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\x06chatId\"k\n#CChatRoom_Cr\
    eateInviteLink_Response\x12\x1f\n\x0binvite_code\x18\x01\x20\x01(\tR\nin\
    viteCode\x12#\n\rseconds_valid\x18\x02\x20\x01(\rR\x0csecondsValid\"F\n#\
    CChatRoom_GetInviteLinkInfo_Request\x12\x1f\n\x0binvite_code\x18\x01\x20\
    \x01(\tR\ninviteCode\"\xea\x02\n$CChatRoom_GetInviteLinkInfo_Response\
    \x12%\n\x0esteamid_sender\x18\x03\x20\x01(\x06R\rsteamidSender\x12!\n\
    \x0ctime_expires\x18\x04\x20\x01(\rR\x0btimeExpires\x12\x17\n\x07chat_id\
    \x18\x06\x20\x01(\x04R\x06chatId\x12P\n\rgroup_summary\x18\x08\x20\x01(\
    \x0b2+.CChatRoom_GetChatRoomGroupSummary_ResponseR\x0cgroupSummary\x12K\
    \n\x15user_chat_group_state\x18\t\x20\x01(\x0b2\x18.CUserChatRoomGroupSt\
    ateR\x12userChatGroupState\x12(\n\x10time_kick_expire\x18\n\x20\x01(\rR\
    \x0etimeKickExpire\x12\x16\n\x06banned\x18\x0b\x20\x01(\x08R\x06banned\"\
    \xa8\x01\n\x1fCChatRoom_GetInviteInfo_Request\x12'\n\x0fsteamid_invitee\
    \x18\x01\x20\x01(\x06R\x0esteamidInvitee\x12\"\n\rchat_group_id\x18\x02\
    \x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x03\x20\x01(\x04R\
    \x06chatId\x12\x1f\n\x0binvite_code\x18\x04\x20\x01(\tR\ninviteCode\"\
    \xb6\x01\n\x20CChatRoom_GetInviteInfo_Response\x12P\n\rgroup_summary\x18\
    \x01\x20\x01(\x0b2+.CChatRoom_GetChatRoomGroupSummary_ResponseR\x0cgroup\
    Summary\x12(\n\x10time_kick_expire\x18\x02\x20\x01(\rR\x0etimeKickExpire\
    \x12\x16\n\x06banned\x18\x03\x20\x01(\x08R\x06banned\"N\n(CChatRoom_GetI\
    nviteLinksForGroup_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\"\x96\x02\n)CChatRoom_GetInviteLinksForGroup_Response\
    \x12V\n\x0cinvite_links\x18\x01\x20\x03(\x0b23.CChatRoom_GetInviteLinksF\
    orGroup_Response.LinkInfoR\x0binviteLinks\x1a\x90\x01\n\x08LinkInfo\x12\
    \x1f\n\x0binvite_code\x18\x01\x20\x01(\tR\ninviteCode\x12'\n\x0fsteamid_\
    creator\x18\x02\x20\x01(\x06R\x0esteamidCreator\x12!\n\x0ctime_expires\
    \x18\x03\x20\x01(\rR\x0btimeExpires\x12\x17\n\x07chat_id\x18\x04\x20\x01\
    (\x04R\x06chatId\"B\n\x1cCChatRoom_GetBanList_Request\x12\"\n\rchat_grou\
    p_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\"\xee\x01\n\x1dCChatRoom_GetBa\
    nList_Response\x12:\n\x04bans\x18\x01\x20\x03(\x0b2&.CChatRoom_GetBanLis\
    t_Response.BanInfoR\x04bans\x1a\x90\x01\n\x07BanInfo\x12\x1c\n\taccounti\
    d\x18\x01\x20\x01(\rR\taccountid\x12'\n\x0faccountid_actor\x18\x02\x20\
    \x01(\rR\x0eaccountidActor\x12\x1f\n\x0btime_banned\x18\x03\x20\x01(\rR\
    \ntimeBanned\x12\x1d\n\nban_reason\x18\x04\x20\x01(\tR\tbanReason\"E\n\
    \x1fCChatRoom_GetInviteList_Request\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\"\x80\x01\n\x14CChatRoomGroupInvite\x12\x1c\n\
    \taccountid\x18\x01\x20\x01(\rR\taccountid\x12'\n\x0faccountid_actor\x18\
    \x02\x20\x01(\rR\x0eaccountidActor\x12!\n\x0ctime_invited\x18\x03\x20\
    \x01(\rR\x0btimeInvited\"S\n\x20CChatRoom_GetInviteList_Response\x12/\n\
    \x07invites\x18\x01\x20\x03(\x0b2\x15.CChatRoomGroupInviteR\x07invites\"\
    i\n\"CChatRoom_DeleteInviteLink_Request\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x1f\n\x0binvite_code\x18\x02\x20\x01(\
    \tR\ninviteCode\"%\n#CChatRoom_DeleteInviteLink_Response\"\xd7\x01\n0CCh\
    atRoom_SetSessionActiveChatRoomGroups_Request\x12$\n\x0echat_group_ids\
    \x18\x01\x20\x03(\x04R\x0cchatGroupIds\x12;\n\x1achat_groups_data_reques\
    ted\x18\x02\x20\x03(\x04R\x17chatGroupsDataRequested\x12@\n\x1cvirtualiz\
    e_members_threshold\x18\x03\x20\x01(\x05R\x1avirtualizeMembersThreshold\
    \"\xb4\x01\n1CChatRoom_SetSessionActiveChatRoomGroups_Response\x125\n\
    \x0bchat_states\x18\x01\x20\x03(\x0b2\x14.CChatRoomGroupStateR\nchatStat\
    es\x12H\n!virtualize_members_chat_group_ids\x18\x02\x20\x03(\x04R\x1dvir\
    tualizeMembersChatGroupIds\"\xfc\x07\n-CChatRoom_SetUserChatGroupPrefere\
    nces_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\
    \x12y\n\x16chat_group_preferences\x18\x02\x20\x01(\x0b2C.CChatRoom_SetUs\
    erChatGroupPreferences_Request.ChatGroupPreferencesR\x14chatGroupPrefere\
    nces\x12v\n\x15chat_room_preferences\x18\x03\x20\x03(\x0b2B.CChatRoom_Se\
    tUserChatGroupPreferences_Request.ChatRoomPreferencesR\x13chatRoomPrefer\
    ences\x1a\xcc\x02\n\x14ChatGroupPreferences\x12\x7f\n\x1adesktop_notific\
    ation_level\x18\x01\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_ECha\
    troomNotificationLevel_InvalidR\x18desktopNotificationLevel\x12}\n\x19mo\
    bile_notification_level\x18\x02\x20\x01(\x0e2\x1b.EChatRoomNotificationL\
    evel:$k_EChatroomNotificationLevel_InvalidR\x17mobileNotificationLevel\
    \x124\n\x16unread_indicator_muted\x18\x03\x20\x01(\x08R\x14unreadIndicat\
    orMuted\x1a\xe4\x02\n\x13ChatRoomPreferences\x12\x17\n\x07chat_id\x18\
    \x01\x20\x01(\x04R\x06chatId\x12\x7f\n\x1adesktop_notification_level\x18\
    \x02\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_EChatroomNotificati\
    onLevel_InvalidR\x18desktopNotificationLevel\x12}\n\x19mobile_notificati\
    on_level\x18\x03\x20\x01(\x0e2\x1b.EChatRoomNotificationLevel:$k_EChatro\
    omNotificationLevel_InvalidR\x17mobileNotificationLevel\x124\n\x16unread\
    _indicator_muted\x18\x04\x20\x01(\x08R\x14unreadIndicatorMuted\"0\n.CCha\
    tRoom_SetUserChatGroupPreferences_Response\"\xfe\x01\n$CChatRoom_DeleteC\
    hatMessages_Request\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchat\
    GroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12I\n\x08m\
    essages\x18\x03\x20\x03(\x0b2-.CChatRoom_DeleteChatMessages_Request.Mess\
    ageR\x08messages\x1aN\n\x07Message\x12)\n\x10server_timestamp\x18\x01\
    \x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x02\x20\x01(\rR\
    \x07ordinal\"'\n%CChatRoom_DeleteChatMessages_Response\"\xec\x02\n+CChat\
    Room_UpdateMemberListView_Notification\x12\"\n\rchat_group_id\x18\x01\
    \x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07view_id\x18\x02\x20\x01(\x04R\
    \x06viewId\x12\x14\n\x05start\x18\x03\x20\x01(\x05R\x05start\x12\x10\n\
    \x03end\x18\x04\x20\x01(\x05R\x03end\x12/\n\x13client_changenumber\x18\
    \x05\x20\x01(\x05R\x12clientChangenumber\x12\x1f\n\x0bdelete_view\x18\
    \x06\x20\x01(\x08R\ndeleteView\x12@\n\x1cpersona_subscribe_accountids\
    \x18\x07\x20\x03(\x05R\x1apersonaSubscribeAccountids\x12D\n\x1epersona_u\
    nsubscribe_accountids\x18\x08\x20\x03(\x05R\x1cpersonaUnsubscribeAccount\
    ids\"\xa4\x01\n\x1fCChatRoom_SearchMembers_Request\x12\"\n\rchat_group_i\
    d\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x1b\n\tsearch_id\x18\x02\x20\
    \x01(\x04R\x08searchId\x12\x1f\n\x0bsearch_text\x18\x03\x20\x01(\tR\nsea\
    rchText\x12\x1f\n\x0bmax_results\x18\x04\x20\x01(\x05R\nmaxResults\"\x86\
    \x02\n\x20CChatRoom_SearchMembers_Response\x12X\n\x10matching_members\
    \x18\x01\x20\x03(\x0b2-.CChatRoom_SearchMembers_Response.MemberMatchR\
    \x0fmatchingMembers\x12!\n\x0cstatus_flags\x18\x02\x20\x01(\rR\x0bstatus\
    Flags\x1ae\n\x0bMemberMatch\x12\x1c\n\taccountid\x18\x01\x20\x01(\x05R\t\
    accountid\x128\n\x07persona\x18\x02\x20\x01(\x0b2\x1e.CMsgClientPersonaS\
    tate.FriendR\x07persona\"\xca\x02\n'CChatRoom_UpdateMessageReaction_Requ\
    est\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\
    \n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12)\n\x10server_timestamp\
    \x18\x03\x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x04\x20\
    \x01(\rR\x07ordinal\x12j\n\rreaction_type\x18\x05\x20\x01(\x0e2\x1d.ECha\
    tRoomMessageReactionType:&k_EChatRoomMessageReactionType_InvalidR\x0crea\
    ctionType\x12\x1a\n\x08reaction\x18\x06\x20\x01(\tR\x08reaction\x12\x15\
    \n\x06is_add\x18\x07\x20\x01(\x08R\x05isAdd\"M\n(CChatRoom_UpdateMessage\
    Reaction_Response\x12!\n\x0cnum_reactors\x18\x01\x20\x01(\rR\x0bnumReact\
    ors\"\xce\x02\n,CChatRoom_GetMessageReactionReactors_Request\x12\"\n\rch\
    at_group_id\x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\
    \x18\x02\x20\x01(\x04R\x06chatId\x12)\n\x10server_timestamp\x18\x03\x20\
    \x01(\rR\x0fserverTimestamp\x12\x18\n\x07ordinal\x18\x04\x20\x01(\rR\x07\
    ordinal\x12j\n\rreaction_type\x18\x05\x20\x01(\x0e2\x1d.EChatRoomMessage\
    ReactionType:&k_EChatRoomMessageReactionType_InvalidR\x0creactionType\
    \x12\x1a\n\x08reaction\x18\x06\x20\x01(\tR\x08reaction\x12\x14\n\x05limi\
    t\x18\x07\x20\x01(\rR\x05limit\"K\n-CChatRoom_GetMessageReactionReactors\
    _Response\x12\x1a\n\x08reactors\x18\x01\x20\x03(\rR\x08reactors\"l\n*CCl\
    anChatRooms_GetClanChatRoomInfo_Request\x12\x18\n\x07steamid\x18\x01\x20\
    \x01(\x06R\x07steamid\x12$\n\nautocreate\x18\x02\x20\x01(\x08:\x04trueR\
    \nautocreate\"\x88\x01\n+CClanChatRooms_GetClanChatRoomInfo_Response\x12\
    Y\n\x12chat_group_summary\x18\x01\x20\x01(\x0b2+.CChatRoom_GetChatRoomGr\
    oupSummary_ResponseR\x10chatGroupSummary\"u\n-CClanChatRooms_SetClanChat\
    RoomPrivate_Request\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steami\
    d\x12*\n\x11chat_room_private\x18\x02\x20\x01(\x08R\x0fchatRoomPrivate\"\
    \\\n.CClanChatRooms_SetClanChatRoomPrivate_Response\x12*\n\x11chat_room_\
    private\x18\x01\x20\x01(\x08R\x0fchatRoomPrivate\"\x82\x01\n\rCChatMenti\
    ons\x12\x1f\n\x0bmention_all\x18\x01\x20\x01(\x08R\nmentionAll\x12!\n\
    \x0cmention_here\x18\x02\x20\x01(\x08R\x0bmentionHere\x12-\n\x12mention_\
    accountids\x18\x03\x20\x03(\rR\x11mentionAccountids\"\x8e\x03\n*CChatRoo\
    m_IncomingChatMessage_Notification\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06\
    chatId\x12%\n\x0esteamid_sender\x18\x03\x20\x01(\x06R\rsteamidSender\x12\
    \x18\n\x07message\x18\x04\x20\x01(\tR\x07message\x12\x1c\n\ttimestamp\
    \x18\x05\x20\x01(\rR\ttimestamp\x12*\n\x08mentions\x18\x06\x20\x01(\x0b2\
    \x0e.CChatMentionsR\x08mentions\x12\x18\n\x07ordinal\x18\x07\x20\x01(\rR\
    \x07ordinal\x125\n\x0eserver_message\x18\x08\x20\x01(\x0b2\x0e.ServerMes\
    sageR\rserverMessage\x12*\n\x11message_no_bbcode\x18\t\x20\x01(\tR\x0fme\
    ssageNoBbcode\x12\x1b\n\tchat_name\x18\n\x20\x01(\tR\x08chatName\"\xac\
    \x02\n*CChatRoom_ChatMessageModified_Notification\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12\x17\n\x07chat_id\x18\x02\x20\
    \x01(\x04R\x06chatId\x12S\n\x08messages\x18\x03\x20\x03(\x0b27.CChatRoom\
    _ChatMessageModified_Notification.ChatMessageR\x08messages\x1al\n\x0bCha\
    tMessage\x12)\n\x10server_timestamp\x18\x01\x20\x01(\rR\x0fserverTimesta\
    mp\x12\x18\n\x07ordinal\x18\x02\x20\x01(\rR\x07ordinal\x12\x18\n\x07dele\
    ted\x18\x03\x20\x01(\x08R\x07deleted\"\xd3\x01\n(CChatRoom_MemberStateCh\
    ange_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bchatGr\
    oupId\x12(\n\x06member\x18\x02\x20\x01(\x0b2\x10.CChatRoomMemberR\x06mem\
    ber\x12Y\n\x06change\x18\x03\x20\x01(\x0e2\x1b.EChatRoomMemberStateChang\
    e:$k_EChatRoomMemberStateChange_InvalidR\x06change\"k\n*CChatRoom_ChatRo\
    omHeaderState_Notification\x12=\n\x0cheader_state\x18\x01\x20\x01(\x0b2\
    \x1a.CChatRoomGroupHeaderStateR\x0bheaderState\"\xad\x01\n/CChatRoom_Cha\
    tRoomGroupRoomsChange_Notification\x12\"\n\rchat_group_id\x18\x01\x20\
    \x01(\x04R\x0bchatGroupId\x12&\n\x0fdefault_chat_id\x18\x02\x20\x01(\x04\
    R\rdefaultChatId\x12.\n\nchat_rooms\x18\x03\x20\x03(\x0b2\x0f.CChatRoomS\
    tateR\tchatRooms\"y\n:CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Noti\
    fication\x12\x17\n\x07chat_id\x18\x01\x20\x01(\x04R\x06chatId\x12\"\n\rc\
    hat_group_id\x18\x02\x20\x01(\x04R\x0bchatGroupId\"\xe4\x02\n;ChatRoomCl\
    ient_NotifyChatGroupUserStateChanged_Notification\x12\"\n\rchat_group_id\
    \x18\x01\x20\x01(\x04R\x0bchatGroupId\x12K\n\x15user_chat_group_state\
    \x18\x02\x20\x01(\x0b2\x18.CUserChatRoomGroupStateR\x12userChatGroupStat\
    e\x12P\n\rgroup_summary\x18\x03\x20\x01(\x0b2+.CChatRoom_GetChatRoomGrou\
    pSummary_ResponseR\x0cgroupSummary\x12b\n\x0buser_action\x18\x04\x20\x01\
    (\x0e2\x1b.EChatRoomMemberStateChange:$k_EChatRoomMemberStateChange_Inva\
    lidR\nuserAction\"\\\n4ChatRoomClient_NotifyChatRoomDisconnect_Notificat\
    ion\x12$\n\x0echat_group_ids\x18\x01\x20\x03(\x04R\x0cchatGroupIds\"\xc4\
    \x01\n\x17CChatRoomMemberListView\x12\x14\n\x05start\x18\x03\x20\x01(\
    \x05R\x05start\x12\x10\n\x03end\x18\x04\x20\x01(\x05R\x03end\x12\x1f\n\
    \x0btotal_count\x18\x05\x20\x01(\x05R\ntotalCount\x12/\n\x13client_chang\
    enumber\x18\x06\x20\x01(\x05R\x12clientChangenumber\x12/\n\x13server_cha\
    ngenumber\x18\x07\x20\x01(\x05R\x12serverChangenumber\"h\n\x1cCChatRoomM\
    emberSummaryCounts\x12\x16\n\x06ingame\x18\x01\x20\x01(\x05R\x06ingame\
    \x12\x16\n\x06online\x18\x02\x20\x01(\x05R\x06online\x12\x18\n\x07offlin\
    e\x18\x03\x20\x01(\x05R\x07offline\"\xc0\x04\n2CChatRoomClient_MemberLis\
    tViewUpdated_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\
    \x0bchatGroupId\x12\x17\n\x07view_id\x18\x02\x20\x01(\x04R\x06viewId\x12\
    ,\n\x04view\x18\x03\x20\x01(\x0b2\x18.CChatRoomMemberListViewR\x04view\
    \x12a\n\x07members\x18\x04\x20\x03(\x0b2G.CChatRoomClient_MemberListView\
    Updated_Notification.MemberListViewEntryR\x07members\x12!\n\x0cstatus_fl\
    ags\x18\x05\x20\x01(\rR\x0bstatusFlags\x12D\n\x0emember_summary\x18\x06\
    \x20\x01(\x0b2\x1d.CChatRoomMemberSummaryCountsR\rmemberSummary\x12O\n\
    \x13subscribed_personas\x18\x07\x20\x03(\x0b2\x1e.CMsgClientPersonaState\
    .FriendR\x12subscribedPersonas\x1a\x81\x01\n\x13MemberListViewEntry\x12\
    \x12\n\x04rank\x18\x01\x20\x01(\x05R\x04rank\x12\x1c\n\taccountid\x18\
    \x02\x20\x01(\rR\taccountid\x128\n\x07persona\x18\x03\x20\x01(\x0b2\x1e.\
    CMsgClientPersonaState.FriendR\x07persona\"\xe3\x02\n&CChatRoom_MessageR\
    eaction_Notification\x12\"\n\rchat_group_id\x18\x01\x20\x01(\x04R\x0bcha\
    tGroupId\x12\x17\n\x07chat_id\x18\x02\x20\x01(\x04R\x06chatId\x12)\n\x10\
    server_timestamp\x18\x03\x20\x01(\rR\x0fserverTimestamp\x12\x18\n\x07ord\
    inal\x18\x04\x20\x01(\rR\x07ordinal\x12\x18\n\x07reactor\x18\x05\x20\x01\
    (\x06R\x07reactor\x12j\n\rreaction_type\x18\x06\x20\x01(\x0e2\x1d.EChatR\
    oomMessageReactionType:&k_EChatRoomMessageReactionType_InvalidR\x0creact\
    ionType\x12\x1a\n\x08reaction\x18\x07\x20\x01(\tR\x08reaction\x12\x15\n\
    \x06is_add\x18\x08\x20\x01(\x08R\x05isAdd\"\xe6!\n2CChatUsability_Client\
    UsabilityMetrics_Notification\x12$\n\x0emetrics_run_id\x18\x01\x20\x01(\
    \rR\x0cmetricsRunId\x12!\n\x0cclient_build\x18\x02\x20\x01(\rR\x0bclient\
    Build\x12'\n\x0fmetrics_version\x18\x03\x20\x01(\rR\x0emetricsVersion\
    \x12\x15\n\x06in_web\x18\x04\x20\x01(\x08R\x05inWeb\x12X\n\x08settings\
    \x18\n\x20\x01(\x0b2<.CChatUsability_ClientUsabilityMetrics_Notification\
    .SettingsR\x08settings\x12h\n\x0evoice_settings\x18\x0b\x20\x01(\x0b2A.C\
    ChatUsability_ClientUsabilityMetrics_Notification.VoiceSettingsR\rvoiceS\
    ettings\x12V\n\x08ui_state\x18\x0c\x20\x01(\x0b2;.CChatUsability_ClientU\
    sabilityMetrics_Notification.UIStateR\x07uiState\x12U\n\x07metrics\x18\r\
    \x20\x01(\x0b2;.CChatUsability_ClientUsabilityMetrics_Notification.Metri\
    csR\x07metrics\x1a\xa1\x0b\n\x08Settings\x12:\n\x19notifications_show_in\
    game\x18\x01\x20\x01(\x08R\x17notificationsShowIngame\x12:\n\x19notifica\
    tions_show_online\x18\x02\x20\x01(\x08R\x17notificationsShowOnline\x12<\
    \n\x1anotifications_show_message\x18\x03\x20\x01(\x08R\x18notificationsS\
    howMessage\x12S\n&notifications_events_and_announcements\x18\x04\x20\x01\
    (\x08R#notificationsEventsAndAnnouncements\x12,\n\x12sounds_play_ingame\
    \x18\x05\x20\x01(\x08R\x10soundsPlayIngame\x12,\n\x12sounds_play_online\
    \x18\x06\x20\x01(\x08R\x10soundsPlayOnline\x12.\n\x13sounds_play_message\
    \x18\x07\x20\x01(\x08R\x11soundsPlayMessage\x12E\n\x1fsounds_events_and_\
    announcements\x18\x08\x20\x01(\x08R\x1csoundsEventsAndAnnouncements\x123\
    \n\x16always_new_chat_window\x18\t\x20\x01(\x08R\x13alwaysNewChatWindow\
    \x12E\n\x1fforce_alphabetic_friend_sorting\x18\n\x20\x01(\x08R\x1cforceA\
    lphabeticFriendSorting\x12&\n\x0fchat_flash_mode\x18\x0b\x20\x01(\x05R\r\
    chatFlashMode\x12.\n\x13remember_open_chats\x18\x0c\x20\x01(\x08R\x11rem\
    emberOpenChats\x120\n\x14compact_quick_access\x18\r\x20\x01(\x08R\x12com\
    pactQuickAccess\x120\n\x14compact_friends_list\x18\x0e\x20\x01(\x08R\x12\
    compactFriendsList\x12X\n)notifications_show_chat_room_notification\x18\
    \x0f\x20\x01(\x08R%notificationsShowChatRoomNotification\x12J\n\"sounds_\
    play_chat_room_notification\x18\x10\x20\x01(\x08R\x1esoundsPlayChatRoomN\
    otification\x12I\n\"hide_offline_friends_in_tag_groups\x18\x11\x20\x01(\
    \x08R\x1dhideOfflineFriendsInTagGroups\x128\n\x18hide_categorized_friend\
    s\x18\x12\x20\x01(\x08R\x16hideCategorizedFriends\x12I\n\"categorize_in_\
    game_friends_by_game\x18\x13\x20\x01(\x08R\x1dcategorizeInGameFriendsByG\
    ame\x12$\n\x0echat_font_size\x18\x14\x20\x01(\x05R\x0cchatFontSize\x12'\
    \n\x0fuse24hour_clock\x18\x15\x20\x01(\x08R\x0euse24hourClock\x12-\n\x13\
    do_not_disturb_mode\x18\x16\x20\x01(\x08R\x10doNotDisturbMode\x124\n\x16\
    disable_embed_inlining\x18\x17\x20\x01(\x08R\x14disableEmbedInlining\x12\
    *\n\x11sign_into_friends\x18\x18\x20\x01(\x08R\x0fsignIntoFriends\x12)\n\
    \x10animated_avatars\x18\x19\x20\x01(\x08R\x0fanimatedAvatars\x1a\xcf\
    \x04\n\rVoiceSettings\x12(\n\x10voice_input_gain\x18\x01\x20\x01(\x02R\
    \x0evoiceInputGain\x12*\n\x11voice_output_gain\x18\x02\x20\x01(\x02R\x0f\
    voiceOutputGain\x12(\n\x10noise_gate_level\x18\x03\x20\x01(\x05R\x0enois\
    eGateLevel\x12=\n\x1bvoice_use_echo_cancellation\x18\x04\x20\x01(\x08R\
    \x18voiceUseEchoCancellation\x12?\n\x1cvoice_use_noise_cancellation\x18\
    \x05\x20\x01(\x08R\x19voiceUseNoiseCancellation\x12<\n\x1bvoice_use_auto\
    _gain_control\x18\x06\x20\x01(\x08R\x17voiceUseAutoGainControl\x127\n\
    \x18selected_non_default_mic\x18\x07\x20\x01(\x08R\x15selectedNonDefault\
    Mic\x12=\n\x1bselected_non_default_output\x18\x08\x20\x01(\x08R\x18selec\
    tedNonDefaultOutput\x12/\n\x14push_to_talk_enabled\x18\t\x20\x01(\x08R\
    \x11pushToTalkEnabled\x12/\n\x14push_to_mute_enabled\x18\n\x20\x01(\x08R\
    \x11pushToMuteEnabled\x12&\n\x0fplay_ptt_sounds\x18\x0b\x20\x01(\x08R\rp\
    layPttSounds\x1a\xaa\t\n\x07UIState\x12.\n\x13friends_list_height\x18\
    \x01\x20\x01(\x05R\x11friendsListHeight\x12,\n\x12friends_list_width\x18\
    \x02\x20\x01(\x05R\x10friendsListWidth\x12.\n\x13friends_list_docked\x18\
    \x03\x20\x01(\x08R\x11friendsListDocked\x124\n\x16friends_list_collapsed\
    \x18\x04\x20\x01(\x08R\x14friendsListCollapsed\x12D\n\x1ffriends_list_gr\
    oup_chats_height\x18\x05\x20\x01(\x05R\x1bfriendsListGroupChatsHeight\
    \x120\n\x14friends_list_visible\x18\x06\x20\x01(\x08R\x12friendsListVisi\
    ble\x12,\n\x12chat_popups_opened\x18\x07\x20\x01(\x05R\x10chatPopupsOpen\
    ed\x123\n\x16group_chat_tabs_opened\x18\x08\x20\x01(\x05R\x13groupChatTa\
    bsOpened\x125\n\x17friend_chat_tabs_opened\x18\t\x20\x01(\x05R\x14friend\
    ChatTabsOpened\x12*\n\x11chat_window_width\x18\n\x20\x01(\x05R\x0fchatWi\
    ndowWidth\x12,\n\x12chat_window_height\x18\x0b\x20\x01(\x05R\x10chatWind\
    owHeight\x12~\n\x11category_collapse\x18\x0c\x20\x01(\x0b2Q.CChatUsabili\
    ty_ClientUsabilityMetrics_Notification.UIState.CategoryCollapseStateR\
    \x10categoryCollapse\x12@\n\x1dgroup_chat_left_col_collapsed\x18\r\x20\
    \x01(\x05R\x19groupChatLeftColCollapsed\x12B\n\x1egroup_chat_right_col_c\
    ollapsed\x18\x0e\x20\x01(\x05R\x1agroupChatRightColCollapsed\x125\n\x18i\
    n_one_on_one_voice_chat\x18\x0f\x20\x01(\x08R\x13inOneOnOneVoiceChat\x12\
    -\n\x13in_group_voice_chat\x18\x10\x20\x01(\x08R\x10inGroupVoiceChat\x1a\
    \x82\x02\n\x15CategoryCollapseState\x12*\n\x11in_game_collapsed\x18\x01\
    \x20\x01(\x08R\x0finGameCollapsed\x12)\n\x10online_collapsed\x18\x02\x20\
    \x01(\x08R\x0fonlineCollapsed\x12+\n\x11offline_collapsed\x18\x03\x20\
    \x01(\x08R\x10offlineCollapsed\x122\n\x15game_groups_collapsed\x18\x04\
    \x20\x01(\x05R\x13gameGroupsCollapsed\x121\n\x14categories_collapsed\x18\
    \x05\x20\x01(\x05R\x13categoriesCollapsed\x1a\x90\x04\n\x07Metrics\x12#\
    \n\rfriends_count\x18\x01\x20\x01(\x05R\x0cfriendsCount\x124\n\x16friend\
    s_category_count\x18\x02\x20\x01(\x05R\x14friendsCategoryCount\x12:\n\
    \x19friends_categorized_count\x18\x03\x20\x01(\x05R\x17friendsCategorize\
    dCount\x120\n\x14friends_online_count\x18\x04\x20\x01(\x05R\x12friendsOn\
    lineCount\x121\n\x15friends_in_game_count\x18\x05\x20\x01(\x05R\x12frien\
    dsInGameCount\x12D\n\x1ffriends_in_game_singleton_count\x18\x06\x20\x01(\
    \x05R\x1bfriendsInGameSingletonCount\x12(\n\x10game_group_count\x18\x07\
    \x20\x01(\x05R\x0egameGroupCount\x124\n\x16friends_favorite_count\x18\
    \x08\x20\x01(\x05R\x14friendsFavoriteCount\x12(\n\x10group_chat_count\
    \x18\t\x20\x01(\x05R\x0egroupChatCount\x129\n\x19group_chat_favorite_cou\
    nt\x18\n\x20\x01(\x05R\x16groupChatFavoriteCount\"a\n9CChatUsability_Req\
    uestClientUsabilityMetrics_Notification\x12$\n\x0emetrics_run_id\x18\x01\
    \x20\x01(\rR\x0cmetricsRunId*\x9c\x01\n\x12EChatRoomJoinState\x12\x20\n\
    \x1ck_EChatRoomJoinState_Default\x10\0\x12\x1d\n\x19k_EChatRoomJoinState\
    _None\x10\x01\x12\x1f\n\x1bk_EChatRoomJoinState_Joined\x10\x02\x12$\n\
    \x20k_EChatRoomJoinState_TestInvalid\x10c*\xa4\x02\n\x12EChatRoomGroupRa\
    nk\x12\x20\n\x1ck_EChatRoomGroupRank_Default\x10\0\x12\x1f\n\x1bk_EChatR\
    oomGroupRank_Viewer\x10\n\x12\x1e\n\x1ak_EChatRoomGroupRank_Guest\x10\
    \x0f\x12\x1f\n\x1bk_EChatRoomGroupRank_Member\x10\x14\x12\"\n\x1ek_EChat\
    RoomGroupRank_Moderator\x10\x1e\x12\x20\n\x1ck_EChatRoomGroupRank_Office\
    r\x10(\x12\x1e\n\x1ak_EChatRoomGroupRank_Owner\x102\x12$\n\x20k_EChatRoo\
    mGroupRank_TestInvalid\x10c*\xf4\x01\n\x1aEChatRoomNotificationLevel\x12\
    (\n$k_EChatroomNotificationLevel_Invalid\x10\0\x12%\n!k_EChatroomNotific\
    ationLevel_None\x10\x01\x12*\n&k_EChatroomNotificationLevel_MentionMe\
    \x10\x02\x12+\n'k_EChatroomNotificationLevel_MentionAll\x10\x03\x12,\n(k\
    _EChatroomNotificationLevel_AllMessages\x10\x04*\x97\x03\n\x16EChatRoomS\
    erverMessage\x12\x20\n\x1ck_EChatRoomServerMsg_Invalid\x10\0\x12'\n#k_EC\
    hatRoomServerMsg_RenameChatRoom\x10\x01\x12\x1f\n\x1bk_EChatRoomServerMs\
    g_Joined\x10\x02\x12\x1f\n\x1bk_EChatRoomServerMsg_Parted\x10\x03\x12\
    \x1f\n\x1bk_EChatRoomServerMsg_Kicked\x10\x04\x12\x20\n\x1ck_EChatRoomSe\
    rverMsg_Invited\x10\x05\x12(\n$k_EChatRoomServerMsg_InviteDismissed\x10\
    \x08\x12/\n+k_EChatRoomServerMsg_ChatRoomTaglineChanged\x10\t\x12.\n*k_E\
    ChatRoomServerMsg_ChatRoomAvatarChanged\x10\n\x12\"\n\x1ek_EChatRoomServ\
    erMsg_AppCustom\x10\x0b*\xa3\x01\n\x1cEChatRoomMessageReactionType\x12*\
    \n&k_EChatRoomMessageReactionType_Invalid\x10\0\x12+\n'k_EChatRoomMessag\
    eReactionType_Emoticon\x10\x01\x12*\n&k_EChatRoomMessageReactionType_Sti\
    cker\x10\x02*\xcb\x03\n\x1aEChatRoomMemberStateChange\x12(\n$k_EChatRoom\
    MemberStateChange_Invalid\x10\0\x12'\n#k_EChatRoomMemberStateChange_Join\
    ed\x10\x01\x12'\n#k_EChatRoomMemberStateChange_Parted\x10\x02\x12'\n#k_E\
    ChatRoomMemberStateChange_Kicked\x10\x03\x12(\n$k_EChatRoomMemberStateCh\
    ange_Invited\x10\x04\x12,\n(k_EChatRoomMemberStateChange_RankChanged\x10\
    \x07\x120\n,k_EChatRoomMemberStateChange_InviteDismissed\x10\x08\x12&\n\
    \"k_EChatRoomMemberStateChange_Muted\x10\t\x12'\n#k_EChatRoomMemberState\
    Change_Banned\x10\n\x12-\n)k_EChatRoomMemberStateChange_RolesChanged\x10\
    \x0c2{\n\x04Chat\x12s\n\x1aRequestFriendPersonaStates\x12).CChat_Request\
    FriendPersonaStates_Request\x1a*.CChat_RequestFriendPersonaStates_Respon\
    se2\x91)\n\x08ChatRoom\x12f\n\x13CreateChatRoomGroup\x12&.CChatRoom_Crea\
    teChatRoomGroup_Request\x1a'.CChatRoom_CreateChatRoomGroup_Response\x12`\
    \n\x11SaveChatRoomGroup\x12$.CChatRoom_SaveChatRoomGroup_Request\x1a%.CC\
    hatRoom_SaveChatRoomGroup_Response\x12f\n\x13RenameChatRoomGroup\x12&.CC\
    hatRoom_RenameChatRoomGroup_Request\x1a'.CChatRoom_RenameChatRoomGroup_R\
    esponse\x12r\n\x17SetChatRoomGroupTagline\x12*.CChatRoom_SetChatRoomGrou\
    pTagline_Request\x1a+.CChatRoom_SetChatRoomGroupTagline_Response\x12o\n\
    \x16SetChatRoomGroupAvatar\x12).CChatRoom_SetChatRoomGroupAvatar_Request\
    \x1a*.CChatRoom_SetChatRoomGroupAvatar_Response\x12\x90\x01\n!SetChatRoo\
    mGroupWatchingBroadcast\x124.CChatRoom_SetChatRoomGroupWatchingBroadcast\
    _Request\x1a5.CChatRoom_SetChatRoomGroupWatchingBroadcast_Response\x12\
    \x81\x01\n\x1cJoinMiniGameForChatRoomGroup\x12/.CChatRoom_JoinMiniGameFo\
    rChatRoomGroup_Request\x1a0.CChatRoom_JoinMiniGameForChatRoomGroup_Respo\
    nse\x12~\n\x1bEndMiniGameForChatRoomGroup\x12..CChatRoom_EndMiniGameForC\
    hatRoomGroup_Request\x1a/.CChatRoom_EndMiniGameForChatRoomGroup_Response\
    \x12L\n\x0fMuteUserInGroup\x12\x1b.CChatRoom_MuteUser_Request\x1a\x1c.CC\
    hatRoom_MuteUser_Response\x12N\n\x11KickUserFromGroup\x12\x1b.CChatRoom_\
    KickUser_Request\x1a\x1c.CChatRoom_KickUser_Response\x12Z\n\x0fSetUserBa\
    nState\x12\".CChatRoom_SetUserBanState_Request\x1a#.CChatRoom_SetUserBan\
    State_Response\x12X\n\x13RevokeInviteToGroup\x12\x1f.CChatRoom_RevokeInv\
    ite_Request\x1a\x20.CChatRoom_RevokeInvite_Response\x12K\n\nCreateRole\
    \x12\x1d.CChatRoom_CreateRole_Request\x1a\x1e.CChatRoom_CreateRole_Respo\
    nse\x12E\n\x08GetRoles\x12\x1b.CChatRoom_GetRoles_Request\x1a\x1c.CChatR\
    oom_GetRoles_Response\x12K\n\nRenameRole\x12\x1d.CChatRoom_RenameRole_Re\
    quest\x1a\x1e.CChatRoom_RenameRole_Response\x12N\n\x0bReorderRole\x12\
    \x1e.CChatRoom_ReorderRole_Request\x1a\x1f.CChatRoom_ReorderRole_Respons\
    e\x12K\n\nDeleteRole\x12\x1d.CChatRoom_DeleteRole_Request\x1a\x1e.CChatR\
    oom_DeleteRole_Response\x12W\n\x0eGetRoleActions\x12!.CChatRoom_GetRoleA\
    ctions_Request\x1a\".CChatRoom_GetRoleActions_Response\x12c\n\x12Replace\
    RoleActions\x12%.CChatRoom_ReplaceRoleActions_Request\x1a&.CChatRoom_Rep\
    laceRoleActions_Response\x12T\n\rAddRoleToUser\x12\x20.CChatRoom_AddRole\
    ToUser_Request\x1a!.CChatRoom_AddRoleToUser_Response\x12Z\n\x0fGetRolesF\
    orUser\x12\".CChatRoom_GetRolesForUser_Request\x1a#.CChatRoom_GetRolesFo\
    rUser_Response\x12c\n\x12DeleteRoleFromUser\x12%.CChatRoom_DeleteRoleFro\
    mUser_Request\x1a&.CChatRoom_DeleteRoleFromUser_Response\x12`\n\x11JoinC\
    hatRoomGroup\x12$.CChatRoom_JoinChatRoomGroup_Request\x1a%.CChatRoom_Joi\
    nChatRoomGroup_Response\x12~\n\x1bInviteFriendToChatRoomGroup\x12..CChat\
    Room_InviteFriendToChatRoomGroup_Request\x1a/.CChatRoom_InviteFriendToCh\
    atRoomGroup_Response\x12c\n\x12LeaveChatRoomGroup\x12%.CChatRoom_LeaveCh\
    atRoomGroup_Request\x1a&.CChatRoom_LeaveChatRoomGroup_Response\x12W\n\
    \x0eCreateChatRoom\x12!.CChatRoom_CreateChatRoom_Request\x1a\".CChatRoom\
    _CreateChatRoom_Response\x12W\n\x0eDeleteChatRoom\x12!.CChatRoom_DeleteC\
    hatRoom_Request\x1a\".CChatRoom_DeleteChatRoom_Response\x12W\n\x0eRename\
    ChatRoom\x12!.CChatRoom_RenameChatRoom_Request\x1a\".CChatRoom_RenameCha\
    tRoom_Response\x12Z\n\x0fReorderChatRoom\x12\".CChatRoom_ReorderChatRoom\
    _Request\x1a#.CChatRoom_ReorderChatRoom_Response\x12Z\n\x0fSendChatMessa\
    ge\x12\".CChatRoom_SendChatMessage_Request\x1a#.CChatRoom_SendChatMessag\
    e_Response\x12T\n\rJoinVoiceChat\x12\x20.CChatRoom_JoinVoiceChat_Request\
    \x1a!.CChatRoom_JoinVoiceChat_Response\x12W\n\x0eLeaveVoiceChat\x12!.CCh\
    atRoom_LeaveVoiceChat_Request\x1a\".CChatRoom_LeaveVoiceChat_Response\
    \x12`\n\x11GetMessageHistory\x12$.CChatRoom_GetMessageHistory_Request\
    \x1a%.CChatRoom_GetMessageHistory_Response\x12f\n\x13GetMyChatRoomGroups\
    \x12&.CChatRoom_GetMyChatRoomGroups_Request\x1a'.CChatRoom_GetMyChatRoom\
    Groups_Response\x12l\n\x15GetChatRoomGroupState\x12(.CChatRoom_GetChatRo\
    omGroupState_Request\x1a).CChatRoom_GetChatRoomGroupState_Response\x12r\
    \n\x17GetChatRoomGroupSummary\x12*.CChatRoom_GetChatRoomGroupSummary_Req\
    uest\x1a+.CChatRoom_GetChatRoomGroupSummary_Response\x12\x87\x01\n\x1eSe\
    tAppChatRoomGroupForceActive\x121.CChatRoom_SetAppChatRoomGroupForceActi\
    ve_Request\x1a2.CChatRoom_SetAppChatRoomGroupForceActive_Response\x12m\n\
    \"SetAppChatRoomGroupStopForceActive\x12:.CChatRoom_SetAppChatRoomGroupS\
    topForceActive_Notification\x1a\x0b.NoResponse\x12E\n\x0eAckChatMessage\
    \x12&.CChatRoom_AckChatMessage_Notification\x1a\x0b.NoResponse\x12]\n\
    \x10CreateInviteLink\x12#.CChatRoom_CreateInviteLink_Request\x1a$.CChatR\
    oom_CreateInviteLink_Response\x12`\n\x11GetInviteLinkInfo\x12$.CChatRoom\
    _GetInviteLinkInfo_Request\x1a%.CChatRoom_GetInviteLinkInfo_Response\x12\
    T\n\rGetInviteInfo\x12\x20.CChatRoom_GetInviteInfo_Request\x1a!.CChatRoo\
    m_GetInviteInfo_Response\x12o\n\x16GetInviteLinksForGroup\x12).CChatRoom\
    _GetInviteLinksForGroup_Request\x1a*.CChatRoom_GetInviteLinksForGroup_Re\
    sponse\x12K\n\nGetBanList\x12\x1d.CChatRoom_GetBanList_Request\x1a\x1e.C\
    ChatRoom_GetBanList_Response\x12T\n\rGetInviteList\x12\x20.CChatRoom_Get\
    InviteList_Request\x1a!.CChatRoom_GetInviteList_Response\x12]\n\x10Delet\
    eInviteLink\x12#.CChatRoom_DeleteInviteLink_Request\x1a$.CChatRoom_Delet\
    eInviteLink_Response\x12\x87\x01\n\x1eSetSessionActiveChatRoomGroups\x12\
    1.CChatRoom_SetSessionActiveChatRoomGroups_Request\x1a2.CChatRoom_SetSes\
    sionActiveChatRoomGroups_Response\x12~\n\x1bSetUserChatGroupPreferences\
    \x12..CChatRoom_SetUserChatGroupPreferences_Request\x1a/.CChatRoom_SetUs\
    erChatGroupPreferences_Response\x12c\n\x12DeleteChatMessages\x12%.CChatR\
    oom_DeleteChatMessages_Request\x1a&.CChatRoom_DeleteChatMessages_Respons\
    e\x12Q\n\x14UpdateMemberListView\x12,.CChatRoom_UpdateMemberListView_Not\
    ification\x1a\x0b.NoResponse\x12T\n\rSearchMembers\x12\x20.CChatRoom_Sea\
    rchMembers_Request\x1a!.CChatRoom_SearchMembers_Response\x12l\n\x15Updat\
    eMessageReaction\x12(.CChatRoom_UpdateMessageReaction_Request\x1a).CChat\
    Room_UpdateMessageReaction_Response\x12{\n\x1aGetMessageReactionReactors\
    \x12-.CChatRoom_GetMessageReactionReactors_Request\x1a..CChatRoom_GetMes\
    sageReactionReactors_Response2\xfc\x01\n\rClanChatRooms\x12p\n\x13GetCla\
    nChatRoomInfo\x12+.CClanChatRooms_GetClanChatRoomInfo_Request\x1a,.CClan\
    ChatRooms_GetClanChatRoomInfo_Response\x12y\n\x16SetClanChatRoomPrivate\
    \x12..CClanChatRooms_SetClanChatRoomPrivate_Request\x1a/.CClanChatRooms_\
    SetClanChatRoomPrivate_Response2\x95\x08\n\x0eChatRoomClient\x12U\n\x19N\
    otifyIncomingChatMessage\x12+.CChatRoom_IncomingChatMessage_Notification\
    \x1a\x0b.NoResponse\x12U\n\x19NotifyChatMessageModified\x12+.CChatRoom_C\
    hatMessageModified_Notification\x1a\x0b.NoResponse\x12Q\n\x17NotifyMembe\
    rStateChange\x12).CChatRoom_MemberStateChange_Notification\x1a\x0b.NoRes\
    ponse\x12[\n\x1fNotifyChatRoomHeaderStateChange\x12+.CChatRoom_ChatRoomH\
    eaderState_Notification\x1a\x0b.NoResponse\x12_\n\x1eNotifyChatRoomGroup\
    RoomsChange\x120.CChatRoom_ChatRoomGroupRoomsChange_Notification\x1a\x0b\
    .NoResponse\x12o\n#NotifyShouldRejoinChatRoomVoiceChat\x12;.CChatRoom_No\
    tifyShouldRejoinChatRoomVoiceChat_Notification\x1a\x0b.NoResponse\x12l\n\
    \x1fNotifyChatGroupUserStateChanged\x12<.ChatRoomClient_NotifyChatGroupU\
    serStateChanged_Notification\x1a\x0b.NoResponse\x12O\n\x18NotifyAckChatM\
    essageEcho\x12&.CChatRoom_AckChatMessage_Notification\x1a\x0b.NoResponse\
    \x12^\n\x18NotifyChatRoomDisconnect\x125.ChatRoomClient_NotifyChatRoomDi\
    sconnect_Notification\x1a\x0b.NoResponse\x12_\n\x1bNotifyMemberListViewU\
    pdated\x123.CChatRoomClient_MemberListViewUpdated_Notification\x1a\x0b.N\
    oResponse\x12M\n\x15NotifyMessageReaction\x12'.CChatRoom_MessageReaction\
    _Notification\x1a\x0b.NoResponse\x1a\x04\xc0\xb5\x18\x022q\n\rChatUsabil\
    ity\x12`\n\x1cNotifyClientUsabilityMetrics\x123.CChatUsability_ClientUsa\
    bilityMetrics_Notification\x1a\x0b.NoResponse2\x8b\x01\n\x13ChatUsabilit\
    yClient\x12n\n#NotifyRequestClientUsabilityMetrics\x12:.CChatUsability_R\
    equestClientUsabilityMetrics_Notification\x1a\x0b.NoResponse\x1a\x04\xc0\
    \xb5\x18\x02B\x03\x80\x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(super::steammessages_base::file_descriptor().clone());
            deps.push(super::steammessages_unified_base_steamclient::file_descriptor().clone());
            deps.push(super::steammessages_clientserver_friends::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(151);
            messages.push(CChat_RequestFriendPersonaStates_Request::generated_message_descriptor_data());
            messages.push(CChat_RequestFriendPersonaStates_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRole::generated_message_descriptor_data());
            messages.push(CChatRoleActions::generated_message_descriptor_data());
            messages.push(CChatPartyBeacon::generated_message_descriptor_data());
            messages.push(CChatRoomGroupHeaderState::generated_message_descriptor_data());
            messages.push(CChatRoomMember::generated_message_descriptor_data());
            messages.push(CChatRoomState::generated_message_descriptor_data());
            messages.push(CChatRoomGroupState::generated_message_descriptor_data());
            messages.push(CUserChatRoomState::generated_message_descriptor_data());
            messages.push(CUserChatRoomGroupState::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SaveChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SaveChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupTagline_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupTagline_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupAvatar_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupAvatar_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupWatchingBroadcast_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetChatRoomGroupWatchingBroadcast_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinMiniGameForChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinMiniGameForChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_EndMiniGameForChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_EndMiniGameForChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_MuteUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_MuteUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_KickUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_KickUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetUserBanState_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetUserBanState_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_RevokeInvite_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_RevokeInvite_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateRole_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateRole_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRoles_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRoles_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameRole_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameRole_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_ReorderRole_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_ReorderRole_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteRole_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteRole_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRoleActions_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRoleActions_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_ReplaceRoleActions_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_ReplaceRoleActions_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_AddRoleToUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_AddRoleToUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRolesForUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetRolesForUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteRoleFromUser_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteRoleFromUser_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_InviteFriendToChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_InviteFriendToChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_LeaveChatRoomGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_LeaveChatRoomGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateChatRoom_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateChatRoom_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteChatRoom_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteChatRoom_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameChatRoom_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_RenameChatRoom_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_ReorderChatRoom_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_ReorderChatRoom_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SendChatMessage_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SendChatMessage_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinVoiceChat_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_JoinVoiceChat_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_LeaveVoiceChat_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_LeaveVoiceChat_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMessageHistory_Request::generated_message_descriptor_data());
            messages.push(ServerMessage::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMessageHistory_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMyChatRoomGroups_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetChatRoomGroupSummary_Response::generated_message_descriptor_data());
            messages.push(CChatRoomSummaryPair::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMyChatRoomGroups_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetChatRoomGroupState_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetChatRoomGroupState_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetChatRoomGroupSummary_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetAppChatRoomGroupForceActive_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetAppChatRoomGroupForceActive_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetAppChatRoomGroupStopForceActive_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_AckChatMessage_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateInviteLink_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_CreateInviteLink_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteLinkInfo_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteLinkInfo_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteInfo_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteInfo_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteLinksForGroup_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteLinksForGroup_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetBanList_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetBanList_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteList_Request::generated_message_descriptor_data());
            messages.push(CChatRoomGroupInvite::generated_message_descriptor_data());
            messages.push(CChatRoom_GetInviteList_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteInviteLink_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteInviteLink_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetSessionActiveChatRoomGroups_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetSessionActiveChatRoomGroups_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_SetUserChatGroupPreferences_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SetUserChatGroupPreferences_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteChatMessages_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_DeleteChatMessages_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_UpdateMemberListView_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_SearchMembers_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_SearchMembers_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_UpdateMessageReaction_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_UpdateMessageReaction_Response::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMessageReactionReactors_Request::generated_message_descriptor_data());
            messages.push(CChatRoom_GetMessageReactionReactors_Response::generated_message_descriptor_data());
            messages.push(CClanChatRooms_GetClanChatRoomInfo_Request::generated_message_descriptor_data());
            messages.push(CClanChatRooms_GetClanChatRoomInfo_Response::generated_message_descriptor_data());
            messages.push(CClanChatRooms_SetClanChatRoomPrivate_Request::generated_message_descriptor_data());
            messages.push(CClanChatRooms_SetClanChatRoomPrivate_Response::generated_message_descriptor_data());
            messages.push(CChatMentions::generated_message_descriptor_data());
            messages.push(CChatRoom_IncomingChatMessage_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_ChatMessageModified_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_MemberStateChange_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_ChatRoomHeaderState_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_ChatRoomGroupRoomsChange_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_NotifyShouldRejoinChatRoomVoiceChat_Notification::generated_message_descriptor_data());
            messages.push(ChatRoomClient_NotifyChatGroupUserStateChanged_Notification::generated_message_descriptor_data());
            messages.push(ChatRoomClient_NotifyChatRoomDisconnect_Notification::generated_message_descriptor_data());
            messages.push(CChatRoomMemberListView::generated_message_descriptor_data());
            messages.push(CChatRoomMemberSummaryCounts::generated_message_descriptor_data());
            messages.push(CChatRoomClient_MemberListViewUpdated_Notification::generated_message_descriptor_data());
            messages.push(CChatRoom_MessageReaction_Notification::generated_message_descriptor_data());
            messages.push(CChatUsability_ClientUsabilityMetrics_Notification::generated_message_descriptor_data());
            messages.push(CChatUsability_RequestClientUsabilityMetrics_Notification::generated_message_descriptor_data());
            messages.push(cchat_room_get_message_history_response::ChatMessage::generated_message_descriptor_data());
            messages.push(cchat_room_get_message_history_response::chat_message::MessageReaction::generated_message_descriptor_data());
            messages.push(cchat_room_get_invite_links_for_group_response::LinkInfo::generated_message_descriptor_data());
            messages.push(cchat_room_get_ban_list_response::BanInfo::generated_message_descriptor_data());
            messages.push(cchat_room_set_user_chat_group_preferences_request::ChatGroupPreferences::generated_message_descriptor_data());
            messages.push(cchat_room_set_user_chat_group_preferences_request::ChatRoomPreferences::generated_message_descriptor_data());
            messages.push(cchat_room_delete_chat_messages_request::Message::generated_message_descriptor_data());
            messages.push(cchat_room_search_members_response::MemberMatch::generated_message_descriptor_data());
            messages.push(cchat_room_chat_message_modified_notification::ChatMessage::generated_message_descriptor_data());
            messages.push(cchat_room_client_member_list_view_updated_notification::MemberListViewEntry::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::Settings::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::VoiceSettings::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::UIState::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::Metrics::generated_message_descriptor_data());
            messages.push(cchat_usability_client_usability_metrics_notification::uistate::CategoryCollapseState::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(EChatRoomJoinState::generated_enum_descriptor_data());
            enums.push(EChatRoomGroupRank::generated_enum_descriptor_data());
            enums.push(EChatRoomNotificationLevel::generated_enum_descriptor_data());
            enums.push(EChatRoomServerMessage::generated_enum_descriptor_data());
            enums.push(EChatRoomMessageReactionType::generated_enum_descriptor_data());
            enums.push(EChatRoomMemberStateChange::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
