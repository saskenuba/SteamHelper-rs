// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_remoteclient_discovery.proto`

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastHeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastHeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.client_id)
    pub client_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.msg_type)
    pub msg_type: ::std::option::Option<crate::EnumOrUnknown<ERemoteClientBroadcastMsg>>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.instance_id)
    pub instance_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.device_id_OBSOLETE)
    pub device_id_OBSOLETE: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastHeader.device_token)
    pub device_token: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastHeader.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastHeader {
    fn default() -> &'a CMsgRemoteClientBroadcastHeader {
        <CMsgRemoteClientBroadcastHeader as crate::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastHeader {
    pub fn new() -> CMsgRemoteClientBroadcastHeader {
        ::std::default::Default::default()
    }

    // optional uint64 client_id = 1;

    pub fn client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // optional .ERemoteClientBroadcastMsg msg_type = 2;

    pub fn msg_type(&self) -> ERemoteClientBroadcastMsg {
        match self.msg_type {
            Some(e) => e.enum_value_or(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            None => ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
        }
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: ERemoteClientBroadcastMsg) {
        self.msg_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint64 instance_id = 3;

    pub fn instance_id(&self) -> u64 {
        self.instance_id.unwrap_or(0)
    }

    pub fn clear_instance_id(&mut self) {
        self.instance_id = ::std::option::Option::None;
    }

    pub fn has_instance_id(&self) -> bool {
        self.instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance_id(&mut self, v: u64) {
        self.instance_id = ::std::option::Option::Some(v);
    }

    // optional uint64 device_id_OBSOLETE = 4;

    pub fn device_id_OBSOLETE(&self) -> u64 {
        self.device_id_OBSOLETE.unwrap_or(0)
    }

    pub fn clear_device_id_OBSOLETE(&mut self) {
        self.device_id_OBSOLETE = ::std::option::Option::None;
    }

    pub fn has_device_id_OBSOLETE(&self) -> bool {
        self.device_id_OBSOLETE.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id_OBSOLETE(&mut self, v: u64) {
        self.device_id_OBSOLETE = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 5;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::bytes::Bytes) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::bytes::Bytes {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::bytes::Bytes {
        self.device_token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_id",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.client_id },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.client_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.msg_type },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.msg_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "instance_id",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.instance_id },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.instance_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_id_OBSOLETE",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.device_id_OBSOLETE },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.device_id_OBSOLETE },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_token",
            |m: &CMsgRemoteClientBroadcastHeader| { &m.device_token },
            |m: &mut CMsgRemoteClientBroadcastHeader| { &mut m.device_token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteClientBroadcastHeader>(
            "CMsgRemoteClientBroadcastHeader",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteClientBroadcastHeader {
    const NAME: &'static str = "CMsgRemoteClientBroadcastHeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.msg_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.instance_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.device_id_OBSOLETE = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.device_token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.msg_type {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.instance_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        if let Some(v) = self.device_id_OBSOLETE {
            my_size += crate::rt::uint64_size(4, v);
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += crate::rt::bytes_size(5, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.client_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.msg_type {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.instance_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.device_id_OBSOLETE {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastHeader {
        CMsgRemoteClientBroadcastHeader::new()
    }

    fn clear(&mut self) {
        self.client_id = ::std::option::Option::None;
        self.msg_type = ::std::option::Option::None;
        self.instance_id = ::std::option::Option::None;
        self.device_id_OBSOLETE = ::std::option::Option::None;
        self.device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastHeader {
        static instance: CMsgRemoteClientBroadcastHeader = CMsgRemoteClientBroadcastHeader {
            client_id: ::std::option::Option::None,
            msg_type: ::std::option::Option::None,
            instance_id: ::std::option::Option::None,
            device_id_OBSOLETE: ::std::option::Option::None,
            device_token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteClientBroadcastHeader {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastHeader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteClientBroadcastHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteClientBroadcastHeader {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.min_version)
    pub min_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.connect_port)
    pub connect_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.hostname)
    pub hostname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.enabled_services)
    pub enabled_services: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.ostype)
    pub ostype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.is64bit)
    pub is64bit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.users)
    pub users: ::std::vec::Vec<cmsg_remote_client_broadcast_status::User>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.euniverse)
    pub euniverse: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.screen_locked)
    pub screen_locked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.games_running)
    pub games_running: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.mac_addresses)
    pub mac_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.download_lan_peer_group)
    pub download_lan_peer_group: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.broadcasting_active)
    pub broadcasting_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.vr_active)
    pub vr_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.content_cache_port)
    pub content_cache_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.ip_addresses)
    pub ip_addresses: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.public_ip_address)
    pub public_ip_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.remoteplay_active)
    pub remoteplay_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.supported_services)
    pub supported_services: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.steam_deck)
    pub steam_deck: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.steam_version)
    pub steam_version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.vr_link_caps)
    pub vr_link_caps: ::std::option::Option<crate::EnumOrUnknown<EVRLinkCaps>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastStatus.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastStatus {
    fn default() -> &'a CMsgRemoteClientBroadcastStatus {
        <CMsgRemoteClientBroadcastStatus as crate::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastStatus {
    pub fn new() -> CMsgRemoteClientBroadcastStatus {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional int32 min_version = 2;

    pub fn min_version(&self) -> i32 {
        self.min_version.unwrap_or(0)
    }

    pub fn clear_min_version(&mut self) {
        self.min_version = ::std::option::Option::None;
    }

    pub fn has_min_version(&self) -> bool {
        self.min_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_version(&mut self, v: i32) {
        self.min_version = ::std::option::Option::Some(v);
    }

    // optional uint32 connect_port = 3;

    pub fn connect_port(&self) -> u32 {
        self.connect_port.unwrap_or(0)
    }

    pub fn clear_connect_port(&mut self) {
        self.connect_port = ::std::option::Option::None;
    }

    pub fn has_connect_port(&self) -> bool {
        self.connect_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_port(&mut self, v: u32) {
        self.connect_port = ::std::option::Option::Some(v);
    }

    // optional string hostname = 4;

    pub fn hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_hostname(&mut self) {
        self.hostname = ::std::option::Option::None;
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 enabled_services = 6;

    pub fn enabled_services(&self) -> u32 {
        self.enabled_services.unwrap_or(0)
    }

    pub fn clear_enabled_services(&mut self) {
        self.enabled_services = ::std::option::Option::None;
    }

    pub fn has_enabled_services(&self) -> bool {
        self.enabled_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled_services(&mut self, v: u32) {
        self.enabled_services = ::std::option::Option::Some(v);
    }

    // optional int32 ostype = 7;

    pub fn ostype(&self) -> i32 {
        self.ostype.unwrap_or(0i32)
    }

    pub fn clear_ostype(&mut self) {
        self.ostype = ::std::option::Option::None;
    }

    pub fn has_ostype(&self) -> bool {
        self.ostype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ostype(&mut self, v: i32) {
        self.ostype = ::std::option::Option::Some(v);
    }

    // optional bool is64bit = 8;

    pub fn is64bit(&self) -> bool {
        self.is64bit.unwrap_or(false)
    }

    pub fn clear_is64bit(&mut self) {
        self.is64bit = ::std::option::Option::None;
    }

    pub fn has_is64bit(&self) -> bool {
        self.is64bit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is64bit(&mut self, v: bool) {
        self.is64bit = ::std::option::Option::Some(v);
    }

    // repeated .CMsgRemoteClientBroadcastStatus.User users = 9;

    pub fn users(&self) -> &[cmsg_remote_client_broadcast_status::User] {
        &self.users
    }

    pub fn clear_users(&mut self) {
        self.users.clear();
    }

    // Param is passed by value, moved
    pub fn set_users(&mut self, v: ::std::vec::Vec<cmsg_remote_client_broadcast_status::User>) {
        self.users = v;
    }

    // Mutable pointer to the field.
    pub fn mut_users(&mut self) -> &mut ::std::vec::Vec<cmsg_remote_client_broadcast_status::User> {
        &mut self.users
    }

    // Take field
    pub fn take_users(&mut self) -> ::std::vec::Vec<cmsg_remote_client_broadcast_status::User> {
        ::std::mem::replace(&mut self.users, ::std::vec::Vec::new())
    }

    // optional int32 euniverse = 11;

    pub fn euniverse(&self) -> i32 {
        self.euniverse.unwrap_or(0)
    }

    pub fn clear_euniverse(&mut self) {
        self.euniverse = ::std::option::Option::None;
    }

    pub fn has_euniverse(&self) -> bool {
        self.euniverse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_euniverse(&mut self, v: i32) {
        self.euniverse = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 12;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional bool screen_locked = 13;

    pub fn screen_locked(&self) -> bool {
        self.screen_locked.unwrap_or(false)
    }

    pub fn clear_screen_locked(&mut self) {
        self.screen_locked = ::std::option::Option::None;
    }

    pub fn has_screen_locked(&self) -> bool {
        self.screen_locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screen_locked(&mut self, v: bool) {
        self.screen_locked = ::std::option::Option::Some(v);
    }

    // optional bool games_running = 14;

    pub fn games_running(&self) -> bool {
        self.games_running.unwrap_or(false)
    }

    pub fn clear_games_running(&mut self) {
        self.games_running = ::std::option::Option::None;
    }

    pub fn has_games_running(&self) -> bool {
        self.games_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games_running(&mut self, v: bool) {
        self.games_running = ::std::option::Option::Some(v);
    }

    // repeated string mac_addresses = 15;

    pub fn mac_addresses(&self) -> &[::std::string::String] {
        &self.mac_addresses
    }

    pub fn clear_mac_addresses(&mut self) {
        self.mac_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_mac_addresses(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.mac_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mac_addresses(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.mac_addresses
    }

    // Take field
    pub fn take_mac_addresses(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.mac_addresses, ::std::vec::Vec::new())
    }

    // optional uint32 download_lan_peer_group = 16;

    pub fn download_lan_peer_group(&self) -> u32 {
        self.download_lan_peer_group.unwrap_or(0)
    }

    pub fn clear_download_lan_peer_group(&mut self) {
        self.download_lan_peer_group = ::std::option::Option::None;
    }

    pub fn has_download_lan_peer_group(&self) -> bool {
        self.download_lan_peer_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_lan_peer_group(&mut self, v: u32) {
        self.download_lan_peer_group = ::std::option::Option::Some(v);
    }

    // optional bool broadcasting_active = 17;

    pub fn broadcasting_active(&self) -> bool {
        self.broadcasting_active.unwrap_or(false)
    }

    pub fn clear_broadcasting_active(&mut self) {
        self.broadcasting_active = ::std::option::Option::None;
    }

    pub fn has_broadcasting_active(&self) -> bool {
        self.broadcasting_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcasting_active(&mut self, v: bool) {
        self.broadcasting_active = ::std::option::Option::Some(v);
    }

    // optional bool vr_active = 18;

    pub fn vr_active(&self) -> bool {
        self.vr_active.unwrap_or(false)
    }

    pub fn clear_vr_active(&mut self) {
        self.vr_active = ::std::option::Option::None;
    }

    pub fn has_vr_active(&self) -> bool {
        self.vr_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_active(&mut self, v: bool) {
        self.vr_active = ::std::option::Option::Some(v);
    }

    // optional uint32 content_cache_port = 19;

    pub fn content_cache_port(&self) -> u32 {
        self.content_cache_port.unwrap_or(0)
    }

    pub fn clear_content_cache_port(&mut self) {
        self.content_cache_port = ::std::option::Option::None;
    }

    pub fn has_content_cache_port(&self) -> bool {
        self.content_cache_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_cache_port(&mut self, v: u32) {
        self.content_cache_port = ::std::option::Option::Some(v);
    }

    // repeated string ip_addresses = 20;

    pub fn ip_addresses(&self) -> &[::std::string::String] {
        &self.ip_addresses
    }

    pub fn clear_ip_addresses(&mut self) {
        self.ip_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_addresses(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.ip_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ip_addresses(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.ip_addresses
    }

    // Take field
    pub fn take_ip_addresses(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.ip_addresses, ::std::vec::Vec::new())
    }

    // optional string public_ip_address = 21;

    pub fn public_ip_address(&self) -> &str {
        match self.public_ip_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_public_ip_address(&mut self) {
        self.public_ip_address = ::std::option::Option::None;
    }

    pub fn has_public_ip_address(&self) -> bool {
        self.public_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip_address(&mut self, v: ::std::string::String) {
        self.public_ip_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_ip_address(&mut self) -> &mut ::std::string::String {
        if self.public_ip_address.is_none() {
            self.public_ip_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.public_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_public_ip_address(&mut self) -> ::std::string::String {
        self.public_ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool remoteplay_active = 22;

    pub fn remoteplay_active(&self) -> bool {
        self.remoteplay_active.unwrap_or(false)
    }

    pub fn clear_remoteplay_active(&mut self) {
        self.remoteplay_active = ::std::option::Option::None;
    }

    pub fn has_remoteplay_active(&self) -> bool {
        self.remoteplay_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remoteplay_active(&mut self, v: bool) {
        self.remoteplay_active = ::std::option::Option::Some(v);
    }

    // optional uint32 supported_services = 23;

    pub fn supported_services(&self) -> u32 {
        self.supported_services.unwrap_or(0)
    }

    pub fn clear_supported_services(&mut self) {
        self.supported_services = ::std::option::Option::None;
    }

    pub fn has_supported_services(&self) -> bool {
        self.supported_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supported_services(&mut self, v: u32) {
        self.supported_services = ::std::option::Option::Some(v);
    }

    // optional bool steam_deck = 24;

    pub fn steam_deck(&self) -> bool {
        self.steam_deck.unwrap_or(false)
    }

    pub fn clear_steam_deck(&mut self) {
        self.steam_deck = ::std::option::Option::None;
    }

    pub fn has_steam_deck(&self) -> bool {
        self.steam_deck.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_deck(&mut self, v: bool) {
        self.steam_deck = ::std::option::Option::Some(v);
    }

    // optional uint64 steam_version = 25;

    pub fn steam_version(&self) -> u64 {
        self.steam_version.unwrap_or(0)
    }

    pub fn clear_steam_version(&mut self) {
        self.steam_version = ::std::option::Option::None;
    }

    pub fn has_steam_version(&self) -> bool {
        self.steam_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_version(&mut self, v: u64) {
        self.steam_version = ::std::option::Option::Some(v);
    }

    // optional .EVRLinkCaps vr_link_caps = 26;

    pub fn vr_link_caps(&self) -> EVRLinkCaps {
        match self.vr_link_caps {
            Some(e) => e.enum_value_or(EVRLinkCaps::k_EVRLinkCapsUnknown),
            None => EVRLinkCaps::k_EVRLinkCapsUnknown,
        }
    }

    pub fn clear_vr_link_caps(&mut self) {
        self.vr_link_caps = ::std::option::Option::None;
    }

    pub fn has_vr_link_caps(&self) -> bool {
        self.vr_link_caps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_link_caps(&mut self, v: EVRLinkCaps) {
        self.vr_link_caps = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.version },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "min_version",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.min_version },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.min_version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "connect_port",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.connect_port },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.connect_port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hostname",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.hostname },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.hostname },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled_services",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.enabled_services },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.enabled_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ostype",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.ostype },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.ostype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is64bit",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.is64bit },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.is64bit },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "users",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.users },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.users },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "euniverse",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.euniverse },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.euniverse },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.timestamp },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.timestamp },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "screen_locked",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.screen_locked },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.screen_locked },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "games_running",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.games_running },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.games_running },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mac_addresses",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.mac_addresses },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.mac_addresses },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "download_lan_peer_group",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.download_lan_peer_group },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.download_lan_peer_group },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcasting_active",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.broadcasting_active },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.broadcasting_active },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "vr_active",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.vr_active },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.vr_active },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "content_cache_port",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.content_cache_port },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.content_cache_port },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ip_addresses",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.ip_addresses },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.ip_addresses },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_ip_address",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.public_ip_address },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.public_ip_address },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "remoteplay_active",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.remoteplay_active },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.remoteplay_active },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "supported_services",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.supported_services },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.supported_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_deck",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.steam_deck },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.steam_deck },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_version",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.steam_version },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.steam_version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "vr_link_caps",
            |m: &CMsgRemoteClientBroadcastStatus| { &m.vr_link_caps },
            |m: &mut CMsgRemoteClientBroadcastStatus| { &mut m.vr_link_caps },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteClientBroadcastStatus>(
            "CMsgRemoteClientBroadcastStatus",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteClientBroadcastStatus {
    const NAME: &'static str = "CMsgRemoteClientBroadcastStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.min_version = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.connect_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.hostname = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.enabled_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.ostype = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.is64bit = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.users.push(is.read_message()?);
                },
                88 => {
                    self.euniverse = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.screen_locked = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.games_running = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    self.mac_addresses.push(is.read_string()?);
                },
                128 => {
                    self.download_lan_peer_group = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.broadcasting_active = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.vr_active = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.content_cache_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                162 => {
                    self.ip_addresses.push(is.read_string()?);
                },
                170 => {
                    self.public_ip_address = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.remoteplay_active = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.supported_services = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.steam_deck = ::std::option::Option::Some(is.read_bool()?);
                },
                200 => {
                    self.steam_version = ::std::option::Option::Some(is.read_uint64()?);
                },
                208 => {
                    self.vr_link_caps = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.min_version {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.connect_port {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hostname.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.enabled_services {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.ostype {
            my_size += crate::rt::int32_size(7, v);
        }
        if let Some(v) = self.is64bit {
            my_size += 1 + 1;
        }
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.euniverse {
            my_size += crate::rt::int32_size(11, v);
        }
        if let Some(v) = self.timestamp {
            my_size += crate::rt::uint32_size(12, v);
        }
        if let Some(v) = self.screen_locked {
            my_size += 1 + 1;
        }
        if let Some(v) = self.games_running {
            my_size += 1 + 1;
        }
        for value in &self.mac_addresses {
            my_size += crate::rt::string_size(15, &value);
        };
        if let Some(v) = self.download_lan_peer_group {
            my_size += crate::rt::uint32_size(16, v);
        }
        if let Some(v) = self.broadcasting_active {
            my_size += 2 + 1;
        }
        if let Some(v) = self.vr_active {
            my_size += 2 + 1;
        }
        if let Some(v) = self.content_cache_port {
            my_size += crate::rt::uint32_size(19, v);
        }
        for value in &self.ip_addresses {
            my_size += crate::rt::string_size(20, &value);
        };
        if let Some(v) = self.public_ip_address.as_ref() {
            my_size += crate::rt::string_size(21, &v);
        }
        if let Some(v) = self.remoteplay_active {
            my_size += 2 + 1;
        }
        if let Some(v) = self.supported_services {
            my_size += crate::rt::uint32_size(23, v);
        }
        if let Some(v) = self.steam_deck {
            my_size += 2 + 1;
        }
        if let Some(v) = self.steam_version {
            my_size += crate::rt::uint64_size(25, v);
        }
        if let Some(v) = self.vr_link_caps {
            my_size += crate::rt::int32_size(26, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.min_version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.connect_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hostname.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.enabled_services {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.ostype {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.is64bit {
            os.write_bool(8, v)?;
        }
        for v in &self.users {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.euniverse {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.screen_locked {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.games_running {
            os.write_bool(14, v)?;
        }
        for v in &self.mac_addresses {
            os.write_string(15, &v)?;
        };
        if let Some(v) = self.download_lan_peer_group {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.broadcasting_active {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.vr_active {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.content_cache_port {
            os.write_uint32(19, v)?;
        }
        for v in &self.ip_addresses {
            os.write_string(20, &v)?;
        };
        if let Some(v) = self.public_ip_address.as_ref() {
            os.write_string(21, v)?;
        }
        if let Some(v) = self.remoteplay_active {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.supported_services {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.steam_deck {
            os.write_bool(24, v)?;
        }
        if let Some(v) = self.steam_version {
            os.write_uint64(25, v)?;
        }
        if let Some(v) = self.vr_link_caps {
            os.write_enum(26, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastStatus {
        CMsgRemoteClientBroadcastStatus::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.min_version = ::std::option::Option::None;
        self.connect_port = ::std::option::Option::None;
        self.hostname = ::std::option::Option::None;
        self.enabled_services = ::std::option::Option::None;
        self.ostype = ::std::option::Option::None;
        self.is64bit = ::std::option::Option::None;
        self.users.clear();
        self.euniverse = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.screen_locked = ::std::option::Option::None;
        self.games_running = ::std::option::Option::None;
        self.mac_addresses.clear();
        self.download_lan_peer_group = ::std::option::Option::None;
        self.broadcasting_active = ::std::option::Option::None;
        self.vr_active = ::std::option::Option::None;
        self.content_cache_port = ::std::option::Option::None;
        self.ip_addresses.clear();
        self.public_ip_address = ::std::option::Option::None;
        self.remoteplay_active = ::std::option::Option::None;
        self.supported_services = ::std::option::Option::None;
        self.steam_deck = ::std::option::Option::None;
        self.steam_version = ::std::option::Option::None;
        self.vr_link_caps = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastStatus {
        static instance: CMsgRemoteClientBroadcastStatus = CMsgRemoteClientBroadcastStatus {
            version: ::std::option::Option::None,
            min_version: ::std::option::Option::None,
            connect_port: ::std::option::Option::None,
            hostname: ::std::option::Option::None,
            enabled_services: ::std::option::Option::None,
            ostype: ::std::option::Option::None,
            is64bit: ::std::option::Option::None,
            users: ::std::vec::Vec::new(),
            euniverse: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            screen_locked: ::std::option::Option::None,
            games_running: ::std::option::Option::None,
            mac_addresses: ::std::vec::Vec::new(),
            download_lan_peer_group: ::std::option::Option::None,
            broadcasting_active: ::std::option::Option::None,
            vr_active: ::std::option::Option::None,
            content_cache_port: ::std::option::Option::None,
            ip_addresses: ::std::vec::Vec::new(),
            public_ip_address: ::std::option::Option::None,
            remoteplay_active: ::std::option::Option::None,
            supported_services: ::std::option::Option::None,
            steam_deck: ::std::option::Option::None,
            steam_version: ::std::option::Option::None,
            vr_link_caps: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteClientBroadcastStatus {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteClientBroadcastStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteClientBroadcastStatus {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRemoteClientBroadcastStatus`
pub mod cmsg_remote_client_broadcast_status {
    // @@protoc_insertion_point(message:CMsgRemoteClientBroadcastStatus.User)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct User {
        // message fields
        // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.User.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastStatus.User.auth_key_id)
        pub auth_key_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastStatus.User.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a User {
        fn default() -> &'a User {
            <User as crate::Message>::default_instance()
        }
    }

    impl User {
        pub fn new() -> User {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional uint32 auth_key_id = 2;

        pub fn auth_key_id(&self) -> u32 {
            self.auth_key_id.unwrap_or(0)
        }

        pub fn clear_auth_key_id(&mut self) {
            self.auth_key_id = ::std::option::Option::None;
        }

        pub fn has_auth_key_id(&self) -> bool {
            self.auth_key_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_auth_key_id(&mut self, v: u32) {
            self.auth_key_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &User| { &m.steamid },
                |m: &mut User| { &mut m.steamid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "auth_key_id",
                |m: &User| { &m.auth_key_id },
                |m: &mut User| { &mut m.auth_key_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<User>(
                "CMsgRemoteClientBroadcastStatus.User",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for User {
        const NAME: &'static str = "User";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.auth_key_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.auth_key_id {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.auth_key_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> User {
            User::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.auth_key_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static User {
            static instance: User = User {
                steamid: ::std::option::Option::None,
                auth_key_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for User {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastStatus.User").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for User {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for User {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastDiscovery)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastDiscovery {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastDiscovery.seq_num)
    pub seq_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastDiscovery.client_ids)
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastDiscovery.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastDiscovery {
    fn default() -> &'a CMsgRemoteClientBroadcastDiscovery {
        <CMsgRemoteClientBroadcastDiscovery as crate::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastDiscovery {
    pub fn new() -> CMsgRemoteClientBroadcastDiscovery {
        ::std::default::Default::default()
    }

    // optional uint32 seq_num = 1;

    pub fn seq_num(&self) -> u32 {
        self.seq_num.unwrap_or(0)
    }

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: u32) {
        self.seq_num = ::std::option::Option::Some(v);
    }

    // repeated uint64 client_ids = 2;

    pub fn client_ids(&self) -> &[u64] {
        &self.client_ids
    }

    pub fn clear_client_ids(&mut self) {
        self.client_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.client_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_client_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.client_ids
    }

    // Take field
    pub fn take_client_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.client_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "seq_num",
            |m: &CMsgRemoteClientBroadcastDiscovery| { &m.seq_num },
            |m: &mut CMsgRemoteClientBroadcastDiscovery| { &mut m.seq_num },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "client_ids",
            |m: &CMsgRemoteClientBroadcastDiscovery| { &m.client_ids },
            |m: &mut CMsgRemoteClientBroadcastDiscovery| { &mut m.client_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteClientBroadcastDiscovery>(
            "CMsgRemoteClientBroadcastDiscovery",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteClientBroadcastDiscovery {
    const NAME: &'static str = "CMsgRemoteClientBroadcastDiscovery";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seq_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.client_ids)?;
                },
                16 => {
                    self.client_ids.push(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seq_num {
            my_size += crate::rt::uint32_size(1, v);
        }
        for value in &self.client_ids {
            my_size += crate::rt::uint64_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.seq_num {
            os.write_uint32(1, v)?;
        }
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastDiscovery {
        CMsgRemoteClientBroadcastDiscovery::new()
    }

    fn clear(&mut self) {
        self.seq_num = ::std::option::Option::None;
        self.client_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastDiscovery {
        static instance: CMsgRemoteClientBroadcastDiscovery = CMsgRemoteClientBroadcastDiscovery {
            seq_num: ::std::option::Option::None,
            client_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteClientBroadcastDiscovery {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastDiscovery").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteClientBroadcastDiscovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteClientBroadcastDiscovery {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteClientBroadcastClientIDDeconflict)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteClientBroadcastClientIDDeconflict {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteClientBroadcastClientIDDeconflict.client_ids)
    pub client_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteClientBroadcastClientIDDeconflict.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteClientBroadcastClientIDDeconflict {
    fn default() -> &'a CMsgRemoteClientBroadcastClientIDDeconflict {
        <CMsgRemoteClientBroadcastClientIDDeconflict as crate::Message>::default_instance()
    }
}

impl CMsgRemoteClientBroadcastClientIDDeconflict {
    pub fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        ::std::default::Default::default()
    }

    // repeated uint64 client_ids = 2;

    pub fn client_ids(&self) -> &[u64] {
        &self.client_ids
    }

    pub fn clear_client_ids(&mut self) {
        self.client_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.client_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_client_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.client_ids
    }

    // Take field
    pub fn take_client_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.client_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "client_ids",
            |m: &CMsgRemoteClientBroadcastClientIDDeconflict| { &m.client_ids },
            |m: &mut CMsgRemoteClientBroadcastClientIDDeconflict| { &mut m.client_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteClientBroadcastClientIDDeconflict>(
            "CMsgRemoteClientBroadcastClientIDDeconflict",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteClientBroadcastClientIDDeconflict {
    const NAME: &'static str = "CMsgRemoteClientBroadcastClientIDDeconflict";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.client_ids)?;
                },
                16 => {
                    self.client_ids.push(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.client_ids {
            my_size += crate::rt::uint64_size(2, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.client_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteClientBroadcastClientIDDeconflict {
        CMsgRemoteClientBroadcastClientIDDeconflict::new()
    }

    fn clear(&mut self) {
        self.client_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteClientBroadcastClientIDDeconflict {
        static instance: CMsgRemoteClientBroadcastClientIDDeconflict = CMsgRemoteClientBroadcastClientIDDeconflict {
            client_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteClientBroadcastClientIDDeconflict").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteClientBroadcastClientIDDeconflict {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteClientBroadcastClientIDDeconflict {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.device_token)
    pub device_token: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.device_name)
    pub device_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.encrypted_request)
    pub encrypted_request: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.auth_key)
    pub auth_key: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationRequest {
        <CMsgRemoteDeviceAuthorizationRequest as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        ::std::default::Default::default()
    }

    // required bytes device_token = 1;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::bytes::Bytes) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::bytes::Bytes {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::bytes::Bytes {
        self.device_token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional string device_name = 2;

    pub fn device_name(&self) -> &str {
        match self.device_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_name(&mut self) {
        self.device_name = ::std::option::Option::None;
    }

    pub fn has_device_name(&self) -> bool {
        self.device_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        if self.device_name.is_none() {
            self.device_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required bytes encrypted_request = 3;

    pub fn encrypted_request(&self) -> &[u8] {
        match self.encrypted_request.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_request(&mut self) {
        self.encrypted_request = ::std::option::Option::None;
    }

    pub fn has_encrypted_request(&self) -> bool {
        self.encrypted_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_request(&mut self, v: ::bytes::Bytes) {
        self.encrypted_request = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_request(&mut self) -> &mut ::bytes::Bytes {
        if self.encrypted_request.is_none() {
            self.encrypted_request = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.encrypted_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_request(&mut self) -> ::bytes::Bytes {
        self.encrypted_request.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes auth_key = 4;

    pub fn auth_key(&self) -> &[u8] {
        match self.auth_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_auth_key(&mut self) {
        self.auth_key = ::std::option::Option::None;
    }

    pub fn has_auth_key(&self) -> bool {
        self.auth_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_key(&mut self, v: ::bytes::Bytes) {
        self.auth_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_key(&mut self) -> &mut ::bytes::Bytes {
        if self.auth_key.is_none() {
            self.auth_key = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.auth_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_key(&mut self) -> ::bytes::Bytes {
        self.auth_key.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_token",
            |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.device_token },
            |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.device_token },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_name",
            |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.device_name },
            |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.device_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypted_request",
            |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.encrypted_request },
            |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.encrypted_request },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "auth_key",
            |m: &CMsgRemoteDeviceAuthorizationRequest| { &m.auth_key },
            |m: &mut CMsgRemoteDeviceAuthorizationRequest| { &mut m.auth_key },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceAuthorizationRequest>(
            "CMsgRemoteDeviceAuthorizationRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceAuthorizationRequest {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationRequest";

    fn is_initialized(&self) -> bool {
        if self.device_token.is_none() {
            return false;
        }
        if self.encrypted_request.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.device_token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                18 => {
                    self.device_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.encrypted_request = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                34 => {
                    self.auth_key = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.device_token.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.device_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.encrypted_request.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.auth_key.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.device_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.encrypted_request.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.auth_key.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationRequest {
        CMsgRemoteDeviceAuthorizationRequest::new()
    }

    fn clear(&mut self) {
        self.device_token = ::std::option::Option::None;
        self.device_name = ::std::option::Option::None;
        self.encrypted_request = ::std::option::Option::None;
        self.auth_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationRequest {
        static instance: CMsgRemoteDeviceAuthorizationRequest = CMsgRemoteDeviceAuthorizationRequest {
            device_token: ::std::option::Option::None,
            device_name: ::std::option::Option::None,
            encrypted_request: ::std::option::Option::None,
            auth_key: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceAuthorizationRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceAuthorizationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceAuthorizationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRemoteDeviceAuthorizationRequest`
pub mod cmsg_remote_device_authorization_request {
    // @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CKeyEscrow_Ticket {
        // message fields
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.password)
        pub password: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.identifier)
        pub identifier: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.payload)
        pub payload: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.usage)
        pub usage: ::std::option::Option<crate::EnumOrUnknown<EKeyEscrowUsage>>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name)
        pub device_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model)
        pub device_model: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial)
        pub device_serial: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_provisioning_id)
        pub device_provisioning_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CKeyEscrow_Ticket {
        fn default() -> &'a CKeyEscrow_Ticket {
            <CKeyEscrow_Ticket as crate::Message>::default_instance()
        }
    }

    impl CKeyEscrow_Ticket {
        pub fn new() -> CKeyEscrow_Ticket {
            ::std::default::Default::default()
        }

        // optional bytes password = 1;

        pub fn password(&self) -> &[u8] {
            match self.password.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_password(&mut self) {
            self.password = ::std::option::Option::None;
        }

        pub fn has_password(&self) -> bool {
            self.password.is_some()
        }

        // Param is passed by value, moved
        pub fn set_password(&mut self, v: ::bytes::Bytes) {
            self.password = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_password(&mut self) -> &mut ::bytes::Bytes {
            if self.password.is_none() {
                self.password = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.password.as_mut().unwrap()
        }

        // Take field
        pub fn take_password(&mut self) -> ::bytes::Bytes {
            self.password.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional uint64 identifier = 2;

        pub fn identifier(&self) -> u64 {
            self.identifier.unwrap_or(0)
        }

        pub fn clear_identifier(&mut self) {
            self.identifier = ::std::option::Option::None;
        }

        pub fn has_identifier(&self) -> bool {
            self.identifier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_identifier(&mut self, v: u64) {
            self.identifier = ::std::option::Option::Some(v);
        }

        // optional bytes payload = 3;

        pub fn payload(&self) -> &[u8] {
            match self.payload.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_payload(&mut self) {
            self.payload = ::std::option::Option::None;
        }

        pub fn has_payload(&self) -> bool {
            self.payload.is_some()
        }

        // Param is passed by value, moved
        pub fn set_payload(&mut self, v: ::bytes::Bytes) {
            self.payload = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_payload(&mut self) -> &mut ::bytes::Bytes {
            if self.payload.is_none() {
                self.payload = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.payload.as_mut().unwrap()
        }

        // Take field
        pub fn take_payload(&mut self) -> ::bytes::Bytes {
            self.payload.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional uint32 timestamp = 4;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5;

        pub fn usage(&self) -> EKeyEscrowUsage {
            match self.usage {
                Some(e) => e.enum_value_or(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                None => EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
            }
        }

        pub fn clear_usage(&mut self) {
            self.usage = ::std::option::Option::None;
        }

        pub fn has_usage(&self) -> bool {
            self.usage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_usage(&mut self, v: EKeyEscrowUsage) {
            self.usage = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional string device_name = 6;

        pub fn device_name(&self) -> &str {
            match self.device_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_name(&mut self) {
            self.device_name = ::std::option::Option::None;
        }

        pub fn has_device_name(&self) -> bool {
            self.device_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_name(&mut self, v: ::std::string::String) {
            self.device_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
            if self.device_name.is_none() {
                self.device_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_name(&mut self) -> ::std::string::String {
            self.device_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string device_model = 7;

        pub fn device_model(&self) -> &str {
            match self.device_model.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_model(&mut self) {
            self.device_model = ::std::option::Option::None;
        }

        pub fn has_device_model(&self) -> bool {
            self.device_model.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_model(&mut self, v: ::std::string::String) {
            self.device_model = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_model(&mut self) -> &mut ::std::string::String {
            if self.device_model.is_none() {
                self.device_model = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_model.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_model(&mut self) -> ::std::string::String {
            self.device_model.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string device_serial = 8;

        pub fn device_serial(&self) -> &str {
            match self.device_serial.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_device_serial(&mut self) {
            self.device_serial = ::std::option::Option::None;
        }

        pub fn has_device_serial(&self) -> bool {
            self.device_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_serial(&mut self, v: ::std::string::String) {
            self.device_serial = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_device_serial(&mut self) -> &mut ::std::string::String {
            if self.device_serial.is_none() {
                self.device_serial = ::std::option::Option::Some(::std::string::String::new());
            }
            self.device_serial.as_mut().unwrap()
        }

        // Take field
        pub fn take_device_serial(&mut self) -> ::std::string::String {
            self.device_serial.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 device_provisioning_id = 9;

        pub fn device_provisioning_id(&self) -> u32 {
            self.device_provisioning_id.unwrap_or(0)
        }

        pub fn clear_device_provisioning_id(&mut self) {
            self.device_provisioning_id = ::std::option::Option::None;
        }

        pub fn has_device_provisioning_id(&self) -> bool {
            self.device_provisioning_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device_provisioning_id(&mut self, v: u32) {
            self.device_provisioning_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "password",
                |m: &CKeyEscrow_Ticket| { &m.password },
                |m: &mut CKeyEscrow_Ticket| { &mut m.password },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "identifier",
                |m: &CKeyEscrow_Ticket| { &m.identifier },
                |m: &mut CKeyEscrow_Ticket| { &mut m.identifier },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "payload",
                |m: &CKeyEscrow_Ticket| { &m.payload },
                |m: &mut CKeyEscrow_Ticket| { &mut m.payload },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &CKeyEscrow_Ticket| { &m.timestamp },
                |m: &mut CKeyEscrow_Ticket| { &mut m.timestamp },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "usage",
                |m: &CKeyEscrow_Ticket| { &m.usage },
                |m: &mut CKeyEscrow_Ticket| { &mut m.usage },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_name",
                |m: &CKeyEscrow_Ticket| { &m.device_name },
                |m: &mut CKeyEscrow_Ticket| { &mut m.device_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_model",
                |m: &CKeyEscrow_Ticket| { &m.device_model },
                |m: &mut CKeyEscrow_Ticket| { &mut m.device_model },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_serial",
                |m: &CKeyEscrow_Ticket| { &m.device_serial },
                |m: &mut CKeyEscrow_Ticket| { &mut m.device_serial },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device_provisioning_id",
                |m: &CKeyEscrow_Ticket| { &m.device_provisioning_id },
                |m: &mut CKeyEscrow_Ticket| { &mut m.device_provisioning_id },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<CKeyEscrow_Ticket>(
                "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for CKeyEscrow_Ticket {
        const NAME: &'static str = "CKeyEscrow_Ticket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.password = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    16 => {
                        self.identifier = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.payload = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    32 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.usage = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    50 => {
                        self.device_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.device_model = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.device_serial = ::std::option::Option::Some(is.read_string()?);
                    },
                    72 => {
                        self.device_provisioning_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.password.as_ref() {
                my_size += crate::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.identifier {
                my_size += crate::rt::uint64_size(2, v);
            }
            if let Some(v) = self.payload.as_ref() {
                my_size += crate::rt::bytes_size(3, &v);
            }
            if let Some(v) = self.timestamp {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.usage {
                my_size += crate::rt::int32_size(5, v.value());
            }
            if let Some(v) = self.device_name.as_ref() {
                my_size += crate::rt::string_size(6, &v);
            }
            if let Some(v) = self.device_model.as_ref() {
                my_size += crate::rt::string_size(7, &v);
            }
            if let Some(v) = self.device_serial.as_ref() {
                my_size += crate::rt::string_size(8, &v);
            }
            if let Some(v) = self.device_provisioning_id {
                my_size += crate::rt::uint32_size(9, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.password.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.identifier {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.payload.as_ref() {
                os.write_bytes(3, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.usage {
                os.write_enum(5, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.device_name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.device_model.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.device_serial.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.device_provisioning_id {
                os.write_uint32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CKeyEscrow_Ticket {
            CKeyEscrow_Ticket::new()
        }

        fn clear(&mut self) {
            self.password = ::std::option::Option::None;
            self.identifier = ::std::option::Option::None;
            self.payload = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.usage = ::std::option::Option::None;
            self.device_name = ::std::option::Option::None;
            self.device_model = ::std::option::Option::None;
            self.device_serial = ::std::option::Option::None;
            self.device_provisioning_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CKeyEscrow_Ticket {
            static instance: CKeyEscrow_Ticket = CKeyEscrow_Ticket {
                password: ::std::option::Option::None,
                identifier: ::std::option::Option::None,
                payload: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                usage: ::std::option::Option::None,
                device_name: ::std::option::Option::None,
                device_model: ::std::option::Option::None,
                device_serial: ::std::option::Option::None,
                device_provisioning_id: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for CKeyEscrow_Ticket {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CKeyEscrow_Ticket {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for CKeyEscrow_Ticket {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage)
    pub enum EKeyEscrowUsage {
        // @@protoc_insertion_point(enum_value:CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage.k_EKeyEscrowUsageStreamingDevice)
        k_EKeyEscrowUsageStreamingDevice = 0,
    }

    impl crate::Enum for EKeyEscrowUsage {
        const NAME: &'static str = "EKeyEscrowUsage";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EKeyEscrowUsage> {
            match value {
                0 => ::std::option::Option::Some(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EKeyEscrowUsage> {
            match str {
                "k_EKeyEscrowUsageStreamingDevice" => ::std::option::Option::Some(EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EKeyEscrowUsage] = &[
            EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice,
        ];
    }

    impl crate::EnumFull for EKeyEscrowUsage {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for EKeyEscrowUsage {
        fn default() -> Self {
            EKeyEscrowUsage::k_EKeyEscrowUsageStreamingDevice
        }
    }

    impl EKeyEscrowUsage {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<EKeyEscrowUsage>("CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage")
        }
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationCancelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationCancelRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationCancelRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationCancelRequest {
        <CMsgRemoteDeviceAuthorizationCancelRequest as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationCancelRequest {
    pub fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceAuthorizationCancelRequest>(
            "CMsgRemoteDeviceAuthorizationCancelRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceAuthorizationCancelRequest {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationCancelRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationCancelRequest {
        CMsgRemoteDeviceAuthorizationCancelRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationCancelRequest {
        static instance: CMsgRemoteDeviceAuthorizationCancelRequest = CMsgRemoteDeviceAuthorizationCancelRequest {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceAuthorizationCancelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceAuthorizationCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationCancelRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.result)
    pub result: ::std::option::Option<crate::EnumOrUnknown<ERemoteDeviceAuthorizationResult>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.auth_key)
    pub auth_key: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationResponse.device_token)
    pub device_token: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationResponse {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationResponse {
        <CMsgRemoteDeviceAuthorizationResponse as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationResponse {
    pub fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        ::std::default::Default::default()
    }

    // required .ERemoteDeviceAuthorizationResult result = 1;

    pub fn result(&self) -> ERemoteDeviceAuthorizationResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            None => ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceAuthorizationResult) {
        self.result = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional fixed64 steamid = 2;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional bytes auth_key = 3;

    pub fn auth_key(&self) -> &[u8] {
        match self.auth_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_auth_key(&mut self) {
        self.auth_key = ::std::option::Option::None;
    }

    pub fn has_auth_key(&self) -> bool {
        self.auth_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_key(&mut self, v: ::bytes::Bytes) {
        self.auth_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_key(&mut self) -> &mut ::bytes::Bytes {
        if self.auth_key.is_none() {
            self.auth_key = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.auth_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_key(&mut self) -> ::bytes::Bytes {
        self.auth_key.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes device_token = 4;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::bytes::Bytes) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::bytes::Bytes {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::bytes::Bytes {
        self.device_token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.result },
            |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.result },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.steamid },
            |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "auth_key",
            |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.auth_key },
            |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.auth_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_token",
            |m: &CMsgRemoteDeviceAuthorizationResponse| { &m.device_token },
            |m: &mut CMsgRemoteDeviceAuthorizationResponse| { &mut m.device_token },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceAuthorizationResponse>(
            "CMsgRemoteDeviceAuthorizationResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceAuthorizationResponse {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationResponse";

    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.auth_key = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                34 => {
                    self.device_token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.auth_key.as_ref() {
            my_size += crate::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.auth_key.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationResponse {
        CMsgRemoteDeviceAuthorizationResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.auth_key = ::std::option::Option::None;
        self.device_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationResponse {
        static instance: CMsgRemoteDeviceAuthorizationResponse = CMsgRemoteDeviceAuthorizationResponse {
            result: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            auth_key: ::std::option::Option::None,
            device_token: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceAuthorizationResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceAuthorizationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceAuthorizationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceAuthorizationConfirmed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceAuthorizationConfirmed {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceAuthorizationConfirmed.result)
    pub result: ::std::option::Option<crate::EnumOrUnknown<ERemoteDeviceAuthorizationResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceAuthorizationConfirmed.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceAuthorizationConfirmed {
    fn default() -> &'a CMsgRemoteDeviceAuthorizationConfirmed {
        <CMsgRemoteDeviceAuthorizationConfirmed as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceAuthorizationConfirmed {
    pub fn new() -> CMsgRemoteDeviceAuthorizationConfirmed {
        ::std::default::Default::default()
    }

    // required .ERemoteDeviceAuthorizationResult result = 1;

    pub fn result(&self) -> ERemoteDeviceAuthorizationResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            None => ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceAuthorizationResult) {
        self.result = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgRemoteDeviceAuthorizationConfirmed| { &m.result },
            |m: &mut CMsgRemoteDeviceAuthorizationConfirmed| { &mut m.result },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceAuthorizationConfirmed>(
            "CMsgRemoteDeviceAuthorizationConfirmed",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceAuthorizationConfirmed {
    const NAME: &'static str = "CMsgRemoteDeviceAuthorizationConfirmed";

    fn is_initialized(&self) -> bool {
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += crate::rt::int32_size(1, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceAuthorizationConfirmed {
        CMsgRemoteDeviceAuthorizationConfirmed::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceAuthorizationConfirmed {
        static instance: CMsgRemoteDeviceAuthorizationConfirmed = CMsgRemoteDeviceAuthorizationConfirmed {
            result: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceAuthorizationConfirmed {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceAuthorizationConfirmed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceAuthorizationConfirmed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceAuthorizationConfirmed {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.maximum_resolution_x)
    pub maximum_resolution_x: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.maximum_resolution_y)
    pub maximum_resolution_y: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.audio_channel_count)
    pub audio_channel_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.device_version)
    pub device_version: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.stream_desktop)
    pub stream_desktop: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.device_token)
    pub device_token: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.pin)
    pub pin: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.enable_video_streaming)
    pub enable_video_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.enable_audio_streaming)
    pub enable_audio_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.enable_input_streaming)
    pub enable_input_streaming: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.network_test)
    pub network_test: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.client_id)
    pub client_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.supported_transport)
    pub supported_transport: ::std::vec::Vec<crate::EnumOrUnknown<EStreamTransport>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.restricted)
    pub restricted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.form_factor)
    pub form_factor: ::std::option::Option<crate::EnumOrUnknown<EStreamDeviceFormFactor>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.gamepad_count)
    pub gamepad_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.gamepads)
    pub gamepads: ::std::vec::Vec<cmsg_remote_device_streaming_request::ReservedGamepad>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.gameid)
    pub gameid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.stream_interface)
    pub stream_interface: ::std::option::Option<crate::EnumOrUnknown<EStreamInterface>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingRequest {
        <CMsgRemoteDeviceStreamingRequest as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_x = 2;

    pub fn maximum_resolution_x(&self) -> i32 {
        self.maximum_resolution_x.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_x(&mut self) {
        self.maximum_resolution_x = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_x(&self) -> bool {
        self.maximum_resolution_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_x(&mut self, v: i32) {
        self.maximum_resolution_x = ::std::option::Option::Some(v);
    }

    // optional int32 maximum_resolution_y = 3;

    pub fn maximum_resolution_y(&self) -> i32 {
        self.maximum_resolution_y.unwrap_or(0)
    }

    pub fn clear_maximum_resolution_y(&mut self) {
        self.maximum_resolution_y = ::std::option::Option::None;
    }

    pub fn has_maximum_resolution_y(&self) -> bool {
        self.maximum_resolution_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum_resolution_y(&mut self, v: i32) {
        self.maximum_resolution_y = ::std::option::Option::Some(v);
    }

    // optional int32 audio_channel_count = 4;

    pub fn audio_channel_count(&self) -> i32 {
        self.audio_channel_count.unwrap_or(2i32)
    }

    pub fn clear_audio_channel_count(&mut self) {
        self.audio_channel_count = ::std::option::Option::None;
    }

    pub fn has_audio_channel_count(&self) -> bool {
        self.audio_channel_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audio_channel_count(&mut self, v: i32) {
        self.audio_channel_count = ::std::option::Option::Some(v);
    }

    // optional string device_version = 5;

    pub fn device_version(&self) -> &str {
        match self.device_version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_device_version(&mut self) {
        self.device_version = ::std::option::Option::None;
    }

    pub fn has_device_version(&self) -> bool {
        self.device_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_version(&mut self, v: ::std::string::String) {
        self.device_version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_version(&mut self) -> &mut ::std::string::String {
        if self.device_version.is_none() {
            self.device_version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.device_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_version(&mut self) -> ::std::string::String {
        self.device_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool stream_desktop = 6;

    pub fn stream_desktop(&self) -> bool {
        self.stream_desktop.unwrap_or(false)
    }

    pub fn clear_stream_desktop(&mut self) {
        self.stream_desktop = ::std::option::Option::None;
    }

    pub fn has_stream_desktop(&self) -> bool {
        self.stream_desktop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_desktop(&mut self, v: bool) {
        self.stream_desktop = ::std::option::Option::Some(v);
    }

    // optional bytes device_token = 7;

    pub fn device_token(&self) -> &[u8] {
        match self.device_token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_device_token(&mut self) {
        self.device_token = ::std::option::Option::None;
    }

    pub fn has_device_token(&self) -> bool {
        self.device_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_token(&mut self, v: ::bytes::Bytes) {
        self.device_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_token(&mut self) -> &mut ::bytes::Bytes {
        if self.device_token.is_none() {
            self.device_token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.device_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_token(&mut self) -> ::bytes::Bytes {
        self.device_token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes pin = 8;

    pub fn pin(&self) -> &[u8] {
        match self.pin.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_pin(&mut self) {
        self.pin = ::std::option::Option::None;
    }

    pub fn has_pin(&self) -> bool {
        self.pin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pin(&mut self, v: ::bytes::Bytes) {
        self.pin = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pin(&mut self) -> &mut ::bytes::Bytes {
        if self.pin.is_none() {
            self.pin = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.pin.as_mut().unwrap()
    }

    // Take field
    pub fn take_pin(&mut self) -> ::bytes::Bytes {
        self.pin.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool enable_video_streaming = 9;

    pub fn enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.unwrap_or(true)
    }

    pub fn clear_enable_video_streaming(&mut self) {
        self.enable_video_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_video_streaming(&self) -> bool {
        self.enable_video_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_video_streaming(&mut self, v: bool) {
        self.enable_video_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_audio_streaming = 10;

    pub fn enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.unwrap_or(true)
    }

    pub fn clear_enable_audio_streaming(&mut self) {
        self.enable_audio_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_audio_streaming(&self) -> bool {
        self.enable_audio_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_audio_streaming(&mut self, v: bool) {
        self.enable_audio_streaming = ::std::option::Option::Some(v);
    }

    // optional bool enable_input_streaming = 11;

    pub fn enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.unwrap_or(true)
    }

    pub fn clear_enable_input_streaming(&mut self) {
        self.enable_input_streaming = ::std::option::Option::None;
    }

    pub fn has_enable_input_streaming(&self) -> bool {
        self.enable_input_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable_input_streaming(&mut self, v: bool) {
        self.enable_input_streaming = ::std::option::Option::Some(v);
    }

    // optional bool network_test = 12;

    pub fn network_test(&self) -> bool {
        self.network_test.unwrap_or(false)
    }

    pub fn clear_network_test(&mut self) {
        self.network_test = ::std::option::Option::None;
    }

    pub fn has_network_test(&self) -> bool {
        self.network_test.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_test(&mut self, v: bool) {
        self.network_test = ::std::option::Option::Some(v);
    }

    // optional uint64 client_id = 13;

    pub fn client_id(&self) -> u64 {
        self.client_id.unwrap_or(0)
    }

    pub fn clear_client_id(&mut self) {
        self.client_id = ::std::option::Option::None;
    }

    pub fn has_client_id(&self) -> bool {
        self.client_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_id(&mut self, v: u64) {
        self.client_id = ::std::option::Option::Some(v);
    }

    // repeated .EStreamTransport supported_transport = 14;

    pub fn supported_transport(&self) -> &[crate::EnumOrUnknown<EStreamTransport>] {
        &self.supported_transport
    }

    pub fn clear_supported_transport(&mut self) {
        self.supported_transport.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_transport(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<EStreamTransport>>) {
        self.supported_transport = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_transport(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<EStreamTransport>> {
        &mut self.supported_transport
    }

    // Take field
    pub fn take_supported_transport(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<EStreamTransport>> {
        ::std::mem::replace(&mut self.supported_transport, ::std::vec::Vec::new())
    }

    // optional bool restricted = 15;

    pub fn restricted(&self) -> bool {
        self.restricted.unwrap_or(false)
    }

    pub fn clear_restricted(&mut self) {
        self.restricted = ::std::option::Option::None;
    }

    pub fn has_restricted(&self) -> bool {
        self.restricted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restricted(&mut self, v: bool) {
        self.restricted = ::std::option::Option::Some(v);
    }

    // optional .EStreamDeviceFormFactor form_factor = 16;

    pub fn form_factor(&self) -> EStreamDeviceFormFactor {
        match self.form_factor {
            Some(e) => e.enum_value_or(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            None => EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
        }
    }

    pub fn clear_form_factor(&mut self) {
        self.form_factor = ::std::option::Option::None;
    }

    pub fn has_form_factor(&self) -> bool {
        self.form_factor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_form_factor(&mut self, v: EStreamDeviceFormFactor) {
        self.form_factor = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional int32 gamepad_count = 17;

    pub fn gamepad_count(&self) -> i32 {
        self.gamepad_count.unwrap_or(0)
    }

    pub fn clear_gamepad_count(&mut self) {
        self.gamepad_count = ::std::option::Option::None;
    }

    pub fn has_gamepad_count(&self) -> bool {
        self.gamepad_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gamepad_count(&mut self, v: i32) {
        self.gamepad_count = ::std::option::Option::Some(v);
    }

    // repeated .CMsgRemoteDeviceStreamingRequest.ReservedGamepad gamepads = 18;

    pub fn gamepads(&self) -> &[cmsg_remote_device_streaming_request::ReservedGamepad] {
        &self.gamepads
    }

    pub fn clear_gamepads(&mut self) {
        self.gamepads.clear();
    }

    // Param is passed by value, moved
    pub fn set_gamepads(&mut self, v: ::std::vec::Vec<cmsg_remote_device_streaming_request::ReservedGamepad>) {
        self.gamepads = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gamepads(&mut self) -> &mut ::std::vec::Vec<cmsg_remote_device_streaming_request::ReservedGamepad> {
        &mut self.gamepads
    }

    // Take field
    pub fn take_gamepads(&mut self) -> ::std::vec::Vec<cmsg_remote_device_streaming_request::ReservedGamepad> {
        ::std::mem::replace(&mut self.gamepads, ::std::vec::Vec::new())
    }

    // optional uint64 gameid = 19;

    pub fn gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional .EStreamInterface stream_interface = 20;

    pub fn stream_interface(&self) -> EStreamInterface {
        match self.stream_interface {
            Some(e) => e.enum_value_or(EStreamInterface::k_EStreamInterfaceDefault),
            None => EStreamInterface::k_EStreamInterfaceDefault,
        }
    }

    pub fn clear_stream_interface(&mut self) {
        self.stream_interface = ::std::option::Option::None;
    }

    pub fn has_stream_interface(&self) -> bool {
        self.stream_interface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_interface(&mut self, v: EStreamInterface) {
        self.stream_interface = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.request_id },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.request_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum_resolution_x",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.maximum_resolution_x },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.maximum_resolution_x },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "maximum_resolution_y",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.maximum_resolution_y },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.maximum_resolution_y },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "audio_channel_count",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.audio_channel_count },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.audio_channel_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_version",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.device_version },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.device_version },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_desktop",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.stream_desktop },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.stream_desktop },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "device_token",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.device_token },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.device_token },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "pin",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.pin },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.pin },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_video_streaming",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_video_streaming },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_video_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_audio_streaming",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_audio_streaming },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_audio_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "enable_input_streaming",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.enable_input_streaming },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.enable_input_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "network_test",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.network_test },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.network_test },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_id",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.client_id },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.client_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_transport",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.supported_transport },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.supported_transport },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "restricted",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.restricted },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.restricted },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "form_factor",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.form_factor },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.form_factor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gamepad_count",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.gamepad_count },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.gamepad_count },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gamepads",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.gamepads },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.gamepads },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameid",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.gameid },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.gameid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_interface",
            |m: &CMsgRemoteDeviceStreamingRequest| { &m.stream_interface },
            |m: &mut CMsgRemoteDeviceStreamingRequest| { &mut m.stream_interface },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamingRequest>(
            "CMsgRemoteDeviceStreamingRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceStreamingRequest {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingRequest";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        for v in &self.gamepads {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.maximum_resolution_x = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.maximum_resolution_y = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.audio_channel_count = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.device_version = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.stream_desktop = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.device_token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                66 => {
                    self.pin = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                72 => {
                    self.enable_video_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.enable_audio_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.enable_input_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.network_test = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.client_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.supported_transport.push(is.read_enum_or_unknown()?);
                },
                114 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_transport)?
                },
                120 => {
                    self.restricted = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.form_factor = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                136 => {
                    self.gamepad_count = ::std::option::Option::Some(is.read_int32()?);
                },
                146 => {
                    self.gamepads.push(is.read_message()?);
                },
                152 => {
                    self.gameid = ::std::option::Option::Some(is.read_uint64()?);
                },
                160 => {
                    self.stream_interface = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.maximum_resolution_x {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.maximum_resolution_y {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.audio_channel_count {
            my_size += crate::rt::int32_size(4, v);
        }
        if let Some(v) = self.device_version.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.stream_desktop {
            my_size += 1 + 1;
        }
        if let Some(v) = self.device_token.as_ref() {
            my_size += crate::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.pin.as_ref() {
            my_size += crate::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.enable_video_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_audio_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.enable_input_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.network_test {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_id {
            my_size += crate::rt::uint64_size(13, v);
        }
        for value in &self.supported_transport {
            my_size += crate::rt::int32_size(14, value.value());
        };
        if let Some(v) = self.restricted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.form_factor {
            my_size += crate::rt::int32_size(16, v.value());
        }
        if let Some(v) = self.gamepad_count {
            my_size += crate::rt::int32_size(17, v);
        }
        for value in &self.gamepads {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gameid {
            my_size += crate::rt::uint64_size(19, v);
        }
        if let Some(v) = self.stream_interface {
            my_size += crate::rt::int32_size(20, v.value());
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.maximum_resolution_x {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.maximum_resolution_y {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.audio_channel_count {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.device_version.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.stream_desktop {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.device_token.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.pin.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.enable_video_streaming {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.enable_audio_streaming {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.enable_input_streaming {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.network_test {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.client_id {
            os.write_uint64(13, v)?;
        }
        for v in &self.supported_transport {
            os.write_enum(14, crate::EnumOrUnknown::value(v))?;
        };
        if let Some(v) = self.restricted {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.form_factor {
            os.write_enum(16, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.gamepad_count {
            os.write_int32(17, v)?;
        }
        for v in &self.gamepads {
            crate::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        if let Some(v) = self.gameid {
            os.write_uint64(19, v)?;
        }
        if let Some(v) = self.stream_interface {
            os.write_enum(20, crate::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingRequest {
        CMsgRemoteDeviceStreamingRequest::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.maximum_resolution_x = ::std::option::Option::None;
        self.maximum_resolution_y = ::std::option::Option::None;
        self.audio_channel_count = ::std::option::Option::None;
        self.device_version = ::std::option::Option::None;
        self.stream_desktop = ::std::option::Option::None;
        self.device_token = ::std::option::Option::None;
        self.pin = ::std::option::Option::None;
        self.enable_video_streaming = ::std::option::Option::None;
        self.enable_audio_streaming = ::std::option::Option::None;
        self.enable_input_streaming = ::std::option::Option::None;
        self.network_test = ::std::option::Option::None;
        self.client_id = ::std::option::Option::None;
        self.supported_transport.clear();
        self.restricted = ::std::option::Option::None;
        self.form_factor = ::std::option::Option::None;
        self.gamepad_count = ::std::option::Option::None;
        self.gamepads.clear();
        self.gameid = ::std::option::Option::None;
        self.stream_interface = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingRequest {
        static instance: CMsgRemoteDeviceStreamingRequest = CMsgRemoteDeviceStreamingRequest {
            request_id: ::std::option::Option::None,
            maximum_resolution_x: ::std::option::Option::None,
            maximum_resolution_y: ::std::option::Option::None,
            audio_channel_count: ::std::option::Option::None,
            device_version: ::std::option::Option::None,
            stream_desktop: ::std::option::Option::None,
            device_token: ::std::option::Option::None,
            pin: ::std::option::Option::None,
            enable_video_streaming: ::std::option::Option::None,
            enable_audio_streaming: ::std::option::Option::None,
            enable_input_streaming: ::std::option::Option::None,
            network_test: ::std::option::Option::None,
            client_id: ::std::option::Option::None,
            supported_transport: ::std::vec::Vec::new(),
            restricted: ::std::option::Option::None,
            form_factor: ::std::option::Option::None,
            gamepad_count: ::std::option::Option::None,
            gamepads: ::std::vec::Vec::new(),
            gameid: ::std::option::Option::None,
            stream_interface: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceStreamingRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceStreamingRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgRemoteDeviceStreamingRequest`
pub mod cmsg_remote_device_streaming_request {
    // @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReservedGamepad {
        // message fields
        // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_type)
        pub controller_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_subtype)
        pub controller_subtype: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReservedGamepad {
        fn default() -> &'a ReservedGamepad {
            <ReservedGamepad as crate::Message>::default_instance()
        }
    }

    impl ReservedGamepad {
        pub fn new() -> ReservedGamepad {
            ::std::default::Default::default()
        }

        // optional uint32 controller_type = 1;

        pub fn controller_type(&self) -> u32 {
            self.controller_type.unwrap_or(0)
        }

        pub fn clear_controller_type(&mut self) {
            self.controller_type = ::std::option::Option::None;
        }

        pub fn has_controller_type(&self) -> bool {
            self.controller_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_type(&mut self, v: u32) {
            self.controller_type = ::std::option::Option::Some(v);
        }

        // optional uint32 controller_subtype = 2;

        pub fn controller_subtype(&self) -> u32 {
            self.controller_subtype.unwrap_or(0)
        }

        pub fn clear_controller_subtype(&mut self) {
            self.controller_subtype = ::std::option::Option::None;
        }

        pub fn has_controller_subtype(&self) -> bool {
            self.controller_subtype.is_some()
        }

        // Param is passed by value, moved
        pub fn set_controller_subtype(&mut self, v: u32) {
            self.controller_subtype = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controller_type",
                |m: &ReservedGamepad| { &m.controller_type },
                |m: &mut ReservedGamepad| { &mut m.controller_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "controller_subtype",
                |m: &ReservedGamepad| { &m.controller_subtype },
                |m: &mut ReservedGamepad| { &mut m.controller_subtype },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ReservedGamepad>(
                "CMsgRemoteDeviceStreamingRequest.ReservedGamepad",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ReservedGamepad {
        const NAME: &'static str = "ReservedGamepad";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.controller_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.controller_subtype = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.controller_type {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.controller_subtype {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.controller_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.controller_subtype {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReservedGamepad {
            ReservedGamepad::new()
        }

        fn clear(&mut self) {
            self.controller_type = ::std::option::Option::None;
            self.controller_subtype = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReservedGamepad {
            static instance: ReservedGamepad = ReservedGamepad {
                controller_type: ::std::option::Option::None,
                controller_subtype: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ReservedGamepad {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingRequest.ReservedGamepad").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReservedGamepad {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ReservedGamepad {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingCancelRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingCancelRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingCancelRequest.request_id)
    pub request_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingCancelRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingCancelRequest {
    fn default() -> &'a CMsgRemoteDeviceStreamingCancelRequest {
        <CMsgRemoteDeviceStreamingCancelRequest as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingCancelRequest {
    pub fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceStreamingCancelRequest| { &m.request_id },
            |m: &mut CMsgRemoteDeviceStreamingCancelRequest| { &mut m.request_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamingCancelRequest>(
            "CMsgRemoteDeviceStreamingCancelRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceStreamingCancelRequest {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingCancelRequest";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingCancelRequest {
        CMsgRemoteDeviceStreamingCancelRequest::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingCancelRequest {
        static instance: CMsgRemoteDeviceStreamingCancelRequest = CMsgRemoteDeviceStreamingCancelRequest {
            request_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceStreamingCancelRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingCancelRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamingCancelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceStreamingCancelRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingProgress.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingProgress.progress)
    pub progress: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingProgress.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingProgress {
    fn default() -> &'a CMsgRemoteDeviceStreamingProgress {
        <CMsgRemoteDeviceStreamingProgress as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingProgress {
    pub fn new() -> CMsgRemoteDeviceStreamingProgress {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional float progress = 2;

    pub fn progress(&self) -> f32 {
        self.progress.unwrap_or(0.)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: f32) {
        self.progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceStreamingProgress| { &m.request_id },
            |m: &mut CMsgRemoteDeviceStreamingProgress| { &mut m.request_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &CMsgRemoteDeviceStreamingProgress| { &m.progress },
            |m: &mut CMsgRemoteDeviceStreamingProgress| { &mut m.progress },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamingProgress>(
            "CMsgRemoteDeviceStreamingProgress",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceStreamingProgress {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingProgress";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.progress = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.progress {
            my_size += 1 + 4;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.progress {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingProgress {
        CMsgRemoteDeviceStreamingProgress::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingProgress {
        static instance: CMsgRemoteDeviceStreamingProgress = CMsgRemoteDeviceStreamingProgress {
            request_id: ::std::option::Option::None,
            progress: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceStreamingProgress {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamingProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceStreamingProgress {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.result)
    pub result: ::std::option::Option<crate::EnumOrUnknown<ERemoteDeviceStreamingResult>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.port)
    pub port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.encrypted_session_key)
    pub encrypted_session_key: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.transport)
    pub transport: ::std::option::Option<crate::EnumOrUnknown<EStreamTransport>>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.relay_server)
    pub relay_server: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamingResponse.cert)
    pub cert: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamingResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamingResponse {
    fn default() -> &'a CMsgRemoteDeviceStreamingResponse {
        <CMsgRemoteDeviceStreamingResponse as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamingResponse {
    pub fn new() -> CMsgRemoteDeviceStreamingResponse {
        ::std::default::Default::default()
    }

    // required uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // required .ERemoteDeviceStreamingResult result = 2;

    pub fn result(&self) -> ERemoteDeviceStreamingResult {
        match self.result {
            Some(e) => e.enum_value_or(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            None => ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ERemoteDeviceStreamingResult) {
        self.result = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 port = 3;

    pub fn port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional bytes encrypted_session_key = 4;

    pub fn encrypted_session_key(&self) -> &[u8] {
        match self.encrypted_session_key.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted_session_key(&mut self) {
        self.encrypted_session_key = ::std::option::Option::None;
    }

    pub fn has_encrypted_session_key(&self) -> bool {
        self.encrypted_session_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_session_key(&mut self, v: ::bytes::Bytes) {
        self.encrypted_session_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_session_key(&mut self) -> &mut ::bytes::Bytes {
        if self.encrypted_session_key.is_none() {
            self.encrypted_session_key = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.encrypted_session_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_session_key(&mut self) -> ::bytes::Bytes {
        self.encrypted_session_key.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional .EStreamTransport transport = 6;

    pub fn transport(&self) -> EStreamTransport {
        match self.transport {
            Some(e) => e.enum_value_or(EStreamTransport::k_EStreamTransportUDP),
            None => EStreamTransport::k_EStreamTransportUDP,
        }
    }

    pub fn clear_transport(&mut self) {
        self.transport = ::std::option::Option::None;
    }

    pub fn has_transport(&self) -> bool {
        self.transport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport(&mut self, v: EStreamTransport) {
        self.transport = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string relay_server = 7;

    pub fn relay_server(&self) -> &str {
        match self.relay_server.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_relay_server(&mut self) {
        self.relay_server = ::std::option::Option::None;
    }

    pub fn has_relay_server(&self) -> bool {
        self.relay_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_server(&mut self, v: ::std::string::String) {
        self.relay_server = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_relay_server(&mut self) -> &mut ::std::string::String {
        if self.relay_server.is_none() {
            self.relay_server = ::std::option::Option::Some(::std::string::String::new());
        }
        self.relay_server.as_mut().unwrap()
    }

    // Take field
    pub fn take_relay_server(&mut self) -> ::std::string::String {
        self.relay_server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cert = 8;

    pub fn cert(&self) -> &str {
        match self.cert.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cert(&mut self) {
        self.cert = ::std::option::Option::None;
    }

    pub fn has_cert(&self) -> bool {
        self.cert.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cert(&mut self, v: ::std::string::String) {
        self.cert = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cert(&mut self) -> &mut ::std::string::String {
        if self.cert.is_none() {
            self.cert = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cert.as_mut().unwrap()
    }

    // Take field
    pub fn take_cert(&mut self) -> ::std::string::String {
        self.cert.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.request_id },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.request_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "result",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.result },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.result },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.port },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.port },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypted_session_key",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.encrypted_session_key },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.encrypted_session_key },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "transport",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.transport },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.transport },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "relay_server",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.relay_server },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.relay_server },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cert",
            |m: &CMsgRemoteDeviceStreamingResponse| { &m.cert },
            |m: &mut CMsgRemoteDeviceStreamingResponse| { &mut m.cert },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamingResponse>(
            "CMsgRemoteDeviceStreamingResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceStreamingResponse {
    const NAME: &'static str = "CMsgRemoteDeviceStreamingResponse";

    fn is_initialized(&self) -> bool {
        if self.request_id.is_none() {
            return false;
        }
        if self.result.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.encrypted_session_key = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                48 => {
                    self.transport = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    self.relay_server = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.cert = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.port {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.encrypted_session_key.as_ref() {
            my_size += crate::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.transport {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.relay_server.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.cert.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.encrypted_session_key.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.transport {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.relay_server.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.cert.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamingResponse {
        CMsgRemoteDeviceStreamingResponse::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.encrypted_session_key = ::std::option::Option::None;
        self.transport = ::std::option::Option::None;
        self.relay_server = ::std::option::Option::None;
        self.cert = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamingResponse {
        static instance: CMsgRemoteDeviceStreamingResponse = CMsgRemoteDeviceStreamingResponse {
            request_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            port: ::std::option::Option::None,
            encrypted_session_key: ::std::option::Option::None,
            transport: ::std::option::Option::None,
            relay_server: ::std::option::Option::None,
            cert: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceStreamingResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceStreamingResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceProofRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceProofRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofRequest.challenge)
    pub challenge: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofRequest.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofRequest.update_secret)
    pub update_secret: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceProofRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofRequest {
    fn default() -> &'a CMsgRemoteDeviceProofRequest {
        <CMsgRemoteDeviceProofRequest as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofRequest {
    pub fn new() -> CMsgRemoteDeviceProofRequest {
        ::std::default::Default::default()
    }

    // required bytes challenge = 1;

    pub fn challenge(&self) -> &[u8] {
        match self.challenge.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_challenge(&mut self) {
        self.challenge = ::std::option::Option::None;
    }

    pub fn has_challenge(&self) -> bool {
        self.challenge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge(&mut self, v: ::bytes::Bytes) {
        self.challenge = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge(&mut self) -> &mut ::bytes::Bytes {
        if self.challenge.is_none() {
            self.challenge = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.challenge.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge(&mut self) -> ::bytes::Bytes {
        self.challenge.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional bool update_secret = 3;

    pub fn update_secret(&self) -> bool {
        self.update_secret.unwrap_or(false)
    }

    pub fn clear_update_secret(&mut self) {
        self.update_secret = ::std::option::Option::None;
    }

    pub fn has_update_secret(&self) -> bool {
        self.update_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_secret(&mut self, v: bool) {
        self.update_secret = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "challenge",
            |m: &CMsgRemoteDeviceProofRequest| { &m.challenge },
            |m: &mut CMsgRemoteDeviceProofRequest| { &mut m.challenge },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceProofRequest| { &m.request_id },
            |m: &mut CMsgRemoteDeviceProofRequest| { &mut m.request_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_secret",
            |m: &CMsgRemoteDeviceProofRequest| { &m.update_secret },
            |m: &mut CMsgRemoteDeviceProofRequest| { &mut m.update_secret },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceProofRequest>(
            "CMsgRemoteDeviceProofRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceProofRequest {
    const NAME: &'static str = "CMsgRemoteDeviceProofRequest";

    fn is_initialized(&self) -> bool {
        if self.challenge.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenge = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.update_secret = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.update_secret {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.challenge.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.update_secret {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceProofRequest {
        CMsgRemoteDeviceProofRequest::new()
    }

    fn clear(&mut self) {
        self.challenge = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.update_secret = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofRequest {
        static instance: CMsgRemoteDeviceProofRequest = CMsgRemoteDeviceProofRequest {
            challenge: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            update_secret: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceProofRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceProofRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceProofRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceProofRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceProofResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceProofResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofResponse.response)
    pub response: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceProofResponse.updated_secret)
    pub updated_secret: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceProofResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceProofResponse {
    fn default() -> &'a CMsgRemoteDeviceProofResponse {
        <CMsgRemoteDeviceProofResponse as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceProofResponse {
    pub fn new() -> CMsgRemoteDeviceProofResponse {
        ::std::default::Default::default()
    }

    // required bytes response = 1;

    pub fn response(&self) -> &[u8] {
        match self.response.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ::bytes::Bytes) {
        self.response = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut ::bytes::Bytes {
        if self.response.is_none() {
            self.response = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> ::bytes::Bytes {
        self.response.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional bool updated_secret = 3;

    pub fn updated_secret(&self) -> bool {
        self.updated_secret.unwrap_or(false)
    }

    pub fn clear_updated_secret(&mut self) {
        self.updated_secret = ::std::option::Option::None;
    }

    pub fn has_updated_secret(&self) -> bool {
        self.updated_secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_secret(&mut self, v: bool) {
        self.updated_secret = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "response",
            |m: &CMsgRemoteDeviceProofResponse| { &m.response },
            |m: &mut CMsgRemoteDeviceProofResponse| { &mut m.response },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgRemoteDeviceProofResponse| { &m.request_id },
            |m: &mut CMsgRemoteDeviceProofResponse| { &mut m.request_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "updated_secret",
            |m: &CMsgRemoteDeviceProofResponse| { &m.updated_secret },
            |m: &mut CMsgRemoteDeviceProofResponse| { &mut m.updated_secret },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceProofResponse>(
            "CMsgRemoteDeviceProofResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceProofResponse {
    const NAME: &'static str = "CMsgRemoteDeviceProofResponse";

    fn is_initialized(&self) -> bool {
        if self.response.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.response = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.updated_secret = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.updated_secret {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.response.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.updated_secret {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceProofResponse {
        CMsgRemoteDeviceProofResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.updated_secret = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceProofResponse {
        static instance: CMsgRemoteDeviceProofResponse = CMsgRemoteDeviceProofResponse {
            response: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            updated_secret: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceProofResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceProofResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceProofResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceProofResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CMsgRemoteDeviceStreamTransportSignal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRemoteDeviceStreamTransportSignal {
    // message fields
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamTransportSignal.token)
    pub token: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CMsgRemoteDeviceStreamTransportSignal.payload)
    pub payload: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRemoteDeviceStreamTransportSignal.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRemoteDeviceStreamTransportSignal {
    fn default() -> &'a CMsgRemoteDeviceStreamTransportSignal {
        <CMsgRemoteDeviceStreamTransportSignal as crate::Message>::default_instance()
    }
}

impl CMsgRemoteDeviceStreamTransportSignal {
    pub fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        ::std::default::Default::default()
    }

    // optional bytes token = 1;

    pub fn token(&self) -> &[u8] {
        match self.token.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::bytes::Bytes) {
        self.token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token(&mut self) -> &mut ::bytes::Bytes {
        if self.token.is_none() {
            self.token = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::bytes::Bytes {
        self.token.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::bytes::Bytes) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::bytes::Bytes {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::bytes::Bytes {
        self.payload.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgRemoteDeviceStreamTransportSignal| { &m.token },
            |m: &mut CMsgRemoteDeviceStreamTransportSignal| { &mut m.token },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CMsgRemoteDeviceStreamTransportSignal| { &m.payload },
            |m: &mut CMsgRemoteDeviceStreamTransportSignal| { &mut m.payload },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRemoteDeviceStreamTransportSignal>(
            "CMsgRemoteDeviceStreamTransportSignal",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CMsgRemoteDeviceStreamTransportSignal {
    const NAME: &'static str = "CMsgRemoteDeviceStreamTransportSignal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.token = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.token.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRemoteDeviceStreamTransportSignal {
        CMsgRemoteDeviceStreamTransportSignal::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRemoteDeviceStreamTransportSignal {
        static instance: CMsgRemoteDeviceStreamTransportSignal = CMsgRemoteDeviceStreamTransportSignal {
            token: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CMsgRemoteDeviceStreamTransportSignal {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRemoteDeviceStreamTransportSignal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRemoteDeviceStreamTransportSignal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CMsgRemoteDeviceStreamTransportSignal {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteClientBroadcastMsg)
pub enum ERemoteClientBroadcastMsg {
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgDiscovery)
    k_ERemoteClientBroadcastMsgDiscovery = 0,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgStatus)
    k_ERemoteClientBroadcastMsgStatus = 1,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgOffline)
    k_ERemoteClientBroadcastMsgOffline = 2,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationRequest)
    k_ERemoteDeviceAuthorizationRequest = 3,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationResponse)
    k_ERemoteDeviceAuthorizationResponse = 4,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingRequest)
    k_ERemoteDeviceStreamingRequest = 5,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingResponse)
    k_ERemoteDeviceStreamingResponse = 6,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceProofRequest)
    k_ERemoteDeviceProofRequest = 7,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceProofResponse)
    k_ERemoteDeviceProofResponse = 8,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationCancelRequest)
    k_ERemoteDeviceAuthorizationCancelRequest = 9,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingCancelRequest)
    k_ERemoteDeviceStreamingCancelRequest = 10,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteClientBroadcastMsgClientIDDeconflict)
    k_ERemoteClientBroadcastMsgClientIDDeconflict = 11,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamTransportSignal)
    k_ERemoteDeviceStreamTransportSignal = 12,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceStreamingProgress)
    k_ERemoteDeviceStreamingProgress = 13,
    // @@protoc_insertion_point(enum_value:ERemoteClientBroadcastMsg.k_ERemoteDeviceAuthorizationConfirmed)
    k_ERemoteDeviceAuthorizationConfirmed = 14,
}

impl crate::Enum for ERemoteClientBroadcastMsg {
    const NAME: &'static str = "ERemoteClientBroadcastMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientBroadcastMsg> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            1 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus),
            2 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline),
            3 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest),
            4 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse),
            5 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest),
            6 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse),
            7 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest),
            8 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse),
            9 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest),
            10 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest),
            11 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict),
            12 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal),
            13 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress),
            14 => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationConfirmed),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteClientBroadcastMsg> {
        match str {
            "k_ERemoteClientBroadcastMsgDiscovery" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery),
            "k_ERemoteClientBroadcastMsgStatus" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus),
            "k_ERemoteClientBroadcastMsgOffline" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline),
            "k_ERemoteDeviceAuthorizationRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest),
            "k_ERemoteDeviceAuthorizationResponse" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse),
            "k_ERemoteDeviceStreamingRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest),
            "k_ERemoteDeviceStreamingResponse" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse),
            "k_ERemoteDeviceProofRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest),
            "k_ERemoteDeviceProofResponse" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse),
            "k_ERemoteDeviceAuthorizationCancelRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest),
            "k_ERemoteDeviceStreamingCancelRequest" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest),
            "k_ERemoteClientBroadcastMsgClientIDDeconflict" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict),
            "k_ERemoteDeviceStreamTransportSignal" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal),
            "k_ERemoteDeviceStreamingProgress" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress),
            "k_ERemoteDeviceAuthorizationConfirmed" => ::std::option::Option::Some(ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationConfirmed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteClientBroadcastMsg] = &[
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery,
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgStatus,
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgOffline,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationResponse,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingResponse,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceProofRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceProofResponse,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationCancelRequest,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingCancelRequest,
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgClientIDDeconflict,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamTransportSignal,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceStreamingProgress,
        ERemoteClientBroadcastMsg::k_ERemoteDeviceAuthorizationConfirmed,
    ];
}

impl crate::EnumFull for ERemoteClientBroadcastMsg {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ERemoteClientBroadcastMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ERemoteClientBroadcastMsg {
    fn default() -> Self {
        ERemoteClientBroadcastMsg::k_ERemoteClientBroadcastMsgDiscovery
    }
}

impl ERemoteClientBroadcastMsg {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ERemoteClientBroadcastMsg>("ERemoteClientBroadcastMsg")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteClientService)
pub enum ERemoteClientService {
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceNone)
    k_ERemoteClientServiceNone = 0,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceRemoteControl)
    k_ERemoteClientServiceRemoteControl = 1,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceGameStreaming)
    k_ERemoteClientServiceGameStreaming = 2,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceSiteLicense)
    k_ERemoteClientServiceSiteLicense = 4,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceContentCache)
    k_ERemoteClientServiceContentCache = 8,
    // @@protoc_insertion_point(enum_value:ERemoteClientService.k_ERemoteClientServiceContentServer)
    k_ERemoteClientServiceContentServer = 16,
}

impl crate::Enum for ERemoteClientService {
    const NAME: &'static str = "ERemoteClientService";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteClientService> {
        match value {
            0 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceNone),
            1 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceRemoteControl),
            2 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceGameStreaming),
            4 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceSiteLicense),
            8 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentCache),
            16 => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentServer),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteClientService> {
        match str {
            "k_ERemoteClientServiceNone" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceNone),
            "k_ERemoteClientServiceRemoteControl" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceRemoteControl),
            "k_ERemoteClientServiceGameStreaming" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceGameStreaming),
            "k_ERemoteClientServiceSiteLicense" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceSiteLicense),
            "k_ERemoteClientServiceContentCache" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentCache),
            "k_ERemoteClientServiceContentServer" => ::std::option::Option::Some(ERemoteClientService::k_ERemoteClientServiceContentServer),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteClientService] = &[
        ERemoteClientService::k_ERemoteClientServiceNone,
        ERemoteClientService::k_ERemoteClientServiceRemoteControl,
        ERemoteClientService::k_ERemoteClientServiceGameStreaming,
        ERemoteClientService::k_ERemoteClientServiceSiteLicense,
        ERemoteClientService::k_ERemoteClientServiceContentCache,
        ERemoteClientService::k_ERemoteClientServiceContentServer,
    ];
}

impl crate::EnumFull for ERemoteClientService {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ERemoteClientService").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            ERemoteClientService::k_ERemoteClientServiceNone => 0,
            ERemoteClientService::k_ERemoteClientServiceRemoteControl => 1,
            ERemoteClientService::k_ERemoteClientServiceGameStreaming => 2,
            ERemoteClientService::k_ERemoteClientServiceSiteLicense => 3,
            ERemoteClientService::k_ERemoteClientServiceContentCache => 4,
            ERemoteClientService::k_ERemoteClientServiceContentServer => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ERemoteClientService {
    fn default() -> Self {
        ERemoteClientService::k_ERemoteClientServiceNone
    }
}

impl ERemoteClientService {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ERemoteClientService>("ERemoteClientService")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EVRLinkCaps)
pub enum EVRLinkCaps {
    // @@protoc_insertion_point(enum_value:EVRLinkCaps.k_EVRLinkCapsUnknown)
    k_EVRLinkCapsUnknown = 0,
    // @@protoc_insertion_point(enum_value:EVRLinkCaps.k_EVRLinkCapsAvailable)
    k_EVRLinkCapsAvailable = 1,
    // @@protoc_insertion_point(enum_value:EVRLinkCaps.k_EVRLinkCapsUnimplemented)
    k_EVRLinkCapsUnimplemented = 2,
    // @@protoc_insertion_point(enum_value:EVRLinkCaps.k_EVRLinkCapsMissingHardwareEncoding)
    k_EVRLinkCapsMissingHardwareEncoding = 3,
}

impl crate::Enum for EVRLinkCaps {
    const NAME: &'static str = "EVRLinkCaps";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EVRLinkCaps> {
        match value {
            0 => ::std::option::Option::Some(EVRLinkCaps::k_EVRLinkCapsUnknown),
            1 => ::std::option::Option::Some(EVRLinkCaps::k_EVRLinkCapsAvailable),
            2 => ::std::option::Option::Some(EVRLinkCaps::k_EVRLinkCapsUnimplemented),
            3 => ::std::option::Option::Some(EVRLinkCaps::k_EVRLinkCapsMissingHardwareEncoding),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EVRLinkCaps> {
        match str {
            "k_EVRLinkCapsUnknown" => ::std::option::Option::Some(EVRLinkCaps::k_EVRLinkCapsUnknown),
            "k_EVRLinkCapsAvailable" => ::std::option::Option::Some(EVRLinkCaps::k_EVRLinkCapsAvailable),
            "k_EVRLinkCapsUnimplemented" => ::std::option::Option::Some(EVRLinkCaps::k_EVRLinkCapsUnimplemented),
            "k_EVRLinkCapsMissingHardwareEncoding" => ::std::option::Option::Some(EVRLinkCaps::k_EVRLinkCapsMissingHardwareEncoding),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EVRLinkCaps] = &[
        EVRLinkCaps::k_EVRLinkCapsUnknown,
        EVRLinkCaps::k_EVRLinkCapsAvailable,
        EVRLinkCaps::k_EVRLinkCapsUnimplemented,
        EVRLinkCaps::k_EVRLinkCapsMissingHardwareEncoding,
    ];
}

impl crate::EnumFull for EVRLinkCaps {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EVRLinkCaps").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EVRLinkCaps {
    fn default() -> Self {
        EVRLinkCaps::k_EVRLinkCapsUnknown
    }
}

impl EVRLinkCaps {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EVRLinkCaps>("EVRLinkCaps")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteDeviceAuthorizationResult)
pub enum ERemoteDeviceAuthorizationResult {
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationSuccess)
    k_ERemoteDeviceAuthorizationSuccess = 0,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationDenied)
    k_ERemoteDeviceAuthorizationDenied = 1,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationNotLoggedIn)
    k_ERemoteDeviceAuthorizationNotLoggedIn = 2,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationOffline)
    k_ERemoteDeviceAuthorizationOffline = 3,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationBusy)
    k_ERemoteDeviceAuthorizationBusy = 4,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationInProgress)
    k_ERemoteDeviceAuthorizationInProgress = 5,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationTimedOut)
    k_ERemoteDeviceAuthorizationTimedOut = 6,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationFailed)
    k_ERemoteDeviceAuthorizationFailed = 7,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceAuthorizationResult.k_ERemoteDeviceAuthorizationCanceled)
    k_ERemoteDeviceAuthorizationCanceled = 8,
}

impl crate::Enum for ERemoteDeviceAuthorizationResult {
    const NAME: &'static str = "ERemoteDeviceAuthorizationResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceAuthorizationResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied),
            2 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn),
            3 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline),
            4 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut),
            7 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed),
            8 => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteDeviceAuthorizationResult> {
        match str {
            "k_ERemoteDeviceAuthorizationSuccess" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess),
            "k_ERemoteDeviceAuthorizationDenied" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied),
            "k_ERemoteDeviceAuthorizationNotLoggedIn" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn),
            "k_ERemoteDeviceAuthorizationOffline" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline),
            "k_ERemoteDeviceAuthorizationBusy" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy),
            "k_ERemoteDeviceAuthorizationInProgress" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress),
            "k_ERemoteDeviceAuthorizationTimedOut" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut),
            "k_ERemoteDeviceAuthorizationFailed" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed),
            "k_ERemoteDeviceAuthorizationCanceled" => ::std::option::Option::Some(ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteDeviceAuthorizationResult] = &[
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationDenied,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationNotLoggedIn,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationOffline,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationBusy,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationInProgress,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationTimedOut,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationFailed,
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationCanceled,
    ];
}

impl crate::EnumFull for ERemoteDeviceAuthorizationResult {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ERemoteDeviceAuthorizationResult").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ERemoteDeviceAuthorizationResult {
    fn default() -> Self {
        ERemoteDeviceAuthorizationResult::k_ERemoteDeviceAuthorizationSuccess
    }
}

impl ERemoteDeviceAuthorizationResult {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ERemoteDeviceAuthorizationResult>("ERemoteDeviceAuthorizationResult")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamDeviceFormFactor)
pub enum EStreamDeviceFormFactor {
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorUnknown)
    k_EStreamDeviceFormFactorUnknown = 0,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorPhone)
    k_EStreamDeviceFormFactorPhone = 1,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorTablet)
    k_EStreamDeviceFormFactorTablet = 2,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorComputer)
    k_EStreamDeviceFormFactorComputer = 3,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorTV)
    k_EStreamDeviceFormFactorTV = 4,
    // @@protoc_insertion_point(enum_value:EStreamDeviceFormFactor.k_EStreamDeviceFormFactorVRHeadset)
    k_EStreamDeviceFormFactorVRHeadset = 5,
}

impl crate::Enum for EStreamDeviceFormFactor {
    const NAME: &'static str = "EStreamDeviceFormFactor";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamDeviceFormFactor> {
        match value {
            0 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            1 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone),
            2 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet),
            3 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer),
            4 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV),
            5 => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorVRHeadset),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamDeviceFormFactor> {
        match str {
            "k_EStreamDeviceFormFactorUnknown" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown),
            "k_EStreamDeviceFormFactorPhone" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone),
            "k_EStreamDeviceFormFactorTablet" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet),
            "k_EStreamDeviceFormFactorComputer" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer),
            "k_EStreamDeviceFormFactorTV" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV),
            "k_EStreamDeviceFormFactorVRHeadset" => ::std::option::Option::Some(EStreamDeviceFormFactor::k_EStreamDeviceFormFactorVRHeadset),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamDeviceFormFactor] = &[
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorPhone,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTablet,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorComputer,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorTV,
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorVRHeadset,
    ];
}

impl crate::EnumFull for EStreamDeviceFormFactor {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamDeviceFormFactor").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamDeviceFormFactor {
    fn default() -> Self {
        EStreamDeviceFormFactor::k_EStreamDeviceFormFactorUnknown
    }
}

impl EStreamDeviceFormFactor {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamDeviceFormFactor>("EStreamDeviceFormFactor")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamTransport)
pub enum EStreamTransport {
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportNone)
    k_EStreamTransportNone = 0,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDP)
    k_EStreamTransportUDP = 1,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDPRelay)
    k_EStreamTransportUDPRelay = 2,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportWebRTC_OBSOLETE)
    k_EStreamTransportWebRTC_OBSOLETE = 3,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportSDR)
    k_EStreamTransportSDR = 4,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDP_SNS)
    k_EStreamTransportUDP_SNS = 5,
    // @@protoc_insertion_point(enum_value:EStreamTransport.k_EStreamTransportUDPRelay_SNS)
    k_EStreamTransportUDPRelay_SNS = 6,
}

impl crate::Enum for EStreamTransport {
    const NAME: &'static str = "EStreamTransport";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamTransport> {
        match value {
            0 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportNone),
            1 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP),
            2 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay),
            3 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportWebRTC_OBSOLETE),
            4 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportSDR),
            5 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP_SNS),
            6 => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay_SNS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamTransport> {
        match str {
            "k_EStreamTransportNone" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportNone),
            "k_EStreamTransportUDP" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP),
            "k_EStreamTransportUDPRelay" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay),
            "k_EStreamTransportWebRTC_OBSOLETE" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportWebRTC_OBSOLETE),
            "k_EStreamTransportSDR" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportSDR),
            "k_EStreamTransportUDP_SNS" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDP_SNS),
            "k_EStreamTransportUDPRelay_SNS" => ::std::option::Option::Some(EStreamTransport::k_EStreamTransportUDPRelay_SNS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamTransport] = &[
        EStreamTransport::k_EStreamTransportNone,
        EStreamTransport::k_EStreamTransportUDP,
        EStreamTransport::k_EStreamTransportUDPRelay,
        EStreamTransport::k_EStreamTransportWebRTC_OBSOLETE,
        EStreamTransport::k_EStreamTransportSDR,
        EStreamTransport::k_EStreamTransportUDP_SNS,
        EStreamTransport::k_EStreamTransportUDPRelay_SNS,
    ];
}

impl crate::EnumFull for EStreamTransport {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamTransport").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamTransport {
    fn default() -> Self {
        EStreamTransport::k_EStreamTransportNone
    }
}

impl EStreamTransport {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamTransport>("EStreamTransport")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStreamInterface)
pub enum EStreamInterface {
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceDefault)
    k_EStreamInterfaceDefault = 0,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceRecentGames)
    k_EStreamInterfaceRecentGames = 1,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceBigPicture)
    k_EStreamInterfaceBigPicture = 2,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceDesktop)
    k_EStreamInterfaceDesktop = 3,
    // @@protoc_insertion_point(enum_value:EStreamInterface.k_EStreamInterfaceSteamVR)
    k_EStreamInterfaceSteamVR = 4,
}

impl crate::Enum for EStreamInterface {
    const NAME: &'static str = "EStreamInterface";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStreamInterface> {
        match value {
            0 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDefault),
            1 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceRecentGames),
            2 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceBigPicture),
            3 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDesktop),
            4 => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceSteamVR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStreamInterface> {
        match str {
            "k_EStreamInterfaceDefault" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDefault),
            "k_EStreamInterfaceRecentGames" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceRecentGames),
            "k_EStreamInterfaceBigPicture" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceBigPicture),
            "k_EStreamInterfaceDesktop" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceDesktop),
            "k_EStreamInterfaceSteamVR" => ::std::option::Option::Some(EStreamInterface::k_EStreamInterfaceSteamVR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStreamInterface] = &[
        EStreamInterface::k_EStreamInterfaceDefault,
        EStreamInterface::k_EStreamInterfaceRecentGames,
        EStreamInterface::k_EStreamInterfaceBigPicture,
        EStreamInterface::k_EStreamInterfaceDesktop,
        EStreamInterface::k_EStreamInterfaceSteamVR,
    ];
}

impl crate::EnumFull for EStreamInterface {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStreamInterface").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStreamInterface {
    fn default() -> Self {
        EStreamInterface::k_EStreamInterfaceDefault
    }
}

impl EStreamInterface {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStreamInterface>("EStreamInterface")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ERemoteDeviceStreamingResult)
pub enum ERemoteDeviceStreamingResult {
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingSuccess)
    k_ERemoteDeviceStreamingSuccess = 0,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingUnauthorized)
    k_ERemoteDeviceStreamingUnauthorized = 1,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingScreenLocked)
    k_ERemoteDeviceStreamingScreenLocked = 2,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingFailed)
    k_ERemoteDeviceStreamingFailed = 3,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingBusy)
    k_ERemoteDeviceStreamingBusy = 4,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingInProgress)
    k_ERemoteDeviceStreamingInProgress = 5,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingCanceled)
    k_ERemoteDeviceStreamingCanceled = 6,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingDriversNotInstalled)
    k_ERemoteDeviceStreamingDriversNotInstalled = 7,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingDisabled)
    k_ERemoteDeviceStreamingDisabled = 8,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingBroadcastingActive)
    k_ERemoteDeviceStreamingBroadcastingActive = 9,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingVRActive)
    k_ERemoteDeviceStreamingVRActive = 10,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingPINRequired)
    k_ERemoteDeviceStreamingPINRequired = 11,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingTransportUnavailable)
    k_ERemoteDeviceStreamingTransportUnavailable = 12,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingInvisible)
    k_ERemoteDeviceStreamingInvisible = 13,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingGameLaunchFailed)
    k_ERemoteDeviceStreamingGameLaunchFailed = 14,
    // @@protoc_insertion_point(enum_value:ERemoteDeviceStreamingResult.k_ERemoteDeviceStreamingSteamVRNotInstalled)
    k_ERemoteDeviceStreamingSteamVRNotInstalled = 15,
}

impl crate::Enum for ERemoteDeviceStreamingResult {
    const NAME: &'static str = "ERemoteDeviceStreamingResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERemoteDeviceStreamingResult> {
        match value {
            0 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            1 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized),
            2 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked),
            3 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed),
            4 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy),
            5 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress),
            6 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled),
            7 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled),
            8 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled),
            9 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive),
            10 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive),
            11 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired),
            12 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable),
            13 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible),
            14 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed),
            15 => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSteamVRNotInstalled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERemoteDeviceStreamingResult> {
        match str {
            "k_ERemoteDeviceStreamingSuccess" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess),
            "k_ERemoteDeviceStreamingUnauthorized" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized),
            "k_ERemoteDeviceStreamingScreenLocked" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked),
            "k_ERemoteDeviceStreamingFailed" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed),
            "k_ERemoteDeviceStreamingBusy" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy),
            "k_ERemoteDeviceStreamingInProgress" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress),
            "k_ERemoteDeviceStreamingCanceled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled),
            "k_ERemoteDeviceStreamingDriversNotInstalled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled),
            "k_ERemoteDeviceStreamingDisabled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled),
            "k_ERemoteDeviceStreamingBroadcastingActive" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive),
            "k_ERemoteDeviceStreamingVRActive" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive),
            "k_ERemoteDeviceStreamingPINRequired" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired),
            "k_ERemoteDeviceStreamingTransportUnavailable" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable),
            "k_ERemoteDeviceStreamingInvisible" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible),
            "k_ERemoteDeviceStreamingGameLaunchFailed" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed),
            "k_ERemoteDeviceStreamingSteamVRNotInstalled" => ::std::option::Option::Some(ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSteamVRNotInstalled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERemoteDeviceStreamingResult] = &[
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingUnauthorized,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingScreenLocked,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingFailed,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBusy,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInProgress,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingCanceled,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDriversNotInstalled,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingDisabled,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingBroadcastingActive,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingVRActive,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingPINRequired,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingTransportUnavailable,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingInvisible,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingGameLaunchFailed,
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSteamVRNotInstalled,
    ];
}

impl crate::EnumFull for ERemoteDeviceStreamingResult {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ERemoteDeviceStreamingResult").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ERemoteDeviceStreamingResult {
    fn default() -> Self {
        ERemoteDeviceStreamingResult::k_ERemoteDeviceStreamingSuccess
    }
}

impl ERemoteDeviceStreamingResult {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ERemoteDeviceStreamingResult>("ERemoteDeviceStreamingResult")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n*steammessages_remoteclient_discovery.proto\"\x8d\x02\n\x1fCMsgRemoteC\
    lientBroadcastHeader\x12\x1b\n\tclient_id\x18\x01\x20\x01(\x04R\x08clien\
    tId\x12[\n\x08msg_type\x18\x02\x20\x01(\x0e2\x1a.ERemoteClientBroadcastM\
    sg:$k_ERemoteClientBroadcastMsgDiscoveryR\x07msgType\x12\x1f\n\x0binstan\
    ce_id\x18\x03\x20\x01(\x04R\ninstanceId\x12,\n\x12device_id_OBSOLETE\x18\
    \x04\x20\x01(\x04R\x10deviceIdOBSOLETE\x12!\n\x0cdevice_token\x18\x05\
    \x20\x01(\x0cR\x0bdeviceToken\"\x8d\x08\n\x1fCMsgRemoteClientBroadcastSt\
    atus\x12\x18\n\x07version\x18\x01\x20\x01(\x05R\x07version\x12\x1f\n\x0b\
    min_version\x18\x02\x20\x01(\x05R\nminVersion\x12!\n\x0cconnect_port\x18\
    \x03\x20\x01(\rR\x0bconnectPort\x12\x1a\n\x08hostname\x18\x04\x20\x01(\t\
    R\x08hostname\x12)\n\x10enabled_services\x18\x06\x20\x01(\rR\x0fenabledS\
    ervices\x12\x19\n\x06ostype\x18\x07\x20\x01(\x05:\x010R\x06ostype\x12\
    \x18\n\x07is64bit\x18\x08\x20\x01(\x08R\x07is64bit\x12;\n\x05users\x18\t\
    \x20\x03(\x0b2%.CMsgRemoteClientBroadcastStatus.UserR\x05users\x12\x1c\n\
    \teuniverse\x18\x0b\x20\x01(\x05R\teuniverse\x12\x1c\n\ttimestamp\x18\
    \x0c\x20\x01(\rR\ttimestamp\x12#\n\rscreen_locked\x18\r\x20\x01(\x08R\
    \x0cscreenLocked\x12#\n\rgames_running\x18\x0e\x20\x01(\x08R\x0cgamesRun\
    ning\x12#\n\rmac_addresses\x18\x0f\x20\x03(\tR\x0cmacAddresses\x125\n\
    \x17download_lan_peer_group\x18\x10\x20\x01(\rR\x14downloadLanPeerGroup\
    \x12/\n\x13broadcasting_active\x18\x11\x20\x01(\x08R\x12broadcastingActi\
    ve\x12\x1b\n\tvr_active\x18\x12\x20\x01(\x08R\x08vrActive\x12,\n\x12cont\
    ent_cache_port\x18\x13\x20\x01(\rR\x10contentCachePort\x12!\n\x0cip_addr\
    esses\x18\x14\x20\x03(\tR\x0bipAddresses\x12*\n\x11public_ip_address\x18\
    \x15\x20\x01(\tR\x0fpublicIpAddress\x12+\n\x11remoteplay_active\x18\x16\
    \x20\x01(\x08R\x10remoteplayActive\x12-\n\x12supported_services\x18\x17\
    \x20\x01(\rR\x11supportedServices\x12\x1d\n\nsteam_deck\x18\x18\x20\x01(\
    \x08R\tsteamDeck\x12#\n\rsteam_version\x18\x19\x20\x01(\x04R\x0csteamVer\
    sion\x12D\n\x0cvr_link_caps\x18\x1a\x20\x01(\x0e2\x0c.EVRLinkCaps:\x14k_\
    EVRLinkCapsUnknownR\nvrLinkCaps\x1a@\n\x04User\x12\x18\n\x07steamid\x18\
    \x01\x20\x01(\x06R\x07steamid\x12\x1e\n\x0bauth_key_id\x18\x02\x20\x01(\
    \rR\tauthKeyId\"\\\n\"CMsgRemoteClientBroadcastDiscovery\x12\x17\n\x07se\
    q_num\x18\x01\x20\x01(\rR\x06seqNum\x12\x1d\n\nclient_ids\x18\x02\x20\
    \x03(\x04R\tclientIds\"L\n+CMsgRemoteClientBroadcastClientIDDeconflict\
    \x12\x1d\n\nclient_ids\x18\x02\x20\x03(\x04R\tclientIds\"\x83\x05\n$CMsg\
    RemoteDeviceAuthorizationRequest\x12!\n\x0cdevice_token\x18\x01\x20\x02(\
    \x0cR\x0bdeviceToken\x12\x1f\n\x0bdevice_name\x18\x02\x20\x01(\tR\ndevic\
    eName\x12+\n\x11encrypted_request\x18\x03\x20\x02(\x0cR\x10encryptedRequ\
    est\x12\x19\n\x08auth_key\x18\x04\x20\x01(\x0cR\x07authKey\x1a\x95\x03\n\
    \x11CKeyEscrow_Ticket\x12\x1a\n\x08password\x18\x01\x20\x01(\x0cR\x08pas\
    sword\x12\x1e\n\nidentifier\x18\x02\x20\x01(\x04R\nidentifier\x12\x18\n\
    \x07payload\x18\x03\x20\x01(\x0cR\x07payload\x12\x1c\n\ttimestamp\x18\
    \x04\x20\x01(\rR\ttimestamp\x12m\n\x05usage\x18\x05\x20\x01(\x0e25.CMsgR\
    emoteDeviceAuthorizationRequest.EKeyEscrowUsage:\x20k_EKeyEscrowUsageStr\
    eamingDeviceR\x05usage\x12\x1f\n\x0bdevice_name\x18\x06\x20\x01(\tR\ndev\
    iceName\x12!\n\x0cdevice_model\x18\x07\x20\x01(\tR\x0bdeviceModel\x12#\n\
    \rdevice_serial\x18\x08\x20\x01(\tR\x0cdeviceSerial\x124\n\x16device_pro\
    visioning_id\x18\t\x20\x01(\rR\x14deviceProvisioningId\"7\n\x0fEKeyEscro\
    wUsage\x12$\n\x20k_EKeyEscrowUsageStreamingDevice\x10\0\",\n*CMsgRemoteD\
    eviceAuthorizationCancelRequest\"\xdf\x01\n%CMsgRemoteDeviceAuthorizatio\
    nResponse\x12^\n\x06result\x18\x01\x20\x02(\x0e2!.ERemoteDeviceAuthoriza\
    tionResult:#k_ERemoteDeviceAuthorizationSuccessR\x06result\x12\x18\n\x07\
    steamid\x18\x02\x20\x01(\x06R\x07steamid\x12\x19\n\x08auth_key\x18\x03\
    \x20\x01(\x0cR\x07authKey\x12!\n\x0cdevice_token\x18\x04\x20\x01(\x0cR\
    \x0bdeviceToken\"\x88\x01\n&CMsgRemoteDeviceAuthorizationConfirmed\x12^\
    \n\x06result\x18\x01\x20\x02(\x0e2!.ERemoteDeviceAuthorizationResult:#k_\
    ERemoteDeviceAuthorizationSuccessR\x06result\"\xe0\x08\n\x20CMsgRemoteDe\
    viceStreamingRequest\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequestI\
    d\x120\n\x14maximum_resolution_x\x18\x02\x20\x01(\x05R\x12maximumResolut\
    ionX\x120\n\x14maximum_resolution_y\x18\x03\x20\x01(\x05R\x12maximumReso\
    lutionY\x121\n\x13audio_channel_count\x18\x04\x20\x01(\x05:\x012R\x11aud\
    ioChannelCount\x12%\n\x0edevice_version\x18\x05\x20\x01(\tR\rdeviceVersi\
    on\x12%\n\x0estream_desktop\x18\x06\x20\x01(\x08R\rstreamDesktop\x12!\n\
    \x0cdevice_token\x18\x07\x20\x01(\x0cR\x0bdeviceToken\x12\x10\n\x03pin\
    \x18\x08\x20\x01(\x0cR\x03pin\x12:\n\x16enable_video_streaming\x18\t\x20\
    \x01(\x08:\x04trueR\x14enableVideoStreaming\x12:\n\x16enable_audio_strea\
    ming\x18\n\x20\x01(\x08:\x04trueR\x14enableAudioStreaming\x12:\n\x16enab\
    le_input_streaming\x18\x0b\x20\x01(\x08:\x04trueR\x14enableInputStreamin\
    g\x12!\n\x0cnetwork_test\x18\x0c\x20\x01(\x08R\x0bnetworkTest\x12\x1b\n\
    \tclient_id\x18\r\x20\x01(\x04R\x08clientId\x12B\n\x13supported_transpor\
    t\x18\x0e\x20\x03(\x0e2\x11.EStreamTransportR\x12supportedTransport\x12\
    \x1e\n\nrestricted\x18\x0f\x20\x01(\x08R\nrestricted\x12[\n\x0bform_fact\
    or\x18\x10\x20\x01(\x0e2\x18.EStreamDeviceFormFactor:\x20k_EStreamDevice\
    FormFactorUnknownR\nformFactor\x12#\n\rgamepad_count\x18\x11\x20\x01(\
    \x05R\x0cgamepadCount\x12M\n\x08gamepads\x18\x12\x20\x03(\x0b21.CMsgRemo\
    teDeviceStreamingRequest.ReservedGamepadR\x08gamepads\x12\x16\n\x06gamei\
    d\x18\x13\x20\x01(\x04R\x06gameid\x12W\n\x10stream_interface\x18\x14\x20\
    \x01(\x0e2\x11.EStreamInterface:\x19k_EStreamInterfaceDefaultR\x0fstream\
    Interface\x1ai\n\x0fReservedGamepad\x12'\n\x0fcontroller_type\x18\x01\
    \x20\x01(\rR\x0econtrollerType\x12-\n\x12controller_subtype\x18\x02\x20\
    \x01(\rR\x11controllerSubtype\"G\n&CMsgRemoteDeviceStreamingCancelReques\
    t\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequestId\"^\n!CMsgRemoteDe\
    viceStreamingProgress\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\rR\trequest\
    Id\x12\x1a\n\x08progress\x18\x02\x20\x01(\x02R\x08progress\"\xe1\x02\n!C\
    MsgRemoteDeviceStreamingResponse\x12\x1d\n\nrequest_id\x18\x01\x20\x02(\
    \rR\trequestId\x12V\n\x06result\x18\x02\x20\x02(\x0e2\x1d.ERemoteDeviceS\
    treamingResult:\x1fk_ERemoteDeviceStreamingSuccessR\x06result\x12\x12\n\
    \x04port\x18\x03\x20\x01(\rR\x04port\x122\n\x15encrypted_session_key\x18\
    \x04\x20\x01(\x0cR\x13encryptedSessionKey\x12F\n\ttransport\x18\x06\x20\
    \x01(\x0e2\x11.EStreamTransport:\x15k_EStreamTransportUDPR\ttransport\
    \x12!\n\x0crelay_server\x18\x07\x20\x01(\tR\x0brelayServer\x12\x12\n\x04\
    cert\x18\x08\x20\x01(\tR\x04cert\"\x80\x01\n\x1cCMsgRemoteDeviceProofReq\
    uest\x12\x1c\n\tchallenge\x18\x01\x20\x02(\x0cR\tchallenge\x12\x1d\n\nre\
    quest_id\x18\x02\x20\x01(\rR\trequestId\x12#\n\rupdate_secret\x18\x03\
    \x20\x01(\x08R\x0cupdateSecret\"\x81\x01\n\x1dCMsgRemoteDeviceProofRespo\
    nse\x12\x1a\n\x08response\x18\x01\x20\x02(\x0cR\x08response\x12\x1d\n\nr\
    equest_id\x18\x02\x20\x01(\rR\trequestId\x12%\n\x0eupdated_secret\x18\
    \x03\x20\x01(\x08R\rupdatedSecret\"W\n%CMsgRemoteDeviceStreamTransportSi\
    gnal\x12\x14\n\x05token\x18\x01\x20\x01(\x0cR\x05token\x12\x18\n\x07payl\
    oad\x18\x02\x20\x01(\x0cR\x07payload*\xfd\x04\n\x19ERemoteClientBroadcas\
    tMsg\x12(\n$k_ERemoteClientBroadcastMsgDiscovery\x10\0\x12%\n!k_ERemoteC\
    lientBroadcastMsgStatus\x10\x01\x12&\n\"k_ERemoteClientBroadcastMsgOffli\
    ne\x10\x02\x12'\n#k_ERemoteDeviceAuthorizationRequest\x10\x03\x12(\n$k_E\
    RemoteDeviceAuthorizationResponse\x10\x04\x12#\n\x1fk_ERemoteDeviceStrea\
    mingRequest\x10\x05\x12$\n\x20k_ERemoteDeviceStreamingResponse\x10\x06\
    \x12\x1f\n\x1bk_ERemoteDeviceProofRequest\x10\x07\x12\x20\n\x1ck_ERemote\
    DeviceProofResponse\x10\x08\x12-\n)k_ERemoteDeviceAuthorizationCancelReq\
    uest\x10\t\x12)\n%k_ERemoteDeviceStreamingCancelRequest\x10\n\x121\n-k_E\
    RemoteClientBroadcastMsgClientIDDeconflict\x10\x0b\x12(\n$k_ERemoteDevic\
    eStreamTransportSignal\x10\x0c\x12$\n\x20k_ERemoteDeviceStreamingProgres\
    s\x10\r\x12)\n%k_ERemoteDeviceAuthorizationConfirmed\x10\x0e*\x80\x02\n\
    \x14ERemoteClientService\x12\x1e\n\x1ak_ERemoteClientServiceNone\x10\0\
    \x12'\n#k_ERemoteClientServiceRemoteControl\x10\x01\x12'\n#k_ERemoteClie\
    ntServiceGameStreaming\x10\x02\x12%\n!k_ERemoteClientServiceSiteLicense\
    \x10\x04\x12&\n\"k_ERemoteClientServiceContentCache\x10\x08\x12'\n#k_ERe\
    moteClientServiceContentServer\x10\x10*\x8d\x01\n\x0bEVRLinkCaps\x12\x18\
    \n\x14k_EVRLinkCapsUnknown\x10\0\x12\x1a\n\x16k_EVRLinkCapsAvailable\x10\
    \x01\x12\x1e\n\x1ak_EVRLinkCapsUnimplemented\x10\x02\x12(\n$k_EVRLinkCap\
    sMissingHardwareEncoding\x10\x03*\x97\x03\n\x20ERemoteDeviceAuthorizatio\
    nResult\x12'\n#k_ERemoteDeviceAuthorizationSuccess\x10\0\x12&\n\"k_ERemo\
    teDeviceAuthorizationDenied\x10\x01\x12+\n'k_ERemoteDeviceAuthorizationN\
    otLoggedIn\x10\x02\x12'\n#k_ERemoteDeviceAuthorizationOffline\x10\x03\
    \x12$\n\x20k_ERemoteDeviceAuthorizationBusy\x10\x04\x12*\n&k_ERemoteDevi\
    ceAuthorizationInProgress\x10\x05\x12(\n$k_ERemoteDeviceAuthorizationTim\
    edOut\x10\x06\x12&\n\"k_ERemoteDeviceAuthorizationFailed\x10\x07\x12(\n$\
    k_ERemoteDeviceAuthorizationCanceled\x10\x08*\xf8\x01\n\x17EStreamDevice\
    FormFactor\x12$\n\x20k_EStreamDeviceFormFactorUnknown\x10\0\x12\"\n\x1ek\
    _EStreamDeviceFormFactorPhone\x10\x01\x12#\n\x1fk_EStreamDeviceFormFacto\
    rTablet\x10\x02\x12%\n!k_EStreamDeviceFormFactorComputer\x10\x03\x12\x1f\
    \n\x1bk_EStreamDeviceFormFactorTV\x10\x04\x12&\n\"k_EStreamDeviceFormFac\
    torVRHeadset\x10\x05*\xee\x01\n\x10EStreamTransport\x12\x1a\n\x16k_EStre\
    amTransportNone\x10\0\x12\x19\n\x15k_EStreamTransportUDP\x10\x01\x12\x1e\
    \n\x1ak_EStreamTransportUDPRelay\x10\x02\x12%\n!k_EStreamTransportWebRTC\
    _OBSOLETE\x10\x03\x12\x19\n\x15k_EStreamTransportSDR\x10\x04\x12\x1d\n\
    \x19k_EStreamTransportUDP_SNS\x10\x05\x12\"\n\x1ek_EStreamTransportUDPRe\
    lay_SNS\x10\x06*\xb4\x01\n\x10EStreamInterface\x12\x1d\n\x19k_EStreamInt\
    erfaceDefault\x10\0\x12!\n\x1dk_EStreamInterfaceRecentGames\x10\x01\x12\
    \x20\n\x1ck_EStreamInterfaceBigPicture\x10\x02\x12\x1d\n\x19k_EStreamInt\
    erfaceDesktop\x10\x03\x12\x1d\n\x19k_EStreamInterfaceSteamVR\x10\x04*\
    \xb9\x05\n\x1cERemoteDeviceStreamingResult\x12#\n\x1fk_ERemoteDeviceStre\
    amingSuccess\x10\0\x12(\n$k_ERemoteDeviceStreamingUnauthorized\x10\x01\
    \x12(\n$k_ERemoteDeviceStreamingScreenLocked\x10\x02\x12\"\n\x1ek_ERemot\
    eDeviceStreamingFailed\x10\x03\x12\x20\n\x1ck_ERemoteDeviceStreamingBusy\
    \x10\x04\x12&\n\"k_ERemoteDeviceStreamingInProgress\x10\x05\x12$\n\x20k_\
    ERemoteDeviceStreamingCanceled\x10\x06\x12/\n+k_ERemoteDeviceStreamingDr\
    iversNotInstalled\x10\x07\x12$\n\x20k_ERemoteDeviceStreamingDisabled\x10\
    \x08\x12.\n*k_ERemoteDeviceStreamingBroadcastingActive\x10\t\x12$\n\x20k\
    _ERemoteDeviceStreamingVRActive\x10\n\x12'\n#k_ERemoteDeviceStreamingPIN\
    Required\x10\x0b\x120\n,k_ERemoteDeviceStreamingTransportUnavailable\x10\
    \x0c\x12%\n!k_ERemoteDeviceStreamingInvisible\x10\r\x12,\n(k_ERemoteDevi\
    ceStreamingGameLaunchFailed\x10\x0e\x12/\n+k_ERemoteDeviceStreamingSteam\
    VRNotInstalled\x10\x0fB\x02H\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(18);
            messages.push(CMsgRemoteClientBroadcastHeader::generated_message_descriptor_data());
            messages.push(CMsgRemoteClientBroadcastStatus::generated_message_descriptor_data());
            messages.push(CMsgRemoteClientBroadcastDiscovery::generated_message_descriptor_data());
            messages.push(CMsgRemoteClientBroadcastClientIDDeconflict::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceAuthorizationRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceAuthorizationCancelRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceAuthorizationResponse::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceAuthorizationConfirmed::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamingRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamingCancelRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamingProgress::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamingResponse::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceProofRequest::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceProofResponse::generated_message_descriptor_data());
            messages.push(CMsgRemoteDeviceStreamTransportSignal::generated_message_descriptor_data());
            messages.push(cmsg_remote_client_broadcast_status::User::generated_message_descriptor_data());
            messages.push(cmsg_remote_device_authorization_request::CKeyEscrow_Ticket::generated_message_descriptor_data());
            messages.push(cmsg_remote_device_streaming_request::ReservedGamepad::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(9);
            enums.push(ERemoteClientBroadcastMsg::generated_enum_descriptor_data());
            enums.push(ERemoteClientService::generated_enum_descriptor_data());
            enums.push(EVRLinkCaps::generated_enum_descriptor_data());
            enums.push(ERemoteDeviceAuthorizationResult::generated_enum_descriptor_data());
            enums.push(EStreamDeviceFormFactor::generated_enum_descriptor_data());
            enums.push(EStreamTransport::generated_enum_descriptor_data());
            enums.push(EStreamInterface::generated_enum_descriptor_data());
            enums.push(ERemoteDeviceStreamingResult::generated_enum_descriptor_data());
            enums.push(cmsg_remote_device_authorization_request::EKeyEscrowUsage::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
