// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_storebrowse.steamclient.proto`

// @@protoc_insertion_point(message:StoreItemID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreItemID {
    // message fields
    // @@protoc_insertion_point(field:StoreItemID.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.bundleid)
    pub bundleid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.tagid)
    pub tagid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.creatorid)
    pub creatorid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItemID.hubcategoryid)
    pub hubcategoryid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreItemID.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreItemID {
    fn default() -> &'a StoreItemID {
        <StoreItemID as crate::Message>::default_instance()
    }
}

impl StoreItemID {
    pub fn new() -> StoreItemID {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 packageid = 2;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional uint32 bundleid = 3;

    pub fn bundleid(&self) -> u32 {
        self.bundleid.unwrap_or(0)
    }

    pub fn clear_bundleid(&mut self) {
        self.bundleid = ::std::option::Option::None;
    }

    pub fn has_bundleid(&self) -> bool {
        self.bundleid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bundleid(&mut self, v: u32) {
        self.bundleid = ::std::option::Option::Some(v);
    }

    // optional uint32 tagid = 4;

    pub fn tagid(&self) -> u32 {
        self.tagid.unwrap_or(0)
    }

    pub fn clear_tagid(&mut self) {
        self.tagid = ::std::option::Option::None;
    }

    pub fn has_tagid(&self) -> bool {
        self.tagid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagid(&mut self, v: u32) {
        self.tagid = ::std::option::Option::Some(v);
    }

    // optional uint32 creatorid = 5;

    pub fn creatorid(&self) -> u32 {
        self.creatorid.unwrap_or(0)
    }

    pub fn clear_creatorid(&mut self) {
        self.creatorid = ::std::option::Option::None;
    }

    pub fn has_creatorid(&self) -> bool {
        self.creatorid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creatorid(&mut self, v: u32) {
        self.creatorid = ::std::option::Option::Some(v);
    }

    // optional uint32 hubcategoryid = 6;

    pub fn hubcategoryid(&self) -> u32 {
        self.hubcategoryid.unwrap_or(0)
    }

    pub fn clear_hubcategoryid(&mut self) {
        self.hubcategoryid = ::std::option::Option::None;
    }

    pub fn has_hubcategoryid(&self) -> bool {
        self.hubcategoryid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hubcategoryid(&mut self, v: u32) {
        self.hubcategoryid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &StoreItemID| { &m.appid },
            |m: &mut StoreItemID| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "packageid",
            |m: &StoreItemID| { &m.packageid },
            |m: &mut StoreItemID| { &mut m.packageid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "bundleid",
            |m: &StoreItemID| { &m.bundleid },
            |m: &mut StoreItemID| { &mut m.bundleid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "tagid",
            |m: &StoreItemID| { &m.tagid },
            |m: &mut StoreItemID| { &mut m.tagid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "creatorid",
            |m: &StoreItemID| { &m.creatorid },
            |m: &mut StoreItemID| { &mut m.creatorid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "hubcategoryid",
            |m: &StoreItemID| { &m.hubcategoryid },
            |m: &mut StoreItemID| { &mut m.hubcategoryid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<StoreItemID>(
            "StoreItemID",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for StoreItemID {
    const NAME: &'static str = "StoreItemID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bundleid = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.creatorid = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.hubcategoryid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.packageid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bundleid {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tagid {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.creatorid {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.hubcategoryid {
            my_size += crate::rt::uint32_size(6, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.packageid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bundleid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tagid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.creatorid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.hubcategoryid {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreItemID {
        StoreItemID::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.packageid = ::std::option::Option::None;
        self.bundleid = ::std::option::Option::None;
        self.tagid = ::std::option::Option::None;
        self.creatorid = ::std::option::Option::None;
        self.hubcategoryid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreItemID {
        static instance: StoreItemID = StoreItemID {
            appid: ::std::option::Option::None,
            packageid: ::std::option::Option::None,
            bundleid: ::std::option::Option::None,
            tagid: ::std::option::Option::None,
            creatorid: ::std::option::Option::None,
            hubcategoryid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for StoreItemID {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StoreItemID").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StoreItemID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for StoreItemID {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StoreBrowseContext)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreBrowseContext {
    // message fields
    // @@protoc_insertion_point(field:StoreBrowseContext.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreBrowseContext.elanguage)
    pub elanguage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:StoreBrowseContext.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreBrowseContext.steam_realm)
    pub steam_realm: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreBrowseContext.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreBrowseContext {
    fn default() -> &'a StoreBrowseContext {
        <StoreBrowseContext as crate::Message>::default_instance()
    }
}

impl StoreBrowseContext {
    pub fn new() -> StoreBrowseContext {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 elanguage = 2;

    pub fn elanguage(&self) -> i32 {
        self.elanguage.unwrap_or(0)
    }

    pub fn clear_elanguage(&mut self) {
        self.elanguage = ::std::option::Option::None;
    }

    pub fn has_elanguage(&self) -> bool {
        self.elanguage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elanguage(&mut self, v: i32) {
        self.elanguage = ::std::option::Option::Some(v);
    }

    // optional string country_code = 3;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 steam_realm = 4;

    pub fn steam_realm(&self) -> i32 {
        self.steam_realm.unwrap_or(0)
    }

    pub fn clear_steam_realm(&mut self) {
        self.steam_realm = ::std::option::Option::None;
    }

    pub fn has_steam_realm(&self) -> bool {
        self.steam_realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_realm(&mut self, v: i32) {
        self.steam_realm = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &StoreBrowseContext| { &m.language },
            |m: &mut StoreBrowseContext| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "elanguage",
            |m: &StoreBrowseContext| { &m.elanguage },
            |m: &mut StoreBrowseContext| { &mut m.elanguage },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "country_code",
            |m: &StoreBrowseContext| { &m.country_code },
            |m: &mut StoreBrowseContext| { &mut m.country_code },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steam_realm",
            |m: &StoreBrowseContext| { &m.steam_realm },
            |m: &mut StoreBrowseContext| { &mut m.steam_realm },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<StoreBrowseContext>(
            "StoreBrowseContext",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for StoreBrowseContext {
    const NAME: &'static str = "StoreBrowseContext";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.steam_realm = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.elanguage {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.steam_realm {
            my_size += crate::rt::int32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.elanguage {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.steam_realm {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreBrowseContext {
        StoreBrowseContext::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.elanguage = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.steam_realm = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreBrowseContext {
        static instance: StoreBrowseContext = StoreBrowseContext {
            language: ::std::option::Option::None,
            elanguage: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            steam_realm: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for StoreBrowseContext {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StoreBrowseContext").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StoreBrowseContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for StoreBrowseContext {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StoreBrowseItemDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreBrowseItemDataRequest {
    // message fields
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_assets)
    pub include_assets: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_release)
    pub include_release: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_platforms)
    pub include_platforms: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_all_purchase_options)
    pub include_all_purchase_options: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_screenshots)
    pub include_screenshots: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_trailers)
    pub include_trailers: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_ratings)
    pub include_ratings: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_tag_count)
    pub include_tag_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_reviews)
    pub include_reviews: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_basic_info)
    pub include_basic_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_supported_languages)
    pub include_supported_languages: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_full_description)
    pub include_full_description: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_included_items)
    pub include_included_items: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.included_item_data_request)
    pub included_item_data_request: crate::MessageField<StoreBrowseItemDataRequest>,
    // @@protoc_insertion_point(field:StoreBrowseItemDataRequest.include_assets_without_overrides)
    pub include_assets_without_overrides: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreBrowseItemDataRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreBrowseItemDataRequest {
    fn default() -> &'a StoreBrowseItemDataRequest {
        <StoreBrowseItemDataRequest as crate::Message>::default_instance()
    }
}

impl StoreBrowseItemDataRequest {
    pub fn new() -> StoreBrowseItemDataRequest {
        ::std::default::Default::default()
    }

    // optional bool include_assets = 1;

    pub fn include_assets(&self) -> bool {
        self.include_assets.unwrap_or(false)
    }

    pub fn clear_include_assets(&mut self) {
        self.include_assets = ::std::option::Option::None;
    }

    pub fn has_include_assets(&self) -> bool {
        self.include_assets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_assets(&mut self, v: bool) {
        self.include_assets = ::std::option::Option::Some(v);
    }

    // optional bool include_release = 2;

    pub fn include_release(&self) -> bool {
        self.include_release.unwrap_or(false)
    }

    pub fn clear_include_release(&mut self) {
        self.include_release = ::std::option::Option::None;
    }

    pub fn has_include_release(&self) -> bool {
        self.include_release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_release(&mut self, v: bool) {
        self.include_release = ::std::option::Option::Some(v);
    }

    // optional bool include_platforms = 3;

    pub fn include_platforms(&self) -> bool {
        self.include_platforms.unwrap_or(false)
    }

    pub fn clear_include_platforms(&mut self) {
        self.include_platforms = ::std::option::Option::None;
    }

    pub fn has_include_platforms(&self) -> bool {
        self.include_platforms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_platforms(&mut self, v: bool) {
        self.include_platforms = ::std::option::Option::Some(v);
    }

    // optional bool include_all_purchase_options = 4;

    pub fn include_all_purchase_options(&self) -> bool {
        self.include_all_purchase_options.unwrap_or(false)
    }

    pub fn clear_include_all_purchase_options(&mut self) {
        self.include_all_purchase_options = ::std::option::Option::None;
    }

    pub fn has_include_all_purchase_options(&self) -> bool {
        self.include_all_purchase_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_all_purchase_options(&mut self, v: bool) {
        self.include_all_purchase_options = ::std::option::Option::Some(v);
    }

    // optional bool include_screenshots = 5;

    pub fn include_screenshots(&self) -> bool {
        self.include_screenshots.unwrap_or(false)
    }

    pub fn clear_include_screenshots(&mut self) {
        self.include_screenshots = ::std::option::Option::None;
    }

    pub fn has_include_screenshots(&self) -> bool {
        self.include_screenshots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_screenshots(&mut self, v: bool) {
        self.include_screenshots = ::std::option::Option::Some(v);
    }

    // optional bool include_trailers = 6;

    pub fn include_trailers(&self) -> bool {
        self.include_trailers.unwrap_or(false)
    }

    pub fn clear_include_trailers(&mut self) {
        self.include_trailers = ::std::option::Option::None;
    }

    pub fn has_include_trailers(&self) -> bool {
        self.include_trailers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_trailers(&mut self, v: bool) {
        self.include_trailers = ::std::option::Option::Some(v);
    }

    // optional bool include_ratings = 7;

    pub fn include_ratings(&self) -> bool {
        self.include_ratings.unwrap_or(false)
    }

    pub fn clear_include_ratings(&mut self) {
        self.include_ratings = ::std::option::Option::None;
    }

    pub fn has_include_ratings(&self) -> bool {
        self.include_ratings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_ratings(&mut self, v: bool) {
        self.include_ratings = ::std::option::Option::Some(v);
    }

    // optional int32 include_tag_count = 8;

    pub fn include_tag_count(&self) -> i32 {
        self.include_tag_count.unwrap_or(0)
    }

    pub fn clear_include_tag_count(&mut self) {
        self.include_tag_count = ::std::option::Option::None;
    }

    pub fn has_include_tag_count(&self) -> bool {
        self.include_tag_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_tag_count(&mut self, v: i32) {
        self.include_tag_count = ::std::option::Option::Some(v);
    }

    // optional bool include_reviews = 9;

    pub fn include_reviews(&self) -> bool {
        self.include_reviews.unwrap_or(false)
    }

    pub fn clear_include_reviews(&mut self) {
        self.include_reviews = ::std::option::Option::None;
    }

    pub fn has_include_reviews(&self) -> bool {
        self.include_reviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_reviews(&mut self, v: bool) {
        self.include_reviews = ::std::option::Option::Some(v);
    }

    // optional bool include_basic_info = 10;

    pub fn include_basic_info(&self) -> bool {
        self.include_basic_info.unwrap_or(false)
    }

    pub fn clear_include_basic_info(&mut self) {
        self.include_basic_info = ::std::option::Option::None;
    }

    pub fn has_include_basic_info(&self) -> bool {
        self.include_basic_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_basic_info(&mut self, v: bool) {
        self.include_basic_info = ::std::option::Option::Some(v);
    }

    // optional bool include_supported_languages = 11;

    pub fn include_supported_languages(&self) -> bool {
        self.include_supported_languages.unwrap_or(false)
    }

    pub fn clear_include_supported_languages(&mut self) {
        self.include_supported_languages = ::std::option::Option::None;
    }

    pub fn has_include_supported_languages(&self) -> bool {
        self.include_supported_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_supported_languages(&mut self, v: bool) {
        self.include_supported_languages = ::std::option::Option::Some(v);
    }

    // optional bool include_full_description = 12;

    pub fn include_full_description(&self) -> bool {
        self.include_full_description.unwrap_or(false)
    }

    pub fn clear_include_full_description(&mut self) {
        self.include_full_description = ::std::option::Option::None;
    }

    pub fn has_include_full_description(&self) -> bool {
        self.include_full_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_full_description(&mut self, v: bool) {
        self.include_full_description = ::std::option::Option::Some(v);
    }

    // optional bool include_included_items = 13;

    pub fn include_included_items(&self) -> bool {
        self.include_included_items.unwrap_or(false)
    }

    pub fn clear_include_included_items(&mut self) {
        self.include_included_items = ::std::option::Option::None;
    }

    pub fn has_include_included_items(&self) -> bool {
        self.include_included_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_included_items(&mut self, v: bool) {
        self.include_included_items = ::std::option::Option::Some(v);
    }

    // optional .StoreBrowseItemDataRequest included_item_data_request = 14;

    pub fn included_item_data_request(&self) -> &StoreBrowseItemDataRequest {
        self.included_item_data_request.as_ref().unwrap_or_else(|| <StoreBrowseItemDataRequest as crate::Message>::default_instance())
    }

    pub fn clear_included_item_data_request(&mut self) {
        self.included_item_data_request.clear();
    }

    pub fn has_included_item_data_request(&self) -> bool {
        self.included_item_data_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_included_item_data_request(&mut self, v: StoreBrowseItemDataRequest) {
        self.included_item_data_request = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_included_item_data_request(&mut self) -> &mut StoreBrowseItemDataRequest {
        self.included_item_data_request.mut_or_insert_default()
    }

    // Take field
    pub fn take_included_item_data_request(&mut self) -> StoreBrowseItemDataRequest {
        self.included_item_data_request.take().unwrap_or_else(|| StoreBrowseItemDataRequest::new())
    }

    // optional bool include_assets_without_overrides = 15;

    pub fn include_assets_without_overrides(&self) -> bool {
        self.include_assets_without_overrides.unwrap_or(false)
    }

    pub fn clear_include_assets_without_overrides(&mut self) {
        self.include_assets_without_overrides = ::std::option::Option::None;
    }

    pub fn has_include_assets_without_overrides(&self) -> bool {
        self.include_assets_without_overrides.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_assets_without_overrides(&mut self, v: bool) {
        self.include_assets_without_overrides = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_assets",
            |m: &StoreBrowseItemDataRequest| { &m.include_assets },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_assets },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_release",
            |m: &StoreBrowseItemDataRequest| { &m.include_release },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_release },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_platforms",
            |m: &StoreBrowseItemDataRequest| { &m.include_platforms },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_platforms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_all_purchase_options",
            |m: &StoreBrowseItemDataRequest| { &m.include_all_purchase_options },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_all_purchase_options },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_screenshots",
            |m: &StoreBrowseItemDataRequest| { &m.include_screenshots },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_screenshots },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_trailers",
            |m: &StoreBrowseItemDataRequest| { &m.include_trailers },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_trailers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_ratings",
            |m: &StoreBrowseItemDataRequest| { &m.include_ratings },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_ratings },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_tag_count",
            |m: &StoreBrowseItemDataRequest| { &m.include_tag_count },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_tag_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_reviews",
            |m: &StoreBrowseItemDataRequest| { &m.include_reviews },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_reviews },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_basic_info",
            |m: &StoreBrowseItemDataRequest| { &m.include_basic_info },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_basic_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_supported_languages",
            |m: &StoreBrowseItemDataRequest| { &m.include_supported_languages },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_supported_languages },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_full_description",
            |m: &StoreBrowseItemDataRequest| { &m.include_full_description },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_full_description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_included_items",
            |m: &StoreBrowseItemDataRequest| { &m.include_included_items },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_included_items },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, StoreBrowseItemDataRequest>(
            "included_item_data_request",
            |m: &StoreBrowseItemDataRequest| { &m.included_item_data_request },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.included_item_data_request },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "include_assets_without_overrides",
            |m: &StoreBrowseItemDataRequest| { &m.include_assets_without_overrides },
            |m: &mut StoreBrowseItemDataRequest| { &mut m.include_assets_without_overrides },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<StoreBrowseItemDataRequest>(
            "StoreBrowseItemDataRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for StoreBrowseItemDataRequest {
    const NAME: &'static str = "StoreBrowseItemDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.include_assets = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.include_release = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.include_platforms = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.include_all_purchase_options = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.include_screenshots = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.include_trailers = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.include_ratings = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.include_tag_count = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.include_reviews = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.include_basic_info = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.include_supported_languages = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.include_full_description = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.include_included_items = ::std::option::Option::Some(is.read_bool()?);
                },
                114 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.included_item_data_request)?;
                },
                120 => {
                    self.include_assets_without_overrides = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.include_assets {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_release {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_platforms {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_all_purchase_options {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_screenshots {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_trailers {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_ratings {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_tag_count {
            my_size += crate::rt::int32_size(8, v);
        }
        if let Some(v) = self.include_reviews {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_basic_info {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_supported_languages {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_full_description {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_included_items {
            my_size += 1 + 1;
        }
        if let Some(v) = self.included_item_data_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.include_assets_without_overrides {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.include_assets {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.include_release {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.include_platforms {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.include_all_purchase_options {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.include_screenshots {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.include_trailers {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.include_ratings {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.include_tag_count {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.include_reviews {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.include_basic_info {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.include_supported_languages {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.include_full_description {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.include_included_items {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.included_item_data_request.as_ref() {
            crate::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.include_assets_without_overrides {
            os.write_bool(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreBrowseItemDataRequest {
        StoreBrowseItemDataRequest::new()
    }

    fn clear(&mut self) {
        self.include_assets = ::std::option::Option::None;
        self.include_release = ::std::option::Option::None;
        self.include_platforms = ::std::option::Option::None;
        self.include_all_purchase_options = ::std::option::Option::None;
        self.include_screenshots = ::std::option::Option::None;
        self.include_trailers = ::std::option::Option::None;
        self.include_ratings = ::std::option::Option::None;
        self.include_tag_count = ::std::option::Option::None;
        self.include_reviews = ::std::option::Option::None;
        self.include_basic_info = ::std::option::Option::None;
        self.include_supported_languages = ::std::option::Option::None;
        self.include_full_description = ::std::option::Option::None;
        self.include_included_items = ::std::option::Option::None;
        self.included_item_data_request.clear();
        self.include_assets_without_overrides = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreBrowseItemDataRequest {
        static instance: StoreBrowseItemDataRequest = StoreBrowseItemDataRequest {
            include_assets: ::std::option::Option::None,
            include_release: ::std::option::Option::None,
            include_platforms: ::std::option::Option::None,
            include_all_purchase_options: ::std::option::Option::None,
            include_screenshots: ::std::option::Option::None,
            include_trailers: ::std::option::Option::None,
            include_ratings: ::std::option::Option::None,
            include_tag_count: ::std::option::Option::None,
            include_reviews: ::std::option::Option::None,
            include_basic_info: ::std::option::Option::None,
            include_supported_languages: ::std::option::Option::None,
            include_full_description: ::std::option::Option::None,
            include_included_items: ::std::option::Option::None,
            included_item_data_request: crate::MessageField::none(),
            include_assets_without_overrides: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for StoreBrowseItemDataRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StoreBrowseItemDataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StoreBrowseItemDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for StoreBrowseItemDataRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStoreBrowse_GetItems_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetItems_Request {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetItems_Request.ids)
    pub ids: ::std::vec::Vec<StoreItemID>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetItems_Request.context)
    pub context: crate::MessageField<StoreBrowseContext>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetItems_Request.data_request)
    pub data_request: crate::MessageField<StoreBrowseItemDataRequest>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetItems_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetItems_Request {
    fn default() -> &'a CStoreBrowse_GetItems_Request {
        <CStoreBrowse_GetItems_Request as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetItems_Request {
    pub fn new() -> CStoreBrowse_GetItems_Request {
        ::std::default::Default::default()
    }

    // repeated .StoreItemID ids = 1;

    pub fn ids(&self) -> &[StoreItemID] {
        &self.ids
    }

    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::std::vec::Vec<StoreItemID>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::std::vec::Vec<StoreItemID> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::std::vec::Vec<StoreItemID> {
        ::std::mem::replace(&mut self.ids, ::std::vec::Vec::new())
    }

    // optional .StoreBrowseContext context = 2;

    pub fn context(&self) -> &StoreBrowseContext {
        self.context.as_ref().unwrap_or_else(|| <StoreBrowseContext as crate::Message>::default_instance())
    }

    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: StoreBrowseContext) {
        self.context = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut StoreBrowseContext {
        self.context.mut_or_insert_default()
    }

    // Take field
    pub fn take_context(&mut self) -> StoreBrowseContext {
        self.context.take().unwrap_or_else(|| StoreBrowseContext::new())
    }

    // optional .StoreBrowseItemDataRequest data_request = 3;

    pub fn data_request(&self) -> &StoreBrowseItemDataRequest {
        self.data_request.as_ref().unwrap_or_else(|| <StoreBrowseItemDataRequest as crate::Message>::default_instance())
    }

    pub fn clear_data_request(&mut self) {
        self.data_request.clear();
    }

    pub fn has_data_request(&self) -> bool {
        self.data_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_request(&mut self, v: StoreBrowseItemDataRequest) {
        self.data_request = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_request(&mut self) -> &mut StoreBrowseItemDataRequest {
        self.data_request.mut_or_insert_default()
    }

    // Take field
    pub fn take_data_request(&mut self) -> StoreBrowseItemDataRequest {
        self.data_request.take().unwrap_or_else(|| StoreBrowseItemDataRequest::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &CStoreBrowse_GetItems_Request| { &m.ids },
            |m: &mut CStoreBrowse_GetItems_Request| { &mut m.ids },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, StoreBrowseContext>(
            "context",
            |m: &CStoreBrowse_GetItems_Request| { &m.context },
            |m: &mut CStoreBrowse_GetItems_Request| { &mut m.context },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, StoreBrowseItemDataRequest>(
            "data_request",
            |m: &CStoreBrowse_GetItems_Request| { &m.data_request },
            |m: &mut CStoreBrowse_GetItems_Request| { &mut m.data_request },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetItems_Request>(
            "CStoreBrowse_GetItems_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetItems_Request {
    const NAME: &'static str = "CStoreBrowse_GetItems_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ids.push(is.read_message()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.data_request)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.data_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.ids {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.context.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.data_request.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetItems_Request {
        CStoreBrowse_GetItems_Request::new()
    }

    fn clear(&mut self) {
        self.ids.clear();
        self.context.clear();
        self.data_request.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetItems_Request {
        static instance: CStoreBrowse_GetItems_Request = CStoreBrowse_GetItems_Request {
            ids: ::std::vec::Vec::new(),
            context: crate::MessageField::none(),
            data_request: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetItems_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetItems_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetItems_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetItems_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:StoreItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreItem {
    // message fields
    // @@protoc_insertion_point(field:StoreItem.item_type)
    pub item_type: ::std::option::Option<crate::EnumOrUnknown<EStoreItemType>>,
    // @@protoc_insertion_point(field:StoreItem.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItem.success)
    pub success: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItem.visible)
    pub visible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.unvailable_for_country_restriction)
    pub unvailable_for_country_restriction: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreItem.store_url_path)
    pub store_url_path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreItem.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItem.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<EStoreAppType>>,
    // @@protoc_insertion_point(field:StoreItem.included_types)
    pub included_types: ::std::vec::Vec<crate::EnumOrUnknown<EStoreAppType>>,
    // @@protoc_insertion_point(field:StoreItem.included_appids)
    pub included_appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:StoreItem.is_free)
    pub is_free: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.is_early_access)
    pub is_early_access: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.related_items)
    pub related_items: crate::MessageField<store_item::RelatedItems>,
    // @@protoc_insertion_point(field:StoreItem.included_items)
    pub included_items: crate::MessageField<store_item::IncludedItems>,
    // @@protoc_insertion_point(field:StoreItem.content_descriptorids)
    pub content_descriptorids: ::std::vec::Vec<crate::EnumOrUnknown<super::enums_productinfo::EContentDescriptorID>>,
    // @@protoc_insertion_point(field:StoreItem.tagids)
    pub tagids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:StoreItem.categories)
    pub categories: crate::MessageField<store_item::Categories>,
    // @@protoc_insertion_point(field:StoreItem.reviews)
    pub reviews: crate::MessageField<store_item::Reviews>,
    // @@protoc_insertion_point(field:StoreItem.basic_info)
    pub basic_info: crate::MessageField<store_item::BasicInfo>,
    // @@protoc_insertion_point(field:StoreItem.tags)
    pub tags: ::std::vec::Vec<store_item::Tag>,
    // @@protoc_insertion_point(field:StoreItem.assets)
    pub assets: crate::MessageField<store_item::Assets>,
    // @@protoc_insertion_point(field:StoreItem.release)
    pub release: crate::MessageField<store_item::ReleaseInfo>,
    // @@protoc_insertion_point(field:StoreItem.platforms)
    pub platforms: crate::MessageField<store_item::Platforms>,
    // @@protoc_insertion_point(field:StoreItem.game_rating)
    pub game_rating: crate::MessageField<StoreGameRating>,
    // @@protoc_insertion_point(field:StoreItem.best_purchase_option)
    pub best_purchase_option: crate::MessageField<store_item::PurchaseOption>,
    // @@protoc_insertion_point(field:StoreItem.purchase_options)
    pub purchase_options: ::std::vec::Vec<store_item::PurchaseOption>,
    // @@protoc_insertion_point(field:StoreItem.accessories)
    pub accessories: ::std::vec::Vec<store_item::PurchaseOption>,
    // @@protoc_insertion_point(field:StoreItem.screenshots)
    pub screenshots: crate::MessageField<store_item::Screenshots>,
    // @@protoc_insertion_point(field:StoreItem.trailers)
    pub trailers: crate::MessageField<store_item::Trailers>,
    // @@protoc_insertion_point(field:StoreItem.supported_languages)
    pub supported_languages: ::std::vec::Vec<store_item::SupportedLanguage>,
    // @@protoc_insertion_point(field:StoreItem.store_url_path_override)
    pub store_url_path_override: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreItem.free_weekend)
    pub free_weekend: crate::MessageField<store_item::FreeWeekend>,
    // @@protoc_insertion_point(field:StoreItem.unlisted)
    pub unlisted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.game_count)
    pub game_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:StoreItem.internal_name)
    pub internal_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreItem.full_description)
    pub full_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreItem.is_free_temporarily)
    pub is_free_temporarily: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreItem.assets_without_overrides)
    pub assets_without_overrides: crate::MessageField<store_item::Assets>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreItem.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreItem {
    fn default() -> &'a StoreItem {
        <StoreItem as crate::Message>::default_instance()
    }
}

impl StoreItem {
    pub fn new() -> StoreItem {
        ::std::default::Default::default()
    }

    // optional .EStoreItemType item_type = 1;

    pub fn item_type(&self) -> EStoreItemType {
        match self.item_type {
            Some(e) => e.enum_value_or(EStoreItemType::k_EStoreItemType_Invalid),
            None => EStoreItemType::k_EStoreItemType_Invalid,
        }
    }

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: EStoreItemType) {
        self.item_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 id = 2;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 success = 3;

    pub fn success(&self) -> u32 {
        self.success.unwrap_or(0)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: u32) {
        self.success = ::std::option::Option::Some(v);
    }

    // optional bool visible = 4;

    pub fn visible(&self) -> bool {
        self.visible.unwrap_or(false)
    }

    pub fn clear_visible(&mut self) {
        self.visible = ::std::option::Option::None;
    }

    pub fn has_visible(&self) -> bool {
        self.visible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visible(&mut self, v: bool) {
        self.visible = ::std::option::Option::Some(v);
    }

    // optional bool unvailable_for_country_restriction = 5;

    pub fn unvailable_for_country_restriction(&self) -> bool {
        self.unvailable_for_country_restriction.unwrap_or(false)
    }

    pub fn clear_unvailable_for_country_restriction(&mut self) {
        self.unvailable_for_country_restriction = ::std::option::Option::None;
    }

    pub fn has_unvailable_for_country_restriction(&self) -> bool {
        self.unvailable_for_country_restriction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unvailable_for_country_restriction(&mut self, v: bool) {
        self.unvailable_for_country_restriction = ::std::option::Option::Some(v);
    }

    // optional string name = 6;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string store_url_path = 7;

    pub fn store_url_path(&self) -> &str {
        match self.store_url_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_store_url_path(&mut self) {
        self.store_url_path = ::std::option::Option::None;
    }

    pub fn has_store_url_path(&self) -> bool {
        self.store_url_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_url_path(&mut self, v: ::std::string::String) {
        self.store_url_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_url_path(&mut self) -> &mut ::std::string::String {
        if self.store_url_path.is_none() {
            self.store_url_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.store_url_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_store_url_path(&mut self) -> ::std::string::String {
        self.store_url_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 9;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional .EStoreAppType type = 10;

    pub fn type_(&self) -> EStoreAppType {
        match self.type_ {
            Some(e) => e.enum_value_or(EStoreAppType::k_EStoreAppType_Game),
            None => EStoreAppType::k_EStoreAppType_Game,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: EStoreAppType) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // repeated .EStoreAppType included_types = 11;

    pub fn included_types(&self) -> &[crate::EnumOrUnknown<EStoreAppType>] {
        &self.included_types
    }

    pub fn clear_included_types(&mut self) {
        self.included_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_included_types(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<EStoreAppType>>) {
        self.included_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_included_types(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<EStoreAppType>> {
        &mut self.included_types
    }

    // Take field
    pub fn take_included_types(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<EStoreAppType>> {
        ::std::mem::replace(&mut self.included_types, ::std::vec::Vec::new())
    }

    // repeated uint32 included_appids = 12;

    pub fn included_appids(&self) -> &[u32] {
        &self.included_appids
    }

    pub fn clear_included_appids(&mut self) {
        self.included_appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_included_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.included_appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_included_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.included_appids
    }

    // Take field
    pub fn take_included_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.included_appids, ::std::vec::Vec::new())
    }

    // optional bool is_free = 13;

    pub fn is_free(&self) -> bool {
        self.is_free.unwrap_or(false)
    }

    pub fn clear_is_free(&mut self) {
        self.is_free = ::std::option::Option::None;
    }

    pub fn has_is_free(&self) -> bool {
        self.is_free.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_free(&mut self, v: bool) {
        self.is_free = ::std::option::Option::Some(v);
    }

    // optional bool is_early_access = 14;

    pub fn is_early_access(&self) -> bool {
        self.is_early_access.unwrap_or(false)
    }

    pub fn clear_is_early_access(&mut self) {
        self.is_early_access = ::std::option::Option::None;
    }

    pub fn has_is_early_access(&self) -> bool {
        self.is_early_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_early_access(&mut self, v: bool) {
        self.is_early_access = ::std::option::Option::Some(v);
    }

    // optional .StoreItem.RelatedItems related_items = 15;

    pub fn related_items(&self) -> &store_item::RelatedItems {
        self.related_items.as_ref().unwrap_or_else(|| <store_item::RelatedItems as crate::Message>::default_instance())
    }

    pub fn clear_related_items(&mut self) {
        self.related_items.clear();
    }

    pub fn has_related_items(&self) -> bool {
        self.related_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_related_items(&mut self, v: store_item::RelatedItems) {
        self.related_items = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_related_items(&mut self) -> &mut store_item::RelatedItems {
        self.related_items.mut_or_insert_default()
    }

    // Take field
    pub fn take_related_items(&mut self) -> store_item::RelatedItems {
        self.related_items.take().unwrap_or_else(|| store_item::RelatedItems::new())
    }

    // optional .StoreItem.IncludedItems included_items = 16;

    pub fn included_items(&self) -> &store_item::IncludedItems {
        self.included_items.as_ref().unwrap_or_else(|| <store_item::IncludedItems as crate::Message>::default_instance())
    }

    pub fn clear_included_items(&mut self) {
        self.included_items.clear();
    }

    pub fn has_included_items(&self) -> bool {
        self.included_items.is_some()
    }

    // Param is passed by value, moved
    pub fn set_included_items(&mut self, v: store_item::IncludedItems) {
        self.included_items = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_included_items(&mut self) -> &mut store_item::IncludedItems {
        self.included_items.mut_or_insert_default()
    }

    // Take field
    pub fn take_included_items(&mut self) -> store_item::IncludedItems {
        self.included_items.take().unwrap_or_else(|| store_item::IncludedItems::new())
    }

    // repeated .EContentDescriptorID content_descriptorids = 20;

    pub fn content_descriptorids(&self) -> &[crate::EnumOrUnknown<super::enums_productinfo::EContentDescriptorID>] {
        &self.content_descriptorids
    }

    pub fn clear_content_descriptorids(&mut self) {
        self.content_descriptorids.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_descriptorids(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<super::enums_productinfo::EContentDescriptorID>>) {
        self.content_descriptorids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_content_descriptorids(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<super::enums_productinfo::EContentDescriptorID>> {
        &mut self.content_descriptorids
    }

    // Take field
    pub fn take_content_descriptorids(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<super::enums_productinfo::EContentDescriptorID>> {
        ::std::mem::replace(&mut self.content_descriptorids, ::std::vec::Vec::new())
    }

    // repeated uint32 tagids = 21;

    pub fn tagids(&self) -> &[u32] {
        &self.tagids
    }

    pub fn clear_tagids(&mut self) {
        self.tagids.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagids(&mut self, v: ::std::vec::Vec<u32>) {
        self.tagids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tagids
    }

    // Take field
    pub fn take_tagids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tagids, ::std::vec::Vec::new())
    }

    // optional .StoreItem.Categories categories = 22;

    pub fn categories(&self) -> &store_item::Categories {
        self.categories.as_ref().unwrap_or_else(|| <store_item::Categories as crate::Message>::default_instance())
    }

    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    pub fn has_categories(&self) -> bool {
        self.categories.is_some()
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: store_item::Categories) {
        self.categories = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_categories(&mut self) -> &mut store_item::Categories {
        self.categories.mut_or_insert_default()
    }

    // Take field
    pub fn take_categories(&mut self) -> store_item::Categories {
        self.categories.take().unwrap_or_else(|| store_item::Categories::new())
    }

    // optional .StoreItem.Reviews reviews = 23;

    pub fn reviews(&self) -> &store_item::Reviews {
        self.reviews.as_ref().unwrap_or_else(|| <store_item::Reviews as crate::Message>::default_instance())
    }

    pub fn clear_reviews(&mut self) {
        self.reviews.clear();
    }

    pub fn has_reviews(&self) -> bool {
        self.reviews.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reviews(&mut self, v: store_item::Reviews) {
        self.reviews = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reviews(&mut self) -> &mut store_item::Reviews {
        self.reviews.mut_or_insert_default()
    }

    // Take field
    pub fn take_reviews(&mut self) -> store_item::Reviews {
        self.reviews.take().unwrap_or_else(|| store_item::Reviews::new())
    }

    // optional .StoreItem.BasicInfo basic_info = 24;

    pub fn basic_info(&self) -> &store_item::BasicInfo {
        self.basic_info.as_ref().unwrap_or_else(|| <store_item::BasicInfo as crate::Message>::default_instance())
    }

    pub fn clear_basic_info(&mut self) {
        self.basic_info.clear();
    }

    pub fn has_basic_info(&self) -> bool {
        self.basic_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_basic_info(&mut self, v: store_item::BasicInfo) {
        self.basic_info = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_basic_info(&mut self) -> &mut store_item::BasicInfo {
        self.basic_info.mut_or_insert_default()
    }

    // Take field
    pub fn take_basic_info(&mut self) -> store_item::BasicInfo {
        self.basic_info.take().unwrap_or_else(|| store_item::BasicInfo::new())
    }

    // repeated .StoreItem.Tag tags = 25;

    pub fn tags(&self) -> &[store_item::Tag] {
        &self.tags
    }

    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::vec::Vec<store_item::Tag>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::std::vec::Vec<store_item::Tag> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::vec::Vec<store_item::Tag> {
        ::std::mem::replace(&mut self.tags, ::std::vec::Vec::new())
    }

    // optional .StoreItem.Assets assets = 30;

    pub fn assets(&self) -> &store_item::Assets {
        self.assets.as_ref().unwrap_or_else(|| <store_item::Assets as crate::Message>::default_instance())
    }

    pub fn clear_assets(&mut self) {
        self.assets.clear();
    }

    pub fn has_assets(&self) -> bool {
        self.assets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assets(&mut self, v: store_item::Assets) {
        self.assets = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assets(&mut self) -> &mut store_item::Assets {
        self.assets.mut_or_insert_default()
    }

    // Take field
    pub fn take_assets(&mut self) -> store_item::Assets {
        self.assets.take().unwrap_or_else(|| store_item::Assets::new())
    }

    // optional .StoreItem.ReleaseInfo release = 31;

    pub fn release(&self) -> &store_item::ReleaseInfo {
        self.release.as_ref().unwrap_or_else(|| <store_item::ReleaseInfo as crate::Message>::default_instance())
    }

    pub fn clear_release(&mut self) {
        self.release.clear();
    }

    pub fn has_release(&self) -> bool {
        self.release.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release(&mut self, v: store_item::ReleaseInfo) {
        self.release = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_release(&mut self) -> &mut store_item::ReleaseInfo {
        self.release.mut_or_insert_default()
    }

    // Take field
    pub fn take_release(&mut self) -> store_item::ReleaseInfo {
        self.release.take().unwrap_or_else(|| store_item::ReleaseInfo::new())
    }

    // optional .StoreItem.Platforms platforms = 32;

    pub fn platforms(&self) -> &store_item::Platforms {
        self.platforms.as_ref().unwrap_or_else(|| <store_item::Platforms as crate::Message>::default_instance())
    }

    pub fn clear_platforms(&mut self) {
        self.platforms.clear();
    }

    pub fn has_platforms(&self) -> bool {
        self.platforms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms(&mut self, v: store_item::Platforms) {
        self.platforms = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_platforms(&mut self) -> &mut store_item::Platforms {
        self.platforms.mut_or_insert_default()
    }

    // Take field
    pub fn take_platforms(&mut self) -> store_item::Platforms {
        self.platforms.take().unwrap_or_else(|| store_item::Platforms::new())
    }

    // optional .StoreGameRating game_rating = 33;

    pub fn game_rating(&self) -> &StoreGameRating {
        self.game_rating.as_ref().unwrap_or_else(|| <StoreGameRating as crate::Message>::default_instance())
    }

    pub fn clear_game_rating(&mut self) {
        self.game_rating.clear();
    }

    pub fn has_game_rating(&self) -> bool {
        self.game_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_rating(&mut self, v: StoreGameRating) {
        self.game_rating = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_rating(&mut self) -> &mut StoreGameRating {
        self.game_rating.mut_or_insert_default()
    }

    // Take field
    pub fn take_game_rating(&mut self) -> StoreGameRating {
        self.game_rating.take().unwrap_or_else(|| StoreGameRating::new())
    }

    // optional .StoreItem.PurchaseOption best_purchase_option = 40;

    pub fn best_purchase_option(&self) -> &store_item::PurchaseOption {
        self.best_purchase_option.as_ref().unwrap_or_else(|| <store_item::PurchaseOption as crate::Message>::default_instance())
    }

    pub fn clear_best_purchase_option(&mut self) {
        self.best_purchase_option.clear();
    }

    pub fn has_best_purchase_option(&self) -> bool {
        self.best_purchase_option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_purchase_option(&mut self, v: store_item::PurchaseOption) {
        self.best_purchase_option = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_best_purchase_option(&mut self) -> &mut store_item::PurchaseOption {
        self.best_purchase_option.mut_or_insert_default()
    }

    // Take field
    pub fn take_best_purchase_option(&mut self) -> store_item::PurchaseOption {
        self.best_purchase_option.take().unwrap_or_else(|| store_item::PurchaseOption::new())
    }

    // repeated .StoreItem.PurchaseOption purchase_options = 41;

    pub fn purchase_options(&self) -> &[store_item::PurchaseOption] {
        &self.purchase_options
    }

    pub fn clear_purchase_options(&mut self) {
        self.purchase_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_purchase_options(&mut self, v: ::std::vec::Vec<store_item::PurchaseOption>) {
        self.purchase_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_purchase_options(&mut self) -> &mut ::std::vec::Vec<store_item::PurchaseOption> {
        &mut self.purchase_options
    }

    // Take field
    pub fn take_purchase_options(&mut self) -> ::std::vec::Vec<store_item::PurchaseOption> {
        ::std::mem::replace(&mut self.purchase_options, ::std::vec::Vec::new())
    }

    // repeated .StoreItem.PurchaseOption accessories = 42;

    pub fn accessories(&self) -> &[store_item::PurchaseOption] {
        &self.accessories
    }

    pub fn clear_accessories(&mut self) {
        self.accessories.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessories(&mut self, v: ::std::vec::Vec<store_item::PurchaseOption>) {
        self.accessories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessories(&mut self) -> &mut ::std::vec::Vec<store_item::PurchaseOption> {
        &mut self.accessories
    }

    // Take field
    pub fn take_accessories(&mut self) -> ::std::vec::Vec<store_item::PurchaseOption> {
        ::std::mem::replace(&mut self.accessories, ::std::vec::Vec::new())
    }

    // optional .StoreItem.Screenshots screenshots = 50;

    pub fn screenshots(&self) -> &store_item::Screenshots {
        self.screenshots.as_ref().unwrap_or_else(|| <store_item::Screenshots as crate::Message>::default_instance())
    }

    pub fn clear_screenshots(&mut self) {
        self.screenshots.clear();
    }

    pub fn has_screenshots(&self) -> bool {
        self.screenshots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_screenshots(&mut self, v: store_item::Screenshots) {
        self.screenshots = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_screenshots(&mut self) -> &mut store_item::Screenshots {
        self.screenshots.mut_or_insert_default()
    }

    // Take field
    pub fn take_screenshots(&mut self) -> store_item::Screenshots {
        self.screenshots.take().unwrap_or_else(|| store_item::Screenshots::new())
    }

    // optional .StoreItem.Trailers trailers = 51;

    pub fn trailers(&self) -> &store_item::Trailers {
        self.trailers.as_ref().unwrap_or_else(|| <store_item::Trailers as crate::Message>::default_instance())
    }

    pub fn clear_trailers(&mut self) {
        self.trailers.clear();
    }

    pub fn has_trailers(&self) -> bool {
        self.trailers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailers(&mut self, v: store_item::Trailers) {
        self.trailers = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trailers(&mut self) -> &mut store_item::Trailers {
        self.trailers.mut_or_insert_default()
    }

    // Take field
    pub fn take_trailers(&mut self) -> store_item::Trailers {
        self.trailers.take().unwrap_or_else(|| store_item::Trailers::new())
    }

    // repeated .StoreItem.SupportedLanguage supported_languages = 52;

    pub fn supported_languages(&self) -> &[store_item::SupportedLanguage] {
        &self.supported_languages
    }

    pub fn clear_supported_languages(&mut self) {
        self.supported_languages.clear();
    }

    // Param is passed by value, moved
    pub fn set_supported_languages(&mut self, v: ::std::vec::Vec<store_item::SupportedLanguage>) {
        self.supported_languages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supported_languages(&mut self) -> &mut ::std::vec::Vec<store_item::SupportedLanguage> {
        &mut self.supported_languages
    }

    // Take field
    pub fn take_supported_languages(&mut self) -> ::std::vec::Vec<store_item::SupportedLanguage> {
        ::std::mem::replace(&mut self.supported_languages, ::std::vec::Vec::new())
    }

    // optional string store_url_path_override = 53;

    pub fn store_url_path_override(&self) -> &str {
        match self.store_url_path_override.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_store_url_path_override(&mut self) {
        self.store_url_path_override = ::std::option::Option::None;
    }

    pub fn has_store_url_path_override(&self) -> bool {
        self.store_url_path_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_url_path_override(&mut self, v: ::std::string::String) {
        self.store_url_path_override = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_url_path_override(&mut self) -> &mut ::std::string::String {
        if self.store_url_path_override.is_none() {
            self.store_url_path_override = ::std::option::Option::Some(::std::string::String::new());
        }
        self.store_url_path_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_store_url_path_override(&mut self) -> ::std::string::String {
        self.store_url_path_override.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .StoreItem.FreeWeekend free_weekend = 54;

    pub fn free_weekend(&self) -> &store_item::FreeWeekend {
        self.free_weekend.as_ref().unwrap_or_else(|| <store_item::FreeWeekend as crate::Message>::default_instance())
    }

    pub fn clear_free_weekend(&mut self) {
        self.free_weekend.clear();
    }

    pub fn has_free_weekend(&self) -> bool {
        self.free_weekend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_free_weekend(&mut self, v: store_item::FreeWeekend) {
        self.free_weekend = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_free_weekend(&mut self) -> &mut store_item::FreeWeekend {
        self.free_weekend.mut_or_insert_default()
    }

    // Take field
    pub fn take_free_weekend(&mut self) -> store_item::FreeWeekend {
        self.free_weekend.take().unwrap_or_else(|| store_item::FreeWeekend::new())
    }

    // optional bool unlisted = 55;

    pub fn unlisted(&self) -> bool {
        self.unlisted.unwrap_or(false)
    }

    pub fn clear_unlisted(&mut self) {
        self.unlisted = ::std::option::Option::None;
    }

    pub fn has_unlisted(&self) -> bool {
        self.unlisted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlisted(&mut self, v: bool) {
        self.unlisted = ::std::option::Option::Some(v);
    }

    // optional uint32 game_count = 56;

    pub fn game_count(&self) -> u32 {
        self.game_count.unwrap_or(0)
    }

    pub fn clear_game_count(&mut self) {
        self.game_count = ::std::option::Option::None;
    }

    pub fn has_game_count(&self) -> bool {
        self.game_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_count(&mut self, v: u32) {
        self.game_count = ::std::option::Option::Some(v);
    }

    // optional string internal_name = 57;

    pub fn internal_name(&self) -> &str {
        match self.internal_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_internal_name(&mut self) {
        self.internal_name = ::std::option::Option::None;
    }

    pub fn has_internal_name(&self) -> bool {
        self.internal_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_internal_name(&mut self, v: ::std::string::String) {
        self.internal_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_internal_name(&mut self) -> &mut ::std::string::String {
        if self.internal_name.is_none() {
            self.internal_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.internal_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_internal_name(&mut self) -> ::std::string::String {
        self.internal_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string full_description = 58;

    pub fn full_description(&self) -> &str {
        match self.full_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_full_description(&mut self) {
        self.full_description = ::std::option::Option::None;
    }

    pub fn has_full_description(&self) -> bool {
        self.full_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_description(&mut self, v: ::std::string::String) {
        self.full_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_description(&mut self) -> &mut ::std::string::String {
        if self.full_description.is_none() {
            self.full_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.full_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_description(&mut self) -> ::std::string::String {
        self.full_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_free_temporarily = 59;

    pub fn is_free_temporarily(&self) -> bool {
        self.is_free_temporarily.unwrap_or(false)
    }

    pub fn clear_is_free_temporarily(&mut self) {
        self.is_free_temporarily = ::std::option::Option::None;
    }

    pub fn has_is_free_temporarily(&self) -> bool {
        self.is_free_temporarily.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_free_temporarily(&mut self, v: bool) {
        self.is_free_temporarily = ::std::option::Option::Some(v);
    }

    // optional .StoreItem.Assets assets_without_overrides = 60;

    pub fn assets_without_overrides(&self) -> &store_item::Assets {
        self.assets_without_overrides.as_ref().unwrap_or_else(|| <store_item::Assets as crate::Message>::default_instance())
    }

    pub fn clear_assets_without_overrides(&mut self) {
        self.assets_without_overrides.clear();
    }

    pub fn has_assets_without_overrides(&self) -> bool {
        self.assets_without_overrides.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assets_without_overrides(&mut self, v: store_item::Assets) {
        self.assets_without_overrides = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assets_without_overrides(&mut self) -> &mut store_item::Assets {
        self.assets_without_overrides.mut_or_insert_default()
    }

    // Take field
    pub fn take_assets_without_overrides(&mut self) -> store_item::Assets {
        self.assets_without_overrides.take().unwrap_or_else(|| store_item::Assets::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(39);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_type",
            |m: &StoreItem| { &m.item_type },
            |m: &mut StoreItem| { &mut m.item_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &StoreItem| { &m.id },
            |m: &mut StoreItem| { &mut m.id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "success",
            |m: &StoreItem| { &m.success },
            |m: &mut StoreItem| { &mut m.success },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "visible",
            |m: &StoreItem| { &m.visible },
            |m: &mut StoreItem| { &mut m.visible },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unvailable_for_country_restriction",
            |m: &StoreItem| { &m.unvailable_for_country_restriction },
            |m: &mut StoreItem| { &mut m.unvailable_for_country_restriction },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &StoreItem| { &m.name },
            |m: &mut StoreItem| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "store_url_path",
            |m: &StoreItem| { &m.store_url_path },
            |m: &mut StoreItem| { &mut m.store_url_path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &StoreItem| { &m.appid },
            |m: &mut StoreItem| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &StoreItem| { &m.type_ },
            |m: &mut StoreItem| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "included_types",
            |m: &StoreItem| { &m.included_types },
            |m: &mut StoreItem| { &mut m.included_types },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "included_appids",
            |m: &StoreItem| { &m.included_appids },
            |m: &mut StoreItem| { &mut m.included_appids },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_free",
            |m: &StoreItem| { &m.is_free },
            |m: &mut StoreItem| { &mut m.is_free },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_early_access",
            |m: &StoreItem| { &m.is_early_access },
            |m: &mut StoreItem| { &mut m.is_early_access },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::RelatedItems>(
            "related_items",
            |m: &StoreItem| { &m.related_items },
            |m: &mut StoreItem| { &mut m.related_items },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::IncludedItems>(
            "included_items",
            |m: &StoreItem| { &m.included_items },
            |m: &mut StoreItem| { &mut m.included_items },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "content_descriptorids",
            |m: &StoreItem| { &m.content_descriptorids },
            |m: &mut StoreItem| { &mut m.content_descriptorids },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tagids",
            |m: &StoreItem| { &m.tagids },
            |m: &mut StoreItem| { &mut m.tagids },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::Categories>(
            "categories",
            |m: &StoreItem| { &m.categories },
            |m: &mut StoreItem| { &mut m.categories },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::Reviews>(
            "reviews",
            |m: &StoreItem| { &m.reviews },
            |m: &mut StoreItem| { &mut m.reviews },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::BasicInfo>(
            "basic_info",
            |m: &StoreItem| { &m.basic_info },
            |m: &mut StoreItem| { &mut m.basic_info },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tags",
            |m: &StoreItem| { &m.tags },
            |m: &mut StoreItem| { &mut m.tags },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::Assets>(
            "assets",
            |m: &StoreItem| { &m.assets },
            |m: &mut StoreItem| { &mut m.assets },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::ReleaseInfo>(
            "release",
            |m: &StoreItem| { &m.release },
            |m: &mut StoreItem| { &mut m.release },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::Platforms>(
            "platforms",
            |m: &StoreItem| { &m.platforms },
            |m: &mut StoreItem| { &mut m.platforms },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, StoreGameRating>(
            "game_rating",
            |m: &StoreItem| { &m.game_rating },
            |m: &mut StoreItem| { &mut m.game_rating },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::PurchaseOption>(
            "best_purchase_option",
            |m: &StoreItem| { &m.best_purchase_option },
            |m: &mut StoreItem| { &mut m.best_purchase_option },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "purchase_options",
            |m: &StoreItem| { &m.purchase_options },
            |m: &mut StoreItem| { &mut m.purchase_options },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accessories",
            |m: &StoreItem| { &m.accessories },
            |m: &mut StoreItem| { &mut m.accessories },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::Screenshots>(
            "screenshots",
            |m: &StoreItem| { &m.screenshots },
            |m: &mut StoreItem| { &mut m.screenshots },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::Trailers>(
            "trailers",
            |m: &StoreItem| { &m.trailers },
            |m: &mut StoreItem| { &mut m.trailers },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_languages",
            |m: &StoreItem| { &m.supported_languages },
            |m: &mut StoreItem| { &mut m.supported_languages },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "store_url_path_override",
            |m: &StoreItem| { &m.store_url_path_override },
            |m: &mut StoreItem| { &mut m.store_url_path_override },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::FreeWeekend>(
            "free_weekend",
            |m: &StoreItem| { &m.free_weekend },
            |m: &mut StoreItem| { &mut m.free_weekend },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unlisted",
            |m: &StoreItem| { &m.unlisted },
            |m: &mut StoreItem| { &mut m.unlisted },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_count",
            |m: &StoreItem| { &m.game_count },
            |m: &mut StoreItem| { &mut m.game_count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "internal_name",
            |m: &StoreItem| { &m.internal_name },
            |m: &mut StoreItem| { &mut m.internal_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "full_description",
            |m: &StoreItem| { &m.full_description },
            |m: &mut StoreItem| { &mut m.full_description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_free_temporarily",
            |m: &StoreItem| { &m.is_free_temporarily },
            |m: &mut StoreItem| { &mut m.is_free_temporarily },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, store_item::Assets>(
            "assets_without_overrides",
            |m: &StoreItem| { &m.assets_without_overrides },
            |m: &mut StoreItem| { &mut m.assets_without_overrides },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<StoreItem>(
            "StoreItem",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for StoreItem {
    const NAME: &'static str = "StoreItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.success = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.visible = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.unvailable_for_country_restriction = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.store_url_path = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.included_types.push(is.read_enum_or_unknown()?);
                },
                90 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.included_types)?
                },
                98 => {
                    is.read_repeated_packed_uint32_into(&mut self.included_appids)?;
                },
                96 => {
                    self.included_appids.push(is.read_uint32()?);
                },
                104 => {
                    self.is_free = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_early_access = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.related_items)?;
                },
                130 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.included_items)?;
                },
                160 => {
                    self.content_descriptorids.push(is.read_enum_or_unknown()?);
                },
                162 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.content_descriptorids)?
                },
                170 => {
                    is.read_repeated_packed_uint32_into(&mut self.tagids)?;
                },
                168 => {
                    self.tagids.push(is.read_uint32()?);
                },
                178 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.categories)?;
                },
                186 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.reviews)?;
                },
                194 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.basic_info)?;
                },
                202 => {
                    self.tags.push(is.read_message()?);
                },
                242 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.assets)?;
                },
                250 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.release)?;
                },
                258 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.platforms)?;
                },
                266 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.game_rating)?;
                },
                322 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.best_purchase_option)?;
                },
                330 => {
                    self.purchase_options.push(is.read_message()?);
                },
                338 => {
                    self.accessories.push(is.read_message()?);
                },
                402 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.screenshots)?;
                },
                410 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.trailers)?;
                },
                418 => {
                    self.supported_languages.push(is.read_message()?);
                },
                426 => {
                    self.store_url_path_override = ::std::option::Option::Some(is.read_string()?);
                },
                434 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.free_weekend)?;
                },
                440 => {
                    self.unlisted = ::std::option::Option::Some(is.read_bool()?);
                },
                448 => {
                    self.game_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                458 => {
                    self.internal_name = ::std::option::Option::Some(is.read_string()?);
                },
                466 => {
                    self.full_description = ::std::option::Option::Some(is.read_string()?);
                },
                472 => {
                    self.is_free_temporarily = ::std::option::Option::Some(is.read_bool()?);
                },
                482 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.assets_without_overrides)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_type {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.id {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.success {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.visible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.unvailable_for_country_restriction {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.store_url_path.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(10, v.value());
        }
        for value in &self.included_types {
            my_size += crate::rt::int32_size(11, value.value());
        };
        for value in &self.included_appids {
            my_size += crate::rt::uint32_size(12, *value);
        };
        if let Some(v) = self.is_free {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_early_access {
            my_size += 1 + 1;
        }
        if let Some(v) = self.related_items.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.included_items.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.content_descriptorids {
            my_size += crate::rt::int32_size(20, value.value());
        };
        for value in &self.tagids {
            my_size += crate::rt::uint32_size(21, *value);
        };
        if let Some(v) = self.categories.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reviews.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.basic_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.assets.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.release.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.platforms.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_rating.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.best_purchase_option.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.purchase_options {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.accessories {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.screenshots.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.trailers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.supported_languages {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.store_url_path_override.as_ref() {
            my_size += crate::rt::string_size(53, &v);
        }
        if let Some(v) = self.free_weekend.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.unlisted {
            my_size += 2 + 1;
        }
        if let Some(v) = self.game_count {
            my_size += crate::rt::uint32_size(56, v);
        }
        if let Some(v) = self.internal_name.as_ref() {
            my_size += crate::rt::string_size(57, &v);
        }
        if let Some(v) = self.full_description.as_ref() {
            my_size += crate::rt::string_size(58, &v);
        }
        if let Some(v) = self.is_free_temporarily {
            my_size += 2 + 1;
        }
        if let Some(v) = self.assets_without_overrides.as_ref() {
            let len = v.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.item_type {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.success {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.visible {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.unvailable_for_country_restriction {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.store_url_path.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(10, crate::EnumOrUnknown::value(&v))?;
        }
        for v in &self.included_types {
            os.write_enum(11, crate::EnumOrUnknown::value(v))?;
        };
        for v in &self.included_appids {
            os.write_uint32(12, *v)?;
        };
        if let Some(v) = self.is_free {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_early_access {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.related_items.as_ref() {
            crate::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.included_items.as_ref() {
            crate::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        for v in &self.content_descriptorids {
            os.write_enum(20, crate::EnumOrUnknown::value(v))?;
        };
        for v in &self.tagids {
            os.write_uint32(21, *v)?;
        };
        if let Some(v) = self.categories.as_ref() {
            crate::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.reviews.as_ref() {
            crate::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.basic_info.as_ref() {
            crate::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        for v in &self.tags {
            crate::rt::write_message_field_with_cached_size(25, v, os)?;
        };
        if let Some(v) = self.assets.as_ref() {
            crate::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.release.as_ref() {
            crate::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.platforms.as_ref() {
            crate::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.game_rating.as_ref() {
            crate::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.best_purchase_option.as_ref() {
            crate::rt::write_message_field_with_cached_size(40, v, os)?;
        }
        for v in &self.purchase_options {
            crate::rt::write_message_field_with_cached_size(41, v, os)?;
        };
        for v in &self.accessories {
            crate::rt::write_message_field_with_cached_size(42, v, os)?;
        };
        if let Some(v) = self.screenshots.as_ref() {
            crate::rt::write_message_field_with_cached_size(50, v, os)?;
        }
        if let Some(v) = self.trailers.as_ref() {
            crate::rt::write_message_field_with_cached_size(51, v, os)?;
        }
        for v in &self.supported_languages {
            crate::rt::write_message_field_with_cached_size(52, v, os)?;
        };
        if let Some(v) = self.store_url_path_override.as_ref() {
            os.write_string(53, v)?;
        }
        if let Some(v) = self.free_weekend.as_ref() {
            crate::rt::write_message_field_with_cached_size(54, v, os)?;
        }
        if let Some(v) = self.unlisted {
            os.write_bool(55, v)?;
        }
        if let Some(v) = self.game_count {
            os.write_uint32(56, v)?;
        }
        if let Some(v) = self.internal_name.as_ref() {
            os.write_string(57, v)?;
        }
        if let Some(v) = self.full_description.as_ref() {
            os.write_string(58, v)?;
        }
        if let Some(v) = self.is_free_temporarily {
            os.write_bool(59, v)?;
        }
        if let Some(v) = self.assets_without_overrides.as_ref() {
            crate::rt::write_message_field_with_cached_size(60, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreItem {
        StoreItem::new()
    }

    fn clear(&mut self) {
        self.item_type = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.success = ::std::option::Option::None;
        self.visible = ::std::option::Option::None;
        self.unvailable_for_country_restriction = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.store_url_path = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.included_types.clear();
        self.included_appids.clear();
        self.is_free = ::std::option::Option::None;
        self.is_early_access = ::std::option::Option::None;
        self.related_items.clear();
        self.included_items.clear();
        self.content_descriptorids.clear();
        self.tagids.clear();
        self.categories.clear();
        self.reviews.clear();
        self.basic_info.clear();
        self.tags.clear();
        self.assets.clear();
        self.release.clear();
        self.platforms.clear();
        self.game_rating.clear();
        self.best_purchase_option.clear();
        self.purchase_options.clear();
        self.accessories.clear();
        self.screenshots.clear();
        self.trailers.clear();
        self.supported_languages.clear();
        self.store_url_path_override = ::std::option::Option::None;
        self.free_weekend.clear();
        self.unlisted = ::std::option::Option::None;
        self.game_count = ::std::option::Option::None;
        self.internal_name = ::std::option::Option::None;
        self.full_description = ::std::option::Option::None;
        self.is_free_temporarily = ::std::option::Option::None;
        self.assets_without_overrides.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreItem {
        static instance: StoreItem = StoreItem {
            item_type: ::std::option::Option::None,
            id: ::std::option::Option::None,
            success: ::std::option::Option::None,
            visible: ::std::option::Option::None,
            unvailable_for_country_restriction: ::std::option::Option::None,
            name: ::std::option::Option::None,
            store_url_path: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            included_types: ::std::vec::Vec::new(),
            included_appids: ::std::vec::Vec::new(),
            is_free: ::std::option::Option::None,
            is_early_access: ::std::option::Option::None,
            related_items: crate::MessageField::none(),
            included_items: crate::MessageField::none(),
            content_descriptorids: ::std::vec::Vec::new(),
            tagids: ::std::vec::Vec::new(),
            categories: crate::MessageField::none(),
            reviews: crate::MessageField::none(),
            basic_info: crate::MessageField::none(),
            tags: ::std::vec::Vec::new(),
            assets: crate::MessageField::none(),
            release: crate::MessageField::none(),
            platforms: crate::MessageField::none(),
            game_rating: crate::MessageField::none(),
            best_purchase_option: crate::MessageField::none(),
            purchase_options: ::std::vec::Vec::new(),
            accessories: ::std::vec::Vec::new(),
            screenshots: crate::MessageField::none(),
            trailers: crate::MessageField::none(),
            supported_languages: ::std::vec::Vec::new(),
            store_url_path_override: ::std::option::Option::None,
            free_weekend: crate::MessageField::none(),
            unlisted: ::std::option::Option::None,
            game_count: ::std::option::Option::None,
            internal_name: ::std::option::Option::None,
            full_description: ::std::option::Option::None,
            is_free_temporarily: ::std::option::Option::None,
            assets_without_overrides: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for StoreItem {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StoreItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StoreItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for StoreItem {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `StoreItem`
pub mod store_item {
    // @@protoc_insertion_point(message:StoreItem.RelatedItems)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RelatedItems {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.RelatedItems.parent_appid)
        pub parent_appid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.RelatedItems.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RelatedItems {
        fn default() -> &'a RelatedItems {
            <RelatedItems as crate::Message>::default_instance()
        }
    }

    impl RelatedItems {
        pub fn new() -> RelatedItems {
            ::std::default::Default::default()
        }

        // optional uint32 parent_appid = 1;

        pub fn parent_appid(&self) -> u32 {
            self.parent_appid.unwrap_or(0)
        }

        pub fn clear_parent_appid(&mut self) {
            self.parent_appid = ::std::option::Option::None;
        }

        pub fn has_parent_appid(&self) -> bool {
            self.parent_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parent_appid(&mut self, v: u32) {
            self.parent_appid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "parent_appid",
                |m: &RelatedItems| { &m.parent_appid },
                |m: &mut RelatedItems| { &mut m.parent_appid },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<RelatedItems>(
                "StoreItem.RelatedItems",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for RelatedItems {
        const NAME: &'static str = "RelatedItems";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.parent_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.parent_appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.parent_appid {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RelatedItems {
            RelatedItems::new()
        }

        fn clear(&mut self) {
            self.parent_appid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RelatedItems {
            static instance: RelatedItems = RelatedItems {
                parent_appid: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for RelatedItems {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.RelatedItems").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RelatedItems {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for RelatedItems {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:StoreItem.IncludedItems)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct IncludedItems {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.IncludedItems.included_apps)
        pub included_apps: ::std::vec::Vec<super::StoreItem>,
        // @@protoc_insertion_point(field:StoreItem.IncludedItems.included_packages)
        pub included_packages: ::std::vec::Vec<super::StoreItem>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.IncludedItems.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a IncludedItems {
        fn default() -> &'a IncludedItems {
            <IncludedItems as crate::Message>::default_instance()
        }
    }

    impl IncludedItems {
        pub fn new() -> IncludedItems {
            ::std::default::Default::default()
        }

        // repeated .StoreItem included_apps = 1;

        pub fn included_apps(&self) -> &[super::StoreItem] {
            &self.included_apps
        }

        pub fn clear_included_apps(&mut self) {
            self.included_apps.clear();
        }

        // Param is passed by value, moved
        pub fn set_included_apps(&mut self, v: ::std::vec::Vec<super::StoreItem>) {
            self.included_apps = v;
        }

        // Mutable pointer to the field.
        pub fn mut_included_apps(&mut self) -> &mut ::std::vec::Vec<super::StoreItem> {
            &mut self.included_apps
        }

        // Take field
        pub fn take_included_apps(&mut self) -> ::std::vec::Vec<super::StoreItem> {
            ::std::mem::replace(&mut self.included_apps, ::std::vec::Vec::new())
        }

        // repeated .StoreItem included_packages = 2;

        pub fn included_packages(&self) -> &[super::StoreItem] {
            &self.included_packages
        }

        pub fn clear_included_packages(&mut self) {
            self.included_packages.clear();
        }

        // Param is passed by value, moved
        pub fn set_included_packages(&mut self, v: ::std::vec::Vec<super::StoreItem>) {
            self.included_packages = v;
        }

        // Mutable pointer to the field.
        pub fn mut_included_packages(&mut self) -> &mut ::std::vec::Vec<super::StoreItem> {
            &mut self.included_packages
        }

        // Take field
        pub fn take_included_packages(&mut self) -> ::std::vec::Vec<super::StoreItem> {
            ::std::mem::replace(&mut self.included_packages, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "included_apps",
                |m: &IncludedItems| { &m.included_apps },
                |m: &mut IncludedItems| { &mut m.included_apps },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "included_packages",
                |m: &IncludedItems| { &m.included_packages },
                |m: &mut IncludedItems| { &mut m.included_packages },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<IncludedItems>(
                "StoreItem.IncludedItems",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for IncludedItems {
        const NAME: &'static str = "IncludedItems";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.included_apps.push(is.read_message()?);
                    },
                    18 => {
                        self.included_packages.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.included_apps {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.included_packages {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            for v in &self.included_apps {
                crate::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.included_packages {
                crate::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> IncludedItems {
            IncludedItems::new()
        }

        fn clear(&mut self) {
            self.included_apps.clear();
            self.included_packages.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static IncludedItems {
            static instance: IncludedItems = IncludedItems {
                included_apps: ::std::vec::Vec::new(),
                included_packages: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for IncludedItems {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.IncludedItems").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for IncludedItems {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for IncludedItems {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:StoreItem.Categories)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Categories {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Categories.supported_player_categoryids)
        pub supported_player_categoryids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:StoreItem.Categories.feature_categoryids)
        pub feature_categoryids: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:StoreItem.Categories.controller_categoryids)
        pub controller_categoryids: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Categories.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Categories {
        fn default() -> &'a Categories {
            <Categories as crate::Message>::default_instance()
        }
    }

    impl Categories {
        pub fn new() -> Categories {
            ::std::default::Default::default()
        }

        // repeated uint32 supported_player_categoryids = 2;

        pub fn supported_player_categoryids(&self) -> &[u32] {
            &self.supported_player_categoryids
        }

        pub fn clear_supported_player_categoryids(&mut self) {
            self.supported_player_categoryids.clear();
        }

        // Param is passed by value, moved
        pub fn set_supported_player_categoryids(&mut self, v: ::std::vec::Vec<u32>) {
            self.supported_player_categoryids = v;
        }

        // Mutable pointer to the field.
        pub fn mut_supported_player_categoryids(&mut self) -> &mut ::std::vec::Vec<u32> {
            &mut self.supported_player_categoryids
        }

        // Take field
        pub fn take_supported_player_categoryids(&mut self) -> ::std::vec::Vec<u32> {
            ::std::mem::replace(&mut self.supported_player_categoryids, ::std::vec::Vec::new())
        }

        // repeated uint32 feature_categoryids = 3;

        pub fn feature_categoryids(&self) -> &[u32] {
            &self.feature_categoryids
        }

        pub fn clear_feature_categoryids(&mut self) {
            self.feature_categoryids.clear();
        }

        // Param is passed by value, moved
        pub fn set_feature_categoryids(&mut self, v: ::std::vec::Vec<u32>) {
            self.feature_categoryids = v;
        }

        // Mutable pointer to the field.
        pub fn mut_feature_categoryids(&mut self) -> &mut ::std::vec::Vec<u32> {
            &mut self.feature_categoryids
        }

        // Take field
        pub fn take_feature_categoryids(&mut self) -> ::std::vec::Vec<u32> {
            ::std::mem::replace(&mut self.feature_categoryids, ::std::vec::Vec::new())
        }

        // repeated uint32 controller_categoryids = 4;

        pub fn controller_categoryids(&self) -> &[u32] {
            &self.controller_categoryids
        }

        pub fn clear_controller_categoryids(&mut self) {
            self.controller_categoryids.clear();
        }

        // Param is passed by value, moved
        pub fn set_controller_categoryids(&mut self, v: ::std::vec::Vec<u32>) {
            self.controller_categoryids = v;
        }

        // Mutable pointer to the field.
        pub fn mut_controller_categoryids(&mut self) -> &mut ::std::vec::Vec<u32> {
            &mut self.controller_categoryids
        }

        // Take field
        pub fn take_controller_categoryids(&mut self) -> ::std::vec::Vec<u32> {
            ::std::mem::replace(&mut self.controller_categoryids, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "supported_player_categoryids",
                |m: &Categories| { &m.supported_player_categoryids },
                |m: &mut Categories| { &mut m.supported_player_categoryids },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "feature_categoryids",
                |m: &Categories| { &m.feature_categoryids },
                |m: &mut Categories| { &mut m.feature_categoryids },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "controller_categoryids",
                |m: &Categories| { &m.controller_categoryids },
                |m: &mut Categories| { &mut m.controller_categoryids },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Categories>(
                "StoreItem.Categories",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Categories {
        const NAME: &'static str = "Categories";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.supported_player_categoryids)?;
                    },
                    16 => {
                        self.supported_player_categoryids.push(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.feature_categoryids)?;
                    },
                    24 => {
                        self.feature_categoryids.push(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint32_into(&mut self.controller_categoryids)?;
                    },
                    32 => {
                        self.controller_categoryids.push(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.supported_player_categoryids {
                my_size += crate::rt::uint32_size(2, *value);
            };
            for value in &self.feature_categoryids {
                my_size += crate::rt::uint32_size(3, *value);
            };
            for value in &self.controller_categoryids {
                my_size += crate::rt::uint32_size(4, *value);
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            for v in &self.supported_player_categoryids {
                os.write_uint32(2, *v)?;
            };
            for v in &self.feature_categoryids {
                os.write_uint32(3, *v)?;
            };
            for v in &self.controller_categoryids {
                os.write_uint32(4, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Categories {
            Categories::new()
        }

        fn clear(&mut self) {
            self.supported_player_categoryids.clear();
            self.feature_categoryids.clear();
            self.controller_categoryids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Categories {
            static instance: Categories = Categories {
                supported_player_categoryids: ::std::vec::Vec::new(),
                feature_categoryids: ::std::vec::Vec::new(),
                controller_categoryids: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Categories {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.Categories").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Categories {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Categories {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:StoreItem.Reviews)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Reviews {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Reviews.summary_filtered)
        pub summary_filtered: crate::MessageField<reviews::StoreReviewSummary>,
        // @@protoc_insertion_point(field:StoreItem.Reviews.summary_unfiltered)
        pub summary_unfiltered: crate::MessageField<reviews::StoreReviewSummary>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Reviews.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Reviews {
        fn default() -> &'a Reviews {
            <Reviews as crate::Message>::default_instance()
        }
    }

    impl Reviews {
        pub fn new() -> Reviews {
            ::std::default::Default::default()
        }

        // optional .StoreItem.Reviews.StoreReviewSummary summary_filtered = 1;

        pub fn summary_filtered(&self) -> &reviews::StoreReviewSummary {
            self.summary_filtered.as_ref().unwrap_or_else(|| <reviews::StoreReviewSummary as crate::Message>::default_instance())
        }

        pub fn clear_summary_filtered(&mut self) {
            self.summary_filtered.clear();
        }

        pub fn has_summary_filtered(&self) -> bool {
            self.summary_filtered.is_some()
        }

        // Param is passed by value, moved
        pub fn set_summary_filtered(&mut self, v: reviews::StoreReviewSummary) {
            self.summary_filtered = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_summary_filtered(&mut self) -> &mut reviews::StoreReviewSummary {
            self.summary_filtered.mut_or_insert_default()
        }

        // Take field
        pub fn take_summary_filtered(&mut self) -> reviews::StoreReviewSummary {
            self.summary_filtered.take().unwrap_or_else(|| reviews::StoreReviewSummary::new())
        }

        // optional .StoreItem.Reviews.StoreReviewSummary summary_unfiltered = 2;

        pub fn summary_unfiltered(&self) -> &reviews::StoreReviewSummary {
            self.summary_unfiltered.as_ref().unwrap_or_else(|| <reviews::StoreReviewSummary as crate::Message>::default_instance())
        }

        pub fn clear_summary_unfiltered(&mut self) {
            self.summary_unfiltered.clear();
        }

        pub fn has_summary_unfiltered(&self) -> bool {
            self.summary_unfiltered.is_some()
        }

        // Param is passed by value, moved
        pub fn set_summary_unfiltered(&mut self, v: reviews::StoreReviewSummary) {
            self.summary_unfiltered = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_summary_unfiltered(&mut self) -> &mut reviews::StoreReviewSummary {
            self.summary_unfiltered.mut_or_insert_default()
        }

        // Take field
        pub fn take_summary_unfiltered(&mut self) -> reviews::StoreReviewSummary {
            self.summary_unfiltered.take().unwrap_or_else(|| reviews::StoreReviewSummary::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, reviews::StoreReviewSummary>(
                "summary_filtered",
                |m: &Reviews| { &m.summary_filtered },
                |m: &mut Reviews| { &mut m.summary_filtered },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, reviews::StoreReviewSummary>(
                "summary_unfiltered",
                |m: &Reviews| { &m.summary_unfiltered },
                |m: &mut Reviews| { &mut m.summary_unfiltered },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Reviews>(
                "StoreItem.Reviews",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Reviews {
        const NAME: &'static str = "Reviews";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.summary_filtered)?;
                    },
                    18 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.summary_unfiltered)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.summary_filtered.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.summary_unfiltered.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.summary_filtered.as_ref() {
                crate::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.summary_unfiltered.as_ref() {
                crate::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Reviews {
            Reviews::new()
        }

        fn clear(&mut self) {
            self.summary_filtered.clear();
            self.summary_unfiltered.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Reviews {
            static instance: Reviews = Reviews {
                summary_filtered: crate::MessageField::none(),
                summary_unfiltered: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Reviews {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.Reviews").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Reviews {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Reviews {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Reviews`
    pub mod reviews {
        // @@protoc_insertion_point(message:StoreItem.Reviews.StoreReviewSummary)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct StoreReviewSummary {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Reviews.StoreReviewSummary.review_count)
            pub review_count: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:StoreItem.Reviews.StoreReviewSummary.percent_positive)
            pub percent_positive: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:StoreItem.Reviews.StoreReviewSummary.review_score)
            pub review_score: ::std::option::Option<crate::EnumOrUnknown<super::super::EUserReviewScore>>,
            // @@protoc_insertion_point(field:StoreItem.Reviews.StoreReviewSummary.review_score_label)
            pub review_score_label: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Reviews.StoreReviewSummary.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a StoreReviewSummary {
            fn default() -> &'a StoreReviewSummary {
                <StoreReviewSummary as crate::Message>::default_instance()
            }
        }

        impl StoreReviewSummary {
            pub fn new() -> StoreReviewSummary {
                ::std::default::Default::default()
            }

            // optional uint32 review_count = 1;

            pub fn review_count(&self) -> u32 {
                self.review_count.unwrap_or(0)
            }

            pub fn clear_review_count(&mut self) {
                self.review_count = ::std::option::Option::None;
            }

            pub fn has_review_count(&self) -> bool {
                self.review_count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_review_count(&mut self, v: u32) {
                self.review_count = ::std::option::Option::Some(v);
            }

            // optional int32 percent_positive = 2;

            pub fn percent_positive(&self) -> i32 {
                self.percent_positive.unwrap_or(0)
            }

            pub fn clear_percent_positive(&mut self) {
                self.percent_positive = ::std::option::Option::None;
            }

            pub fn has_percent_positive(&self) -> bool {
                self.percent_positive.is_some()
            }

            // Param is passed by value, moved
            pub fn set_percent_positive(&mut self, v: i32) {
                self.percent_positive = ::std::option::Option::Some(v);
            }

            // optional .EUserReviewScore review_score = 3;

            pub fn review_score(&self) -> super::super::EUserReviewScore {
                match self.review_score {
                    Some(e) => e.enum_value_or(super::super::EUserReviewScore::k_EUserReviewScore_None),
                    None => super::super::EUserReviewScore::k_EUserReviewScore_None,
                }
            }

            pub fn clear_review_score(&mut self) {
                self.review_score = ::std::option::Option::None;
            }

            pub fn has_review_score(&self) -> bool {
                self.review_score.is_some()
            }

            // Param is passed by value, moved
            pub fn set_review_score(&mut self, v: super::super::EUserReviewScore) {
                self.review_score = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
            }

            // optional string review_score_label = 4;

            pub fn review_score_label(&self) -> &str {
                match self.review_score_label.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_review_score_label(&mut self) {
                self.review_score_label = ::std::option::Option::None;
            }

            pub fn has_review_score_label(&self) -> bool {
                self.review_score_label.is_some()
            }

            // Param is passed by value, moved
            pub fn set_review_score_label(&mut self, v: ::std::string::String) {
                self.review_score_label = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_review_score_label(&mut self) -> &mut ::std::string::String {
                if self.review_score_label.is_none() {
                    self.review_score_label = ::std::option::Option::Some(::std::string::String::new());
                }
                self.review_score_label.as_mut().unwrap()
            }

            // Take field
            pub fn take_review_score_label(&mut self) -> ::std::string::String {
                self.review_score_label.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "review_count",
                    |m: &StoreReviewSummary| { &m.review_count },
                    |m: &mut StoreReviewSummary| { &mut m.review_count },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "percent_positive",
                    |m: &StoreReviewSummary| { &m.percent_positive },
                    |m: &mut StoreReviewSummary| { &mut m.percent_positive },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "review_score",
                    |m: &StoreReviewSummary| { &m.review_score },
                    |m: &mut StoreReviewSummary| { &mut m.review_score },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "review_score_label",
                    |m: &StoreReviewSummary| { &m.review_score_label },
                    |m: &mut StoreReviewSummary| { &mut m.review_score_label },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<StoreReviewSummary>(
                    "StoreItem.Reviews.StoreReviewSummary",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for StoreReviewSummary {
            const NAME: &'static str = "StoreReviewSummary";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.review_count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.percent_positive = ::std::option::Option::Some(is.read_int32()?);
                        },
                        24 => {
                            self.review_score = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        34 => {
                            self.review_score_label = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.review_count {
                    my_size += crate::rt::uint32_size(1, v);
                }
                if let Some(v) = self.percent_positive {
                    my_size += crate::rt::int32_size(2, v);
                }
                if let Some(v) = self.review_score {
                    my_size += crate::rt::int32_size(3, v.value());
                }
                if let Some(v) = self.review_score_label.as_ref() {
                    my_size += crate::rt::string_size(4, &v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.review_count {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.percent_positive {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.review_score {
                    os.write_enum(3, crate::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.review_score_label.as_ref() {
                    os.write_string(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> StoreReviewSummary {
                StoreReviewSummary::new()
            }

            fn clear(&mut self) {
                self.review_count = ::std::option::Option::None;
                self.percent_positive = ::std::option::Option::None;
                self.review_score = ::std::option::Option::None;
                self.review_score_label = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static StoreReviewSummary {
                static instance: StoreReviewSummary = StoreReviewSummary {
                    review_count: ::std::option::Option::None,
                    percent_positive: ::std::option::Option::None,
                    review_score: ::std::option::Option::None,
                    review_score_label: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for StoreReviewSummary {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StoreItem.Reviews.StoreReviewSummary").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for StoreReviewSummary {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for StoreReviewSummary {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:StoreItem.BasicInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BasicInfo {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.short_description)
        pub short_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.publishers)
        pub publishers: ::std::vec::Vec<basic_info::CreatorHomeLink>,
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.developers)
        pub developers: ::std::vec::Vec<basic_info::CreatorHomeLink>,
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.franchises)
        pub franchises: ::std::vec::Vec<basic_info::CreatorHomeLink>,
        // @@protoc_insertion_point(field:StoreItem.BasicInfo.capsule_headline)
        pub capsule_headline: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.BasicInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BasicInfo {
        fn default() -> &'a BasicInfo {
            <BasicInfo as crate::Message>::default_instance()
        }
    }

    impl BasicInfo {
        pub fn new() -> BasicInfo {
            ::std::default::Default::default()
        }

        // optional string short_description = 1;

        pub fn short_description(&self) -> &str {
            match self.short_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_short_description(&mut self) {
            self.short_description = ::std::option::Option::None;
        }

        pub fn has_short_description(&self) -> bool {
            self.short_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_short_description(&mut self, v: ::std::string::String) {
            self.short_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_short_description(&mut self) -> &mut ::std::string::String {
            if self.short_description.is_none() {
                self.short_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.short_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_short_description(&mut self) -> ::std::string::String {
            self.short_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // repeated .StoreItem.BasicInfo.CreatorHomeLink publishers = 2;

        pub fn publishers(&self) -> &[basic_info::CreatorHomeLink] {
            &self.publishers
        }

        pub fn clear_publishers(&mut self) {
            self.publishers.clear();
        }

        // Param is passed by value, moved
        pub fn set_publishers(&mut self, v: ::std::vec::Vec<basic_info::CreatorHomeLink>) {
            self.publishers = v;
        }

        // Mutable pointer to the field.
        pub fn mut_publishers(&mut self) -> &mut ::std::vec::Vec<basic_info::CreatorHomeLink> {
            &mut self.publishers
        }

        // Take field
        pub fn take_publishers(&mut self) -> ::std::vec::Vec<basic_info::CreatorHomeLink> {
            ::std::mem::replace(&mut self.publishers, ::std::vec::Vec::new())
        }

        // repeated .StoreItem.BasicInfo.CreatorHomeLink developers = 3;

        pub fn developers(&self) -> &[basic_info::CreatorHomeLink] {
            &self.developers
        }

        pub fn clear_developers(&mut self) {
            self.developers.clear();
        }

        // Param is passed by value, moved
        pub fn set_developers(&mut self, v: ::std::vec::Vec<basic_info::CreatorHomeLink>) {
            self.developers = v;
        }

        // Mutable pointer to the field.
        pub fn mut_developers(&mut self) -> &mut ::std::vec::Vec<basic_info::CreatorHomeLink> {
            &mut self.developers
        }

        // Take field
        pub fn take_developers(&mut self) -> ::std::vec::Vec<basic_info::CreatorHomeLink> {
            ::std::mem::replace(&mut self.developers, ::std::vec::Vec::new())
        }

        // repeated .StoreItem.BasicInfo.CreatorHomeLink franchises = 4;

        pub fn franchises(&self) -> &[basic_info::CreatorHomeLink] {
            &self.franchises
        }

        pub fn clear_franchises(&mut self) {
            self.franchises.clear();
        }

        // Param is passed by value, moved
        pub fn set_franchises(&mut self, v: ::std::vec::Vec<basic_info::CreatorHomeLink>) {
            self.franchises = v;
        }

        // Mutable pointer to the field.
        pub fn mut_franchises(&mut self) -> &mut ::std::vec::Vec<basic_info::CreatorHomeLink> {
            &mut self.franchises
        }

        // Take field
        pub fn take_franchises(&mut self) -> ::std::vec::Vec<basic_info::CreatorHomeLink> {
            ::std::mem::replace(&mut self.franchises, ::std::vec::Vec::new())
        }

        // optional string capsule_headline = 5;

        pub fn capsule_headline(&self) -> &str {
            match self.capsule_headline.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_capsule_headline(&mut self) {
            self.capsule_headline = ::std::option::Option::None;
        }

        pub fn has_capsule_headline(&self) -> bool {
            self.capsule_headline.is_some()
        }

        // Param is passed by value, moved
        pub fn set_capsule_headline(&mut self, v: ::std::string::String) {
            self.capsule_headline = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_capsule_headline(&mut self) -> &mut ::std::string::String {
            if self.capsule_headline.is_none() {
                self.capsule_headline = ::std::option::Option::Some(::std::string::String::new());
            }
            self.capsule_headline.as_mut().unwrap()
        }

        // Take field
        pub fn take_capsule_headline(&mut self) -> ::std::string::String {
            self.capsule_headline.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "short_description",
                |m: &BasicInfo| { &m.short_description },
                |m: &mut BasicInfo| { &mut m.short_description },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "publishers",
                |m: &BasicInfo| { &m.publishers },
                |m: &mut BasicInfo| { &mut m.publishers },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "developers",
                |m: &BasicInfo| { &m.developers },
                |m: &mut BasicInfo| { &mut m.developers },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "franchises",
                |m: &BasicInfo| { &m.franchises },
                |m: &mut BasicInfo| { &mut m.franchises },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "capsule_headline",
                |m: &BasicInfo| { &m.capsule_headline },
                |m: &mut BasicInfo| { &mut m.capsule_headline },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<BasicInfo>(
                "StoreItem.BasicInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for BasicInfo {
        const NAME: &'static str = "BasicInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.short_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.publishers.push(is.read_message()?);
                    },
                    26 => {
                        self.developers.push(is.read_message()?);
                    },
                    34 => {
                        self.franchises.push(is.read_message()?);
                    },
                    42 => {
                        self.capsule_headline = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.short_description.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            for value in &self.publishers {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.developers {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.franchises {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.capsule_headline.as_ref() {
                my_size += crate::rt::string_size(5, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.short_description.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.publishers {
                crate::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.developers {
                crate::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.franchises {
                crate::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            if let Some(v) = self.capsule_headline.as_ref() {
                os.write_string(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BasicInfo {
            BasicInfo::new()
        }

        fn clear(&mut self) {
            self.short_description = ::std::option::Option::None;
            self.publishers.clear();
            self.developers.clear();
            self.franchises.clear();
            self.capsule_headline = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BasicInfo {
            static instance: BasicInfo = BasicInfo {
                short_description: ::std::option::Option::None,
                publishers: ::std::vec::Vec::new(),
                developers: ::std::vec::Vec::new(),
                franchises: ::std::vec::Vec::new(),
                capsule_headline: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for BasicInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.BasicInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for BasicInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for BasicInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `BasicInfo`
    pub mod basic_info {
        // @@protoc_insertion_point(message:StoreItem.BasicInfo.CreatorHomeLink)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CreatorHomeLink {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.BasicInfo.CreatorHomeLink.name)
            pub name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.BasicInfo.CreatorHomeLink.creator_clan_account_id)
            pub creator_clan_account_id: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.BasicInfo.CreatorHomeLink.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CreatorHomeLink {
            fn default() -> &'a CreatorHomeLink {
                <CreatorHomeLink as crate::Message>::default_instance()
            }
        }

        impl CreatorHomeLink {
            pub fn new() -> CreatorHomeLink {
                ::std::default::Default::default()
            }

            // optional string name = 1;

            pub fn name(&self) -> &str {
                match self.name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_name(&mut self) {
                self.name = ::std::option::Option::None;
            }

            pub fn has_name(&self) -> bool {
                self.name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_name(&mut self, v: ::std::string::String) {
                self.name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_name(&mut self) -> &mut ::std::string::String {
                if self.name.is_none() {
                    self.name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.name.as_mut().unwrap()
            }

            // Take field
            pub fn take_name(&mut self) -> ::std::string::String {
                self.name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 creator_clan_account_id = 2;

            pub fn creator_clan_account_id(&self) -> u32 {
                self.creator_clan_account_id.unwrap_or(0)
            }

            pub fn clear_creator_clan_account_id(&mut self) {
                self.creator_clan_account_id = ::std::option::Option::None;
            }

            pub fn has_creator_clan_account_id(&self) -> bool {
                self.creator_clan_account_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_creator_clan_account_id(&mut self, v: u32) {
                self.creator_clan_account_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "name",
                    |m: &CreatorHomeLink| { &m.name },
                    |m: &mut CreatorHomeLink| { &mut m.name },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "creator_clan_account_id",
                    |m: &CreatorHomeLink| { &m.creator_clan_account_id },
                    |m: &mut CreatorHomeLink| { &mut m.creator_clan_account_id },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<CreatorHomeLink>(
                    "StoreItem.BasicInfo.CreatorHomeLink",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for CreatorHomeLink {
            const NAME: &'static str = "CreatorHomeLink";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.name = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.creator_clan_account_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.name.as_ref() {
                    my_size += crate::rt::string_size(1, &v);
                }
                if let Some(v) = self.creator_clan_account_id {
                    my_size += crate::rt::uint32_size(2, v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.creator_clan_account_id {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CreatorHomeLink {
                CreatorHomeLink::new()
            }

            fn clear(&mut self) {
                self.name = ::std::option::Option::None;
                self.creator_clan_account_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CreatorHomeLink {
                static instance: CreatorHomeLink = CreatorHomeLink {
                    name: ::std::option::Option::None,
                    creator_clan_account_id: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for CreatorHomeLink {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StoreItem.BasicInfo.CreatorHomeLink").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for CreatorHomeLink {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for CreatorHomeLink {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Tag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tag {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Tag.tagid)
        pub tagid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.Tag.weight)
        pub weight: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Tag.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tag {
        fn default() -> &'a Tag {
            <Tag as crate::Message>::default_instance()
        }
    }

    impl Tag {
        pub fn new() -> Tag {
            ::std::default::Default::default()
        }

        // optional uint32 tagid = 1;

        pub fn tagid(&self) -> u32 {
            self.tagid.unwrap_or(0)
        }

        pub fn clear_tagid(&mut self) {
            self.tagid = ::std::option::Option::None;
        }

        pub fn has_tagid(&self) -> bool {
            self.tagid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tagid(&mut self, v: u32) {
            self.tagid = ::std::option::Option::Some(v);
        }

        // optional uint32 weight = 2;

        pub fn weight(&self) -> u32 {
            self.weight.unwrap_or(0)
        }

        pub fn clear_weight(&mut self) {
            self.weight = ::std::option::Option::None;
        }

        pub fn has_weight(&self) -> bool {
            self.weight.is_some()
        }

        // Param is passed by value, moved
        pub fn set_weight(&mut self, v: u32) {
            self.weight = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "tagid",
                |m: &Tag| { &m.tagid },
                |m: &mut Tag| { &mut m.tagid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "weight",
                |m: &Tag| { &m.weight },
                |m: &mut Tag| { &mut m.weight },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Tag>(
                "StoreItem.Tag",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Tag {
        const NAME: &'static str = "Tag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tagid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.weight = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tagid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.weight {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.tagid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.weight {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tag {
            Tag::new()
        }

        fn clear(&mut self) {
            self.tagid = ::std::option::Option::None;
            self.weight = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tag {
            static instance: Tag = Tag {
                tagid: ::std::option::Option::None,
                weight: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Tag {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.Tag").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Tag {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Tag {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:StoreItem.Assets)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Assets {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Assets.asset_url_format)
        pub asset_url_format: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.main_capsule)
        pub main_capsule: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.small_capsule)
        pub small_capsule: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.header)
        pub header: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.package_header)
        pub package_header: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.page_background)
        pub page_background: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.hero_capsule)
        pub hero_capsule: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.hero_capsule_2x)
        pub hero_capsule_2x: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.library_capsule)
        pub library_capsule: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.library_capsule_2x)
        pub library_capsule_2x: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.library_hero)
        pub library_hero: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.library_hero_2x)
        pub library_hero_2x: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.community_icon)
        pub community_icon: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.Assets.clan_avatar)
        pub clan_avatar: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Assets.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Assets {
        fn default() -> &'a Assets {
            <Assets as crate::Message>::default_instance()
        }
    }

    impl Assets {
        pub fn new() -> Assets {
            ::std::default::Default::default()
        }

        // optional string asset_url_format = 1;

        pub fn asset_url_format(&self) -> &str {
            match self.asset_url_format.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_asset_url_format(&mut self) {
            self.asset_url_format = ::std::option::Option::None;
        }

        pub fn has_asset_url_format(&self) -> bool {
            self.asset_url_format.is_some()
        }

        // Param is passed by value, moved
        pub fn set_asset_url_format(&mut self, v: ::std::string::String) {
            self.asset_url_format = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_asset_url_format(&mut self) -> &mut ::std::string::String {
            if self.asset_url_format.is_none() {
                self.asset_url_format = ::std::option::Option::Some(::std::string::String::new());
            }
            self.asset_url_format.as_mut().unwrap()
        }

        // Take field
        pub fn take_asset_url_format(&mut self) -> ::std::string::String {
            self.asset_url_format.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string main_capsule = 2;

        pub fn main_capsule(&self) -> &str {
            match self.main_capsule.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_main_capsule(&mut self) {
            self.main_capsule = ::std::option::Option::None;
        }

        pub fn has_main_capsule(&self) -> bool {
            self.main_capsule.is_some()
        }

        // Param is passed by value, moved
        pub fn set_main_capsule(&mut self, v: ::std::string::String) {
            self.main_capsule = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_main_capsule(&mut self) -> &mut ::std::string::String {
            if self.main_capsule.is_none() {
                self.main_capsule = ::std::option::Option::Some(::std::string::String::new());
            }
            self.main_capsule.as_mut().unwrap()
        }

        // Take field
        pub fn take_main_capsule(&mut self) -> ::std::string::String {
            self.main_capsule.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string small_capsule = 3;

        pub fn small_capsule(&self) -> &str {
            match self.small_capsule.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_small_capsule(&mut self) {
            self.small_capsule = ::std::option::Option::None;
        }

        pub fn has_small_capsule(&self) -> bool {
            self.small_capsule.is_some()
        }

        // Param is passed by value, moved
        pub fn set_small_capsule(&mut self, v: ::std::string::String) {
            self.small_capsule = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_small_capsule(&mut self) -> &mut ::std::string::String {
            if self.small_capsule.is_none() {
                self.small_capsule = ::std::option::Option::Some(::std::string::String::new());
            }
            self.small_capsule.as_mut().unwrap()
        }

        // Take field
        pub fn take_small_capsule(&mut self) -> ::std::string::String {
            self.small_capsule.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string header = 4;

        pub fn header(&self) -> &str {
            match self.header.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_header(&mut self) {
            self.header = ::std::option::Option::None;
        }

        pub fn has_header(&self) -> bool {
            self.header.is_some()
        }

        // Param is passed by value, moved
        pub fn set_header(&mut self, v: ::std::string::String) {
            self.header = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_header(&mut self) -> &mut ::std::string::String {
            if self.header.is_none() {
                self.header = ::std::option::Option::Some(::std::string::String::new());
            }
            self.header.as_mut().unwrap()
        }

        // Take field
        pub fn take_header(&mut self) -> ::std::string::String {
            self.header.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string package_header = 5;

        pub fn package_header(&self) -> &str {
            match self.package_header.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_package_header(&mut self) {
            self.package_header = ::std::option::Option::None;
        }

        pub fn has_package_header(&self) -> bool {
            self.package_header.is_some()
        }

        // Param is passed by value, moved
        pub fn set_package_header(&mut self, v: ::std::string::String) {
            self.package_header = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_package_header(&mut self) -> &mut ::std::string::String {
            if self.package_header.is_none() {
                self.package_header = ::std::option::Option::Some(::std::string::String::new());
            }
            self.package_header.as_mut().unwrap()
        }

        // Take field
        pub fn take_package_header(&mut self) -> ::std::string::String {
            self.package_header.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string page_background = 6;

        pub fn page_background(&self) -> &str {
            match self.page_background.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_page_background(&mut self) {
            self.page_background = ::std::option::Option::None;
        }

        pub fn has_page_background(&self) -> bool {
            self.page_background.is_some()
        }

        // Param is passed by value, moved
        pub fn set_page_background(&mut self, v: ::std::string::String) {
            self.page_background = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_page_background(&mut self) -> &mut ::std::string::String {
            if self.page_background.is_none() {
                self.page_background = ::std::option::Option::Some(::std::string::String::new());
            }
            self.page_background.as_mut().unwrap()
        }

        // Take field
        pub fn take_page_background(&mut self) -> ::std::string::String {
            self.page_background.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string hero_capsule = 7;

        pub fn hero_capsule(&self) -> &str {
            match self.hero_capsule.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hero_capsule(&mut self) {
            self.hero_capsule = ::std::option::Option::None;
        }

        pub fn has_hero_capsule(&self) -> bool {
            self.hero_capsule.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_capsule(&mut self, v: ::std::string::String) {
            self.hero_capsule = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hero_capsule(&mut self) -> &mut ::std::string::String {
            if self.hero_capsule.is_none() {
                self.hero_capsule = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hero_capsule.as_mut().unwrap()
        }

        // Take field
        pub fn take_hero_capsule(&mut self) -> ::std::string::String {
            self.hero_capsule.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string hero_capsule_2x = 8;

        pub fn hero_capsule_2x(&self) -> &str {
            match self.hero_capsule_2x.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_hero_capsule_2x(&mut self) {
            self.hero_capsule_2x = ::std::option::Option::None;
        }

        pub fn has_hero_capsule_2x(&self) -> bool {
            self.hero_capsule_2x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_capsule_2x(&mut self, v: ::std::string::String) {
            self.hero_capsule_2x = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_hero_capsule_2x(&mut self) -> &mut ::std::string::String {
            if self.hero_capsule_2x.is_none() {
                self.hero_capsule_2x = ::std::option::Option::Some(::std::string::String::new());
            }
            self.hero_capsule_2x.as_mut().unwrap()
        }

        // Take field
        pub fn take_hero_capsule_2x(&mut self) -> ::std::string::String {
            self.hero_capsule_2x.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string library_capsule = 9;

        pub fn library_capsule(&self) -> &str {
            match self.library_capsule.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_library_capsule(&mut self) {
            self.library_capsule = ::std::option::Option::None;
        }

        pub fn has_library_capsule(&self) -> bool {
            self.library_capsule.is_some()
        }

        // Param is passed by value, moved
        pub fn set_library_capsule(&mut self, v: ::std::string::String) {
            self.library_capsule = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_library_capsule(&mut self) -> &mut ::std::string::String {
            if self.library_capsule.is_none() {
                self.library_capsule = ::std::option::Option::Some(::std::string::String::new());
            }
            self.library_capsule.as_mut().unwrap()
        }

        // Take field
        pub fn take_library_capsule(&mut self) -> ::std::string::String {
            self.library_capsule.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string library_capsule_2x = 10;

        pub fn library_capsule_2x(&self) -> &str {
            match self.library_capsule_2x.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_library_capsule_2x(&mut self) {
            self.library_capsule_2x = ::std::option::Option::None;
        }

        pub fn has_library_capsule_2x(&self) -> bool {
            self.library_capsule_2x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_library_capsule_2x(&mut self, v: ::std::string::String) {
            self.library_capsule_2x = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_library_capsule_2x(&mut self) -> &mut ::std::string::String {
            if self.library_capsule_2x.is_none() {
                self.library_capsule_2x = ::std::option::Option::Some(::std::string::String::new());
            }
            self.library_capsule_2x.as_mut().unwrap()
        }

        // Take field
        pub fn take_library_capsule_2x(&mut self) -> ::std::string::String {
            self.library_capsule_2x.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string library_hero = 11;

        pub fn library_hero(&self) -> &str {
            match self.library_hero.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_library_hero(&mut self) {
            self.library_hero = ::std::option::Option::None;
        }

        pub fn has_library_hero(&self) -> bool {
            self.library_hero.is_some()
        }

        // Param is passed by value, moved
        pub fn set_library_hero(&mut self, v: ::std::string::String) {
            self.library_hero = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_library_hero(&mut self) -> &mut ::std::string::String {
            if self.library_hero.is_none() {
                self.library_hero = ::std::option::Option::Some(::std::string::String::new());
            }
            self.library_hero.as_mut().unwrap()
        }

        // Take field
        pub fn take_library_hero(&mut self) -> ::std::string::String {
            self.library_hero.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string library_hero_2x = 12;

        pub fn library_hero_2x(&self) -> &str {
            match self.library_hero_2x.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_library_hero_2x(&mut self) {
            self.library_hero_2x = ::std::option::Option::None;
        }

        pub fn has_library_hero_2x(&self) -> bool {
            self.library_hero_2x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_library_hero_2x(&mut self, v: ::std::string::String) {
            self.library_hero_2x = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_library_hero_2x(&mut self) -> &mut ::std::string::String {
            if self.library_hero_2x.is_none() {
                self.library_hero_2x = ::std::option::Option::Some(::std::string::String::new());
            }
            self.library_hero_2x.as_mut().unwrap()
        }

        // Take field
        pub fn take_library_hero_2x(&mut self) -> ::std::string::String {
            self.library_hero_2x.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string community_icon = 13;

        pub fn community_icon(&self) -> &str {
            match self.community_icon.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_community_icon(&mut self) {
            self.community_icon = ::std::option::Option::None;
        }

        pub fn has_community_icon(&self) -> bool {
            self.community_icon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_community_icon(&mut self, v: ::std::string::String) {
            self.community_icon = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_community_icon(&mut self) -> &mut ::std::string::String {
            if self.community_icon.is_none() {
                self.community_icon = ::std::option::Option::Some(::std::string::String::new());
            }
            self.community_icon.as_mut().unwrap()
        }

        // Take field
        pub fn take_community_icon(&mut self) -> ::std::string::String {
            self.community_icon.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string clan_avatar = 14;

        pub fn clan_avatar(&self) -> &str {
            match self.clan_avatar.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_clan_avatar(&mut self) {
            self.clan_avatar = ::std::option::Option::None;
        }

        pub fn has_clan_avatar(&self) -> bool {
            self.clan_avatar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_clan_avatar(&mut self, v: ::std::string::String) {
            self.clan_avatar = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_clan_avatar(&mut self) -> &mut ::std::string::String {
            if self.clan_avatar.is_none() {
                self.clan_avatar = ::std::option::Option::Some(::std::string::String::new());
            }
            self.clan_avatar.as_mut().unwrap()
        }

        // Take field
        pub fn take_clan_avatar(&mut self) -> ::std::string::String {
            self.clan_avatar.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(14);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "asset_url_format",
                |m: &Assets| { &m.asset_url_format },
                |m: &mut Assets| { &mut m.asset_url_format },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "main_capsule",
                |m: &Assets| { &m.main_capsule },
                |m: &mut Assets| { &mut m.main_capsule },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "small_capsule",
                |m: &Assets| { &m.small_capsule },
                |m: &mut Assets| { &mut m.small_capsule },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "header",
                |m: &Assets| { &m.header },
                |m: &mut Assets| { &mut m.header },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "package_header",
                |m: &Assets| { &m.package_header },
                |m: &mut Assets| { &mut m.package_header },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "page_background",
                |m: &Assets| { &m.page_background },
                |m: &mut Assets| { &mut m.page_background },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_capsule",
                |m: &Assets| { &m.hero_capsule },
                |m: &mut Assets| { &mut m.hero_capsule },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "hero_capsule_2x",
                |m: &Assets| { &m.hero_capsule_2x },
                |m: &mut Assets| { &mut m.hero_capsule_2x },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "library_capsule",
                |m: &Assets| { &m.library_capsule },
                |m: &mut Assets| { &mut m.library_capsule },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "library_capsule_2x",
                |m: &Assets| { &m.library_capsule_2x },
                |m: &mut Assets| { &mut m.library_capsule_2x },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "library_hero",
                |m: &Assets| { &m.library_hero },
                |m: &mut Assets| { &mut m.library_hero },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "library_hero_2x",
                |m: &Assets| { &m.library_hero_2x },
                |m: &mut Assets| { &mut m.library_hero_2x },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "community_icon",
                |m: &Assets| { &m.community_icon },
                |m: &mut Assets| { &mut m.community_icon },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "clan_avatar",
                |m: &Assets| { &m.clan_avatar },
                |m: &mut Assets| { &mut m.clan_avatar },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Assets>(
                "StoreItem.Assets",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Assets {
        const NAME: &'static str = "Assets";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.asset_url_format = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.main_capsule = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.small_capsule = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.header = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.package_header = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.page_background = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.hero_capsule = ::std::option::Option::Some(is.read_string()?);
                    },
                    66 => {
                        self.hero_capsule_2x = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.library_capsule = ::std::option::Option::Some(is.read_string()?);
                    },
                    82 => {
                        self.library_capsule_2x = ::std::option::Option::Some(is.read_string()?);
                    },
                    90 => {
                        self.library_hero = ::std::option::Option::Some(is.read_string()?);
                    },
                    98 => {
                        self.library_hero_2x = ::std::option::Option::Some(is.read_string()?);
                    },
                    106 => {
                        self.community_icon = ::std::option::Option::Some(is.read_string()?);
                    },
                    114 => {
                        self.clan_avatar = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.asset_url_format.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.main_capsule.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.small_capsule.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.header.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.package_header.as_ref() {
                my_size += crate::rt::string_size(5, &v);
            }
            if let Some(v) = self.page_background.as_ref() {
                my_size += crate::rt::string_size(6, &v);
            }
            if let Some(v) = self.hero_capsule.as_ref() {
                my_size += crate::rt::string_size(7, &v);
            }
            if let Some(v) = self.hero_capsule_2x.as_ref() {
                my_size += crate::rt::string_size(8, &v);
            }
            if let Some(v) = self.library_capsule.as_ref() {
                my_size += crate::rt::string_size(9, &v);
            }
            if let Some(v) = self.library_capsule_2x.as_ref() {
                my_size += crate::rt::string_size(10, &v);
            }
            if let Some(v) = self.library_hero.as_ref() {
                my_size += crate::rt::string_size(11, &v);
            }
            if let Some(v) = self.library_hero_2x.as_ref() {
                my_size += crate::rt::string_size(12, &v);
            }
            if let Some(v) = self.community_icon.as_ref() {
                my_size += crate::rt::string_size(13, &v);
            }
            if let Some(v) = self.clan_avatar.as_ref() {
                my_size += crate::rt::string_size(14, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.asset_url_format.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.main_capsule.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.small_capsule.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.header.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.package_header.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.page_background.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.hero_capsule.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.hero_capsule_2x.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.library_capsule.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.library_capsule_2x.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.library_hero.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.library_hero_2x.as_ref() {
                os.write_string(12, v)?;
            }
            if let Some(v) = self.community_icon.as_ref() {
                os.write_string(13, v)?;
            }
            if let Some(v) = self.clan_avatar.as_ref() {
                os.write_string(14, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Assets {
            Assets::new()
        }

        fn clear(&mut self) {
            self.asset_url_format = ::std::option::Option::None;
            self.main_capsule = ::std::option::Option::None;
            self.small_capsule = ::std::option::Option::None;
            self.header = ::std::option::Option::None;
            self.package_header = ::std::option::Option::None;
            self.page_background = ::std::option::Option::None;
            self.hero_capsule = ::std::option::Option::None;
            self.hero_capsule_2x = ::std::option::Option::None;
            self.library_capsule = ::std::option::Option::None;
            self.library_capsule_2x = ::std::option::Option::None;
            self.library_hero = ::std::option::Option::None;
            self.library_hero_2x = ::std::option::Option::None;
            self.community_icon = ::std::option::Option::None;
            self.clan_avatar = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Assets {
            static instance: Assets = Assets {
                asset_url_format: ::std::option::Option::None,
                main_capsule: ::std::option::Option::None,
                small_capsule: ::std::option::Option::None,
                header: ::std::option::Option::None,
                package_header: ::std::option::Option::None,
                page_background: ::std::option::Option::None,
                hero_capsule: ::std::option::Option::None,
                hero_capsule_2x: ::std::option::Option::None,
                library_capsule: ::std::option::Option::None,
                library_capsule_2x: ::std::option::Option::None,
                library_hero: ::std::option::Option::None,
                library_hero_2x: ::std::option::Option::None,
                community_icon: ::std::option::Option::None,
                clan_avatar: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Assets {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.Assets").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Assets {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Assets {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:StoreItem.ReleaseInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReleaseInfo {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.steam_release_date)
        pub steam_release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.original_release_date)
        pub original_release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.original_steam_release_date)
        pub original_steam_release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.is_coming_soon)
        pub is_coming_soon: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.is_preload)
        pub is_preload: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.custom_release_date_message)
        pub custom_release_date_message: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.is_abridged_release_date)
        pub is_abridged_release_date: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.coming_soon_display)
        pub coming_soon_display: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.is_early_access)
        pub is_early_access: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.mac_release_date)
        pub mac_release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.ReleaseInfo.linux_release_date)
        pub linux_release_date: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.ReleaseInfo.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReleaseInfo {
        fn default() -> &'a ReleaseInfo {
            <ReleaseInfo as crate::Message>::default_instance()
        }
    }

    impl ReleaseInfo {
        pub fn new() -> ReleaseInfo {
            ::std::default::Default::default()
        }

        // optional uint32 steam_release_date = 1;

        pub fn steam_release_date(&self) -> u32 {
            self.steam_release_date.unwrap_or(0)
        }

        pub fn clear_steam_release_date(&mut self) {
            self.steam_release_date = ::std::option::Option::None;
        }

        pub fn has_steam_release_date(&self) -> bool {
            self.steam_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_release_date(&mut self, v: u32) {
            self.steam_release_date = ::std::option::Option::Some(v);
        }

        // optional uint32 original_release_date = 2;

        pub fn original_release_date(&self) -> u32 {
            self.original_release_date.unwrap_or(0)
        }

        pub fn clear_original_release_date(&mut self) {
            self.original_release_date = ::std::option::Option::None;
        }

        pub fn has_original_release_date(&self) -> bool {
            self.original_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_release_date(&mut self, v: u32) {
            self.original_release_date = ::std::option::Option::Some(v);
        }

        // optional uint32 original_steam_release_date = 3;

        pub fn original_steam_release_date(&self) -> u32 {
            self.original_steam_release_date.unwrap_or(0)
        }

        pub fn clear_original_steam_release_date(&mut self) {
            self.original_steam_release_date = ::std::option::Option::None;
        }

        pub fn has_original_steam_release_date(&self) -> bool {
            self.original_steam_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_steam_release_date(&mut self, v: u32) {
            self.original_steam_release_date = ::std::option::Option::Some(v);
        }

        // optional bool is_coming_soon = 4;

        pub fn is_coming_soon(&self) -> bool {
            self.is_coming_soon.unwrap_or(false)
        }

        pub fn clear_is_coming_soon(&mut self) {
            self.is_coming_soon = ::std::option::Option::None;
        }

        pub fn has_is_coming_soon(&self) -> bool {
            self.is_coming_soon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_coming_soon(&mut self, v: bool) {
            self.is_coming_soon = ::std::option::Option::Some(v);
        }

        // optional bool is_preload = 5;

        pub fn is_preload(&self) -> bool {
            self.is_preload.unwrap_or(false)
        }

        pub fn clear_is_preload(&mut self) {
            self.is_preload = ::std::option::Option::None;
        }

        pub fn has_is_preload(&self) -> bool {
            self.is_preload.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_preload(&mut self, v: bool) {
            self.is_preload = ::std::option::Option::Some(v);
        }

        // optional string custom_release_date_message = 6;

        pub fn custom_release_date_message(&self) -> &str {
            match self.custom_release_date_message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_custom_release_date_message(&mut self) {
            self.custom_release_date_message = ::std::option::Option::None;
        }

        pub fn has_custom_release_date_message(&self) -> bool {
            self.custom_release_date_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_custom_release_date_message(&mut self, v: ::std::string::String) {
            self.custom_release_date_message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_custom_release_date_message(&mut self) -> &mut ::std::string::String {
            if self.custom_release_date_message.is_none() {
                self.custom_release_date_message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.custom_release_date_message.as_mut().unwrap()
        }

        // Take field
        pub fn take_custom_release_date_message(&mut self) -> ::std::string::String {
            self.custom_release_date_message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_abridged_release_date = 7;

        pub fn is_abridged_release_date(&self) -> bool {
            self.is_abridged_release_date.unwrap_or(false)
        }

        pub fn clear_is_abridged_release_date(&mut self) {
            self.is_abridged_release_date = ::std::option::Option::None;
        }

        pub fn has_is_abridged_release_date(&self) -> bool {
            self.is_abridged_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_abridged_release_date(&mut self, v: bool) {
            self.is_abridged_release_date = ::std::option::Option::Some(v);
        }

        // optional string coming_soon_display = 8;

        pub fn coming_soon_display(&self) -> &str {
            match self.coming_soon_display.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_coming_soon_display(&mut self) {
            self.coming_soon_display = ::std::option::Option::None;
        }

        pub fn has_coming_soon_display(&self) -> bool {
            self.coming_soon_display.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coming_soon_display(&mut self, v: ::std::string::String) {
            self.coming_soon_display = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_coming_soon_display(&mut self) -> &mut ::std::string::String {
            if self.coming_soon_display.is_none() {
                self.coming_soon_display = ::std::option::Option::Some(::std::string::String::new());
            }
            self.coming_soon_display.as_mut().unwrap()
        }

        // Take field
        pub fn take_coming_soon_display(&mut self) -> ::std::string::String {
            self.coming_soon_display.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool is_early_access = 10;

        pub fn is_early_access(&self) -> bool {
            self.is_early_access.unwrap_or(false)
        }

        pub fn clear_is_early_access(&mut self) {
            self.is_early_access = ::std::option::Option::None;
        }

        pub fn has_is_early_access(&self) -> bool {
            self.is_early_access.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_early_access(&mut self, v: bool) {
            self.is_early_access = ::std::option::Option::Some(v);
        }

        // optional uint32 mac_release_date = 20;

        pub fn mac_release_date(&self) -> u32 {
            self.mac_release_date.unwrap_or(0)
        }

        pub fn clear_mac_release_date(&mut self) {
            self.mac_release_date = ::std::option::Option::None;
        }

        pub fn has_mac_release_date(&self) -> bool {
            self.mac_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac_release_date(&mut self, v: u32) {
            self.mac_release_date = ::std::option::Option::Some(v);
        }

        // optional uint32 linux_release_date = 21;

        pub fn linux_release_date(&self) -> u32 {
            self.linux_release_date.unwrap_or(0)
        }

        pub fn clear_linux_release_date(&mut self) {
            self.linux_release_date = ::std::option::Option::None;
        }

        pub fn has_linux_release_date(&self) -> bool {
            self.linux_release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_linux_release_date(&mut self, v: u32) {
            self.linux_release_date = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_release_date",
                |m: &ReleaseInfo| { &m.steam_release_date },
                |m: &mut ReleaseInfo| { &mut m.steam_release_date },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "original_release_date",
                |m: &ReleaseInfo| { &m.original_release_date },
                |m: &mut ReleaseInfo| { &mut m.original_release_date },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "original_steam_release_date",
                |m: &ReleaseInfo| { &m.original_steam_release_date },
                |m: &mut ReleaseInfo| { &mut m.original_steam_release_date },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_coming_soon",
                |m: &ReleaseInfo| { &m.is_coming_soon },
                |m: &mut ReleaseInfo| { &mut m.is_coming_soon },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_preload",
                |m: &ReleaseInfo| { &m.is_preload },
                |m: &mut ReleaseInfo| { &mut m.is_preload },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "custom_release_date_message",
                |m: &ReleaseInfo| { &m.custom_release_date_message },
                |m: &mut ReleaseInfo| { &mut m.custom_release_date_message },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_abridged_release_date",
                |m: &ReleaseInfo| { &m.is_abridged_release_date },
                |m: &mut ReleaseInfo| { &mut m.is_abridged_release_date },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "coming_soon_display",
                |m: &ReleaseInfo| { &m.coming_soon_display },
                |m: &mut ReleaseInfo| { &mut m.coming_soon_display },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_early_access",
                |m: &ReleaseInfo| { &m.is_early_access },
                |m: &mut ReleaseInfo| { &mut m.is_early_access },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "mac_release_date",
                |m: &ReleaseInfo| { &m.mac_release_date },
                |m: &mut ReleaseInfo| { &mut m.mac_release_date },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "linux_release_date",
                |m: &ReleaseInfo| { &m.linux_release_date },
                |m: &mut ReleaseInfo| { &mut m.linux_release_date },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ReleaseInfo>(
                "StoreItem.ReleaseInfo",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ReleaseInfo {
        const NAME: &'static str = "ReleaseInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.steam_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.original_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.original_steam_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.is_coming_soon = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.is_preload = ::std::option::Option::Some(is.read_bool()?);
                    },
                    50 => {
                        self.custom_release_date_message = ::std::option::Option::Some(is.read_string()?);
                    },
                    56 => {
                        self.is_abridged_release_date = ::std::option::Option::Some(is.read_bool()?);
                    },
                    66 => {
                        self.coming_soon_display = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.is_early_access = ::std::option::Option::Some(is.read_bool()?);
                    },
                    160 => {
                        self.mac_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.linux_release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_release_date {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.original_release_date {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.original_steam_release_date {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.is_coming_soon {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_preload {
                my_size += 1 + 1;
            }
            if let Some(v) = self.custom_release_date_message.as_ref() {
                my_size += crate::rt::string_size(6, &v);
            }
            if let Some(v) = self.is_abridged_release_date {
                my_size += 1 + 1;
            }
            if let Some(v) = self.coming_soon_display.as_ref() {
                my_size += crate::rt::string_size(8, &v);
            }
            if let Some(v) = self.is_early_access {
                my_size += 1 + 1;
            }
            if let Some(v) = self.mac_release_date {
                my_size += crate::rt::uint32_size(20, v);
            }
            if let Some(v) = self.linux_release_date {
                my_size += crate::rt::uint32_size(21, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steam_release_date {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.original_release_date {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.original_steam_release_date {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.is_coming_soon {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.is_preload {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.custom_release_date_message.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.is_abridged_release_date {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.coming_soon_display.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.is_early_access {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.mac_release_date {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.linux_release_date {
                os.write_uint32(21, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReleaseInfo {
            ReleaseInfo::new()
        }

        fn clear(&mut self) {
            self.steam_release_date = ::std::option::Option::None;
            self.original_release_date = ::std::option::Option::None;
            self.original_steam_release_date = ::std::option::Option::None;
            self.is_coming_soon = ::std::option::Option::None;
            self.is_preload = ::std::option::Option::None;
            self.custom_release_date_message = ::std::option::Option::None;
            self.is_abridged_release_date = ::std::option::Option::None;
            self.coming_soon_display = ::std::option::Option::None;
            self.is_early_access = ::std::option::Option::None;
            self.mac_release_date = ::std::option::Option::None;
            self.linux_release_date = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReleaseInfo {
            static instance: ReleaseInfo = ReleaseInfo {
                steam_release_date: ::std::option::Option::None,
                original_release_date: ::std::option::Option::None,
                original_steam_release_date: ::std::option::Option::None,
                is_coming_soon: ::std::option::Option::None,
                is_preload: ::std::option::Option::None,
                custom_release_date_message: ::std::option::Option::None,
                is_abridged_release_date: ::std::option::Option::None,
                coming_soon_display: ::std::option::Option::None,
                is_early_access: ::std::option::Option::None,
                mac_release_date: ::std::option::Option::None,
                linux_release_date: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ReleaseInfo {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.ReleaseInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReleaseInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ReleaseInfo {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:StoreItem.Platforms)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Platforms {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Platforms.windows)
        pub windows: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.Platforms.mac)
        pub mac: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.Platforms.steamos_linux)
        pub steamos_linux: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.Platforms.vr_support)
        pub vr_support: crate::MessageField<platforms::VRSupport>,
        // @@protoc_insertion_point(field:StoreItem.Platforms.steam_deck_compat_category)
        pub steam_deck_compat_category: ::std::option::Option<crate::EnumOrUnknown<super::super::enums::ESteamDeckCompatibilityCategory>>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Platforms.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Platforms {
        fn default() -> &'a Platforms {
            <Platforms as crate::Message>::default_instance()
        }
    }

    impl Platforms {
        pub fn new() -> Platforms {
            ::std::default::Default::default()
        }

        // optional bool windows = 1;

        pub fn windows(&self) -> bool {
            self.windows.unwrap_or(false)
        }

        pub fn clear_windows(&mut self) {
            self.windows = ::std::option::Option::None;
        }

        pub fn has_windows(&self) -> bool {
            self.windows.is_some()
        }

        // Param is passed by value, moved
        pub fn set_windows(&mut self, v: bool) {
            self.windows = ::std::option::Option::Some(v);
        }

        // optional bool mac = 2;

        pub fn mac(&self) -> bool {
            self.mac.unwrap_or(false)
        }

        pub fn clear_mac(&mut self) {
            self.mac = ::std::option::Option::None;
        }

        pub fn has_mac(&self) -> bool {
            self.mac.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mac(&mut self, v: bool) {
            self.mac = ::std::option::Option::Some(v);
        }

        // optional bool steamos_linux = 3;

        pub fn steamos_linux(&self) -> bool {
            self.steamos_linux.unwrap_or(false)
        }

        pub fn clear_steamos_linux(&mut self) {
            self.steamos_linux = ::std::option::Option::None;
        }

        pub fn has_steamos_linux(&self) -> bool {
            self.steamos_linux.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamos_linux(&mut self, v: bool) {
            self.steamos_linux = ::std::option::Option::Some(v);
        }

        // optional .StoreItem.Platforms.VRSupport vr_support = 10;

        pub fn vr_support(&self) -> &platforms::VRSupport {
            self.vr_support.as_ref().unwrap_or_else(|| <platforms::VRSupport as crate::Message>::default_instance())
        }

        pub fn clear_vr_support(&mut self) {
            self.vr_support.clear();
        }

        pub fn has_vr_support(&self) -> bool {
            self.vr_support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vr_support(&mut self, v: platforms::VRSupport) {
            self.vr_support = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vr_support(&mut self) -> &mut platforms::VRSupport {
            self.vr_support.mut_or_insert_default()
        }

        // Take field
        pub fn take_vr_support(&mut self) -> platforms::VRSupport {
            self.vr_support.take().unwrap_or_else(|| platforms::VRSupport::new())
        }

        // optional .ESteamDeckCompatibilityCategory steam_deck_compat_category = 11;

        pub fn steam_deck_compat_category(&self) -> super::super::enums::ESteamDeckCompatibilityCategory {
            match self.steam_deck_compat_category {
                Some(e) => e.enum_value_or(super::super::enums::ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown),
                None => super::super::enums::ESteamDeckCompatibilityCategory::k_ESteamDeckCompatibilityCategory_Unknown,
            }
        }

        pub fn clear_steam_deck_compat_category(&mut self) {
            self.steam_deck_compat_category = ::std::option::Option::None;
        }

        pub fn has_steam_deck_compat_category(&self) -> bool {
            self.steam_deck_compat_category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_deck_compat_category(&mut self, v: super::super::enums::ESteamDeckCompatibilityCategory) {
            self.steam_deck_compat_category = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "windows",
                |m: &Platforms| { &m.windows },
                |m: &mut Platforms| { &mut m.windows },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "mac",
                |m: &Platforms| { &m.mac },
                |m: &mut Platforms| { &mut m.mac },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamos_linux",
                |m: &Platforms| { &m.steamos_linux },
                |m: &mut Platforms| { &mut m.steamos_linux },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, platforms::VRSupport>(
                "vr_support",
                |m: &Platforms| { &m.vr_support },
                |m: &mut Platforms| { &mut m.vr_support },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steam_deck_compat_category",
                |m: &Platforms| { &m.steam_deck_compat_category },
                |m: &mut Platforms| { &mut m.steam_deck_compat_category },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Platforms>(
                "StoreItem.Platforms",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Platforms {
        const NAME: &'static str = "Platforms";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.windows = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.mac = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.steamos_linux = ::std::option::Option::Some(is.read_bool()?);
                    },
                    82 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.vr_support)?;
                    },
                    88 => {
                        self.steam_deck_compat_category = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.windows {
                my_size += 1 + 1;
            }
            if let Some(v) = self.mac {
                my_size += 1 + 1;
            }
            if let Some(v) = self.steamos_linux {
                my_size += 1 + 1;
            }
            if let Some(v) = self.vr_support.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.steam_deck_compat_category {
                my_size += crate::rt::int32_size(11, v.value());
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.windows {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.mac {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.steamos_linux {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.vr_support.as_ref() {
                crate::rt::write_message_field_with_cached_size(10, v, os)?;
            }
            if let Some(v) = self.steam_deck_compat_category {
                os.write_enum(11, crate::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Platforms {
            Platforms::new()
        }

        fn clear(&mut self) {
            self.windows = ::std::option::Option::None;
            self.mac = ::std::option::Option::None;
            self.steamos_linux = ::std::option::Option::None;
            self.vr_support.clear();
            self.steam_deck_compat_category = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Platforms {
            static instance: Platforms = Platforms {
                windows: ::std::option::Option::None,
                mac: ::std::option::Option::None,
                steamos_linux: ::std::option::Option::None,
                vr_support: crate::MessageField::none(),
                steam_deck_compat_category: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Platforms {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.Platforms").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Platforms {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Platforms {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Platforms`
    pub mod platforms {
        // @@protoc_insertion_point(message:StoreItem.Platforms.VRSupport)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct VRSupport {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.vrhmd)
            pub vrhmd: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.vrhmd_only)
            pub vrhmd_only: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.htc_vive)
            pub htc_vive: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.oculus_rift)
            pub oculus_rift: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.windows_mr)
            pub windows_mr: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:StoreItem.Platforms.VRSupport.valve_index)
            pub valve_index: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Platforms.VRSupport.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a VRSupport {
            fn default() -> &'a VRSupport {
                <VRSupport as crate::Message>::default_instance()
            }
        }

        impl VRSupport {
            pub fn new() -> VRSupport {
                ::std::default::Default::default()
            }

            // optional bool vrhmd = 1;

            pub fn vrhmd(&self) -> bool {
                self.vrhmd.unwrap_or(false)
            }

            pub fn clear_vrhmd(&mut self) {
                self.vrhmd = ::std::option::Option::None;
            }

            pub fn has_vrhmd(&self) -> bool {
                self.vrhmd.is_some()
            }

            // Param is passed by value, moved
            pub fn set_vrhmd(&mut self, v: bool) {
                self.vrhmd = ::std::option::Option::Some(v);
            }

            // optional bool vrhmd_only = 2;

            pub fn vrhmd_only(&self) -> bool {
                self.vrhmd_only.unwrap_or(false)
            }

            pub fn clear_vrhmd_only(&mut self) {
                self.vrhmd_only = ::std::option::Option::None;
            }

            pub fn has_vrhmd_only(&self) -> bool {
                self.vrhmd_only.is_some()
            }

            // Param is passed by value, moved
            pub fn set_vrhmd_only(&mut self, v: bool) {
                self.vrhmd_only = ::std::option::Option::Some(v);
            }

            // optional bool htc_vive = 40;

            pub fn htc_vive(&self) -> bool {
                self.htc_vive.unwrap_or(false)
            }

            pub fn clear_htc_vive(&mut self) {
                self.htc_vive = ::std::option::Option::None;
            }

            pub fn has_htc_vive(&self) -> bool {
                self.htc_vive.is_some()
            }

            // Param is passed by value, moved
            pub fn set_htc_vive(&mut self, v: bool) {
                self.htc_vive = ::std::option::Option::Some(v);
            }

            // optional bool oculus_rift = 41;

            pub fn oculus_rift(&self) -> bool {
                self.oculus_rift.unwrap_or(false)
            }

            pub fn clear_oculus_rift(&mut self) {
                self.oculus_rift = ::std::option::Option::None;
            }

            pub fn has_oculus_rift(&self) -> bool {
                self.oculus_rift.is_some()
            }

            // Param is passed by value, moved
            pub fn set_oculus_rift(&mut self, v: bool) {
                self.oculus_rift = ::std::option::Option::Some(v);
            }

            // optional bool windows_mr = 42;

            pub fn windows_mr(&self) -> bool {
                self.windows_mr.unwrap_or(false)
            }

            pub fn clear_windows_mr(&mut self) {
                self.windows_mr = ::std::option::Option::None;
            }

            pub fn has_windows_mr(&self) -> bool {
                self.windows_mr.is_some()
            }

            // Param is passed by value, moved
            pub fn set_windows_mr(&mut self, v: bool) {
                self.windows_mr = ::std::option::Option::Some(v);
            }

            // optional bool valve_index = 43;

            pub fn valve_index(&self) -> bool {
                self.valve_index.unwrap_or(false)
            }

            pub fn clear_valve_index(&mut self) {
                self.valve_index = ::std::option::Option::None;
            }

            pub fn has_valve_index(&self) -> bool {
                self.valve_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_valve_index(&mut self, v: bool) {
                self.valve_index = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "vrhmd",
                    |m: &VRSupport| { &m.vrhmd },
                    |m: &mut VRSupport| { &mut m.vrhmd },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "vrhmd_only",
                    |m: &VRSupport| { &m.vrhmd_only },
                    |m: &mut VRSupport| { &mut m.vrhmd_only },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "htc_vive",
                    |m: &VRSupport| { &m.htc_vive },
                    |m: &mut VRSupport| { &mut m.htc_vive },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "oculus_rift",
                    |m: &VRSupport| { &m.oculus_rift },
                    |m: &mut VRSupport| { &mut m.oculus_rift },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "windows_mr",
                    |m: &VRSupport| { &m.windows_mr },
                    |m: &mut VRSupport| { &mut m.windows_mr },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "valve_index",
                    |m: &VRSupport| { &m.valve_index },
                    |m: &mut VRSupport| { &mut m.valve_index },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<VRSupport>(
                    "StoreItem.Platforms.VRSupport",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for VRSupport {
            const NAME: &'static str = "VRSupport";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.vrhmd = ::std::option::Option::Some(is.read_bool()?);
                        },
                        16 => {
                            self.vrhmd_only = ::std::option::Option::Some(is.read_bool()?);
                        },
                        320 => {
                            self.htc_vive = ::std::option::Option::Some(is.read_bool()?);
                        },
                        328 => {
                            self.oculus_rift = ::std::option::Option::Some(is.read_bool()?);
                        },
                        336 => {
                            self.windows_mr = ::std::option::Option::Some(is.read_bool()?);
                        },
                        344 => {
                            self.valve_index = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.vrhmd {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.vrhmd_only {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.htc_vive {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.oculus_rift {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.windows_mr {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.valve_index {
                    my_size += 2 + 1;
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.vrhmd {
                    os.write_bool(1, v)?;
                }
                if let Some(v) = self.vrhmd_only {
                    os.write_bool(2, v)?;
                }
                if let Some(v) = self.htc_vive {
                    os.write_bool(40, v)?;
                }
                if let Some(v) = self.oculus_rift {
                    os.write_bool(41, v)?;
                }
                if let Some(v) = self.windows_mr {
                    os.write_bool(42, v)?;
                }
                if let Some(v) = self.valve_index {
                    os.write_bool(43, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> VRSupport {
                VRSupport::new()
            }

            fn clear(&mut self) {
                self.vrhmd = ::std::option::Option::None;
                self.vrhmd_only = ::std::option::Option::None;
                self.htc_vive = ::std::option::Option::None;
                self.oculus_rift = ::std::option::Option::None;
                self.windows_mr = ::std::option::Option::None;
                self.valve_index = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static VRSupport {
                static instance: VRSupport = VRSupport {
                    vrhmd: ::std::option::Option::None,
                    vrhmd_only: ::std::option::Option::None,
                    htc_vive: ::std::option::Option::None,
                    oculus_rift: ::std::option::Option::None,
                    windows_mr: ::std::option::Option::None,
                    valve_index: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for VRSupport {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StoreItem.Platforms.VRSupport").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for VRSupport {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for VRSupport {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:StoreItem.PurchaseOption)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PurchaseOption {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.packageid)
        pub packageid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.bundleid)
        pub bundleid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.purchase_option_name)
        pub purchase_option_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.final_price_in_cents)
        pub final_price_in_cents: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.original_price_in_cents)
        pub original_price_in_cents: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_final_price_in_cents)
        pub user_final_price_in_cents: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.formatted_final_price)
        pub formatted_final_price: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.formatted_original_price)
        pub formatted_original_price: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.discount_pct)
        pub discount_pct: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_discount_pct)
        pub user_discount_pct: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.bundle_discount_pct)
        pub bundle_discount_pct: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.active_discounts)
        pub active_discounts: ::std::vec::Vec<purchase_option::Discount>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_active_discounts)
        pub user_active_discounts: ::std::vec::Vec<purchase_option::Discount>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.inactive_discounts)
        pub inactive_discounts: ::std::vec::Vec<purchase_option::Discount>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_can_purchase)
        pub user_can_purchase: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.user_can_purchase_as_gift)
        pub user_can_purchase_as_gift: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.is_commercial_license)
        pub is_commercial_license: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.should_suppress_discount_pct)
        pub should_suppress_discount_pct: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.hide_discount_pct_for_compliance)
        pub hide_discount_pct_for_compliance: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.included_game_count)
        pub included_game_count: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.lowest_recent_price_in_cents)
        pub lowest_recent_price_in_cents: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.requires_shipping)
        pub requires_shipping: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.PurchaseOption.recurrence_info)
        pub recurrence_info: crate::MessageField<purchase_option::RecurrenceInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.PurchaseOption.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PurchaseOption {
        fn default() -> &'a PurchaseOption {
            <PurchaseOption as crate::Message>::default_instance()
        }
    }

    impl PurchaseOption {
        pub fn new() -> PurchaseOption {
            ::std::default::Default::default()
        }

        // optional int32 packageid = 1;

        pub fn packageid(&self) -> i32 {
            self.packageid.unwrap_or(0)
        }

        pub fn clear_packageid(&mut self) {
            self.packageid = ::std::option::Option::None;
        }

        pub fn has_packageid(&self) -> bool {
            self.packageid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packageid(&mut self, v: i32) {
            self.packageid = ::std::option::Option::Some(v);
        }

        // optional int32 bundleid = 2;

        pub fn bundleid(&self) -> i32 {
            self.bundleid.unwrap_or(0)
        }

        pub fn clear_bundleid(&mut self) {
            self.bundleid = ::std::option::Option::None;
        }

        pub fn has_bundleid(&self) -> bool {
            self.bundleid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bundleid(&mut self, v: i32) {
            self.bundleid = ::std::option::Option::Some(v);
        }

        // optional string purchase_option_name = 3;

        pub fn purchase_option_name(&self) -> &str {
            match self.purchase_option_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_purchase_option_name(&mut self) {
            self.purchase_option_name = ::std::option::Option::None;
        }

        pub fn has_purchase_option_name(&self) -> bool {
            self.purchase_option_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_purchase_option_name(&mut self, v: ::std::string::String) {
            self.purchase_option_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_purchase_option_name(&mut self) -> &mut ::std::string::String {
            if self.purchase_option_name.is_none() {
                self.purchase_option_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.purchase_option_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_purchase_option_name(&mut self) -> ::std::string::String {
            self.purchase_option_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int64 final_price_in_cents = 5;

        pub fn final_price_in_cents(&self) -> i64 {
            self.final_price_in_cents.unwrap_or(0)
        }

        pub fn clear_final_price_in_cents(&mut self) {
            self.final_price_in_cents = ::std::option::Option::None;
        }

        pub fn has_final_price_in_cents(&self) -> bool {
            self.final_price_in_cents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_final_price_in_cents(&mut self, v: i64) {
            self.final_price_in_cents = ::std::option::Option::Some(v);
        }

        // optional int64 original_price_in_cents = 6;

        pub fn original_price_in_cents(&self) -> i64 {
            self.original_price_in_cents.unwrap_or(0)
        }

        pub fn clear_original_price_in_cents(&mut self) {
            self.original_price_in_cents = ::std::option::Option::None;
        }

        pub fn has_original_price_in_cents(&self) -> bool {
            self.original_price_in_cents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_price_in_cents(&mut self, v: i64) {
            self.original_price_in_cents = ::std::option::Option::Some(v);
        }

        // optional int64 user_final_price_in_cents = 7;

        pub fn user_final_price_in_cents(&self) -> i64 {
            self.user_final_price_in_cents.unwrap_or(0)
        }

        pub fn clear_user_final_price_in_cents(&mut self) {
            self.user_final_price_in_cents = ::std::option::Option::None;
        }

        pub fn has_user_final_price_in_cents(&self) -> bool {
            self.user_final_price_in_cents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_final_price_in_cents(&mut self, v: i64) {
            self.user_final_price_in_cents = ::std::option::Option::Some(v);
        }

        // optional string formatted_final_price = 8;

        pub fn formatted_final_price(&self) -> &str {
            match self.formatted_final_price.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_formatted_final_price(&mut self) {
            self.formatted_final_price = ::std::option::Option::None;
        }

        pub fn has_formatted_final_price(&self) -> bool {
            self.formatted_final_price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_formatted_final_price(&mut self, v: ::std::string::String) {
            self.formatted_final_price = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_formatted_final_price(&mut self) -> &mut ::std::string::String {
            if self.formatted_final_price.is_none() {
                self.formatted_final_price = ::std::option::Option::Some(::std::string::String::new());
            }
            self.formatted_final_price.as_mut().unwrap()
        }

        // Take field
        pub fn take_formatted_final_price(&mut self) -> ::std::string::String {
            self.formatted_final_price.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string formatted_original_price = 9;

        pub fn formatted_original_price(&self) -> &str {
            match self.formatted_original_price.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_formatted_original_price(&mut self) {
            self.formatted_original_price = ::std::option::Option::None;
        }

        pub fn has_formatted_original_price(&self) -> bool {
            self.formatted_original_price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_formatted_original_price(&mut self, v: ::std::string::String) {
            self.formatted_original_price = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_formatted_original_price(&mut self) -> &mut ::std::string::String {
            if self.formatted_original_price.is_none() {
                self.formatted_original_price = ::std::option::Option::Some(::std::string::String::new());
            }
            self.formatted_original_price.as_mut().unwrap()
        }

        // Take field
        pub fn take_formatted_original_price(&mut self) -> ::std::string::String {
            self.formatted_original_price.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 discount_pct = 10;

        pub fn discount_pct(&self) -> i32 {
            self.discount_pct.unwrap_or(0)
        }

        pub fn clear_discount_pct(&mut self) {
            self.discount_pct = ::std::option::Option::None;
        }

        pub fn has_discount_pct(&self) -> bool {
            self.discount_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_discount_pct(&mut self, v: i32) {
            self.discount_pct = ::std::option::Option::Some(v);
        }

        // optional int32 user_discount_pct = 11;

        pub fn user_discount_pct(&self) -> i32 {
            self.user_discount_pct.unwrap_or(0)
        }

        pub fn clear_user_discount_pct(&mut self) {
            self.user_discount_pct = ::std::option::Option::None;
        }

        pub fn has_user_discount_pct(&self) -> bool {
            self.user_discount_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_discount_pct(&mut self, v: i32) {
            self.user_discount_pct = ::std::option::Option::Some(v);
        }

        // optional int32 bundle_discount_pct = 12;

        pub fn bundle_discount_pct(&self) -> i32 {
            self.bundle_discount_pct.unwrap_or(0)
        }

        pub fn clear_bundle_discount_pct(&mut self) {
            self.bundle_discount_pct = ::std::option::Option::None;
        }

        pub fn has_bundle_discount_pct(&self) -> bool {
            self.bundle_discount_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_bundle_discount_pct(&mut self, v: i32) {
            self.bundle_discount_pct = ::std::option::Option::Some(v);
        }

        // repeated .StoreItem.PurchaseOption.Discount active_discounts = 20;

        pub fn active_discounts(&self) -> &[purchase_option::Discount] {
            &self.active_discounts
        }

        pub fn clear_active_discounts(&mut self) {
            self.active_discounts.clear();
        }

        // Param is passed by value, moved
        pub fn set_active_discounts(&mut self, v: ::std::vec::Vec<purchase_option::Discount>) {
            self.active_discounts = v;
        }

        // Mutable pointer to the field.
        pub fn mut_active_discounts(&mut self) -> &mut ::std::vec::Vec<purchase_option::Discount> {
            &mut self.active_discounts
        }

        // Take field
        pub fn take_active_discounts(&mut self) -> ::std::vec::Vec<purchase_option::Discount> {
            ::std::mem::replace(&mut self.active_discounts, ::std::vec::Vec::new())
        }

        // repeated .StoreItem.PurchaseOption.Discount user_active_discounts = 21;

        pub fn user_active_discounts(&self) -> &[purchase_option::Discount] {
            &self.user_active_discounts
        }

        pub fn clear_user_active_discounts(&mut self) {
            self.user_active_discounts.clear();
        }

        // Param is passed by value, moved
        pub fn set_user_active_discounts(&mut self, v: ::std::vec::Vec<purchase_option::Discount>) {
            self.user_active_discounts = v;
        }

        // Mutable pointer to the field.
        pub fn mut_user_active_discounts(&mut self) -> &mut ::std::vec::Vec<purchase_option::Discount> {
            &mut self.user_active_discounts
        }

        // Take field
        pub fn take_user_active_discounts(&mut self) -> ::std::vec::Vec<purchase_option::Discount> {
            ::std::mem::replace(&mut self.user_active_discounts, ::std::vec::Vec::new())
        }

        // repeated .StoreItem.PurchaseOption.Discount inactive_discounts = 22;

        pub fn inactive_discounts(&self) -> &[purchase_option::Discount] {
            &self.inactive_discounts
        }

        pub fn clear_inactive_discounts(&mut self) {
            self.inactive_discounts.clear();
        }

        // Param is passed by value, moved
        pub fn set_inactive_discounts(&mut self, v: ::std::vec::Vec<purchase_option::Discount>) {
            self.inactive_discounts = v;
        }

        // Mutable pointer to the field.
        pub fn mut_inactive_discounts(&mut self) -> &mut ::std::vec::Vec<purchase_option::Discount> {
            &mut self.inactive_discounts
        }

        // Take field
        pub fn take_inactive_discounts(&mut self) -> ::std::vec::Vec<purchase_option::Discount> {
            ::std::mem::replace(&mut self.inactive_discounts, ::std::vec::Vec::new())
        }

        // optional bool user_can_purchase = 30;

        pub fn user_can_purchase(&self) -> bool {
            self.user_can_purchase.unwrap_or(false)
        }

        pub fn clear_user_can_purchase(&mut self) {
            self.user_can_purchase = ::std::option::Option::None;
        }

        pub fn has_user_can_purchase(&self) -> bool {
            self.user_can_purchase.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_can_purchase(&mut self, v: bool) {
            self.user_can_purchase = ::std::option::Option::Some(v);
        }

        // optional bool user_can_purchase_as_gift = 31;

        pub fn user_can_purchase_as_gift(&self) -> bool {
            self.user_can_purchase_as_gift.unwrap_or(false)
        }

        pub fn clear_user_can_purchase_as_gift(&mut self) {
            self.user_can_purchase_as_gift = ::std::option::Option::None;
        }

        pub fn has_user_can_purchase_as_gift(&self) -> bool {
            self.user_can_purchase_as_gift.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_can_purchase_as_gift(&mut self, v: bool) {
            self.user_can_purchase_as_gift = ::std::option::Option::Some(v);
        }

        // optional bool is_commercial_license = 40;

        pub fn is_commercial_license(&self) -> bool {
            self.is_commercial_license.unwrap_or(false)
        }

        pub fn clear_is_commercial_license(&mut self) {
            self.is_commercial_license = ::std::option::Option::None;
        }

        pub fn has_is_commercial_license(&self) -> bool {
            self.is_commercial_license.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_commercial_license(&mut self, v: bool) {
            self.is_commercial_license = ::std::option::Option::Some(v);
        }

        // optional bool should_suppress_discount_pct = 41;

        pub fn should_suppress_discount_pct(&self) -> bool {
            self.should_suppress_discount_pct.unwrap_or(false)
        }

        pub fn clear_should_suppress_discount_pct(&mut self) {
            self.should_suppress_discount_pct = ::std::option::Option::None;
        }

        pub fn has_should_suppress_discount_pct(&self) -> bool {
            self.should_suppress_discount_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_should_suppress_discount_pct(&mut self, v: bool) {
            self.should_suppress_discount_pct = ::std::option::Option::Some(v);
        }

        // optional bool hide_discount_pct_for_compliance = 42;

        pub fn hide_discount_pct_for_compliance(&self) -> bool {
            self.hide_discount_pct_for_compliance.unwrap_or(false)
        }

        pub fn clear_hide_discount_pct_for_compliance(&mut self) {
            self.hide_discount_pct_for_compliance = ::std::option::Option::None;
        }

        pub fn has_hide_discount_pct_for_compliance(&self) -> bool {
            self.hide_discount_pct_for_compliance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hide_discount_pct_for_compliance(&mut self, v: bool) {
            self.hide_discount_pct_for_compliance = ::std::option::Option::Some(v);
        }

        // optional int32 included_game_count = 43;

        pub fn included_game_count(&self) -> i32 {
            self.included_game_count.unwrap_or(0)
        }

        pub fn clear_included_game_count(&mut self) {
            self.included_game_count = ::std::option::Option::None;
        }

        pub fn has_included_game_count(&self) -> bool {
            self.included_game_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_included_game_count(&mut self, v: i32) {
            self.included_game_count = ::std::option::Option::Some(v);
        }

        // optional int64 lowest_recent_price_in_cents = 44;

        pub fn lowest_recent_price_in_cents(&self) -> i64 {
            self.lowest_recent_price_in_cents.unwrap_or(0)
        }

        pub fn clear_lowest_recent_price_in_cents(&mut self) {
            self.lowest_recent_price_in_cents = ::std::option::Option::None;
        }

        pub fn has_lowest_recent_price_in_cents(&self) -> bool {
            self.lowest_recent_price_in_cents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lowest_recent_price_in_cents(&mut self, v: i64) {
            self.lowest_recent_price_in_cents = ::std::option::Option::Some(v);
        }

        // optional bool requires_shipping = 45;

        pub fn requires_shipping(&self) -> bool {
            self.requires_shipping.unwrap_or(false)
        }

        pub fn clear_requires_shipping(&mut self) {
            self.requires_shipping = ::std::option::Option::None;
        }

        pub fn has_requires_shipping(&self) -> bool {
            self.requires_shipping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_requires_shipping(&mut self, v: bool) {
            self.requires_shipping = ::std::option::Option::Some(v);
        }

        // optional .StoreItem.PurchaseOption.RecurrenceInfo recurrence_info = 46;

        pub fn recurrence_info(&self) -> &purchase_option::RecurrenceInfo {
            self.recurrence_info.as_ref().unwrap_or_else(|| <purchase_option::RecurrenceInfo as crate::Message>::default_instance())
        }

        pub fn clear_recurrence_info(&mut self) {
            self.recurrence_info.clear();
        }

        pub fn has_recurrence_info(&self) -> bool {
            self.recurrence_info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_recurrence_info(&mut self, v: purchase_option::RecurrenceInfo) {
            self.recurrence_info = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_recurrence_info(&mut self) -> &mut purchase_option::RecurrenceInfo {
            self.recurrence_info.mut_or_insert_default()
        }

        // Take field
        pub fn take_recurrence_info(&mut self) -> purchase_option::RecurrenceInfo {
            self.recurrence_info.take().unwrap_or_else(|| purchase_option::RecurrenceInfo::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(23);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "packageid",
                |m: &PurchaseOption| { &m.packageid },
                |m: &mut PurchaseOption| { &mut m.packageid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bundleid",
                |m: &PurchaseOption| { &m.bundleid },
                |m: &mut PurchaseOption| { &mut m.bundleid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "purchase_option_name",
                |m: &PurchaseOption| { &m.purchase_option_name },
                |m: &mut PurchaseOption| { &mut m.purchase_option_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "final_price_in_cents",
                |m: &PurchaseOption| { &m.final_price_in_cents },
                |m: &mut PurchaseOption| { &mut m.final_price_in_cents },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "original_price_in_cents",
                |m: &PurchaseOption| { &m.original_price_in_cents },
                |m: &mut PurchaseOption| { &mut m.original_price_in_cents },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "user_final_price_in_cents",
                |m: &PurchaseOption| { &m.user_final_price_in_cents },
                |m: &mut PurchaseOption| { &mut m.user_final_price_in_cents },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "formatted_final_price",
                |m: &PurchaseOption| { &m.formatted_final_price },
                |m: &mut PurchaseOption| { &mut m.formatted_final_price },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "formatted_original_price",
                |m: &PurchaseOption| { &m.formatted_original_price },
                |m: &mut PurchaseOption| { &mut m.formatted_original_price },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "discount_pct",
                |m: &PurchaseOption| { &m.discount_pct },
                |m: &mut PurchaseOption| { &mut m.discount_pct },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "user_discount_pct",
                |m: &PurchaseOption| { &m.user_discount_pct },
                |m: &mut PurchaseOption| { &mut m.user_discount_pct },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "bundle_discount_pct",
                |m: &PurchaseOption| { &m.bundle_discount_pct },
                |m: &mut PurchaseOption| { &mut m.bundle_discount_pct },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "active_discounts",
                |m: &PurchaseOption| { &m.active_discounts },
                |m: &mut PurchaseOption| { &mut m.active_discounts },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "user_active_discounts",
                |m: &PurchaseOption| { &m.user_active_discounts },
                |m: &mut PurchaseOption| { &mut m.user_active_discounts },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "inactive_discounts",
                |m: &PurchaseOption| { &m.inactive_discounts },
                |m: &mut PurchaseOption| { &mut m.inactive_discounts },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "user_can_purchase",
                |m: &PurchaseOption| { &m.user_can_purchase },
                |m: &mut PurchaseOption| { &mut m.user_can_purchase },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "user_can_purchase_as_gift",
                |m: &PurchaseOption| { &m.user_can_purchase_as_gift },
                |m: &mut PurchaseOption| { &mut m.user_can_purchase_as_gift },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_commercial_license",
                |m: &PurchaseOption| { &m.is_commercial_license },
                |m: &mut PurchaseOption| { &mut m.is_commercial_license },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "should_suppress_discount_pct",
                |m: &PurchaseOption| { &m.should_suppress_discount_pct },
                |m: &mut PurchaseOption| { &mut m.should_suppress_discount_pct },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "hide_discount_pct_for_compliance",
                |m: &PurchaseOption| { &m.hide_discount_pct_for_compliance },
                |m: &mut PurchaseOption| { &mut m.hide_discount_pct_for_compliance },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "included_game_count",
                |m: &PurchaseOption| { &m.included_game_count },
                |m: &mut PurchaseOption| { &mut m.included_game_count },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "lowest_recent_price_in_cents",
                |m: &PurchaseOption| { &m.lowest_recent_price_in_cents },
                |m: &mut PurchaseOption| { &mut m.lowest_recent_price_in_cents },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "requires_shipping",
                |m: &PurchaseOption| { &m.requires_shipping },
                |m: &mut PurchaseOption| { &mut m.requires_shipping },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, purchase_option::RecurrenceInfo>(
                "recurrence_info",
                |m: &PurchaseOption| { &m.recurrence_info },
                |m: &mut PurchaseOption| { &mut m.recurrence_info },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<PurchaseOption>(
                "StoreItem.PurchaseOption",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for PurchaseOption {
        const NAME: &'static str = "PurchaseOption";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.packageid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.bundleid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.purchase_option_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.final_price_in_cents = ::std::option::Option::Some(is.read_int64()?);
                    },
                    48 => {
                        self.original_price_in_cents = ::std::option::Option::Some(is.read_int64()?);
                    },
                    56 => {
                        self.user_final_price_in_cents = ::std::option::Option::Some(is.read_int64()?);
                    },
                    66 => {
                        self.formatted_final_price = ::std::option::Option::Some(is.read_string()?);
                    },
                    74 => {
                        self.formatted_original_price = ::std::option::Option::Some(is.read_string()?);
                    },
                    80 => {
                        self.discount_pct = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.user_discount_pct = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.bundle_discount_pct = ::std::option::Option::Some(is.read_int32()?);
                    },
                    162 => {
                        self.active_discounts.push(is.read_message()?);
                    },
                    170 => {
                        self.user_active_discounts.push(is.read_message()?);
                    },
                    178 => {
                        self.inactive_discounts.push(is.read_message()?);
                    },
                    240 => {
                        self.user_can_purchase = ::std::option::Option::Some(is.read_bool()?);
                    },
                    248 => {
                        self.user_can_purchase_as_gift = ::std::option::Option::Some(is.read_bool()?);
                    },
                    320 => {
                        self.is_commercial_license = ::std::option::Option::Some(is.read_bool()?);
                    },
                    328 => {
                        self.should_suppress_discount_pct = ::std::option::Option::Some(is.read_bool()?);
                    },
                    336 => {
                        self.hide_discount_pct_for_compliance = ::std::option::Option::Some(is.read_bool()?);
                    },
                    344 => {
                        self.included_game_count = ::std::option::Option::Some(is.read_int32()?);
                    },
                    352 => {
                        self.lowest_recent_price_in_cents = ::std::option::Option::Some(is.read_int64()?);
                    },
                    360 => {
                        self.requires_shipping = ::std::option::Option::Some(is.read_bool()?);
                    },
                    370 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.recurrence_info)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.packageid {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.bundleid {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.purchase_option_name.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.final_price_in_cents {
                my_size += crate::rt::int64_size(5, v);
            }
            if let Some(v) = self.original_price_in_cents {
                my_size += crate::rt::int64_size(6, v);
            }
            if let Some(v) = self.user_final_price_in_cents {
                my_size += crate::rt::int64_size(7, v);
            }
            if let Some(v) = self.formatted_final_price.as_ref() {
                my_size += crate::rt::string_size(8, &v);
            }
            if let Some(v) = self.formatted_original_price.as_ref() {
                my_size += crate::rt::string_size(9, &v);
            }
            if let Some(v) = self.discount_pct {
                my_size += crate::rt::int32_size(10, v);
            }
            if let Some(v) = self.user_discount_pct {
                my_size += crate::rt::int32_size(11, v);
            }
            if let Some(v) = self.bundle_discount_pct {
                my_size += crate::rt::int32_size(12, v);
            }
            for value in &self.active_discounts {
                let len = value.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.user_active_discounts {
                let len = value.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.inactive_discounts {
                let len = value.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.user_can_purchase {
                my_size += 2 + 1;
            }
            if let Some(v) = self.user_can_purchase_as_gift {
                my_size += 2 + 1;
            }
            if let Some(v) = self.is_commercial_license {
                my_size += 2 + 1;
            }
            if let Some(v) = self.should_suppress_discount_pct {
                my_size += 2 + 1;
            }
            if let Some(v) = self.hide_discount_pct_for_compliance {
                my_size += 2 + 1;
            }
            if let Some(v) = self.included_game_count {
                my_size += crate::rt::int32_size(43, v);
            }
            if let Some(v) = self.lowest_recent_price_in_cents {
                my_size += crate::rt::int64_size(44, v);
            }
            if let Some(v) = self.requires_shipping {
                my_size += 2 + 1;
            }
            if let Some(v) = self.recurrence_info.as_ref() {
                let len = v.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.packageid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.bundleid {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.purchase_option_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.final_price_in_cents {
                os.write_int64(5, v)?;
            }
            if let Some(v) = self.original_price_in_cents {
                os.write_int64(6, v)?;
            }
            if let Some(v) = self.user_final_price_in_cents {
                os.write_int64(7, v)?;
            }
            if let Some(v) = self.formatted_final_price.as_ref() {
                os.write_string(8, v)?;
            }
            if let Some(v) = self.formatted_original_price.as_ref() {
                os.write_string(9, v)?;
            }
            if let Some(v) = self.discount_pct {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.user_discount_pct {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.bundle_discount_pct {
                os.write_int32(12, v)?;
            }
            for v in &self.active_discounts {
                crate::rt::write_message_field_with_cached_size(20, v, os)?;
            };
            for v in &self.user_active_discounts {
                crate::rt::write_message_field_with_cached_size(21, v, os)?;
            };
            for v in &self.inactive_discounts {
                crate::rt::write_message_field_with_cached_size(22, v, os)?;
            };
            if let Some(v) = self.user_can_purchase {
                os.write_bool(30, v)?;
            }
            if let Some(v) = self.user_can_purchase_as_gift {
                os.write_bool(31, v)?;
            }
            if let Some(v) = self.is_commercial_license {
                os.write_bool(40, v)?;
            }
            if let Some(v) = self.should_suppress_discount_pct {
                os.write_bool(41, v)?;
            }
            if let Some(v) = self.hide_discount_pct_for_compliance {
                os.write_bool(42, v)?;
            }
            if let Some(v) = self.included_game_count {
                os.write_int32(43, v)?;
            }
            if let Some(v) = self.lowest_recent_price_in_cents {
                os.write_int64(44, v)?;
            }
            if let Some(v) = self.requires_shipping {
                os.write_bool(45, v)?;
            }
            if let Some(v) = self.recurrence_info.as_ref() {
                crate::rt::write_message_field_with_cached_size(46, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PurchaseOption {
            PurchaseOption::new()
        }

        fn clear(&mut self) {
            self.packageid = ::std::option::Option::None;
            self.bundleid = ::std::option::Option::None;
            self.purchase_option_name = ::std::option::Option::None;
            self.final_price_in_cents = ::std::option::Option::None;
            self.original_price_in_cents = ::std::option::Option::None;
            self.user_final_price_in_cents = ::std::option::Option::None;
            self.formatted_final_price = ::std::option::Option::None;
            self.formatted_original_price = ::std::option::Option::None;
            self.discount_pct = ::std::option::Option::None;
            self.user_discount_pct = ::std::option::Option::None;
            self.bundle_discount_pct = ::std::option::Option::None;
            self.active_discounts.clear();
            self.user_active_discounts.clear();
            self.inactive_discounts.clear();
            self.user_can_purchase = ::std::option::Option::None;
            self.user_can_purchase_as_gift = ::std::option::Option::None;
            self.is_commercial_license = ::std::option::Option::None;
            self.should_suppress_discount_pct = ::std::option::Option::None;
            self.hide_discount_pct_for_compliance = ::std::option::Option::None;
            self.included_game_count = ::std::option::Option::None;
            self.lowest_recent_price_in_cents = ::std::option::Option::None;
            self.requires_shipping = ::std::option::Option::None;
            self.recurrence_info.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PurchaseOption {
            static instance: PurchaseOption = PurchaseOption {
                packageid: ::std::option::Option::None,
                bundleid: ::std::option::Option::None,
                purchase_option_name: ::std::option::Option::None,
                final_price_in_cents: ::std::option::Option::None,
                original_price_in_cents: ::std::option::Option::None,
                user_final_price_in_cents: ::std::option::Option::None,
                formatted_final_price: ::std::option::Option::None,
                formatted_original_price: ::std::option::Option::None,
                discount_pct: ::std::option::Option::None,
                user_discount_pct: ::std::option::Option::None,
                bundle_discount_pct: ::std::option::Option::None,
                active_discounts: ::std::vec::Vec::new(),
                user_active_discounts: ::std::vec::Vec::new(),
                inactive_discounts: ::std::vec::Vec::new(),
                user_can_purchase: ::std::option::Option::None,
                user_can_purchase_as_gift: ::std::option::Option::None,
                is_commercial_license: ::std::option::Option::None,
                should_suppress_discount_pct: ::std::option::Option::None,
                hide_discount_pct_for_compliance: ::std::option::Option::None,
                included_game_count: ::std::option::Option::None,
                lowest_recent_price_in_cents: ::std::option::Option::None,
                requires_shipping: ::std::option::Option::None,
                recurrence_info: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for PurchaseOption {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.PurchaseOption").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PurchaseOption {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for PurchaseOption {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `PurchaseOption`
    pub mod purchase_option {
        // @@protoc_insertion_point(message:StoreItem.PurchaseOption.Discount)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Discount {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.Discount.discount_amount)
            pub discount_amount: ::std::option::Option<i64>,
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.Discount.discount_description)
            pub discount_description: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.Discount.discount_end_date)
            pub discount_end_date: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.PurchaseOption.Discount.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Discount {
            fn default() -> &'a Discount {
                <Discount as crate::Message>::default_instance()
            }
        }

        impl Discount {
            pub fn new() -> Discount {
                ::std::default::Default::default()
            }

            // optional int64 discount_amount = 1;

            pub fn discount_amount(&self) -> i64 {
                self.discount_amount.unwrap_or(0)
            }

            pub fn clear_discount_amount(&mut self) {
                self.discount_amount = ::std::option::Option::None;
            }

            pub fn has_discount_amount(&self) -> bool {
                self.discount_amount.is_some()
            }

            // Param is passed by value, moved
            pub fn set_discount_amount(&mut self, v: i64) {
                self.discount_amount = ::std::option::Option::Some(v);
            }

            // optional string discount_description = 2;

            pub fn discount_description(&self) -> &str {
                match self.discount_description.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_discount_description(&mut self) {
                self.discount_description = ::std::option::Option::None;
            }

            pub fn has_discount_description(&self) -> bool {
                self.discount_description.is_some()
            }

            // Param is passed by value, moved
            pub fn set_discount_description(&mut self, v: ::std::string::String) {
                self.discount_description = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_discount_description(&mut self) -> &mut ::std::string::String {
                if self.discount_description.is_none() {
                    self.discount_description = ::std::option::Option::Some(::std::string::String::new());
                }
                self.discount_description.as_mut().unwrap()
            }

            // Take field
            pub fn take_discount_description(&mut self) -> ::std::string::String {
                self.discount_description.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional uint32 discount_end_date = 3;

            pub fn discount_end_date(&self) -> u32 {
                self.discount_end_date.unwrap_or(0)
            }

            pub fn clear_discount_end_date(&mut self) {
                self.discount_end_date = ::std::option::Option::None;
            }

            pub fn has_discount_end_date(&self) -> bool {
                self.discount_end_date.is_some()
            }

            // Param is passed by value, moved
            pub fn set_discount_end_date(&mut self, v: u32) {
                self.discount_end_date = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(3);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "discount_amount",
                    |m: &Discount| { &m.discount_amount },
                    |m: &mut Discount| { &mut m.discount_amount },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "discount_description",
                    |m: &Discount| { &m.discount_description },
                    |m: &mut Discount| { &mut m.discount_description },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "discount_end_date",
                    |m: &Discount| { &m.discount_end_date },
                    |m: &mut Discount| { &mut m.discount_end_date },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<Discount>(
                    "StoreItem.PurchaseOption.Discount",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for Discount {
            const NAME: &'static str = "Discount";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.discount_amount = ::std::option::Option::Some(is.read_int64()?);
                        },
                        18 => {
                            self.discount_description = ::std::option::Option::Some(is.read_string()?);
                        },
                        24 => {
                            self.discount_end_date = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.discount_amount {
                    my_size += crate::rt::int64_size(1, v);
                }
                if let Some(v) = self.discount_description.as_ref() {
                    my_size += crate::rt::string_size(2, &v);
                }
                if let Some(v) = self.discount_end_date {
                    my_size += crate::rt::uint32_size(3, v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.discount_amount {
                    os.write_int64(1, v)?;
                }
                if let Some(v) = self.discount_description.as_ref() {
                    os.write_string(2, v)?;
                }
                if let Some(v) = self.discount_end_date {
                    os.write_uint32(3, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Discount {
                Discount::new()
            }

            fn clear(&mut self) {
                self.discount_amount = ::std::option::Option::None;
                self.discount_description = ::std::option::Option::None;
                self.discount_end_date = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Discount {
                static instance: Discount = Discount {
                    discount_amount: ::std::option::Option::None,
                    discount_description: ::std::option::Option::None,
                    discount_end_date: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for Discount {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StoreItem.PurchaseOption.Discount").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Discount {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for Discount {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:StoreItem.PurchaseOption.RecurrenceInfo)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct RecurrenceInfo {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.RecurrenceInfo.packageid)
            pub packageid: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.RecurrenceInfo.billing_agreement_type)
            pub billing_agreement_type: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.RecurrenceInfo.renewal_time_unit)
            pub renewal_time_unit: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:StoreItem.PurchaseOption.RecurrenceInfo.renewal_time_period)
            pub renewal_time_period: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.PurchaseOption.RecurrenceInfo.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a RecurrenceInfo {
            fn default() -> &'a RecurrenceInfo {
                <RecurrenceInfo as crate::Message>::default_instance()
            }
        }

        impl RecurrenceInfo {
            pub fn new() -> RecurrenceInfo {
                ::std::default::Default::default()
            }

            // optional int32 packageid = 1;

            pub fn packageid(&self) -> i32 {
                self.packageid.unwrap_or(0)
            }

            pub fn clear_packageid(&mut self) {
                self.packageid = ::std::option::Option::None;
            }

            pub fn has_packageid(&self) -> bool {
                self.packageid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_packageid(&mut self, v: i32) {
                self.packageid = ::std::option::Option::Some(v);
            }

            // optional int32 billing_agreement_type = 2;

            pub fn billing_agreement_type(&self) -> i32 {
                self.billing_agreement_type.unwrap_or(0)
            }

            pub fn clear_billing_agreement_type(&mut self) {
                self.billing_agreement_type = ::std::option::Option::None;
            }

            pub fn has_billing_agreement_type(&self) -> bool {
                self.billing_agreement_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_billing_agreement_type(&mut self, v: i32) {
                self.billing_agreement_type = ::std::option::Option::Some(v);
            }

            // optional int32 renewal_time_unit = 3;

            pub fn renewal_time_unit(&self) -> i32 {
                self.renewal_time_unit.unwrap_or(0)
            }

            pub fn clear_renewal_time_unit(&mut self) {
                self.renewal_time_unit = ::std::option::Option::None;
            }

            pub fn has_renewal_time_unit(&self) -> bool {
                self.renewal_time_unit.is_some()
            }

            // Param is passed by value, moved
            pub fn set_renewal_time_unit(&mut self, v: i32) {
                self.renewal_time_unit = ::std::option::Option::Some(v);
            }

            // optional int32 renewal_time_period = 4;

            pub fn renewal_time_period(&self) -> i32 {
                self.renewal_time_period.unwrap_or(0)
            }

            pub fn clear_renewal_time_period(&mut self) {
                self.renewal_time_period = ::std::option::Option::None;
            }

            pub fn has_renewal_time_period(&self) -> bool {
                self.renewal_time_period.is_some()
            }

            // Param is passed by value, moved
            pub fn set_renewal_time_period(&mut self, v: i32) {
                self.renewal_time_period = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(4);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "packageid",
                    |m: &RecurrenceInfo| { &m.packageid },
                    |m: &mut RecurrenceInfo| { &mut m.packageid },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "billing_agreement_type",
                    |m: &RecurrenceInfo| { &m.billing_agreement_type },
                    |m: &mut RecurrenceInfo| { &mut m.billing_agreement_type },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "renewal_time_unit",
                    |m: &RecurrenceInfo| { &m.renewal_time_unit },
                    |m: &mut RecurrenceInfo| { &mut m.renewal_time_unit },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "renewal_time_period",
                    |m: &RecurrenceInfo| { &m.renewal_time_period },
                    |m: &mut RecurrenceInfo| { &mut m.renewal_time_period },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<RecurrenceInfo>(
                    "StoreItem.PurchaseOption.RecurrenceInfo",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for RecurrenceInfo {
            const NAME: &'static str = "RecurrenceInfo";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.packageid = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.billing_agreement_type = ::std::option::Option::Some(is.read_int32()?);
                        },
                        24 => {
                            self.renewal_time_unit = ::std::option::Option::Some(is.read_int32()?);
                        },
                        32 => {
                            self.renewal_time_period = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.packageid {
                    my_size += crate::rt::int32_size(1, v);
                }
                if let Some(v) = self.billing_agreement_type {
                    my_size += crate::rt::int32_size(2, v);
                }
                if let Some(v) = self.renewal_time_unit {
                    my_size += crate::rt::int32_size(3, v);
                }
                if let Some(v) = self.renewal_time_period {
                    my_size += crate::rt::int32_size(4, v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.packageid {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.billing_agreement_type {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.renewal_time_unit {
                    os.write_int32(3, v)?;
                }
                if let Some(v) = self.renewal_time_period {
                    os.write_int32(4, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> RecurrenceInfo {
                RecurrenceInfo::new()
            }

            fn clear(&mut self) {
                self.packageid = ::std::option::Option::None;
                self.billing_agreement_type = ::std::option::Option::None;
                self.renewal_time_unit = ::std::option::Option::None;
                self.renewal_time_period = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static RecurrenceInfo {
                static instance: RecurrenceInfo = RecurrenceInfo {
                    packageid: ::std::option::Option::None,
                    billing_agreement_type: ::std::option::Option::None,
                    renewal_time_unit: ::std::option::Option::None,
                    renewal_time_period: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for RecurrenceInfo {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StoreItem.PurchaseOption.RecurrenceInfo").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for RecurrenceInfo {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for RecurrenceInfo {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Screenshots)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Screenshots {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Screenshots.all_ages_screenshots)
        pub all_ages_screenshots: ::std::vec::Vec<screenshots::Screenshot>,
        // @@protoc_insertion_point(field:StoreItem.Screenshots.mature_content_screenshots)
        pub mature_content_screenshots: ::std::vec::Vec<screenshots::Screenshot>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Screenshots.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Screenshots {
        fn default() -> &'a Screenshots {
            <Screenshots as crate::Message>::default_instance()
        }
    }

    impl Screenshots {
        pub fn new() -> Screenshots {
            ::std::default::Default::default()
        }

        // repeated .StoreItem.Screenshots.Screenshot all_ages_screenshots = 2;

        pub fn all_ages_screenshots(&self) -> &[screenshots::Screenshot] {
            &self.all_ages_screenshots
        }

        pub fn clear_all_ages_screenshots(&mut self) {
            self.all_ages_screenshots.clear();
        }

        // Param is passed by value, moved
        pub fn set_all_ages_screenshots(&mut self, v: ::std::vec::Vec<screenshots::Screenshot>) {
            self.all_ages_screenshots = v;
        }

        // Mutable pointer to the field.
        pub fn mut_all_ages_screenshots(&mut self) -> &mut ::std::vec::Vec<screenshots::Screenshot> {
            &mut self.all_ages_screenshots
        }

        // Take field
        pub fn take_all_ages_screenshots(&mut self) -> ::std::vec::Vec<screenshots::Screenshot> {
            ::std::mem::replace(&mut self.all_ages_screenshots, ::std::vec::Vec::new())
        }

        // repeated .StoreItem.Screenshots.Screenshot mature_content_screenshots = 3;

        pub fn mature_content_screenshots(&self) -> &[screenshots::Screenshot] {
            &self.mature_content_screenshots
        }

        pub fn clear_mature_content_screenshots(&mut self) {
            self.mature_content_screenshots.clear();
        }

        // Param is passed by value, moved
        pub fn set_mature_content_screenshots(&mut self, v: ::std::vec::Vec<screenshots::Screenshot>) {
            self.mature_content_screenshots = v;
        }

        // Mutable pointer to the field.
        pub fn mut_mature_content_screenshots(&mut self) -> &mut ::std::vec::Vec<screenshots::Screenshot> {
            &mut self.mature_content_screenshots
        }

        // Take field
        pub fn take_mature_content_screenshots(&mut self) -> ::std::vec::Vec<screenshots::Screenshot> {
            ::std::mem::replace(&mut self.mature_content_screenshots, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "all_ages_screenshots",
                |m: &Screenshots| { &m.all_ages_screenshots },
                |m: &mut Screenshots| { &mut m.all_ages_screenshots },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "mature_content_screenshots",
                |m: &Screenshots| { &m.mature_content_screenshots },
                |m: &mut Screenshots| { &mut m.mature_content_screenshots },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Screenshots>(
                "StoreItem.Screenshots",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Screenshots {
        const NAME: &'static str = "Screenshots";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    18 => {
                        self.all_ages_screenshots.push(is.read_message()?);
                    },
                    26 => {
                        self.mature_content_screenshots.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.all_ages_screenshots {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.mature_content_screenshots {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            for v in &self.all_ages_screenshots {
                crate::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.mature_content_screenshots {
                crate::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Screenshots {
            Screenshots::new()
        }

        fn clear(&mut self) {
            self.all_ages_screenshots.clear();
            self.mature_content_screenshots.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Screenshots {
            static instance: Screenshots = Screenshots {
                all_ages_screenshots: ::std::vec::Vec::new(),
                mature_content_screenshots: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Screenshots {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.Screenshots").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Screenshots {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Screenshots {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Screenshots`
    pub mod screenshots {
        // @@protoc_insertion_point(message:StoreItem.Screenshots.Screenshot)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Screenshot {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Screenshots.Screenshot.filename)
            pub filename: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Screenshots.Screenshot.ordinal)
            pub ordinal: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Screenshots.Screenshot.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Screenshot {
            fn default() -> &'a Screenshot {
                <Screenshot as crate::Message>::default_instance()
            }
        }

        impl Screenshot {
            pub fn new() -> Screenshot {
                ::std::default::Default::default()
            }

            // optional string filename = 1;

            pub fn filename(&self) -> &str {
                match self.filename.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_filename(&mut self) {
                self.filename = ::std::option::Option::None;
            }

            pub fn has_filename(&self) -> bool {
                self.filename.is_some()
            }

            // Param is passed by value, moved
            pub fn set_filename(&mut self, v: ::std::string::String) {
                self.filename = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_filename(&mut self) -> &mut ::std::string::String {
                if self.filename.is_none() {
                    self.filename = ::std::option::Option::Some(::std::string::String::new());
                }
                self.filename.as_mut().unwrap()
            }

            // Take field
            pub fn take_filename(&mut self) -> ::std::string::String {
                self.filename.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional int32 ordinal = 2;

            pub fn ordinal(&self) -> i32 {
                self.ordinal.unwrap_or(0)
            }

            pub fn clear_ordinal(&mut self) {
                self.ordinal = ::std::option::Option::None;
            }

            pub fn has_ordinal(&self) -> bool {
                self.ordinal.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ordinal(&mut self, v: i32) {
                self.ordinal = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "filename",
                    |m: &Screenshot| { &m.filename },
                    |m: &mut Screenshot| { &mut m.filename },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "ordinal",
                    |m: &Screenshot| { &m.ordinal },
                    |m: &mut Screenshot| { &mut m.ordinal },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<Screenshot>(
                    "StoreItem.Screenshots.Screenshot",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for Screenshot {
            const NAME: &'static str = "Screenshot";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.filename = ::std::option::Option::Some(is.read_string()?);
                        },
                        16 => {
                            self.ordinal = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.filename.as_ref() {
                    my_size += crate::rt::string_size(1, &v);
                }
                if let Some(v) = self.ordinal {
                    my_size += crate::rt::int32_size(2, v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.filename.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.ordinal {
                    os.write_int32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Screenshot {
                Screenshot::new()
            }

            fn clear(&mut self) {
                self.filename = ::std::option::Option::None;
                self.ordinal = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Screenshot {
                static instance: Screenshot = Screenshot {
                    filename: ::std::option::Option::None,
                    ordinal: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for Screenshot {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StoreItem.Screenshots.Screenshot").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Screenshot {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for Screenshot {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:StoreItem.Trailers)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Trailers {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.Trailers.highlights)
        pub highlights: ::std::vec::Vec<trailers::Trailer>,
        // @@protoc_insertion_point(field:StoreItem.Trailers.other_trailers)
        pub other_trailers: ::std::vec::Vec<trailers::Trailer>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.Trailers.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Trailers {
        fn default() -> &'a Trailers {
            <Trailers as crate::Message>::default_instance()
        }
    }

    impl Trailers {
        pub fn new() -> Trailers {
            ::std::default::Default::default()
        }

        // repeated .StoreItem.Trailers.Trailer highlights = 1;

        pub fn highlights(&self) -> &[trailers::Trailer] {
            &self.highlights
        }

        pub fn clear_highlights(&mut self) {
            self.highlights.clear();
        }

        // Param is passed by value, moved
        pub fn set_highlights(&mut self, v: ::std::vec::Vec<trailers::Trailer>) {
            self.highlights = v;
        }

        // Mutable pointer to the field.
        pub fn mut_highlights(&mut self) -> &mut ::std::vec::Vec<trailers::Trailer> {
            &mut self.highlights
        }

        // Take field
        pub fn take_highlights(&mut self) -> ::std::vec::Vec<trailers::Trailer> {
            ::std::mem::replace(&mut self.highlights, ::std::vec::Vec::new())
        }

        // repeated .StoreItem.Trailers.Trailer other_trailers = 2;

        pub fn other_trailers(&self) -> &[trailers::Trailer] {
            &self.other_trailers
        }

        pub fn clear_other_trailers(&mut self) {
            self.other_trailers.clear();
        }

        // Param is passed by value, moved
        pub fn set_other_trailers(&mut self, v: ::std::vec::Vec<trailers::Trailer>) {
            self.other_trailers = v;
        }

        // Mutable pointer to the field.
        pub fn mut_other_trailers(&mut self) -> &mut ::std::vec::Vec<trailers::Trailer> {
            &mut self.other_trailers
        }

        // Take field
        pub fn take_other_trailers(&mut self) -> ::std::vec::Vec<trailers::Trailer> {
            ::std::mem::replace(&mut self.other_trailers, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "highlights",
                |m: &Trailers| { &m.highlights },
                |m: &mut Trailers| { &mut m.highlights },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "other_trailers",
                |m: &Trailers| { &m.other_trailers },
                |m: &mut Trailers| { &mut m.other_trailers },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Trailers>(
                "StoreItem.Trailers",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Trailers {
        const NAME: &'static str = "Trailers";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.highlights.push(is.read_message()?);
                    },
                    18 => {
                        self.other_trailers.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.highlights {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.other_trailers {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            for v in &self.highlights {
                crate::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.other_trailers {
                crate::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Trailers {
            Trailers::new()
        }

        fn clear(&mut self) {
            self.highlights.clear();
            self.other_trailers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Trailers {
            static instance: Trailers = Trailers {
                highlights: ::std::vec::Vec::new(),
                other_trailers: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Trailers {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.Trailers").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Trailers {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Trailers {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Trailers`
    pub mod trailers {
        // @@protoc_insertion_point(message:StoreItem.Trailers.VideoSource)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct VideoSource {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Trailers.VideoSource.filename)
            pub filename: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.VideoSource.type)
            pub type_: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Trailers.VideoSource.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a VideoSource {
            fn default() -> &'a VideoSource {
                <VideoSource as crate::Message>::default_instance()
            }
        }

        impl VideoSource {
            pub fn new() -> VideoSource {
                ::std::default::Default::default()
            }

            // optional string filename = 1;

            pub fn filename(&self) -> &str {
                match self.filename.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_filename(&mut self) {
                self.filename = ::std::option::Option::None;
            }

            pub fn has_filename(&self) -> bool {
                self.filename.is_some()
            }

            // Param is passed by value, moved
            pub fn set_filename(&mut self, v: ::std::string::String) {
                self.filename = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_filename(&mut self) -> &mut ::std::string::String {
                if self.filename.is_none() {
                    self.filename = ::std::option::Option::Some(::std::string::String::new());
                }
                self.filename.as_mut().unwrap()
            }

            // Take field
            pub fn take_filename(&mut self) -> ::std::string::String {
                self.filename.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string type = 2;

            pub fn type_(&self) -> &str {
                match self.type_.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_type_(&mut self) {
                self.type_ = ::std::option::Option::None;
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: ::std::string::String) {
                self.type_ = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_type(&mut self) -> &mut ::std::string::String {
                if self.type_.is_none() {
                    self.type_ = ::std::option::Option::Some(::std::string::String::new());
                }
                self.type_.as_mut().unwrap()
            }

            // Take field
            pub fn take_type_(&mut self) -> ::std::string::String {
                self.type_.take().unwrap_or_else(|| ::std::string::String::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "filename",
                    |m: &VideoSource| { &m.filename },
                    |m: &mut VideoSource| { &mut m.filename },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "type",
                    |m: &VideoSource| { &m.type_ },
                    |m: &mut VideoSource| { &mut m.type_ },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<VideoSource>(
                    "StoreItem.Trailers.VideoSource",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for VideoSource {
            const NAME: &'static str = "VideoSource";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.filename = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.type_ = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.filename.as_ref() {
                    my_size += crate::rt::string_size(1, &v);
                }
                if let Some(v) = self.type_.as_ref() {
                    my_size += crate::rt::string_size(2, &v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.filename.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.type_.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> VideoSource {
                VideoSource::new()
            }

            fn clear(&mut self) {
                self.filename = ::std::option::Option::None;
                self.type_ = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static VideoSource {
                static instance: VideoSource = VideoSource {
                    filename: ::std::option::Option::None,
                    type_: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for VideoSource {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StoreItem.Trailers.VideoSource").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for VideoSource {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for VideoSource {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }

        // @@protoc_insertion_point(message:StoreItem.Trailers.Trailer)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Trailer {
            // message fields
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_name)
            pub trailer_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_url_format)
            pub trailer_url_format: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_480p)
            pub trailer_480p: ::std::vec::Vec<VideoSource>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_max)
            pub trailer_max: ::std::vec::Vec<VideoSource>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.microtrailer)
            pub microtrailer: ::std::vec::Vec<VideoSource>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.screenshot_medium)
            pub screenshot_medium: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.screenshot_full)
            pub screenshot_full: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:StoreItem.Trailers.Trailer.trailer_base_id)
            pub trailer_base_id: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:StoreItem.Trailers.Trailer.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Trailer {
            fn default() -> &'a Trailer {
                <Trailer as crate::Message>::default_instance()
            }
        }

        impl Trailer {
            pub fn new() -> Trailer {
                ::std::default::Default::default()
            }

            // optional string trailer_name = 1;

            pub fn trailer_name(&self) -> &str {
                match self.trailer_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_trailer_name(&mut self) {
                self.trailer_name = ::std::option::Option::None;
            }

            pub fn has_trailer_name(&self) -> bool {
                self.trailer_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trailer_name(&mut self, v: ::std::string::String) {
                self.trailer_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_trailer_name(&mut self) -> &mut ::std::string::String {
                if self.trailer_name.is_none() {
                    self.trailer_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.trailer_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_trailer_name(&mut self) -> ::std::string::String {
                self.trailer_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string trailer_url_format = 2;

            pub fn trailer_url_format(&self) -> &str {
                match self.trailer_url_format.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_trailer_url_format(&mut self) {
                self.trailer_url_format = ::std::option::Option::None;
            }

            pub fn has_trailer_url_format(&self) -> bool {
                self.trailer_url_format.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trailer_url_format(&mut self, v: ::std::string::String) {
                self.trailer_url_format = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_trailer_url_format(&mut self) -> &mut ::std::string::String {
                if self.trailer_url_format.is_none() {
                    self.trailer_url_format = ::std::option::Option::Some(::std::string::String::new());
                }
                self.trailer_url_format.as_mut().unwrap()
            }

            // Take field
            pub fn take_trailer_url_format(&mut self) -> ::std::string::String {
                self.trailer_url_format.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // repeated .StoreItem.Trailers.VideoSource trailer_480p = 3;

            pub fn trailer_480p(&self) -> &[VideoSource] {
                &self.trailer_480p
            }

            pub fn clear_trailer_480p(&mut self) {
                self.trailer_480p.clear();
            }

            // Param is passed by value, moved
            pub fn set_trailer_480p(&mut self, v: ::std::vec::Vec<VideoSource>) {
                self.trailer_480p = v;
            }

            // Mutable pointer to the field.
            pub fn mut_trailer_480p(&mut self) -> &mut ::std::vec::Vec<VideoSource> {
                &mut self.trailer_480p
            }

            // Take field
            pub fn take_trailer_480p(&mut self) -> ::std::vec::Vec<VideoSource> {
                ::std::mem::replace(&mut self.trailer_480p, ::std::vec::Vec::new())
            }

            // repeated .StoreItem.Trailers.VideoSource trailer_max = 4;

            pub fn trailer_max(&self) -> &[VideoSource] {
                &self.trailer_max
            }

            pub fn clear_trailer_max(&mut self) {
                self.trailer_max.clear();
            }

            // Param is passed by value, moved
            pub fn set_trailer_max(&mut self, v: ::std::vec::Vec<VideoSource>) {
                self.trailer_max = v;
            }

            // Mutable pointer to the field.
            pub fn mut_trailer_max(&mut self) -> &mut ::std::vec::Vec<VideoSource> {
                &mut self.trailer_max
            }

            // Take field
            pub fn take_trailer_max(&mut self) -> ::std::vec::Vec<VideoSource> {
                ::std::mem::replace(&mut self.trailer_max, ::std::vec::Vec::new())
            }

            // repeated .StoreItem.Trailers.VideoSource microtrailer = 5;

            pub fn microtrailer(&self) -> &[VideoSource] {
                &self.microtrailer
            }

            pub fn clear_microtrailer(&mut self) {
                self.microtrailer.clear();
            }

            // Param is passed by value, moved
            pub fn set_microtrailer(&mut self, v: ::std::vec::Vec<VideoSource>) {
                self.microtrailer = v;
            }

            // Mutable pointer to the field.
            pub fn mut_microtrailer(&mut self) -> &mut ::std::vec::Vec<VideoSource> {
                &mut self.microtrailer
            }

            // Take field
            pub fn take_microtrailer(&mut self) -> ::std::vec::Vec<VideoSource> {
                ::std::mem::replace(&mut self.microtrailer, ::std::vec::Vec::new())
            }

            // optional string screenshot_medium = 10;

            pub fn screenshot_medium(&self) -> &str {
                match self.screenshot_medium.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_screenshot_medium(&mut self) {
                self.screenshot_medium = ::std::option::Option::None;
            }

            pub fn has_screenshot_medium(&self) -> bool {
                self.screenshot_medium.is_some()
            }

            // Param is passed by value, moved
            pub fn set_screenshot_medium(&mut self, v: ::std::string::String) {
                self.screenshot_medium = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_screenshot_medium(&mut self) -> &mut ::std::string::String {
                if self.screenshot_medium.is_none() {
                    self.screenshot_medium = ::std::option::Option::Some(::std::string::String::new());
                }
                self.screenshot_medium.as_mut().unwrap()
            }

            // Take field
            pub fn take_screenshot_medium(&mut self) -> ::std::string::String {
                self.screenshot_medium.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string screenshot_full = 11;

            pub fn screenshot_full(&self) -> &str {
                match self.screenshot_full.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_screenshot_full(&mut self) {
                self.screenshot_full = ::std::option::Option::None;
            }

            pub fn has_screenshot_full(&self) -> bool {
                self.screenshot_full.is_some()
            }

            // Param is passed by value, moved
            pub fn set_screenshot_full(&mut self, v: ::std::string::String) {
                self.screenshot_full = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_screenshot_full(&mut self) -> &mut ::std::string::String {
                if self.screenshot_full.is_none() {
                    self.screenshot_full = ::std::option::Option::Some(::std::string::String::new());
                }
                self.screenshot_full.as_mut().unwrap()
            }

            // Take field
            pub fn take_screenshot_full(&mut self) -> ::std::string::String {
                self.screenshot_full.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional int32 trailer_base_id = 12;

            pub fn trailer_base_id(&self) -> i32 {
                self.trailer_base_id.unwrap_or(0)
            }

            pub fn clear_trailer_base_id(&mut self) {
                self.trailer_base_id = ::std::option::Option::None;
            }

            pub fn has_trailer_base_id(&self) -> bool {
                self.trailer_base_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_trailer_base_id(&mut self, v: i32) {
                self.trailer_base_id = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(8);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "trailer_name",
                    |m: &Trailer| { &m.trailer_name },
                    |m: &mut Trailer| { &mut m.trailer_name },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "trailer_url_format",
                    |m: &Trailer| { &m.trailer_url_format },
                    |m: &mut Trailer| { &mut m.trailer_url_format },
                ));
                fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "trailer_480p",
                    |m: &Trailer| { &m.trailer_480p },
                    |m: &mut Trailer| { &mut m.trailer_480p },
                ));
                fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "trailer_max",
                    |m: &Trailer| { &m.trailer_max },
                    |m: &mut Trailer| { &mut m.trailer_max },
                ));
                fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "microtrailer",
                    |m: &Trailer| { &m.microtrailer },
                    |m: &mut Trailer| { &mut m.microtrailer },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "screenshot_medium",
                    |m: &Trailer| { &m.screenshot_medium },
                    |m: &mut Trailer| { &mut m.screenshot_medium },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "screenshot_full",
                    |m: &Trailer| { &m.screenshot_full },
                    |m: &mut Trailer| { &mut m.screenshot_full },
                ));
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "trailer_base_id",
                    |m: &Trailer| { &m.trailer_base_id },
                    |m: &mut Trailer| { &mut m.trailer_base_id },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<Trailer>(
                    "StoreItem.Trailers.Trailer",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for Trailer {
            const NAME: &'static str = "Trailer";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        10 => {
                            self.trailer_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        18 => {
                            self.trailer_url_format = ::std::option::Option::Some(is.read_string()?);
                        },
                        26 => {
                            self.trailer_480p.push(is.read_message()?);
                        },
                        34 => {
                            self.trailer_max.push(is.read_message()?);
                        },
                        42 => {
                            self.microtrailer.push(is.read_message()?);
                        },
                        82 => {
                            self.screenshot_medium = ::std::option::Option::Some(is.read_string()?);
                        },
                        90 => {
                            self.screenshot_full = ::std::option::Option::Some(is.read_string()?);
                        },
                        96 => {
                            self.trailer_base_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.trailer_name.as_ref() {
                    my_size += crate::rt::string_size(1, &v);
                }
                if let Some(v) = self.trailer_url_format.as_ref() {
                    my_size += crate::rt::string_size(2, &v);
                }
                for value in &self.trailer_480p {
                    let len = value.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.trailer_max {
                    let len = value.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.microtrailer {
                    let len = value.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.screenshot_medium.as_ref() {
                    my_size += crate::rt::string_size(10, &v);
                }
                if let Some(v) = self.screenshot_full.as_ref() {
                    my_size += crate::rt::string_size(11, &v);
                }
                if let Some(v) = self.trailer_base_id {
                    my_size += crate::rt::int32_size(12, v);
                }
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.trailer_name.as_ref() {
                    os.write_string(1, v)?;
                }
                if let Some(v) = self.trailer_url_format.as_ref() {
                    os.write_string(2, v)?;
                }
                for v in &self.trailer_480p {
                    crate::rt::write_message_field_with_cached_size(3, v, os)?;
                };
                for v in &self.trailer_max {
                    crate::rt::write_message_field_with_cached_size(4, v, os)?;
                };
                for v in &self.microtrailer {
                    crate::rt::write_message_field_with_cached_size(5, v, os)?;
                };
                if let Some(v) = self.screenshot_medium.as_ref() {
                    os.write_string(10, v)?;
                }
                if let Some(v) = self.screenshot_full.as_ref() {
                    os.write_string(11, v)?;
                }
                if let Some(v) = self.trailer_base_id {
                    os.write_int32(12, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Trailer {
                Trailer::new()
            }

            fn clear(&mut self) {
                self.trailer_name = ::std::option::Option::None;
                self.trailer_url_format = ::std::option::Option::None;
                self.trailer_480p.clear();
                self.trailer_max.clear();
                self.microtrailer.clear();
                self.screenshot_medium = ::std::option::Option::None;
                self.screenshot_full = ::std::option::Option::None;
                self.trailer_base_id = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Trailer {
                static instance: Trailer = Trailer {
                    trailer_name: ::std::option::Option::None,
                    trailer_url_format: ::std::option::Option::None,
                    trailer_480p: ::std::vec::Vec::new(),
                    trailer_max: ::std::vec::Vec::new(),
                    microtrailer: ::std::vec::Vec::new(),
                    screenshot_medium: ::std::option::Option::None,
                    screenshot_full: ::std::option::Option::None,
                    trailer_base_id: ::std::option::Option::None,
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for Trailer {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("StoreItem.Trailers.Trailer").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Trailer {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for Trailer {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:StoreItem.SupportedLanguage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SupportedLanguage {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.SupportedLanguage.elanguage)
        pub elanguage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:StoreItem.SupportedLanguage.supported)
        pub supported: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.SupportedLanguage.full_audio)
        pub full_audio: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:StoreItem.SupportedLanguage.subtitles)
        pub subtitles: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.SupportedLanguage.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SupportedLanguage {
        fn default() -> &'a SupportedLanguage {
            <SupportedLanguage as crate::Message>::default_instance()
        }
    }

    impl SupportedLanguage {
        pub fn new() -> SupportedLanguage {
            ::std::default::Default::default()
        }

        // optional int32 elanguage = 1;

        pub fn elanguage(&self) -> i32 {
            self.elanguage.unwrap_or(0)
        }

        pub fn clear_elanguage(&mut self) {
            self.elanguage = ::std::option::Option::None;
        }

        pub fn has_elanguage(&self) -> bool {
            self.elanguage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_elanguage(&mut self, v: i32) {
            self.elanguage = ::std::option::Option::Some(v);
        }

        // optional bool supported = 2;

        pub fn supported(&self) -> bool {
            self.supported.unwrap_or(false)
        }

        pub fn clear_supported(&mut self) {
            self.supported = ::std::option::Option::None;
        }

        pub fn has_supported(&self) -> bool {
            self.supported.is_some()
        }

        // Param is passed by value, moved
        pub fn set_supported(&mut self, v: bool) {
            self.supported = ::std::option::Option::Some(v);
        }

        // optional bool full_audio = 3;

        pub fn full_audio(&self) -> bool {
            self.full_audio.unwrap_or(false)
        }

        pub fn clear_full_audio(&mut self) {
            self.full_audio = ::std::option::Option::None;
        }

        pub fn has_full_audio(&self) -> bool {
            self.full_audio.is_some()
        }

        // Param is passed by value, moved
        pub fn set_full_audio(&mut self, v: bool) {
            self.full_audio = ::std::option::Option::Some(v);
        }

        // optional bool subtitles = 4;

        pub fn subtitles(&self) -> bool {
            self.subtitles.unwrap_or(false)
        }

        pub fn clear_subtitles(&mut self) {
            self.subtitles = ::std::option::Option::None;
        }

        pub fn has_subtitles(&self) -> bool {
            self.subtitles.is_some()
        }

        // Param is passed by value, moved
        pub fn set_subtitles(&mut self, v: bool) {
            self.subtitles = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "elanguage",
                |m: &SupportedLanguage| { &m.elanguage },
                |m: &mut SupportedLanguage| { &mut m.elanguage },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "supported",
                |m: &SupportedLanguage| { &m.supported },
                |m: &mut SupportedLanguage| { &mut m.supported },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "full_audio",
                |m: &SupportedLanguage| { &m.full_audio },
                |m: &mut SupportedLanguage| { &mut m.full_audio },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "subtitles",
                |m: &SupportedLanguage| { &m.subtitles },
                |m: &mut SupportedLanguage| { &mut m.subtitles },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<SupportedLanguage>(
                "StoreItem.SupportedLanguage",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for SupportedLanguage {
        const NAME: &'static str = "SupportedLanguage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.supported = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.full_audio = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.subtitles = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.elanguage {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.supported {
                my_size += 1 + 1;
            }
            if let Some(v) = self.full_audio {
                my_size += 1 + 1;
            }
            if let Some(v) = self.subtitles {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.elanguage {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.supported {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.full_audio {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.subtitles {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SupportedLanguage {
            SupportedLanguage::new()
        }

        fn clear(&mut self) {
            self.elanguage = ::std::option::Option::None;
            self.supported = ::std::option::Option::None;
            self.full_audio = ::std::option::Option::None;
            self.subtitles = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SupportedLanguage {
            static instance: SupportedLanguage = SupportedLanguage {
                elanguage: ::std::option::Option::None,
                supported: ::std::option::Option::None,
                full_audio: ::std::option::Option::None,
                subtitles: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for SupportedLanguage {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.SupportedLanguage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SupportedLanguage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for SupportedLanguage {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:StoreItem.FreeWeekend)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FreeWeekend {
        // message fields
        // @@protoc_insertion_point(field:StoreItem.FreeWeekend.start_time)
        pub start_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.FreeWeekend.end_time)
        pub end_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:StoreItem.FreeWeekend.text)
        pub text: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:StoreItem.FreeWeekend.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FreeWeekend {
        fn default() -> &'a FreeWeekend {
            <FreeWeekend as crate::Message>::default_instance()
        }
    }

    impl FreeWeekend {
        pub fn new() -> FreeWeekend {
            ::std::default::Default::default()
        }

        // optional uint32 start_time = 1;

        pub fn start_time(&self) -> u32 {
            self.start_time.unwrap_or(0)
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: u32) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // optional uint32 end_time = 2;

        pub fn end_time(&self) -> u32 {
            self.end_time.unwrap_or(0)
        }

        pub fn clear_end_time(&mut self) {
            self.end_time = ::std::option::Option::None;
        }

        pub fn has_end_time(&self) -> bool {
            self.end_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_time(&mut self, v: u32) {
            self.end_time = ::std::option::Option::Some(v);
        }

        // optional string text = 3;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "start_time",
                |m: &FreeWeekend| { &m.start_time },
                |m: &mut FreeWeekend| { &mut m.start_time },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "end_time",
                |m: &FreeWeekend| { &m.end_time },
                |m: &mut FreeWeekend| { &mut m.end_time },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "text",
                |m: &FreeWeekend| { &m.text },
                |m: &mut FreeWeekend| { &mut m.text },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<FreeWeekend>(
                "StoreItem.FreeWeekend",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for FreeWeekend {
        const NAME: &'static str = "FreeWeekend";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start_time {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.end_time {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.text.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.start_time {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.end_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.text.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FreeWeekend {
            FreeWeekend::new()
        }

        fn clear(&mut self) {
            self.start_time = ::std::option::Option::None;
            self.end_time = ::std::option::Option::None;
            self.text = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FreeWeekend {
            static instance: FreeWeekend = FreeWeekend {
                start_time: ::std::option::Option::None,
                end_time: ::std::option::Option::None,
                text: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for FreeWeekend {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("StoreItem.FreeWeekend").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FreeWeekend {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for FreeWeekend {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:StoreGameRating)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct StoreGameRating {
    // message fields
    // @@protoc_insertion_point(field:StoreGameRating.type)
    pub type_: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.rating)
    pub rating: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.descriptors)
    pub descriptors: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.interactive_elements)
    pub interactive_elements: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.required_age)
    pub required_age: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:StoreGameRating.use_age_gate)
    pub use_age_gate: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:StoreGameRating.image_url)
    pub image_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:StoreGameRating.image_target)
    pub image_target: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:StoreGameRating.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StoreGameRating {
    fn default() -> &'a StoreGameRating {
        <StoreGameRating as crate::Message>::default_instance()
    }
}

impl StoreGameRating {
    pub fn new() -> StoreGameRating {
        ::std::default::Default::default()
    }

    // optional string type = 1;

    pub fn type_(&self) -> &str {
        match self.type_.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ::std::string::String) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type(&mut self) -> &mut ::std::string::String {
        if self.type_.is_none() {
            self.type_ = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_(&mut self) -> ::std::string::String {
        self.type_.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rating = 2;

    pub fn rating(&self) -> &str {
        match self.rating.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rating(&mut self) {
        self.rating = ::std::option::Option::None;
    }

    pub fn has_rating(&self) -> bool {
        self.rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating(&mut self, v: ::std::string::String) {
        self.rating = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rating(&mut self) -> &mut ::std::string::String {
        if self.rating.is_none() {
            self.rating = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rating.as_mut().unwrap()
    }

    // Take field
    pub fn take_rating(&mut self) -> ::std::string::String {
        self.rating.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string descriptors = 3;

    pub fn descriptors(&self) -> &[::std::string::String] {
        &self.descriptors
    }

    pub fn clear_descriptors(&mut self) {
        self.descriptors.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptors(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.descriptors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_descriptors(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.descriptors
    }

    // Take field
    pub fn take_descriptors(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.descriptors, ::std::vec::Vec::new())
    }

    // optional string interactive_elements = 4;

    pub fn interactive_elements(&self) -> &str {
        match self.interactive_elements.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_interactive_elements(&mut self) {
        self.interactive_elements = ::std::option::Option::None;
    }

    pub fn has_interactive_elements(&self) -> bool {
        self.interactive_elements.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interactive_elements(&mut self, v: ::std::string::String) {
        self.interactive_elements = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interactive_elements(&mut self) -> &mut ::std::string::String {
        if self.interactive_elements.is_none() {
            self.interactive_elements = ::std::option::Option::Some(::std::string::String::new());
        }
        self.interactive_elements.as_mut().unwrap()
    }

    // Take field
    pub fn take_interactive_elements(&mut self) -> ::std::string::String {
        self.interactive_elements.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 required_age = 10;

    pub fn required_age(&self) -> i32 {
        self.required_age.unwrap_or(0)
    }

    pub fn clear_required_age(&mut self) {
        self.required_age = ::std::option::Option::None;
    }

    pub fn has_required_age(&self) -> bool {
        self.required_age.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_age(&mut self, v: i32) {
        self.required_age = ::std::option::Option::Some(v);
    }

    // optional bool use_age_gate = 11;

    pub fn use_age_gate(&self) -> bool {
        self.use_age_gate.unwrap_or(false)
    }

    pub fn clear_use_age_gate(&mut self) {
        self.use_age_gate = ::std::option::Option::None;
    }

    pub fn has_use_age_gate(&self) -> bool {
        self.use_age_gate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_age_gate(&mut self, v: bool) {
        self.use_age_gate = ::std::option::Option::Some(v);
    }

    // optional string image_url = 20;

    pub fn image_url(&self) -> &str {
        match self.image_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image_url(&mut self) {
        self.image_url = ::std::option::Option::None;
    }

    pub fn has_image_url(&self) -> bool {
        self.image_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_url(&mut self, v: ::std::string::String) {
        self.image_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_url(&mut self) -> &mut ::std::string::String {
        if self.image_url.is_none() {
            self.image_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_url(&mut self) -> ::std::string::String {
        self.image_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image_target = 21;

    pub fn image_target(&self) -> &str {
        match self.image_target.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image_target(&mut self) {
        self.image_target = ::std::option::Option::None;
    }

    pub fn has_image_target(&self) -> bool {
        self.image_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_target(&mut self, v: ::std::string::String) {
        self.image_target = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_target(&mut self) -> &mut ::std::string::String {
        if self.image_target.is_none() {
            self.image_target = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image_target.as_mut().unwrap()
    }

    // Take field
    pub fn take_image_target(&mut self) -> ::std::string::String {
        self.image_target.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &StoreGameRating| { &m.type_ },
            |m: &mut StoreGameRating| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rating",
            |m: &StoreGameRating| { &m.rating },
            |m: &mut StoreGameRating| { &mut m.rating },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "descriptors",
            |m: &StoreGameRating| { &m.descriptors },
            |m: &mut StoreGameRating| { &mut m.descriptors },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "interactive_elements",
            |m: &StoreGameRating| { &m.interactive_elements },
            |m: &mut StoreGameRating| { &mut m.interactive_elements },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "required_age",
            |m: &StoreGameRating| { &m.required_age },
            |m: &mut StoreGameRating| { &mut m.required_age },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "use_age_gate",
            |m: &StoreGameRating| { &m.use_age_gate },
            |m: &mut StoreGameRating| { &mut m.use_age_gate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_url",
            |m: &StoreGameRating| { &m.image_url },
            |m: &mut StoreGameRating| { &mut m.image_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_target",
            |m: &StoreGameRating| { &m.image_target },
            |m: &mut StoreGameRating| { &mut m.image_target },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<StoreGameRating>(
            "StoreGameRating",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for StoreGameRating {
    const NAME: &'static str = "StoreGameRating";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.rating = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.descriptors.push(is.read_string()?);
                },
                34 => {
                    self.interactive_elements = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.required_age = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.use_age_gate = ::std::option::Option::Some(is.read_bool()?);
                },
                162 => {
                    self.image_url = ::std::option::Option::Some(is.read_string()?);
                },
                170 => {
                    self.image_target = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.rating.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        for value in &self.descriptors {
            my_size += crate::rt::string_size(3, &value);
        };
        if let Some(v) = self.interactive_elements.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.required_age {
            my_size += crate::rt::int32_size(10, v);
        }
        if let Some(v) = self.use_age_gate {
            my_size += 1 + 1;
        }
        if let Some(v) = self.image_url.as_ref() {
            my_size += crate::rt::string_size(20, &v);
        }
        if let Some(v) = self.image_target.as_ref() {
            my_size += crate::rt::string_size(21, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.type_.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.rating.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.descriptors {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.interactive_elements.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.required_age {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.use_age_gate {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.image_url.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.image_target.as_ref() {
            os.write_string(21, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StoreGameRating {
        StoreGameRating::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.rating = ::std::option::Option::None;
        self.descriptors.clear();
        self.interactive_elements = ::std::option::Option::None;
        self.required_age = ::std::option::Option::None;
        self.use_age_gate = ::std::option::Option::None;
        self.image_url = ::std::option::Option::None;
        self.image_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StoreGameRating {
        static instance: StoreGameRating = StoreGameRating {
            type_: ::std::option::Option::None,
            rating: ::std::option::Option::None,
            descriptors: ::std::vec::Vec::new(),
            interactive_elements: ::std::option::Option::None,
            required_age: ::std::option::Option::None,
            use_age_gate: ::std::option::Option::None,
            image_url: ::std::option::Option::None,
            image_target: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for StoreGameRating {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StoreGameRating").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StoreGameRating {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for StoreGameRating {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStoreBrowse_GetItems_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetItems_Response {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetItems_Response.store_items)
    pub store_items: ::std::vec::Vec<StoreItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetItems_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetItems_Response {
    fn default() -> &'a CStoreBrowse_GetItems_Response {
        <CStoreBrowse_GetItems_Response as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetItems_Response {
    pub fn new() -> CStoreBrowse_GetItems_Response {
        ::std::default::Default::default()
    }

    // repeated .StoreItem store_items = 1;

    pub fn store_items(&self) -> &[StoreItem] {
        &self.store_items
    }

    pub fn clear_store_items(&mut self) {
        self.store_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_store_items(&mut self, v: ::std::vec::Vec<StoreItem>) {
        self.store_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_store_items(&mut self) -> &mut ::std::vec::Vec<StoreItem> {
        &mut self.store_items
    }

    // Take field
    pub fn take_store_items(&mut self) -> ::std::vec::Vec<StoreItem> {
        ::std::mem::replace(&mut self.store_items, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "store_items",
            |m: &CStoreBrowse_GetItems_Response| { &m.store_items },
            |m: &mut CStoreBrowse_GetItems_Response| { &mut m.store_items },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetItems_Response>(
            "CStoreBrowse_GetItems_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetItems_Response {
    const NAME: &'static str = "CStoreBrowse_GetItems_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.store_items.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.store_items {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.store_items {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetItems_Response {
        CStoreBrowse_GetItems_Response::new()
    }

    fn clear(&mut self) {
        self.store_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetItems_Response {
        static instance: CStoreBrowse_GetItems_Response = CStoreBrowse_GetItems_Response {
            store_items: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetItems_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetItems_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetItems_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetItems_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStoreBrowse_GetStoreCategories_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetStoreCategories_Request {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Request.elanguage)
    pub elanguage: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetStoreCategories_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetStoreCategories_Request {
    fn default() -> &'a CStoreBrowse_GetStoreCategories_Request {
        <CStoreBrowse_GetStoreCategories_Request as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetStoreCategories_Request {
    pub fn new() -> CStoreBrowse_GetStoreCategories_Request {
        ::std::default::Default::default()
    }

    // optional string language = 1;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 elanguage = 2;

    pub fn elanguage(&self) -> i32 {
        self.elanguage.unwrap_or(-1i32)
    }

    pub fn clear_elanguage(&mut self) {
        self.elanguage = ::std::option::Option::None;
    }

    pub fn has_elanguage(&self) -> bool {
        self.elanguage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elanguage(&mut self, v: i32) {
        self.elanguage = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CStoreBrowse_GetStoreCategories_Request| { &m.language },
            |m: &mut CStoreBrowse_GetStoreCategories_Request| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "elanguage",
            |m: &CStoreBrowse_GetStoreCategories_Request| { &m.elanguage },
            |m: &mut CStoreBrowse_GetStoreCategories_Request| { &mut m.elanguage },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetStoreCategories_Request>(
            "CStoreBrowse_GetStoreCategories_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetStoreCategories_Request {
    const NAME: &'static str = "CStoreBrowse_GetStoreCategories_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.elanguage = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.elanguage {
            my_size += crate::rt::int32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.language.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.elanguage {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetStoreCategories_Request {
        CStoreBrowse_GetStoreCategories_Request::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.elanguage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetStoreCategories_Request {
        static instance: CStoreBrowse_GetStoreCategories_Request = CStoreBrowse_GetStoreCategories_Request {
            language: ::std::option::Option::None,
            elanguage: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetStoreCategories_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetStoreCategories_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetStoreCategories_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetStoreCategories_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStoreBrowse_GetStoreCategories_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetStoreCategories_Response {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.categories)
    pub categories: ::std::vec::Vec<cstore_browse_get_store_categories_response::Category>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetStoreCategories_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetStoreCategories_Response {
    fn default() -> &'a CStoreBrowse_GetStoreCategories_Response {
        <CStoreBrowse_GetStoreCategories_Response as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetStoreCategories_Response {
    pub fn new() -> CStoreBrowse_GetStoreCategories_Response {
        ::std::default::Default::default()
    }

    // repeated .CStoreBrowse_GetStoreCategories_Response.Category categories = 1;

    pub fn categories(&self) -> &[cstore_browse_get_store_categories_response::Category] {
        &self.categories
    }

    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::std::vec::Vec<cstore_browse_get_store_categories_response::Category>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::std::vec::Vec<cstore_browse_get_store_categories_response::Category> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::std::vec::Vec<cstore_browse_get_store_categories_response::Category> {
        ::std::mem::replace(&mut self.categories, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "categories",
            |m: &CStoreBrowse_GetStoreCategories_Response| { &m.categories },
            |m: &mut CStoreBrowse_GetStoreCategories_Response| { &mut m.categories },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetStoreCategories_Response>(
            "CStoreBrowse_GetStoreCategories_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetStoreCategories_Response {
    const NAME: &'static str = "CStoreBrowse_GetStoreCategories_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.categories.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.categories {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.categories {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetStoreCategories_Response {
        CStoreBrowse_GetStoreCategories_Response::new()
    }

    fn clear(&mut self) {
        self.categories.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetStoreCategories_Response {
        static instance: CStoreBrowse_GetStoreCategories_Response = CStoreBrowse_GetStoreCategories_Response {
            categories: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetStoreCategories_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetStoreCategories_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetStoreCategories_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetStoreCategories_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStoreBrowse_GetStoreCategories_Response`
pub mod cstore_browse_get_store_categories_response {
    // @@protoc_insertion_point(message:CStoreBrowse_GetStoreCategories_Response.Category)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Category {
        // message fields
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.categoryid)
        pub categoryid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.type)
        pub type_: ::std::option::Option<crate::EnumOrUnknown<super::EStoreCategoryType>>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.internal_name)
        pub internal_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.display_name)
        pub display_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.image_url)
        pub image_url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetStoreCategories_Response.Category.show_in_search)
        pub show_in_search: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CStoreBrowse_GetStoreCategories_Response.Category.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Category {
        fn default() -> &'a Category {
            <Category as crate::Message>::default_instance()
        }
    }

    impl Category {
        pub fn new() -> Category {
            ::std::default::Default::default()
        }

        // optional uint32 categoryid = 1;

        pub fn categoryid(&self) -> u32 {
            self.categoryid.unwrap_or(0)
        }

        pub fn clear_categoryid(&mut self) {
            self.categoryid = ::std::option::Option::None;
        }

        pub fn has_categoryid(&self) -> bool {
            self.categoryid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_categoryid(&mut self, v: u32) {
            self.categoryid = ::std::option::Option::Some(v);
        }

        // optional .EStoreCategoryType type = 2;

        pub fn type_(&self) -> super::EStoreCategoryType {
            match self.type_ {
                Some(e) => e.enum_value_or(super::EStoreCategoryType::k_EStoreCategoryType_Category),
                None => super::EStoreCategoryType::k_EStoreCategoryType_Category,
            }
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: super::EStoreCategoryType) {
            self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional string internal_name = 3;

        pub fn internal_name(&self) -> &str {
            match self.internal_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_internal_name(&mut self) {
            self.internal_name = ::std::option::Option::None;
        }

        pub fn has_internal_name(&self) -> bool {
            self.internal_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_internal_name(&mut self, v: ::std::string::String) {
            self.internal_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_internal_name(&mut self) -> &mut ::std::string::String {
            if self.internal_name.is_none() {
                self.internal_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.internal_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_internal_name(&mut self) -> ::std::string::String {
            self.internal_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string display_name = 4;

        pub fn display_name(&self) -> &str {
            match self.display_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_display_name(&mut self) {
            self.display_name = ::std::option::Option::None;
        }

        pub fn has_display_name(&self) -> bool {
            self.display_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_display_name(&mut self, v: ::std::string::String) {
            self.display_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
            if self.display_name.is_none() {
                self.display_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.display_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_display_name(&mut self) -> ::std::string::String {
            self.display_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string image_url = 5;

        pub fn image_url(&self) -> &str {
            match self.image_url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_image_url(&mut self) {
            self.image_url = ::std::option::Option::None;
        }

        pub fn has_image_url(&self) -> bool {
            self.image_url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_url(&mut self, v: ::std::string::String) {
            self.image_url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_image_url(&mut self) -> &mut ::std::string::String {
            if self.image_url.is_none() {
                self.image_url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.image_url.as_mut().unwrap()
        }

        // Take field
        pub fn take_image_url(&mut self) -> ::std::string::String {
            self.image_url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool show_in_search = 6;

        pub fn show_in_search(&self) -> bool {
            self.show_in_search.unwrap_or(false)
        }

        pub fn clear_show_in_search(&mut self) {
            self.show_in_search = ::std::option::Option::None;
        }

        pub fn has_show_in_search(&self) -> bool {
            self.show_in_search.is_some()
        }

        // Param is passed by value, moved
        pub fn set_show_in_search(&mut self, v: bool) {
            self.show_in_search = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "categoryid",
                |m: &Category| { &m.categoryid },
                |m: &mut Category| { &mut m.categoryid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Category| { &m.type_ },
                |m: &mut Category| { &mut m.type_ },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "internal_name",
                |m: &Category| { &m.internal_name },
                |m: &mut Category| { &mut m.internal_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "display_name",
                |m: &Category| { &m.display_name },
                |m: &mut Category| { &mut m.display_name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_url",
                |m: &Category| { &m.image_url },
                |m: &mut Category| { &mut m.image_url },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "show_in_search",
                |m: &Category| { &m.show_in_search },
                |m: &mut Category| { &mut m.show_in_search },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Category>(
                "CStoreBrowse_GetStoreCategories_Response.Category",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Category {
        const NAME: &'static str = "Category";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.categoryid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    26 => {
                        self.internal_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.display_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    42 => {
                        self.image_url = ::std::option::Option::Some(is.read_string()?);
                    },
                    48 => {
                        self.show_in_search = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.categoryid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.type_ {
                my_size += crate::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.internal_name.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.display_name.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            if let Some(v) = self.image_url.as_ref() {
                my_size += crate::rt::string_size(5, &v);
            }
            if let Some(v) = self.show_in_search {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.categoryid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.internal_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.display_name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.image_url.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.show_in_search {
                os.write_bool(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Category {
            Category::new()
        }

        fn clear(&mut self) {
            self.categoryid = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.internal_name = ::std::option::Option::None;
            self.display_name = ::std::option::Option::None;
            self.image_url = ::std::option::Option::None;
            self.show_in_search = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Category {
            static instance: Category = Category {
                categoryid: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                internal_name: ::std::option::Option::None,
                display_name: ::std::option::Option::None,
                image_url: ::std::option::Option::None,
                show_in_search: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Category {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStoreBrowse_GetStoreCategories_Response.Category").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Category {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Category {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStoreBrowse_GetDLCForApps_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetDLCForApps_Request {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Request.context)
    pub context: crate::MessageField<StoreBrowseContext>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Request.store_page_filter)
    pub store_page_filter: crate::MessageField<super::contenthubs::CStorePageFilter>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Request.appids)
    pub appids: ::std::vec::Vec<StoreItemID>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForApps_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetDLCForApps_Request {
    fn default() -> &'a CStoreBrowse_GetDLCForApps_Request {
        <CStoreBrowse_GetDLCForApps_Request as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetDLCForApps_Request {
    pub fn new() -> CStoreBrowse_GetDLCForApps_Request {
        ::std::default::Default::default()
    }

    // optional .StoreBrowseContext context = 1;

    pub fn context(&self) -> &StoreBrowseContext {
        self.context.as_ref().unwrap_or_else(|| <StoreBrowseContext as crate::Message>::default_instance())
    }

    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: StoreBrowseContext) {
        self.context = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut StoreBrowseContext {
        self.context.mut_or_insert_default()
    }

    // Take field
    pub fn take_context(&mut self) -> StoreBrowseContext {
        self.context.take().unwrap_or_else(|| StoreBrowseContext::new())
    }

    // optional .CStorePageFilter store_page_filter = 2;

    pub fn store_page_filter(&self) -> &super::contenthubs::CStorePageFilter {
        self.store_page_filter.as_ref().unwrap_or_else(|| <super::contenthubs::CStorePageFilter as crate::Message>::default_instance())
    }

    pub fn clear_store_page_filter(&mut self) {
        self.store_page_filter.clear();
    }

    pub fn has_store_page_filter(&self) -> bool {
        self.store_page_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_page_filter(&mut self, v: super::contenthubs::CStorePageFilter) {
        self.store_page_filter = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_page_filter(&mut self) -> &mut super::contenthubs::CStorePageFilter {
        self.store_page_filter.mut_or_insert_default()
    }

    // Take field
    pub fn take_store_page_filter(&mut self) -> super::contenthubs::CStorePageFilter {
        self.store_page_filter.take().unwrap_or_else(|| super::contenthubs::CStorePageFilter::new())
    }

    // repeated .StoreItemID appids = 3;

    pub fn appids(&self) -> &[StoreItemID] {
        &self.appids
    }

    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<StoreItemID>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<StoreItemID> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<StoreItemID> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }

    // optional uint64 steamid = 4;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, StoreBrowseContext>(
            "context",
            |m: &CStoreBrowse_GetDLCForApps_Request| { &m.context },
            |m: &mut CStoreBrowse_GetDLCForApps_Request| { &mut m.context },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::contenthubs::CStorePageFilter>(
            "store_page_filter",
            |m: &CStoreBrowse_GetDLCForApps_Request| { &m.store_page_filter },
            |m: &mut CStoreBrowse_GetDLCForApps_Request| { &mut m.store_page_filter },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appids",
            |m: &CStoreBrowse_GetDLCForApps_Request| { &m.appids },
            |m: &mut CStoreBrowse_GetDLCForApps_Request| { &mut m.appids },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CStoreBrowse_GetDLCForApps_Request| { &m.steamid },
            |m: &mut CStoreBrowse_GetDLCForApps_Request| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetDLCForApps_Request>(
            "CStoreBrowse_GetDLCForApps_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetDLCForApps_Request {
    const NAME: &'static str = "CStoreBrowse_GetDLCForApps_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                26 => {
                    self.appids.push(is.read_message()?);
                },
                32 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.appids {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.steamid {
            my_size += crate::rt::uint64_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.context.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.appids {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.steamid {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetDLCForApps_Request {
        CStoreBrowse_GetDLCForApps_Request::new()
    }

    fn clear(&mut self) {
        self.context.clear();
        self.store_page_filter.clear();
        self.appids.clear();
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetDLCForApps_Request {
        static instance: CStoreBrowse_GetDLCForApps_Request = CStoreBrowse_GetDLCForApps_Request {
            context: crate::MessageField::none(),
            store_page_filter: crate::MessageField::none(),
            appids: ::std::vec::Vec::new(),
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetDLCForApps_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetDLCForApps_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetDLCForApps_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetDLCForApps_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStoreBrowse_GetDLCForApps_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetDLCForApps_Response {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.dlc_data)
    pub dlc_data: ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::DLCData>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.playtime)
    pub playtime: ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::PlaytimeForApp>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForApps_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetDLCForApps_Response {
    fn default() -> &'a CStoreBrowse_GetDLCForApps_Response {
        <CStoreBrowse_GetDLCForApps_Response as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetDLCForApps_Response {
    pub fn new() -> CStoreBrowse_GetDLCForApps_Response {
        ::std::default::Default::default()
    }

    // repeated .CStoreBrowse_GetDLCForApps_Response.DLCData dlc_data = 1;

    pub fn dlc_data(&self) -> &[cstore_browse_get_dlcfor_apps_response::DLCData] {
        &self.dlc_data
    }

    pub fn clear_dlc_data(&mut self) {
        self.dlc_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_dlc_data(&mut self, v: ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::DLCData>) {
        self.dlc_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dlc_data(&mut self) -> &mut ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::DLCData> {
        &mut self.dlc_data
    }

    // Take field
    pub fn take_dlc_data(&mut self) -> ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::DLCData> {
        ::std::mem::replace(&mut self.dlc_data, ::std::vec::Vec::new())
    }

    // repeated .CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp playtime = 2;

    pub fn playtime(&self) -> &[cstore_browse_get_dlcfor_apps_response::PlaytimeForApp] {
        &self.playtime
    }

    pub fn clear_playtime(&mut self) {
        self.playtime.clear();
    }

    // Param is passed by value, moved
    pub fn set_playtime(&mut self, v: ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::PlaytimeForApp>) {
        self.playtime = v;
    }

    // Mutable pointer to the field.
    pub fn mut_playtime(&mut self) -> &mut ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::PlaytimeForApp> {
        &mut self.playtime
    }

    // Take field
    pub fn take_playtime(&mut self) -> ::std::vec::Vec<cstore_browse_get_dlcfor_apps_response::PlaytimeForApp> {
        ::std::mem::replace(&mut self.playtime, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dlc_data",
            |m: &CStoreBrowse_GetDLCForApps_Response| { &m.dlc_data },
            |m: &mut CStoreBrowse_GetDLCForApps_Response| { &mut m.dlc_data },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "playtime",
            |m: &CStoreBrowse_GetDLCForApps_Response| { &m.playtime },
            |m: &mut CStoreBrowse_GetDLCForApps_Response| { &mut m.playtime },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetDLCForApps_Response>(
            "CStoreBrowse_GetDLCForApps_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetDLCForApps_Response {
    const NAME: &'static str = "CStoreBrowse_GetDLCForApps_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dlc_data.push(is.read_message()?);
                },
                18 => {
                    self.playtime.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dlc_data {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.playtime {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.dlc_data {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.playtime {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetDLCForApps_Response {
        CStoreBrowse_GetDLCForApps_Response::new()
    }

    fn clear(&mut self) {
        self.dlc_data.clear();
        self.playtime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetDLCForApps_Response {
        static instance: CStoreBrowse_GetDLCForApps_Response = CStoreBrowse_GetDLCForApps_Response {
            dlc_data: ::std::vec::Vec::new(),
            playtime: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetDLCForApps_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetDLCForApps_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetDLCForApps_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetDLCForApps_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStoreBrowse_GetDLCForApps_Response`
pub mod cstore_browse_get_dlcfor_apps_response {
    // @@protoc_insertion_point(message:CStoreBrowse_GetDLCForApps_Response.DLCData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DLCData {
        // message fields
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.parentappid)
        pub parentappid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.release_date)
        pub release_date: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.coming_soon)
        pub coming_soon: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.price)
        pub price: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.discount)
        pub discount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.DLCData.free)
        pub free: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForApps_Response.DLCData.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DLCData {
        fn default() -> &'a DLCData {
            <DLCData as crate::Message>::default_instance()
        }
    }

    impl DLCData {
        pub fn new() -> DLCData {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 parentappid = 2;

        pub fn parentappid(&self) -> u32 {
            self.parentappid.unwrap_or(0)
        }

        pub fn clear_parentappid(&mut self) {
            self.parentappid = ::std::option::Option::None;
        }

        pub fn has_parentappid(&self) -> bool {
            self.parentappid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parentappid(&mut self, v: u32) {
            self.parentappid = ::std::option::Option::Some(v);
        }

        // optional uint32 release_date = 3;

        pub fn release_date(&self) -> u32 {
            self.release_date.unwrap_or(0)
        }

        pub fn clear_release_date(&mut self) {
            self.release_date = ::std::option::Option::None;
        }

        pub fn has_release_date(&self) -> bool {
            self.release_date.is_some()
        }

        // Param is passed by value, moved
        pub fn set_release_date(&mut self, v: u32) {
            self.release_date = ::std::option::Option::Some(v);
        }

        // optional bool coming_soon = 4;

        pub fn coming_soon(&self) -> bool {
            self.coming_soon.unwrap_or(false)
        }

        pub fn clear_coming_soon(&mut self) {
            self.coming_soon = ::std::option::Option::None;
        }

        pub fn has_coming_soon(&self) -> bool {
            self.coming_soon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coming_soon(&mut self, v: bool) {
            self.coming_soon = ::std::option::Option::Some(v);
        }

        // optional int64 price = 5;

        pub fn price(&self) -> i64 {
            self.price.unwrap_or(0)
        }

        pub fn clear_price(&mut self) {
            self.price = ::std::option::Option::None;
        }

        pub fn has_price(&self) -> bool {
            self.price.is_some()
        }

        // Param is passed by value, moved
        pub fn set_price(&mut self, v: i64) {
            self.price = ::std::option::Option::Some(v);
        }

        // optional uint32 discount = 6;

        pub fn discount(&self) -> u32 {
            self.discount.unwrap_or(0)
        }

        pub fn clear_discount(&mut self) {
            self.discount = ::std::option::Option::None;
        }

        pub fn has_discount(&self) -> bool {
            self.discount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_discount(&mut self, v: u32) {
            self.discount = ::std::option::Option::Some(v);
        }

        // optional bool free = 7;

        pub fn free(&self) -> bool {
            self.free.unwrap_or(false)
        }

        pub fn clear_free(&mut self) {
            self.free = ::std::option::Option::None;
        }

        pub fn has_free(&self) -> bool {
            self.free.is_some()
        }

        // Param is passed by value, moved
        pub fn set_free(&mut self, v: bool) {
            self.free = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &DLCData| { &m.appid },
                |m: &mut DLCData| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "parentappid",
                |m: &DLCData| { &m.parentappid },
                |m: &mut DLCData| { &mut m.parentappid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "release_date",
                |m: &DLCData| { &m.release_date },
                |m: &mut DLCData| { &mut m.release_date },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "coming_soon",
                |m: &DLCData| { &m.coming_soon },
                |m: &mut DLCData| { &mut m.coming_soon },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "price",
                |m: &DLCData| { &m.price },
                |m: &mut DLCData| { &mut m.price },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "discount",
                |m: &DLCData| { &m.discount },
                |m: &mut DLCData| { &mut m.discount },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "free",
                |m: &DLCData| { &m.free },
                |m: &mut DLCData| { &mut m.free },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DLCData>(
                "CStoreBrowse_GetDLCForApps_Response.DLCData",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DLCData {
        const NAME: &'static str = "DLCData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.parentappid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.release_date = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.coming_soon = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.price = ::std::option::Option::Some(is.read_int64()?);
                    },
                    48 => {
                        self.discount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.free = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.parentappid {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.release_date {
                my_size += crate::rt::uint32_size(3, v);
            }
            if let Some(v) = self.coming_soon {
                my_size += 1 + 1;
            }
            if let Some(v) = self.price {
                my_size += crate::rt::int64_size(5, v);
            }
            if let Some(v) = self.discount {
                my_size += crate::rt::uint32_size(6, v);
            }
            if let Some(v) = self.free {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.parentappid {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.release_date {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.coming_soon {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.price {
                os.write_int64(5, v)?;
            }
            if let Some(v) = self.discount {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.free {
                os.write_bool(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DLCData {
            DLCData::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.parentappid = ::std::option::Option::None;
            self.release_date = ::std::option::Option::None;
            self.coming_soon = ::std::option::Option::None;
            self.price = ::std::option::Option::None;
            self.discount = ::std::option::Option::None;
            self.free = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DLCData {
            static instance: DLCData = DLCData {
                appid: ::std::option::Option::None,
                parentappid: ::std::option::Option::None,
                release_date: ::std::option::Option::None,
                coming_soon: ::std::option::Option::None,
                price: ::std::option::Option::None,
                discount: ::std::option::Option::None,
                free: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DLCData {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStoreBrowse_GetDLCForApps_Response.DLCData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DLCData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DLCData {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlaytimeForApp {
        // message fields
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.appid)
        pub appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.playtime)
        pub playtime: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.last_played)
        pub last_played: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlaytimeForApp {
        fn default() -> &'a PlaytimeForApp {
            <PlaytimeForApp as crate::Message>::default_instance()
        }
    }

    impl PlaytimeForApp {
        pub fn new() -> PlaytimeForApp {
            ::std::default::Default::default()
        }

        // optional uint32 appid = 1;

        pub fn appid(&self) -> u32 {
            self.appid.unwrap_or(0)
        }

        pub fn clear_appid(&mut self) {
            self.appid = ::std::option::Option::None;
        }

        pub fn has_appid(&self) -> bool {
            self.appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_appid(&mut self, v: u32) {
            self.appid = ::std::option::Option::Some(v);
        }

        // optional uint32 playtime = 2;

        pub fn playtime(&self) -> u32 {
            self.playtime.unwrap_or(0)
        }

        pub fn clear_playtime(&mut self) {
            self.playtime = ::std::option::Option::None;
        }

        pub fn has_playtime(&self) -> bool {
            self.playtime.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playtime(&mut self, v: u32) {
            self.playtime = ::std::option::Option::Some(v);
        }

        // optional uint32 last_played = 3;

        pub fn last_played(&self) -> u32 {
            self.last_played.unwrap_or(0)
        }

        pub fn clear_last_played(&mut self) {
            self.last_played = ::std::option::Option::None;
        }

        pub fn has_last_played(&self) -> bool {
            self.last_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_played(&mut self, v: u32) {
            self.last_played = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "appid",
                |m: &PlaytimeForApp| { &m.appid },
                |m: &mut PlaytimeForApp| { &mut m.appid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "playtime",
                |m: &PlaytimeForApp| { &m.playtime },
                |m: &mut PlaytimeForApp| { &mut m.playtime },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "last_played",
                |m: &PlaytimeForApp| { &m.last_played },
                |m: &mut PlaytimeForApp| { &mut m.last_played },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<PlaytimeForApp>(
                "CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for PlaytimeForApp {
        const NAME: &'static str = "PlaytimeForApp";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.playtime = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.last_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.playtime {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.last_played {
                my_size += crate::rt::uint32_size(3, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.appid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.playtime {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.last_played {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlaytimeForApp {
            PlaytimeForApp::new()
        }

        fn clear(&mut self) {
            self.appid = ::std::option::Option::None;
            self.playtime = ::std::option::Option::None;
            self.last_played = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlaytimeForApp {
            static instance: PlaytimeForApp = PlaytimeForApp {
                appid: ::std::option::Option::None,
                playtime: ::std::option::Option::None,
                last_played: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for PlaytimeForApp {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlaytimeForApp {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for PlaytimeForApp {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStoreBrowse_GetDLCForAppsSolr_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetDLCForAppsSolr_Request {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.context)
    pub context: crate::MessageField<StoreBrowseContext>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.appids)
    pub appids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.flavor)
    pub flavor: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Request.store_page_filter)
    pub store_page_filter: crate::MessageField<super::contenthubs::CStorePageFilter>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForAppsSolr_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetDLCForAppsSolr_Request {
    fn default() -> &'a CStoreBrowse_GetDLCForAppsSolr_Request {
        <CStoreBrowse_GetDLCForAppsSolr_Request as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetDLCForAppsSolr_Request {
    pub fn new() -> CStoreBrowse_GetDLCForAppsSolr_Request {
        ::std::default::Default::default()
    }

    // optional .StoreBrowseContext context = 1;

    pub fn context(&self) -> &StoreBrowseContext {
        self.context.as_ref().unwrap_or_else(|| <StoreBrowseContext as crate::Message>::default_instance())
    }

    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: StoreBrowseContext) {
        self.context = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut StoreBrowseContext {
        self.context.mut_or_insert_default()
    }

    // Take field
    pub fn take_context(&mut self) -> StoreBrowseContext {
        self.context.take().unwrap_or_else(|| StoreBrowseContext::new())
    }

    // repeated uint32 appids = 2;

    pub fn appids(&self) -> &[u32] {
        &self.appids
    }

    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }

    // optional string flavor = 3;

    pub fn flavor(&self) -> &str {
        match self.flavor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_flavor(&mut self) {
        self.flavor = ::std::option::Option::None;
    }

    pub fn has_flavor(&self) -> bool {
        self.flavor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flavor(&mut self, v: ::std::string::String) {
        self.flavor = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flavor(&mut self) -> &mut ::std::string::String {
        if self.flavor.is_none() {
            self.flavor = ::std::option::Option::Some(::std::string::String::new());
        }
        self.flavor.as_mut().unwrap()
    }

    // Take field
    pub fn take_flavor(&mut self) -> ::std::string::String {
        self.flavor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 count = 4;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional .CStorePageFilter store_page_filter = 5;

    pub fn store_page_filter(&self) -> &super::contenthubs::CStorePageFilter {
        self.store_page_filter.as_ref().unwrap_or_else(|| <super::contenthubs::CStorePageFilter as crate::Message>::default_instance())
    }

    pub fn clear_store_page_filter(&mut self) {
        self.store_page_filter.clear();
    }

    pub fn has_store_page_filter(&self) -> bool {
        self.store_page_filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_page_filter(&mut self, v: super::contenthubs::CStorePageFilter) {
        self.store_page_filter = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_store_page_filter(&mut self) -> &mut super::contenthubs::CStorePageFilter {
        self.store_page_filter.mut_or_insert_default()
    }

    // Take field
    pub fn take_store_page_filter(&mut self) -> super::contenthubs::CStorePageFilter {
        self.store_page_filter.take().unwrap_or_else(|| super::contenthubs::CStorePageFilter::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, StoreBrowseContext>(
            "context",
            |m: &CStoreBrowse_GetDLCForAppsSolr_Request| { &m.context },
            |m: &mut CStoreBrowse_GetDLCForAppsSolr_Request| { &mut m.context },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "appids",
            |m: &CStoreBrowse_GetDLCForAppsSolr_Request| { &m.appids },
            |m: &mut CStoreBrowse_GetDLCForAppsSolr_Request| { &mut m.appids },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "flavor",
            |m: &CStoreBrowse_GetDLCForAppsSolr_Request| { &m.flavor },
            |m: &mut CStoreBrowse_GetDLCForAppsSolr_Request| { &mut m.flavor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CStoreBrowse_GetDLCForAppsSolr_Request| { &m.count },
            |m: &mut CStoreBrowse_GetDLCForAppsSolr_Request| { &mut m.count },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::contenthubs::CStorePageFilter>(
            "store_page_filter",
            |m: &CStoreBrowse_GetDLCForAppsSolr_Request| { &m.store_page_filter },
            |m: &mut CStoreBrowse_GetDLCForAppsSolr_Request| { &mut m.store_page_filter },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetDLCForAppsSolr_Request>(
            "CStoreBrowse_GetDLCForAppsSolr_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetDLCForAppsSolr_Request {
    const NAME: &'static str = "CStoreBrowse_GetDLCForAppsSolr_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.appids)?;
                },
                16 => {
                    self.appids.push(is.read_uint32()?);
                },
                26 => {
                    self.flavor = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.store_page_filter)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.appids {
            my_size += crate::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.flavor.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.count {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.context.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.appids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.flavor.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.store_page_filter.as_ref() {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetDLCForAppsSolr_Request {
        CStoreBrowse_GetDLCForAppsSolr_Request::new()
    }

    fn clear(&mut self) {
        self.context.clear();
        self.appids.clear();
        self.flavor = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.store_page_filter.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetDLCForAppsSolr_Request {
        static instance: CStoreBrowse_GetDLCForAppsSolr_Request = CStoreBrowse_GetDLCForAppsSolr_Request {
            context: crate::MessageField::none(),
            appids: ::std::vec::Vec::new(),
            flavor: ::std::option::Option::None,
            count: ::std::option::Option::None,
            store_page_filter: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetDLCForAppsSolr_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetDLCForAppsSolr_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetDLCForAppsSolr_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetDLCForAppsSolr_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStoreBrowse_GetDLCForAppsSolr_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetDLCForAppsSolr_Response {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Response.dlc_lists)
    pub dlc_lists: ::std::vec::Vec<cstore_browse_get_dlcfor_apps_solr_response::DLCList>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForAppsSolr_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetDLCForAppsSolr_Response {
    fn default() -> &'a CStoreBrowse_GetDLCForAppsSolr_Response {
        <CStoreBrowse_GetDLCForAppsSolr_Response as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetDLCForAppsSolr_Response {
    pub fn new() -> CStoreBrowse_GetDLCForAppsSolr_Response {
        ::std::default::Default::default()
    }

    // repeated .CStoreBrowse_GetDLCForAppsSolr_Response.DLCList dlc_lists = 1;

    pub fn dlc_lists(&self) -> &[cstore_browse_get_dlcfor_apps_solr_response::DLCList] {
        &self.dlc_lists
    }

    pub fn clear_dlc_lists(&mut self) {
        self.dlc_lists.clear();
    }

    // Param is passed by value, moved
    pub fn set_dlc_lists(&mut self, v: ::std::vec::Vec<cstore_browse_get_dlcfor_apps_solr_response::DLCList>) {
        self.dlc_lists = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dlc_lists(&mut self) -> &mut ::std::vec::Vec<cstore_browse_get_dlcfor_apps_solr_response::DLCList> {
        &mut self.dlc_lists
    }

    // Take field
    pub fn take_dlc_lists(&mut self) -> ::std::vec::Vec<cstore_browse_get_dlcfor_apps_solr_response::DLCList> {
        ::std::mem::replace(&mut self.dlc_lists, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dlc_lists",
            |m: &CStoreBrowse_GetDLCForAppsSolr_Response| { &m.dlc_lists },
            |m: &mut CStoreBrowse_GetDLCForAppsSolr_Response| { &mut m.dlc_lists },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetDLCForAppsSolr_Response>(
            "CStoreBrowse_GetDLCForAppsSolr_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetDLCForAppsSolr_Response {
    const NAME: &'static str = "CStoreBrowse_GetDLCForAppsSolr_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dlc_lists.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.dlc_lists {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.dlc_lists {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetDLCForAppsSolr_Response {
        CStoreBrowse_GetDLCForAppsSolr_Response::new()
    }

    fn clear(&mut self) {
        self.dlc_lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetDLCForAppsSolr_Response {
        static instance: CStoreBrowse_GetDLCForAppsSolr_Response = CStoreBrowse_GetDLCForAppsSolr_Response {
            dlc_lists: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetDLCForAppsSolr_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetDLCForAppsSolr_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetDLCForAppsSolr_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetDLCForAppsSolr_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CStoreBrowse_GetDLCForAppsSolr_Response`
pub mod cstore_browse_get_dlcfor_apps_solr_response {
    // @@protoc_insertion_point(message:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DLCList {
        // message fields
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.parent_appid)
        pub parent_appid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.dlc_appids)
        pub dlc_appids: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DLCList {
        fn default() -> &'a DLCList {
            <DLCList as crate::Message>::default_instance()
        }
    }

    impl DLCList {
        pub fn new() -> DLCList {
            ::std::default::Default::default()
        }

        // optional uint32 parent_appid = 1;

        pub fn parent_appid(&self) -> u32 {
            self.parent_appid.unwrap_or(0)
        }

        pub fn clear_parent_appid(&mut self) {
            self.parent_appid = ::std::option::Option::None;
        }

        pub fn has_parent_appid(&self) -> bool {
            self.parent_appid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_parent_appid(&mut self, v: u32) {
            self.parent_appid = ::std::option::Option::Some(v);
        }

        // repeated uint32 dlc_appids = 2;

        pub fn dlc_appids(&self) -> &[u32] {
            &self.dlc_appids
        }

        pub fn clear_dlc_appids(&mut self) {
            self.dlc_appids.clear();
        }

        // Param is passed by value, moved
        pub fn set_dlc_appids(&mut self, v: ::std::vec::Vec<u32>) {
            self.dlc_appids = v;
        }

        // Mutable pointer to the field.
        pub fn mut_dlc_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
            &mut self.dlc_appids
        }

        // Take field
        pub fn take_dlc_appids(&mut self) -> ::std::vec::Vec<u32> {
            ::std::mem::replace(&mut self.dlc_appids, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "parent_appid",
                |m: &DLCList| { &m.parent_appid },
                |m: &mut DLCList| { &mut m.parent_appid },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "dlc_appids",
                |m: &DLCList| { &m.dlc_appids },
                |m: &mut DLCList| { &mut m.dlc_appids },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DLCList>(
                "CStoreBrowse_GetDLCForAppsSolr_Response.DLCList",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DLCList {
        const NAME: &'static str = "DLCList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.parent_appid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.dlc_appids)?;
                    },
                    16 => {
                        self.dlc_appids.push(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.parent_appid {
                my_size += crate::rt::uint32_size(1, v);
            }
            for value in &self.dlc_appids {
                my_size += crate::rt::uint32_size(2, *value);
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.parent_appid {
                os.write_uint32(1, v)?;
            }
            for v in &self.dlc_appids {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DLCList {
            DLCList::new()
        }

        fn clear(&mut self) {
            self.parent_appid = ::std::option::Option::None;
            self.dlc_appids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DLCList {
            static instance: DLCList = DLCList {
                parent_appid: ::std::option::Option::None,
                dlc_appids: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DLCList {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CStoreBrowse_GetDLCForAppsSolr_Response.DLCList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DLCList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DLCList {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CStoreBrowse_GetHardwareItems_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetHardwareItems_Request {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetHardwareItems_Request.packageid)
    pub packageid: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CStoreBrowse_GetHardwareItems_Request.context)
    pub context: crate::MessageField<StoreBrowseContext>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetHardwareItems_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetHardwareItems_Request {
    fn default() -> &'a CStoreBrowse_GetHardwareItems_Request {
        <CStoreBrowse_GetHardwareItems_Request as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetHardwareItems_Request {
    pub fn new() -> CStoreBrowse_GetHardwareItems_Request {
        ::std::default::Default::default()
    }

    // repeated uint32 packageid = 1;

    pub fn packageid(&self) -> &[u32] {
        &self.packageid
    }

    pub fn clear_packageid(&mut self) {
        self.packageid.clear();
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: ::std::vec::Vec<u32>) {
        self.packageid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packageid(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.packageid
    }

    // Take field
    pub fn take_packageid(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packageid, ::std::vec::Vec::new())
    }

    // optional .StoreBrowseContext context = 2;

    pub fn context(&self) -> &StoreBrowseContext {
        self.context.as_ref().unwrap_or_else(|| <StoreBrowseContext as crate::Message>::default_instance())
    }

    pub fn clear_context(&mut self) {
        self.context.clear();
    }

    pub fn has_context(&self) -> bool {
        self.context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context(&mut self, v: StoreBrowseContext) {
        self.context = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_context(&mut self) -> &mut StoreBrowseContext {
        self.context.mut_or_insert_default()
    }

    // Take field
    pub fn take_context(&mut self) -> StoreBrowseContext {
        self.context.take().unwrap_or_else(|| StoreBrowseContext::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packageid",
            |m: &CStoreBrowse_GetHardwareItems_Request| { &m.packageid },
            |m: &mut CStoreBrowse_GetHardwareItems_Request| { &mut m.packageid },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, StoreBrowseContext>(
            "context",
            |m: &CStoreBrowse_GetHardwareItems_Request| { &m.context },
            |m: &mut CStoreBrowse_GetHardwareItems_Request| { &mut m.context },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetHardwareItems_Request>(
            "CStoreBrowse_GetHardwareItems_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetHardwareItems_Request {
    const NAME: &'static str = "CStoreBrowse_GetHardwareItems_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.packageid)?;
                },
                8 => {
                    self.packageid.push(is.read_uint32()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.context)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.packageid {
            my_size += crate::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.packageid {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.context.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetHardwareItems_Request {
        CStoreBrowse_GetHardwareItems_Request::new()
    }

    fn clear(&mut self) {
        self.packageid.clear();
        self.context.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetHardwareItems_Request {
        static instance: CStoreBrowse_GetHardwareItems_Request = CStoreBrowse_GetHardwareItems_Request {
            packageid: ::std::vec::Vec::new(),
            context: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetHardwareItems_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetHardwareItems_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetHardwareItems_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetHardwareItems_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CHardwarePackageDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHardwarePackageDetails {
    // message fields
    // @@protoc_insertion_point(field:CHardwarePackageDetails.packageid)
    pub packageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.inventory_available)
    pub inventory_available: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.high_pending_orders)
    pub high_pending_orders: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.account_restricted_from_purchasing)
    pub account_restricted_from_purchasing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.requires_reservation)
    pub requires_reservation: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.rtime_estimated_notification)
    pub rtime_estimated_notification: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.notificaton_token)
    pub notificaton_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.reservation_state)
    pub reservation_state: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.expired)
    pub expired: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.time_expires)
    pub time_expires: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.time_reserved)
    pub time_reserved: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.allow_quantity_purchase)
    pub allow_quantity_purchase: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.max_quantity_per_purchase)
    pub max_quantity_per_purchase: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.allow_purchase_in_country)
    pub allow_purchase_in_country: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.estimated_delivery_soonest_business_days)
    pub estimated_delivery_soonest_business_days: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHardwarePackageDetails.estimated_delivery_latest_business_days)
    pub estimated_delivery_latest_business_days: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CHardwarePackageDetails.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHardwarePackageDetails {
    fn default() -> &'a CHardwarePackageDetails {
        <CHardwarePackageDetails as crate::Message>::default_instance()
    }
}

impl CHardwarePackageDetails {
    pub fn new() -> CHardwarePackageDetails {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;

    pub fn packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional bool inventory_available = 3;

    pub fn inventory_available(&self) -> bool {
        self.inventory_available.unwrap_or(false)
    }

    pub fn clear_inventory_available(&mut self) {
        self.inventory_available = ::std::option::Option::None;
    }

    pub fn has_inventory_available(&self) -> bool {
        self.inventory_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory_available(&mut self, v: bool) {
        self.inventory_available = ::std::option::Option::Some(v);
    }

    // optional bool high_pending_orders = 4;

    pub fn high_pending_orders(&self) -> bool {
        self.high_pending_orders.unwrap_or(false)
    }

    pub fn clear_high_pending_orders(&mut self) {
        self.high_pending_orders = ::std::option::Option::None;
    }

    pub fn has_high_pending_orders(&self) -> bool {
        self.high_pending_orders.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_pending_orders(&mut self, v: bool) {
        self.high_pending_orders = ::std::option::Option::Some(v);
    }

    // optional bool account_restricted_from_purchasing = 5;

    pub fn account_restricted_from_purchasing(&self) -> bool {
        self.account_restricted_from_purchasing.unwrap_or(false)
    }

    pub fn clear_account_restricted_from_purchasing(&mut self) {
        self.account_restricted_from_purchasing = ::std::option::Option::None;
    }

    pub fn has_account_restricted_from_purchasing(&self) -> bool {
        self.account_restricted_from_purchasing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_restricted_from_purchasing(&mut self, v: bool) {
        self.account_restricted_from_purchasing = ::std::option::Option::Some(v);
    }

    // optional bool requires_reservation = 6;

    pub fn requires_reservation(&self) -> bool {
        self.requires_reservation.unwrap_or(false)
    }

    pub fn clear_requires_reservation(&mut self) {
        self.requires_reservation = ::std::option::Option::None;
    }

    pub fn has_requires_reservation(&self) -> bool {
        self.requires_reservation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_reservation(&mut self, v: bool) {
        self.requires_reservation = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_estimated_notification = 7;

    pub fn rtime_estimated_notification(&self) -> u32 {
        self.rtime_estimated_notification.unwrap_or(0)
    }

    pub fn clear_rtime_estimated_notification(&mut self) {
        self.rtime_estimated_notification = ::std::option::Option::None;
    }

    pub fn has_rtime_estimated_notification(&self) -> bool {
        self.rtime_estimated_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_estimated_notification(&mut self, v: u32) {
        self.rtime_estimated_notification = ::std::option::Option::Some(v);
    }

    // optional string notificaton_token = 8;

    pub fn notificaton_token(&self) -> &str {
        match self.notificaton_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notificaton_token(&mut self) {
        self.notificaton_token = ::std::option::Option::None;
    }

    pub fn has_notificaton_token(&self) -> bool {
        self.notificaton_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notificaton_token(&mut self, v: ::std::string::String) {
        self.notificaton_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notificaton_token(&mut self) -> &mut ::std::string::String {
        if self.notificaton_token.is_none() {
            self.notificaton_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notificaton_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_notificaton_token(&mut self) -> ::std::string::String {
        self.notificaton_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 reservation_state = 9;

    pub fn reservation_state(&self) -> i32 {
        self.reservation_state.unwrap_or(0)
    }

    pub fn clear_reservation_state(&mut self) {
        self.reservation_state = ::std::option::Option::None;
    }

    pub fn has_reservation_state(&self) -> bool {
        self.reservation_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_state(&mut self, v: i32) {
        self.reservation_state = ::std::option::Option::Some(v);
    }

    // optional bool expired = 10;

    pub fn expired(&self) -> bool {
        self.expired.unwrap_or(false)
    }

    pub fn clear_expired(&mut self) {
        self.expired = ::std::option::Option::None;
    }

    pub fn has_expired(&self) -> bool {
        self.expired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expired(&mut self, v: bool) {
        self.expired = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 11;

    pub fn time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }

    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint32 time_reserved = 12;

    pub fn time_reserved(&self) -> u32 {
        self.time_reserved.unwrap_or(0)
    }

    pub fn clear_time_reserved(&mut self) {
        self.time_reserved = ::std::option::Option::None;
    }

    pub fn has_time_reserved(&self) -> bool {
        self.time_reserved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_reserved(&mut self, v: u32) {
        self.time_reserved = ::std::option::Option::Some(v);
    }

    // optional bool allow_quantity_purchase = 13;

    pub fn allow_quantity_purchase(&self) -> bool {
        self.allow_quantity_purchase.unwrap_or(false)
    }

    pub fn clear_allow_quantity_purchase(&mut self) {
        self.allow_quantity_purchase = ::std::option::Option::None;
    }

    pub fn has_allow_quantity_purchase(&self) -> bool {
        self.allow_quantity_purchase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_quantity_purchase(&mut self, v: bool) {
        self.allow_quantity_purchase = ::std::option::Option::Some(v);
    }

    // optional int32 max_quantity_per_purchase = 14;

    pub fn max_quantity_per_purchase(&self) -> i32 {
        self.max_quantity_per_purchase.unwrap_or(0)
    }

    pub fn clear_max_quantity_per_purchase(&mut self) {
        self.max_quantity_per_purchase = ::std::option::Option::None;
    }

    pub fn has_max_quantity_per_purchase(&self) -> bool {
        self.max_quantity_per_purchase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_quantity_per_purchase(&mut self, v: i32) {
        self.max_quantity_per_purchase = ::std::option::Option::Some(v);
    }

    // optional bool allow_purchase_in_country = 15;

    pub fn allow_purchase_in_country(&self) -> bool {
        self.allow_purchase_in_country.unwrap_or(false)
    }

    pub fn clear_allow_purchase_in_country(&mut self) {
        self.allow_purchase_in_country = ::std::option::Option::None;
    }

    pub fn has_allow_purchase_in_country(&self) -> bool {
        self.allow_purchase_in_country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_purchase_in_country(&mut self, v: bool) {
        self.allow_purchase_in_country = ::std::option::Option::Some(v);
    }

    // optional uint32 estimated_delivery_soonest_business_days = 17;

    pub fn estimated_delivery_soonest_business_days(&self) -> u32 {
        self.estimated_delivery_soonest_business_days.unwrap_or(0)
    }

    pub fn clear_estimated_delivery_soonest_business_days(&mut self) {
        self.estimated_delivery_soonest_business_days = ::std::option::Option::None;
    }

    pub fn has_estimated_delivery_soonest_business_days(&self) -> bool {
        self.estimated_delivery_soonest_business_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimated_delivery_soonest_business_days(&mut self, v: u32) {
        self.estimated_delivery_soonest_business_days = ::std::option::Option::Some(v);
    }

    // optional uint32 estimated_delivery_latest_business_days = 18;

    pub fn estimated_delivery_latest_business_days(&self) -> u32 {
        self.estimated_delivery_latest_business_days.unwrap_or(0)
    }

    pub fn clear_estimated_delivery_latest_business_days(&mut self) {
        self.estimated_delivery_latest_business_days = ::std::option::Option::None;
    }

    pub fn has_estimated_delivery_latest_business_days(&self) -> bool {
        self.estimated_delivery_latest_business_days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimated_delivery_latest_business_days(&mut self, v: u32) {
        self.estimated_delivery_latest_business_days = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "packageid",
            |m: &CHardwarePackageDetails| { &m.packageid },
            |m: &mut CHardwarePackageDetails| { &mut m.packageid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory_available",
            |m: &CHardwarePackageDetails| { &m.inventory_available },
            |m: &mut CHardwarePackageDetails| { &mut m.inventory_available },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "high_pending_orders",
            |m: &CHardwarePackageDetails| { &m.high_pending_orders },
            |m: &mut CHardwarePackageDetails| { &mut m.high_pending_orders },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_restricted_from_purchasing",
            |m: &CHardwarePackageDetails| { &m.account_restricted_from_purchasing },
            |m: &mut CHardwarePackageDetails| { &mut m.account_restricted_from_purchasing },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "requires_reservation",
            |m: &CHardwarePackageDetails| { &m.requires_reservation },
            |m: &mut CHardwarePackageDetails| { &mut m.requires_reservation },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rtime_estimated_notification",
            |m: &CHardwarePackageDetails| { &m.rtime_estimated_notification },
            |m: &mut CHardwarePackageDetails| { &mut m.rtime_estimated_notification },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "notificaton_token",
            |m: &CHardwarePackageDetails| { &m.notificaton_token },
            |m: &mut CHardwarePackageDetails| { &mut m.notificaton_token },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservation_state",
            |m: &CHardwarePackageDetails| { &m.reservation_state },
            |m: &mut CHardwarePackageDetails| { &mut m.reservation_state },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "expired",
            |m: &CHardwarePackageDetails| { &m.expired },
            |m: &mut CHardwarePackageDetails| { &mut m.expired },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_expires",
            |m: &CHardwarePackageDetails| { &m.time_expires },
            |m: &mut CHardwarePackageDetails| { &mut m.time_expires },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_reserved",
            |m: &CHardwarePackageDetails| { &m.time_reserved },
            |m: &mut CHardwarePackageDetails| { &mut m.time_reserved },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_quantity_purchase",
            |m: &CHardwarePackageDetails| { &m.allow_quantity_purchase },
            |m: &mut CHardwarePackageDetails| { &mut m.allow_quantity_purchase },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_quantity_per_purchase",
            |m: &CHardwarePackageDetails| { &m.max_quantity_per_purchase },
            |m: &mut CHardwarePackageDetails| { &mut m.max_quantity_per_purchase },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_purchase_in_country",
            |m: &CHardwarePackageDetails| { &m.allow_purchase_in_country },
            |m: &mut CHardwarePackageDetails| { &mut m.allow_purchase_in_country },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "estimated_delivery_soonest_business_days",
            |m: &CHardwarePackageDetails| { &m.estimated_delivery_soonest_business_days },
            |m: &mut CHardwarePackageDetails| { &mut m.estimated_delivery_soonest_business_days },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "estimated_delivery_latest_business_days",
            |m: &CHardwarePackageDetails| { &m.estimated_delivery_latest_business_days },
            |m: &mut CHardwarePackageDetails| { &mut m.estimated_delivery_latest_business_days },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CHardwarePackageDetails>(
            "CHardwarePackageDetails",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CHardwarePackageDetails {
    const NAME: &'static str = "CHardwarePackageDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.packageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.inventory_available = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.high_pending_orders = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.account_restricted_from_purchasing = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.requires_reservation = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.rtime_estimated_notification = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.notificaton_token = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.reservation_state = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.expired = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.time_expires = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.time_reserved = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.allow_quantity_purchase = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.max_quantity_per_purchase = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.allow_purchase_in_country = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.estimated_delivery_soonest_business_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.estimated_delivery_latest_business_days = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.inventory_available {
            my_size += 1 + 1;
        }
        if let Some(v) = self.high_pending_orders {
            my_size += 1 + 1;
        }
        if let Some(v) = self.account_restricted_from_purchasing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.requires_reservation {
            my_size += 1 + 1;
        }
        if let Some(v) = self.rtime_estimated_notification {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.notificaton_token.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.reservation_state {
            my_size += crate::rt::int32_size(9, v);
        }
        if let Some(v) = self.expired {
            my_size += 1 + 1;
        }
        if let Some(v) = self.time_expires {
            my_size += crate::rt::uint32_size(11, v);
        }
        if let Some(v) = self.time_reserved {
            my_size += crate::rt::uint32_size(12, v);
        }
        if let Some(v) = self.allow_quantity_purchase {
            my_size += 1 + 1;
        }
        if let Some(v) = self.max_quantity_per_purchase {
            my_size += crate::rt::int32_size(14, v);
        }
        if let Some(v) = self.allow_purchase_in_country {
            my_size += 1 + 1;
        }
        if let Some(v) = self.estimated_delivery_soonest_business_days {
            my_size += crate::rt::uint32_size(17, v);
        }
        if let Some(v) = self.estimated_delivery_latest_business_days {
            my_size += crate::rt::uint32_size(18, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inventory_available {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.high_pending_orders {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.account_restricted_from_purchasing {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.requires_reservation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.rtime_estimated_notification {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.notificaton_token.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.reservation_state {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.expired {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.time_reserved {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.allow_quantity_purchase {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.max_quantity_per_purchase {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.allow_purchase_in_country {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.estimated_delivery_soonest_business_days {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.estimated_delivery_latest_business_days {
            os.write_uint32(18, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHardwarePackageDetails {
        CHardwarePackageDetails::new()
    }

    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.inventory_available = ::std::option::Option::None;
        self.high_pending_orders = ::std::option::Option::None;
        self.account_restricted_from_purchasing = ::std::option::Option::None;
        self.requires_reservation = ::std::option::Option::None;
        self.rtime_estimated_notification = ::std::option::Option::None;
        self.notificaton_token = ::std::option::Option::None;
        self.reservation_state = ::std::option::Option::None;
        self.expired = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.time_reserved = ::std::option::Option::None;
        self.allow_quantity_purchase = ::std::option::Option::None;
        self.max_quantity_per_purchase = ::std::option::Option::None;
        self.allow_purchase_in_country = ::std::option::Option::None;
        self.estimated_delivery_soonest_business_days = ::std::option::Option::None;
        self.estimated_delivery_latest_business_days = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHardwarePackageDetails {
        static instance: CHardwarePackageDetails = CHardwarePackageDetails {
            packageid: ::std::option::Option::None,
            inventory_available: ::std::option::Option::None,
            high_pending_orders: ::std::option::Option::None,
            account_restricted_from_purchasing: ::std::option::Option::None,
            requires_reservation: ::std::option::Option::None,
            rtime_estimated_notification: ::std::option::Option::None,
            notificaton_token: ::std::option::Option::None,
            reservation_state: ::std::option::Option::None,
            expired: ::std::option::Option::None,
            time_expires: ::std::option::Option::None,
            time_reserved: ::std::option::Option::None,
            allow_quantity_purchase: ::std::option::Option::None,
            max_quantity_per_purchase: ::std::option::Option::None,
            allow_purchase_in_country: ::std::option::Option::None,
            estimated_delivery_soonest_business_days: ::std::option::Option::None,
            estimated_delivery_latest_business_days: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CHardwarePackageDetails {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHardwarePackageDetails").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHardwarePackageDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CHardwarePackageDetails {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CStoreBrowse_GetHardwareItems_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CStoreBrowse_GetHardwareItems_Response {
    // message fields
    // @@protoc_insertion_point(field:CStoreBrowse_GetHardwareItems_Response.details)
    pub details: ::std::vec::Vec<CHardwarePackageDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:CStoreBrowse_GetHardwareItems_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CStoreBrowse_GetHardwareItems_Response {
    fn default() -> &'a CStoreBrowse_GetHardwareItems_Response {
        <CStoreBrowse_GetHardwareItems_Response as crate::Message>::default_instance()
    }
}

impl CStoreBrowse_GetHardwareItems_Response {
    pub fn new() -> CStoreBrowse_GetHardwareItems_Response {
        ::std::default::Default::default()
    }

    // repeated .CHardwarePackageDetails details = 1;

    pub fn details(&self) -> &[CHardwarePackageDetails] {
        &self.details
    }

    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<CHardwarePackageDetails>) {
        self.details = v;
    }

    // Mutable pointer to the field.
    pub fn mut_details(&mut self) -> &mut ::std::vec::Vec<CHardwarePackageDetails> {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<CHardwarePackageDetails> {
        ::std::mem::replace(&mut self.details, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "details",
            |m: &CStoreBrowse_GetHardwareItems_Response| { &m.details },
            |m: &mut CStoreBrowse_GetHardwareItems_Response| { &mut m.details },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CStoreBrowse_GetHardwareItems_Response>(
            "CStoreBrowse_GetHardwareItems_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CStoreBrowse_GetHardwareItems_Response {
    const NAME: &'static str = "CStoreBrowse_GetHardwareItems_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.details.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.details {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.details {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CStoreBrowse_GetHardwareItems_Response {
        CStoreBrowse_GetHardwareItems_Response::new()
    }

    fn clear(&mut self) {
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CStoreBrowse_GetHardwareItems_Response {
        static instance: CStoreBrowse_GetHardwareItems_Response = CStoreBrowse_GetHardwareItems_Response {
            details: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CStoreBrowse_GetHardwareItems_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CStoreBrowse_GetHardwareItems_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CStoreBrowse_GetHardwareItems_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CStoreBrowse_GetHardwareItems_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStoreItemType)
pub enum EStoreItemType {
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Invalid)
    k_EStoreItemType_Invalid = -1,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_App)
    k_EStoreItemType_App = 0,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Package)
    k_EStoreItemType_Package = 1,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Bundle)
    k_EStoreItemType_Bundle = 2,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Mtx)
    k_EStoreItemType_Mtx = 3,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Tag)
    k_EStoreItemType_Tag = 4,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_Creator)
    k_EStoreItemType_Creator = 5,
    // @@protoc_insertion_point(enum_value:EStoreItemType.k_EStoreItemType_HubCategory)
    k_EStoreItemType_HubCategory = 6,
}

impl crate::Enum for EStoreItemType {
    const NAME: &'static str = "EStoreItemType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStoreItemType> {
        match value {
            -1 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Invalid),
            0 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_App),
            1 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Package),
            2 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Bundle),
            3 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Mtx),
            4 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Tag),
            5 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Creator),
            6 => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_HubCategory),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStoreItemType> {
        match str {
            "k_EStoreItemType_Invalid" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Invalid),
            "k_EStoreItemType_App" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_App),
            "k_EStoreItemType_Package" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Package),
            "k_EStoreItemType_Bundle" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Bundle),
            "k_EStoreItemType_Mtx" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Mtx),
            "k_EStoreItemType_Tag" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Tag),
            "k_EStoreItemType_Creator" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_Creator),
            "k_EStoreItemType_HubCategory" => ::std::option::Option::Some(EStoreItemType::k_EStoreItemType_HubCategory),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStoreItemType] = &[
        EStoreItemType::k_EStoreItemType_Invalid,
        EStoreItemType::k_EStoreItemType_App,
        EStoreItemType::k_EStoreItemType_Package,
        EStoreItemType::k_EStoreItemType_Bundle,
        EStoreItemType::k_EStoreItemType_Mtx,
        EStoreItemType::k_EStoreItemType_Tag,
        EStoreItemType::k_EStoreItemType_Creator,
        EStoreItemType::k_EStoreItemType_HubCategory,
    ];
}

impl crate::EnumFull for EStoreItemType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStoreItemType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EStoreItemType::k_EStoreItemType_Invalid => 0,
            EStoreItemType::k_EStoreItemType_App => 1,
            EStoreItemType::k_EStoreItemType_Package => 2,
            EStoreItemType::k_EStoreItemType_Bundle => 3,
            EStoreItemType::k_EStoreItemType_Mtx => 4,
            EStoreItemType::k_EStoreItemType_Tag => 5,
            EStoreItemType::k_EStoreItemType_Creator => 6,
            EStoreItemType::k_EStoreItemType_HubCategory => 7,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EStoreItemType {
    fn default() -> Self {
        EStoreItemType::k_EStoreItemType_Invalid
    }
}

impl EStoreItemType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStoreItemType>("EStoreItemType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStoreAppType)
pub enum EStoreAppType {
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Game)
    k_EStoreAppType_Game = 0,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Demo)
    k_EStoreAppType_Demo = 1,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Mod)
    k_EStoreAppType_Mod = 2,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Movie)
    k_EStoreAppType_Movie = 3,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_DLC)
    k_EStoreAppType_DLC = 4,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Guide)
    k_EStoreAppType_Guide = 5,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Software)
    k_EStoreAppType_Software = 6,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Video)
    k_EStoreAppType_Video = 7,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Series)
    k_EStoreAppType_Series = 8,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Episode)
    k_EStoreAppType_Episode = 9,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Hardware)
    k_EStoreAppType_Hardware = 10,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Music)
    k_EStoreAppType_Music = 11,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Beta)
    k_EStoreAppType_Beta = 12,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Tool)
    k_EStoreAppType_Tool = 13,
    // @@protoc_insertion_point(enum_value:EStoreAppType.k_EStoreAppType_Advertising)
    k_EStoreAppType_Advertising = 14,
}

impl crate::Enum for EStoreAppType {
    const NAME: &'static str = "EStoreAppType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStoreAppType> {
        match value {
            0 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Game),
            1 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Demo),
            2 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Mod),
            3 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Movie),
            4 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_DLC),
            5 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Guide),
            6 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Software),
            7 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Video),
            8 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Series),
            9 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Episode),
            10 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Hardware),
            11 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Music),
            12 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Beta),
            13 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Tool),
            14 => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Advertising),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStoreAppType> {
        match str {
            "k_EStoreAppType_Game" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Game),
            "k_EStoreAppType_Demo" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Demo),
            "k_EStoreAppType_Mod" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Mod),
            "k_EStoreAppType_Movie" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Movie),
            "k_EStoreAppType_DLC" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_DLC),
            "k_EStoreAppType_Guide" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Guide),
            "k_EStoreAppType_Software" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Software),
            "k_EStoreAppType_Video" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Video),
            "k_EStoreAppType_Series" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Series),
            "k_EStoreAppType_Episode" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Episode),
            "k_EStoreAppType_Hardware" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Hardware),
            "k_EStoreAppType_Music" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Music),
            "k_EStoreAppType_Beta" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Beta),
            "k_EStoreAppType_Tool" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Tool),
            "k_EStoreAppType_Advertising" => ::std::option::Option::Some(EStoreAppType::k_EStoreAppType_Advertising),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStoreAppType] = &[
        EStoreAppType::k_EStoreAppType_Game,
        EStoreAppType::k_EStoreAppType_Demo,
        EStoreAppType::k_EStoreAppType_Mod,
        EStoreAppType::k_EStoreAppType_Movie,
        EStoreAppType::k_EStoreAppType_DLC,
        EStoreAppType::k_EStoreAppType_Guide,
        EStoreAppType::k_EStoreAppType_Software,
        EStoreAppType::k_EStoreAppType_Video,
        EStoreAppType::k_EStoreAppType_Series,
        EStoreAppType::k_EStoreAppType_Episode,
        EStoreAppType::k_EStoreAppType_Hardware,
        EStoreAppType::k_EStoreAppType_Music,
        EStoreAppType::k_EStoreAppType_Beta,
        EStoreAppType::k_EStoreAppType_Tool,
        EStoreAppType::k_EStoreAppType_Advertising,
    ];
}

impl crate::EnumFull for EStoreAppType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStoreAppType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStoreAppType {
    fn default() -> Self {
        EStoreAppType::k_EStoreAppType_Game
    }
}

impl EStoreAppType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStoreAppType>("EStoreAppType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUserReviewScore)
pub enum EUserReviewScore {
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_None)
    k_EUserReviewScore_None = 0,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_OverwhelminglyNegative)
    k_EUserReviewScore_OverwhelminglyNegative = 1,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_VeryNegative)
    k_EUserReviewScore_VeryNegative = 2,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_Negative)
    k_EUserReviewScore_Negative = 3,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_MostlyNegative)
    k_EUserReviewScore_MostlyNegative = 4,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_Mixed)
    k_EUserReviewScore_Mixed = 5,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_MostlyPositive)
    k_EUserReviewScore_MostlyPositive = 6,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_Positive)
    k_EUserReviewScore_Positive = 7,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_VeryPositive)
    k_EUserReviewScore_VeryPositive = 8,
    // @@protoc_insertion_point(enum_value:EUserReviewScore.k_EUserReviewScore_OverwhelminglyPositive)
    k_EUserReviewScore_OverwhelminglyPositive = 9,
}

impl crate::Enum for EUserReviewScore {
    const NAME: &'static str = "EUserReviewScore";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUserReviewScore> {
        match value {
            0 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_None),
            1 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_OverwhelminglyNegative),
            2 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_VeryNegative),
            3 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Negative),
            4 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_MostlyNegative),
            5 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Mixed),
            6 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_MostlyPositive),
            7 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Positive),
            8 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_VeryPositive),
            9 => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_OverwhelminglyPositive),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUserReviewScore> {
        match str {
            "k_EUserReviewScore_None" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_None),
            "k_EUserReviewScore_OverwhelminglyNegative" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_OverwhelminglyNegative),
            "k_EUserReviewScore_VeryNegative" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_VeryNegative),
            "k_EUserReviewScore_Negative" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Negative),
            "k_EUserReviewScore_MostlyNegative" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_MostlyNegative),
            "k_EUserReviewScore_Mixed" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Mixed),
            "k_EUserReviewScore_MostlyPositive" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_MostlyPositive),
            "k_EUserReviewScore_Positive" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_Positive),
            "k_EUserReviewScore_VeryPositive" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_VeryPositive),
            "k_EUserReviewScore_OverwhelminglyPositive" => ::std::option::Option::Some(EUserReviewScore::k_EUserReviewScore_OverwhelminglyPositive),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUserReviewScore] = &[
        EUserReviewScore::k_EUserReviewScore_None,
        EUserReviewScore::k_EUserReviewScore_OverwhelminglyNegative,
        EUserReviewScore::k_EUserReviewScore_VeryNegative,
        EUserReviewScore::k_EUserReviewScore_Negative,
        EUserReviewScore::k_EUserReviewScore_MostlyNegative,
        EUserReviewScore::k_EUserReviewScore_Mixed,
        EUserReviewScore::k_EUserReviewScore_MostlyPositive,
        EUserReviewScore::k_EUserReviewScore_Positive,
        EUserReviewScore::k_EUserReviewScore_VeryPositive,
        EUserReviewScore::k_EUserReviewScore_OverwhelminglyPositive,
    ];
}

impl crate::EnumFull for EUserReviewScore {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EUserReviewScore").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EUserReviewScore {
    fn default() -> Self {
        EUserReviewScore::k_EUserReviewScore_None
    }
}

impl EUserReviewScore {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EUserReviewScore>("EUserReviewScore")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStoreCategoryType)
pub enum EStoreCategoryType {
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_Category)
    k_EStoreCategoryType_Category = 0,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_SupportedPlayers)
    k_EStoreCategoryType_SupportedPlayers = 1,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_Feature)
    k_EStoreCategoryType_Feature = 2,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_ControllerSupport)
    k_EStoreCategoryType_ControllerSupport = 3,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_CloudGaming)
    k_EStoreCategoryType_CloudGaming = 4,
    // @@protoc_insertion_point(enum_value:EStoreCategoryType.k_EStoreCategoryType_MAX)
    k_EStoreCategoryType_MAX = 5,
}

impl crate::Enum for EStoreCategoryType {
    const NAME: &'static str = "EStoreCategoryType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStoreCategoryType> {
        match value {
            0 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_Category),
            1 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_SupportedPlayers),
            2 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_Feature),
            3 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_ControllerSupport),
            4 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_CloudGaming),
            5 => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_MAX),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStoreCategoryType> {
        match str {
            "k_EStoreCategoryType_Category" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_Category),
            "k_EStoreCategoryType_SupportedPlayers" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_SupportedPlayers),
            "k_EStoreCategoryType_Feature" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_Feature),
            "k_EStoreCategoryType_ControllerSupport" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_ControllerSupport),
            "k_EStoreCategoryType_CloudGaming" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_CloudGaming),
            "k_EStoreCategoryType_MAX" => ::std::option::Option::Some(EStoreCategoryType::k_EStoreCategoryType_MAX),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStoreCategoryType] = &[
        EStoreCategoryType::k_EStoreCategoryType_Category,
        EStoreCategoryType::k_EStoreCategoryType_SupportedPlayers,
        EStoreCategoryType::k_EStoreCategoryType_Feature,
        EStoreCategoryType::k_EStoreCategoryType_ControllerSupport,
        EStoreCategoryType::k_EStoreCategoryType_CloudGaming,
        EStoreCategoryType::k_EStoreCategoryType_MAX,
    ];
}

impl crate::EnumFull for EStoreCategoryType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EStoreCategoryType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EStoreCategoryType {
    fn default() -> Self {
        EStoreCategoryType::k_EStoreCategoryType_Category
    }
}

impl EStoreCategoryType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EStoreCategoryType>("EStoreCategoryType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n+steammessages_storebrowse.steamclient.proto\x1a\x18steammessages_base\
    .proto\x1a,steammessages_unified_base.steamclient.proto\x1a\x17enums_pro\
    ductinfo.proto\x1a\x0benums.proto\x1a\x11contenthubs.proto\"\xb7\x01\n\
    \x0bStoreItemID\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1c\
    \n\tpackageid\x18\x02\x20\x01(\rR\tpackageid\x12\x1a\n\x08bundleid\x18\
    \x03\x20\x01(\rR\x08bundleid\x12\x14\n\x05tagid\x18\x04\x20\x01(\rR\x05t\
    agid\x12\x1c\n\tcreatorid\x18\x05\x20\x01(\rR\tcreatorid\x12$\n\rhubcate\
    goryid\x18\x06\x20\x01(\rR\rhubcategoryid\"\x92\x01\n\x12StoreBrowseCont\
    ext\x12\x1a\n\x08language\x18\x01\x20\x01(\tR\x08language\x12\x1c\n\tela\
    nguage\x18\x02\x20\x01(\x05R\telanguage\x12!\n\x0ccountry_code\x18\x03\
    \x20\x01(\tR\x0bcountryCode\x12\x1f\n\x0bsteam_realm\x18\x04\x20\x01(\
    \x05R\nsteamRealm\"\xb5\x06\n\x1aStoreBrowseItemDataRequest\x12%\n\x0ein\
    clude_assets\x18\x01\x20\x01(\x08R\rincludeAssets\x12'\n\x0finclude_rele\
    ase\x18\x02\x20\x01(\x08R\x0eincludeRelease\x12+\n\x11include_platforms\
    \x18\x03\x20\x01(\x08R\x10includePlatforms\x12?\n\x1cinclude_all_purchas\
    e_options\x18\x04\x20\x01(\x08R\x19includeAllPurchaseOptions\x12/\n\x13i\
    nclude_screenshots\x18\x05\x20\x01(\x08R\x12includeScreenshots\x12)\n\
    \x10include_trailers\x18\x06\x20\x01(\x08R\x0fincludeTrailers\x12'\n\x0f\
    include_ratings\x18\x07\x20\x01(\x08R\x0eincludeRatings\x12*\n\x11includ\
    e_tag_count\x18\x08\x20\x01(\x05R\x0fincludeTagCount\x12'\n\x0finclude_r\
    eviews\x18\t\x20\x01(\x08R\x0eincludeReviews\x12,\n\x12include_basic_inf\
    o\x18\n\x20\x01(\x08R\x10includeBasicInfo\x12>\n\x1binclude_supported_la\
    nguages\x18\x0b\x20\x01(\x08R\x19includeSupportedLanguages\x128\n\x18inc\
    lude_full_description\x18\x0c\x20\x01(\x08R\x16includeFullDescription\
    \x124\n\x16include_included_items\x18\r\x20\x01(\x08R\x14includeIncluded\
    Items\x12X\n\x1aincluded_item_data_request\x18\x0e\x20\x01(\x0b2\x1b.Sto\
    reBrowseItemDataRequestR\x17includedItemDataRequest\x12G\n\x20include_as\
    sets_without_overrides\x18\x0f\x20\x01(\x08R\x1dincludeAssetsWithoutOver\
    rides\"\xae\x01\n\x1dCStoreBrowse_GetItems_Request\x12\x1e\n\x03ids\x18\
    \x01\x20\x03(\x0b2\x0c.StoreItemIDR\x03ids\x12-\n\x07context\x18\x02\x20\
    \x01(\x0b2\x13.StoreBrowseContextR\x07context\x12>\n\x0cdata_request\x18\
    \x03\x20\x01(\x0b2\x1b.StoreBrowseItemDataRequestR\x0bdataRequest\"\xc3:\
    \n\tStoreItem\x12F\n\titem_type\x18\x01\x20\x01(\x0e2\x0f.EStoreItemType\
    :\x18k_EStoreItemType_InvalidR\x08itemType\x12\x0e\n\x02id\x18\x02\x20\
    \x01(\rR\x02id\x12\x18\n\x07success\x18\x03\x20\x01(\rR\x07success\x12\
    \x18\n\x07visible\x18\x04\x20\x01(\x08R\x07visible\x12K\n\"unvailable_fo\
    r_country_restriction\x18\x05\x20\x01(\x08R\x1funvailableForCountryRestr\
    iction\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\x12$\n\x0estore_url\
    _path\x18\x07\x20\x01(\tR\x0cstoreUrlPath\x12\x14\n\x05appid\x18\t\x20\
    \x01(\rR\x05appid\x128\n\x04type\x18\n\x20\x01(\x0e2\x0e.EStoreAppType:\
    \x14k_EStoreAppType_GameR\x04type\x125\n\x0eincluded_types\x18\x0b\x20\
    \x03(\x0e2\x0e.EStoreAppTypeR\rincludedTypes\x12'\n\x0fincluded_appids\
    \x18\x0c\x20\x03(\rR\x0eincludedAppids\x12\x17\n\x07is_free\x18\r\x20\
    \x01(\x08R\x06isFree\x12&\n\x0fis_early_access\x18\x0e\x20\x01(\x08R\ris\
    EarlyAccess\x12<\n\rrelated_items\x18\x0f\x20\x01(\x0b2\x17.StoreItem.Re\
    latedItemsR\x0crelatedItems\x12?\n\x0eincluded_items\x18\x10\x20\x01(\
    \x0b2\x18.StoreItem.IncludedItemsR\rincludedItems\x12J\n\x15content_desc\
    riptorids\x18\x14\x20\x03(\x0e2\x15.EContentDescriptorIDR\x14contentDesc\
    riptorids\x12\x16\n\x06tagids\x18\x15\x20\x03(\rR\x06tagids\x125\n\ncate\
    gories\x18\x16\x20\x01(\x0b2\x15.StoreItem.CategoriesR\ncategories\x12,\
    \n\x07reviews\x18\x17\x20\x01(\x0b2\x12.StoreItem.ReviewsR\x07reviews\
    \x123\n\nbasic_info\x18\x18\x20\x01(\x0b2\x14.StoreItem.BasicInfoR\tbasi\
    cInfo\x12\"\n\x04tags\x18\x19\x20\x03(\x0b2\x0e.StoreItem.TagR\x04tags\
    \x12)\n\x06assets\x18\x1e\x20\x01(\x0b2\x11.StoreItem.AssetsR\x06assets\
    \x120\n\x07release\x18\x1f\x20\x01(\x0b2\x16.StoreItem.ReleaseInfoR\x07r\
    elease\x122\n\tplatforms\x18\x20\x20\x01(\x0b2\x14.StoreItem.PlatformsR\
    \tplatforms\x121\n\x0bgame_rating\x18!\x20\x01(\x0b2\x10.StoreGameRating\
    R\ngameRating\x12K\n\x14best_purchase_option\x18(\x20\x01(\x0b2\x19.Stor\
    eItem.PurchaseOptionR\x12bestPurchaseOption\x12D\n\x10purchase_options\
    \x18)\x20\x03(\x0b2\x19.StoreItem.PurchaseOptionR\x0fpurchaseOptions\x12\
    ;\n\x0baccessories\x18*\x20\x03(\x0b2\x19.StoreItem.PurchaseOptionR\x0ba\
    ccessories\x128\n\x0bscreenshots\x182\x20\x01(\x0b2\x16.StoreItem.Screen\
    shotsR\x0bscreenshots\x12/\n\x08trailers\x183\x20\x01(\x0b2\x13.StoreIte\
    m.TrailersR\x08trailers\x12M\n\x13supported_languages\x184\x20\x03(\x0b2\
    \x1c.StoreItem.SupportedLanguageR\x12supportedLanguages\x125\n\x17store_\
    url_path_override\x185\x20\x01(\tR\x14storeUrlPathOverride\x129\n\x0cfre\
    e_weekend\x186\x20\x01(\x0b2\x16.StoreItem.FreeWeekendR\x0bfreeWeekend\
    \x12\x1a\n\x08unlisted\x187\x20\x01(\x08R\x08unlisted\x12\x1d\n\ngame_co\
    unt\x188\x20\x01(\rR\tgameCount\x12#\n\rinternal_name\x189\x20\x01(\tR\
    \x0cinternalName\x12)\n\x10full_description\x18:\x20\x01(\tR\x0ffullDesc\
    ription\x12.\n\x13is_free_temporarily\x18;\x20\x01(\x08R\x11isFreeTempor\
    arily\x12K\n\x18assets_without_overrides\x18<\x20\x01(\x0b2\x11.StoreIte\
    m.AssetsR\x16assetsWithoutOverrides\x1a1\n\x0cRelatedItems\x12!\n\x0cpar\
    ent_appid\x18\x01\x20\x01(\rR\x0bparentAppid\x1ay\n\rIncludedItems\x12/\
    \n\rincluded_apps\x18\x01\x20\x03(\x0b2\n.StoreItemR\x0cincludedApps\x12\
    7\n\x11included_packages\x18\x02\x20\x03(\x0b2\n.StoreItemR\x10includedP\
    ackages\x1a\xb6\x01\n\nCategories\x12@\n\x1csupported_player_categoryids\
    \x18\x02\x20\x03(\rR\x1asupportedPlayerCategoryids\x12/\n\x13feature_cat\
    egoryids\x18\x03\x20\x03(\rR\x12featureCategoryids\x125\n\x16controller_\
    categoryids\x18\x04\x20\x03(\rR\x15controllerCategoryids\x1a\x93\x03\n\
    \x07Reviews\x12P\n\x10summary_filtered\x18\x01\x20\x01(\x0b2%.StoreItem.\
    Reviews.StoreReviewSummaryR\x0fsummaryFiltered\x12T\n\x12summary_unfilte\
    red\x18\x02\x20\x01(\x0b2%.StoreItem.Reviews.StoreReviewSummaryR\x11summ\
    aryUnfiltered\x1a\xdf\x01\n\x12StoreReviewSummary\x12!\n\x0creview_count\
    \x18\x01\x20\x01(\rR\x0breviewCount\x12)\n\x10percent_positive\x18\x02\
    \x20\x01(\x05R\x0fpercentPositive\x12M\n\x0creview_score\x18\x03\x20\x01\
    (\x0e2\x11.EUserReviewScore:\x17k_EUserReviewScore_NoneR\x0breviewScore\
    \x12,\n\x12review_score_label\x18\x04\x20\x01(\tR\x10reviewScoreLabel\
    \x1a\x93\x03\n\tBasicInfo\x12+\n\x11short_description\x18\x01\x20\x01(\t\
    R\x10shortDescription\x12D\n\npublishers\x18\x02\x20\x03(\x0b2$.StoreIte\
    m.BasicInfo.CreatorHomeLinkR\npublishers\x12D\n\ndevelopers\x18\x03\x20\
    \x03(\x0b2$.StoreItem.BasicInfo.CreatorHomeLinkR\ndevelopers\x12D\n\nfra\
    nchises\x18\x04\x20\x03(\x0b2$.StoreItem.BasicInfo.CreatorHomeLinkR\nfra\
    nchises\x12)\n\x10capsule_headline\x18\x05\x20\x01(\tR\x0fcapsuleHeadlin\
    e\x1a\\\n\x0fCreatorHomeLink\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\x125\n\x17creator_clan_account_id\x18\x02\x20\x01(\rR\x14creatorClanA\
    ccountId\x1a3\n\x03Tag\x12\x14\n\x05tagid\x18\x01\x20\x01(\rR\x05tagid\
    \x12\x16\n\x06weight\x18\x02\x20\x01(\rR\x06weight\x1a\x97\x04\n\x06Asse\
    ts\x12(\n\x10asset_url_format\x18\x01\x20\x01(\tR\x0eassetUrlFormat\x12!\
    \n\x0cmain_capsule\x18\x02\x20\x01(\tR\x0bmainCapsule\x12#\n\rsmall_caps\
    ule\x18\x03\x20\x01(\tR\x0csmallCapsule\x12\x16\n\x06header\x18\x04\x20\
    \x01(\tR\x06header\x12%\n\x0epackage_header\x18\x05\x20\x01(\tR\rpackage\
    Header\x12'\n\x0fpage_background\x18\x06\x20\x01(\tR\x0epageBackground\
    \x12!\n\x0chero_capsule\x18\x07\x20\x01(\tR\x0bheroCapsule\x12&\n\x0fher\
    o_capsule_2x\x18\x08\x20\x01(\tR\rheroCapsule2x\x12'\n\x0flibrary_capsul\
    e\x18\t\x20\x01(\tR\x0elibraryCapsule\x12,\n\x12library_capsule_2x\x18\n\
    \x20\x01(\tR\x10libraryCapsule2x\x12!\n\x0clibrary_hero\x18\x0b\x20\x01(\
    \tR\x0blibraryHero\x12&\n\x0flibrary_hero_2x\x18\x0c\x20\x01(\tR\rlibrar\
    yHero2x\x12%\n\x0ecommunity_icon\x18\r\x20\x01(\tR\rcommunityIcon\x12\
    \x1f\n\x0bclan_avatar\x18\x0e\x20\x01(\tR\nclanAvatar\x1a\x9b\x04\n\x0bR\
    eleaseInfo\x12,\n\x12steam_release_date\x18\x01\x20\x01(\rR\x10steamRele\
    aseDate\x122\n\x15original_release_date\x18\x02\x20\x01(\rR\x13originalR\
    eleaseDate\x12=\n\x1boriginal_steam_release_date\x18\x03\x20\x01(\rR\x18\
    originalSteamReleaseDate\x12$\n\x0eis_coming_soon\x18\x04\x20\x01(\x08R\
    \x0cisComingSoon\x12\x1d\n\nis_preload\x18\x05\x20\x01(\x08R\tisPreload\
    \x12=\n\x1bcustom_release_date_message\x18\x06\x20\x01(\tR\x18customRele\
    aseDateMessage\x127\n\x18is_abridged_release_date\x18\x07\x20\x01(\x08R\
    \x15isAbridgedReleaseDate\x12.\n\x13coming_soon_display\x18\x08\x20\x01(\
    \tR\x11comingSoonDisplay\x12&\n\x0fis_early_access\x18\n\x20\x01(\x08R\r\
    isEarlyAccess\x12(\n\x10mac_release_date\x18\x14\x20\x01(\rR\x0emacRelea\
    seDate\x12,\n\x12linux_release_date\x18\x15\x20\x01(\rR\x10linuxReleaseD\
    ate\x1a\xe5\x03\n\tPlatforms\x12\x18\n\x07windows\x18\x01\x20\x01(\x08R\
    \x07windows\x12\x10\n\x03mac\x18\x02\x20\x01(\x08R\x03mac\x12#\n\rsteamo\
    s_linux\x18\x03\x20\x01(\x08R\x0csteamosLinux\x12=\n\nvr_support\x18\n\
    \x20\x01(\x0b2\x1e.StoreItem.Platforms.VRSupportR\tvrSupport\x12\x88\x01\
    \n\x1asteam_deck_compat_category\x18\x0b\x20\x01(\x0e2\x20.ESteamDeckCom\
    patibilityCategory:)k_ESteamDeckCompatibilityCategory_UnknownR\x17steamD\
    eckCompatCategory\x1a\xbc\x01\n\tVRSupport\x12\x14\n\x05vrhmd\x18\x01\
    \x20\x01(\x08R\x05vrhmd\x12\x1d\n\nvrhmd_only\x18\x02\x20\x01(\x08R\tvrh\
    mdOnly\x12\x19\n\x08htc_vive\x18(\x20\x01(\x08R\x07htcVive\x12\x1f\n\x0b\
    oculus_rift\x18)\x20\x01(\x08R\noculusRift\x12\x1d\n\nwindows_mr\x18*\
    \x20\x01(\x08R\twindowsMr\x12\x1f\n\x0bvalve_index\x18+\x20\x01(\x08R\nv\
    alveIndex\x1a\xf7\x0c\n\x0ePurchaseOption\x12\x1c\n\tpackageid\x18\x01\
    \x20\x01(\x05R\tpackageid\x12\x1a\n\x08bundleid\x18\x02\x20\x01(\x05R\
    \x08bundleid\x120\n\x14purchase_option_name\x18\x03\x20\x01(\tR\x12purch\
    aseOptionName\x12/\n\x14final_price_in_cents\x18\x05\x20\x01(\x03R\x11fi\
    nalPriceInCents\x125\n\x17original_price_in_cents\x18\x06\x20\x01(\x03R\
    \x14originalPriceInCents\x128\n\x19user_final_price_in_cents\x18\x07\x20\
    \x01(\x03R\x15userFinalPriceInCents\x122\n\x15formatted_final_price\x18\
    \x08\x20\x01(\tR\x13formattedFinalPrice\x128\n\x18formatted_original_pri\
    ce\x18\t\x20\x01(\tR\x16formattedOriginalPrice\x12!\n\x0cdiscount_pct\
    \x18\n\x20\x01(\x05R\x0bdiscountPct\x12*\n\x11user_discount_pct\x18\x0b\
    \x20\x01(\x05R\x0fuserDiscountPct\x12.\n\x13bundle_discount_pct\x18\x0c\
    \x20\x01(\x05R\x11bundleDiscountPct\x12M\n\x10active_discounts\x18\x14\
    \x20\x03(\x0b2\".StoreItem.PurchaseOption.DiscountR\x0factiveDiscounts\
    \x12V\n\x15user_active_discounts\x18\x15\x20\x03(\x0b2\".StoreItem.Purch\
    aseOption.DiscountR\x13userActiveDiscounts\x12Q\n\x12inactive_discounts\
    \x18\x16\x20\x03(\x0b2\".StoreItem.PurchaseOption.DiscountR\x11inactiveD\
    iscounts\x12*\n\x11user_can_purchase\x18\x1e\x20\x01(\x08R\x0fuserCanPur\
    chase\x128\n\x19user_can_purchase_as_gift\x18\x1f\x20\x01(\x08R\x15userC\
    anPurchaseAsGift\x122\n\x15is_commercial_license\x18(\x20\x01(\x08R\x13i\
    sCommercialLicense\x12?\n\x1cshould_suppress_discount_pct\x18)\x20\x01(\
    \x08R\x19shouldSuppressDiscountPct\x12M\n\x20hide_discount_pct_for_compl\
    iance\x18*\x20\x01(\x08:\x05falseR\x1chideDiscountPctForCompliance\x12.\
    \n\x13included_game_count\x18+\x20\x01(\x05R\x11includedGameCount\x12>\n\
    \x1clowest_recent_price_in_cents\x18,\x20\x01(\x03R\x18lowestRecentPrice\
    InCents\x12+\n\x11requires_shipping\x18-\x20\x01(\x08R\x10requiresShippi\
    ng\x12Q\n\x0frecurrence_info\x18.\x20\x01(\x0b2(.StoreItem.PurchaseOptio\
    n.RecurrenceInfoR\x0erecurrenceInfo\x1a\x92\x01\n\x08Discount\x12'\n\x0f\
    discount_amount\x18\x01\x20\x01(\x03R\x0ediscountAmount\x121\n\x14discou\
    nt_description\x18\x02\x20\x01(\tR\x13discountDescription\x12*\n\x11disc\
    ount_end_date\x18\x03\x20\x01(\rR\x0fdiscountEndDate\x1a\xc0\x01\n\x0eRe\
    currenceInfo\x12\x1c\n\tpackageid\x18\x01\x20\x01(\x05R\tpackageid\x124\
    \n\x16billing_agreement_type\x18\x02\x20\x01(\x05R\x14billingAgreementTy\
    pe\x12*\n\x11renewal_time_unit\x18\x03\x20\x01(\x05R\x0frenewalTimeUnit\
    \x12.\n\x13renewal_time_period\x18\x04\x20\x01(\x05R\x11renewalTimePerio\
    d\x1a\x87\x02\n\x0bScreenshots\x12S\n\x14all_ages_screenshots\x18\x02\
    \x20\x03(\x0b2!.StoreItem.Screenshots.ScreenshotR\x12allAgesScreenshots\
    \x12_\n\x1amature_content_screenshots\x18\x03\x20\x03(\x0b2!.StoreItem.S\
    creenshots.ScreenshotR\x18matureContentScreenshots\x1aB\n\nScreenshot\
    \x12\x1a\n\x08filename\x18\x01\x20\x01(\tR\x08filename\x12\x18\n\x07ordi\
    nal\x18\x02\x20\x01(\x05R\x07ordinal\x1a\xf0\x04\n\x08Trailers\x12;\n\nh\
    ighlights\x18\x01\x20\x03(\x0b2\x1b.StoreItem.Trailers.TrailerR\nhighlig\
    hts\x12B\n\x0eother_trailers\x18\x02\x20\x03(\x0b2\x1b.StoreItem.Trailer\
    s.TrailerR\rotherTrailers\x1a=\n\x0bVideoSource\x12\x1a\n\x08filename\
    \x18\x01\x20\x01(\tR\x08filename\x12\x12\n\x04type\x18\x02\x20\x01(\tR\
    \x04type\x1a\xa3\x03\n\x07Trailer\x12!\n\x0ctrailer_name\x18\x01\x20\x01\
    (\tR\x0btrailerName\x12,\n\x12trailer_url_format\x18\x02\x20\x01(\tR\x10\
    trailerUrlFormat\x12B\n\x0ctrailer_480p\x18\x03\x20\x03(\x0b2\x1f.StoreI\
    tem.Trailers.VideoSourceR\x0btrailer480p\x12@\n\x0btrailer_max\x18\x04\
    \x20\x03(\x0b2\x1f.StoreItem.Trailers.VideoSourceR\ntrailerMax\x12C\n\
    \x0cmicrotrailer\x18\x05\x20\x03(\x0b2\x1f.StoreItem.Trailers.VideoSourc\
    eR\x0cmicrotrailer\x12+\n\x11screenshot_medium\x18\n\x20\x01(\tR\x10scre\
    enshotMedium\x12'\n\x0fscreenshot_full\x18\x0b\x20\x01(\tR\x0escreenshot\
    Full\x12&\n\x0ftrailer_base_id\x18\x0c\x20\x01(\x05R\rtrailerBaseId\x1a\
    \x8c\x01\n\x11SupportedLanguage\x12\x1c\n\telanguage\x18\x01\x20\x01(\
    \x05R\telanguage\x12\x1c\n\tsupported\x18\x02\x20\x01(\x08R\tsupported\
    \x12\x1d\n\nfull_audio\x18\x03\x20\x01(\x08R\tfullAudio\x12\x1c\n\tsubti\
    tles\x18\x04\x20\x01(\x08R\tsubtitles\x1a[\n\x0bFreeWeekend\x12\x1d\n\ns\
    tart_time\x18\x01\x20\x01(\rR\tstartTime\x12\x19\n\x08end_time\x18\x02\
    \x20\x01(\rR\x07endTime\x12\x12\n\x04text\x18\x03\x20\x01(\tR\x04text\"\
    \x97\x02\n\x0fStoreGameRating\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04t\
    ype\x12\x16\n\x06rating\x18\x02\x20\x01(\tR\x06rating\x12\x20\n\x0bdescr\
    iptors\x18\x03\x20\x03(\tR\x0bdescriptors\x121\n\x14interactive_elements\
    \x18\x04\x20\x01(\tR\x13interactiveElements\x12!\n\x0crequired_age\x18\n\
    \x20\x01(\x05R\x0brequiredAge\x12\x20\n\x0cuse_age_gate\x18\x0b\x20\x01(\
    \x08R\nuseAgeGate\x12\x1b\n\timage_url\x18\x14\x20\x01(\tR\x08imageUrl\
    \x12!\n\x0cimage_target\x18\x15\x20\x01(\tR\x0bimageTarget\"M\n\x1eCStor\
    eBrowse_GetItems_Response\x12+\n\x0bstore_items\x18\x01\x20\x03(\x0b2\n.\
    StoreItemR\nstoreItems\"g\n'CStoreBrowse_GetStoreCategories_Request\x12\
    \x1a\n\x08language\x18\x01\x20\x01(\tR\x08language\x12\x20\n\telanguage\
    \x18\x02\x20\x01(\x05:\x02-1R\telanguage\"\xfe\x02\n(CStoreBrowse_GetSto\
    reCategories_Response\x12R\n\ncategories\x18\x01\x20\x03(\x0b22.CStoreBr\
    owse_GetStoreCategories_Response.CategoryR\ncategories\x1a\xfd\x01\n\x08\
    Category\x12\x1e\n\ncategoryid\x18\x01\x20\x01(\rR\ncategoryid\x12F\n\
    \x04type\x18\x02\x20\x01(\x0e2\x13.EStoreCategoryType:\x1dk_EStoreCatego\
    ryType_CategoryR\x04type\x12#\n\rinternal_name\x18\x03\x20\x01(\tR\x0cin\
    ternalName\x12!\n\x0cdisplay_name\x18\x04\x20\x01(\tR\x0bdisplayName\x12\
    \x1b\n\timage_url\x18\x05\x20\x01(\tR\x08imageUrl\x12$\n\x0eshow_in_sear\
    ch\x18\x06\x20\x01(\x08R\x0cshowInSearch\"\xd2\x01\n\"CStoreBrowse_GetDL\
    CForApps_Request\x12-\n\x07context\x18\x01\x20\x01(\x0b2\x13.StoreBrowse\
    ContextR\x07context\x12=\n\x11store_page_filter\x18\x02\x20\x01(\x0b2\
    \x11.CStorePageFilterR\x0fstorePageFilter\x12$\n\x06appids\x18\x03\x20\
    \x03(\x0b2\x0c.StoreItemIDR\x06appids\x12\x18\n\x07steamid\x18\x04\x20\
    \x01(\x04R\x07steamid\"\xf2\x03\n#CStoreBrowse_GetDLCForApps_Response\
    \x12G\n\x08dlc_data\x18\x01\x20\x03(\x0b2,.CStoreBrowse_GetDLCForApps_Re\
    sponse.DLCDataR\x07dlcData\x12O\n\x08playtime\x18\x02\x20\x03(\x0b23.CSt\
    oreBrowse_GetDLCForApps_Response.PlaytimeForAppR\x08playtime\x1a\xcb\x01\
    \n\x07DLCData\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x20\n\
    \x0bparentappid\x18\x02\x20\x01(\rR\x0bparentappid\x12!\n\x0crelease_dat\
    e\x18\x03\x20\x01(\rR\x0breleaseDate\x12\x1f\n\x0bcoming_soon\x18\x04\
    \x20\x01(\x08R\ncomingSoon\x12\x14\n\x05price\x18\x05\x20\x01(\x03R\x05p\
    rice\x12\x1a\n\x08discount\x18\x06\x20\x01(\rR\x08discount\x12\x12\n\x04\
    free\x18\x07\x20\x01(\x08R\x04free\x1ac\n\x0ePlaytimeForApp\x12\x14\n\
    \x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x1a\n\x08playtime\x18\x02\x20\
    \x01(\rR\x08playtime\x12\x1f\n\x0blast_played\x18\x03\x20\x01(\rR\nlastP\
    layed\"\xdc\x01\n&CStoreBrowse_GetDLCForAppsSolr_Request\x12-\n\x07conte\
    xt\x18\x01\x20\x01(\x0b2\x13.StoreBrowseContextR\x07context\x12\x16\n\
    \x06appids\x18\x02\x20\x03(\rR\x06appids\x12\x16\n\x06flavor\x18\x03\x20\
    \x01(\tR\x06flavor\x12\x14\n\x05count\x18\x04\x20\x01(\rR\x05count\x12=\
    \n\x11store_page_filter\x18\x05\x20\x01(\x0b2\x11.CStorePageFilterR\x0fs\
    torePageFilter\"\xc5\x01\n'CStoreBrowse_GetDLCForAppsSolr_Response\x12M\
    \n\tdlc_lists\x18\x01\x20\x03(\x0b20.CStoreBrowse_GetDLCForAppsSolr_Resp\
    onse.DLCListR\x08dlcLists\x1aK\n\x07DLCList\x12!\n\x0cparent_appid\x18\
    \x01\x20\x01(\rR\x0bparentAppid\x12\x1d\n\ndlc_appids\x18\x02\x20\x03(\r\
    R\tdlcAppids\"t\n%CStoreBrowse_GetHardwareItems_Request\x12\x1c\n\tpacka\
    geid\x18\x01\x20\x03(\rR\tpackageid\x12-\n\x07context\x18\x02\x20\x01(\
    \x0b2\x13.StoreBrowseContextR\x07context\"\xf2\x06\n\x17CHardwarePackage\
    Details\x12\x1c\n\tpackageid\x18\x01\x20\x01(\rR\tpackageid\x12/\n\x13in\
    ventory_available\x18\x03\x20\x01(\x08R\x12inventoryAvailable\x12.\n\x13\
    high_pending_orders\x18\x04\x20\x01(\x08R\x11highPendingOrders\x12K\n\"a\
    ccount_restricted_from_purchasing\x18\x05\x20\x01(\x08R\x1faccountRestri\
    ctedFromPurchasing\x121\n\x14requires_reservation\x18\x06\x20\x01(\x08R\
    \x13requiresReservation\x12@\n\x1crtime_estimated_notification\x18\x07\
    \x20\x01(\rR\x1artimeEstimatedNotification\x12+\n\x11notificaton_token\
    \x18\x08\x20\x01(\tR\x10notificatonToken\x12+\n\x11reservation_state\x18\
    \t\x20\x01(\x05R\x10reservationState\x12\x18\n\x07expired\x18\n\x20\x01(\
    \x08R\x07expired\x12!\n\x0ctime_expires\x18\x0b\x20\x01(\rR\x0btimeExpir\
    es\x12#\n\rtime_reserved\x18\x0c\x20\x01(\rR\x0ctimeReserved\x126\n\x17a\
    llow_quantity_purchase\x18\r\x20\x01(\x08R\x15allowQuantityPurchase\x129\
    \n\x19max_quantity_per_purchase\x18\x0e\x20\x01(\x05R\x16maxQuantityPerP\
    urchase\x129\n\x19allow_purchase_in_country\x18\x0f\x20\x01(\x08R\x16all\
    owPurchaseInCountry\x12V\n(estimated_delivery_soonest_business_days\x18\
    \x11\x20\x01(\rR$estimatedDeliverySoonestBusinessDays\x12T\n'estimated_d\
    elivery_latest_business_days\x18\x12\x20\x01(\rR#estimatedDeliveryLatest\
    BusinessDays\"\\\n&CStoreBrowse_GetHardwareItems_Response\x122\n\x07deta\
    ils\x18\x01\x20\x03(\x0b2\x18.CHardwarePackageDetailsR\x07details*\x80\
    \x02\n\x0eEStoreItemType\x12%\n\x18k_EStoreItemType_Invalid\x10\xff\xff\
    \xff\xff\xff\xff\xff\xff\xff\x01\x12\x18\n\x14k_EStoreItemType_App\x10\0\
    \x12\x1c\n\x18k_EStoreItemType_Package\x10\x01\x12\x1b\n\x17k_EStoreItem\
    Type_Bundle\x10\x02\x12\x18\n\x14k_EStoreItemType_Mtx\x10\x03\x12\x18\n\
    \x14k_EStoreItemType_Tag\x10\x04\x12\x1c\n\x18k_EStoreItemType_Creator\
    \x10\x05\x12\x20\n\x1ck_EStoreItemType_HubCategory\x10\x06*\xab\x03\n\rE\
    StoreAppType\x12\x18\n\x14k_EStoreAppType_Game\x10\0\x12\x18\n\x14k_ESto\
    reAppType_Demo\x10\x01\x12\x17\n\x13k_EStoreAppType_Mod\x10\x02\x12\x19\
    \n\x15k_EStoreAppType_Movie\x10\x03\x12\x17\n\x13k_EStoreAppType_DLC\x10\
    \x04\x12\x19\n\x15k_EStoreAppType_Guide\x10\x05\x12\x1c\n\x18k_EStoreApp\
    Type_Software\x10\x06\x12\x19\n\x15k_EStoreAppType_Video\x10\x07\x12\x1a\
    \n\x16k_EStoreAppType_Series\x10\x08\x12\x1b\n\x17k_EStoreAppType_Episod\
    e\x10\t\x12\x1c\n\x18k_EStoreAppType_Hardware\x10\n\x12\x19\n\x15k_EStor\
    eAppType_Music\x10\x0b\x12\x18\n\x14k_EStoreAppType_Beta\x10\x0c\x12\x18\
    \n\x14k_EStoreAppType_Tool\x10\r\x12\x1f\n\x1bk_EStoreAppType_Advertisin\
    g\x10\x0e*\x85\x03\n\x10EUserReviewScore\x12\x1b\n\x17k_EUserReviewScore\
    _None\x10\0\x12-\n)k_EUserReviewScore_OverwhelminglyNegative\x10\x01\x12\
    #\n\x1fk_EUserReviewScore_VeryNegative\x10\x02\x12\x1f\n\x1bk_EUserRevie\
    wScore_Negative\x10\x03\x12%\n!k_EUserReviewScore_MostlyNegative\x10\x04\
    \x12\x1c\n\x18k_EUserReviewScore_Mixed\x10\x05\x12%\n!k_EUserReviewScore\
    _MostlyPositive\x10\x06\x12\x1f\n\x1bk_EUserReviewScore_Positive\x10\x07\
    \x12#\n\x1fk_EUserReviewScore_VeryPositive\x10\x08\x12-\n)k_EUserReviewS\
    core_OverwhelminglyPositive\x10\t*\xf4\x01\n\x12EStoreCategoryType\x12!\
    \n\x1dk_EStoreCategoryType_Category\x10\0\x12)\n%k_EStoreCategoryType_Su\
    pportedPlayers\x10\x01\x12\x20\n\x1ck_EStoreCategoryType_Feature\x10\x02\
    \x12*\n&k_EStoreCategoryType_ControllerSupport\x10\x03\x12$\n\x20k_EStor\
    eCategoryType_CloudGaming\x10\x04\x12\x1c\n\x18k_EStoreCategoryType_MAX\
    \x10\x052\xee\x03\n\x0bStoreBrowse\x12K\n\x08GetItems\x12\x1e.CStoreBrow\
    se_GetItems_Request\x1a\x1f.CStoreBrowse_GetItems_Response\x12i\n\x12Get\
    StoreCategories\x12(.CStoreBrowse_GetStoreCategories_Request\x1a).CStore\
    Browse_GetStoreCategories_Response\x12Z\n\rGetDLCForApps\x12#.CStoreBrow\
    se_GetDLCForApps_Request\x1a$.CStoreBrowse_GetDLCForApps_Response\x12f\n\
    \x11GetDLCForAppsSolr\x12'.CStoreBrowse_GetDLCForAppsSolr_Request\x1a(.C\
    StoreBrowse_GetDLCForAppsSolr_Response\x12c\n\x10GetHardwareItems\x12&.C\
    StoreBrowse_GetHardwareItems_Request\x1a'.CStoreBrowse_GetHardwareItems_\
    ResponseB\x03\x80\x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(5);
            deps.push(super::steammessages_base::file_descriptor().clone());
            deps.push(super::steammessages_unified_base_steamclient::file_descriptor().clone());
            deps.push(super::enums_productinfo::file_descriptor().clone());
            deps.push(super::enums::file_descriptor().clone());
            deps.push(super::contenthubs::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(42);
            messages.push(StoreItemID::generated_message_descriptor_data());
            messages.push(StoreBrowseContext::generated_message_descriptor_data());
            messages.push(StoreBrowseItemDataRequest::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetItems_Request::generated_message_descriptor_data());
            messages.push(StoreItem::generated_message_descriptor_data());
            messages.push(StoreGameRating::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetItems_Response::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetStoreCategories_Request::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetStoreCategories_Response::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetDLCForApps_Request::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetDLCForApps_Response::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetDLCForAppsSolr_Request::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetDLCForAppsSolr_Response::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetHardwareItems_Request::generated_message_descriptor_data());
            messages.push(CHardwarePackageDetails::generated_message_descriptor_data());
            messages.push(CStoreBrowse_GetHardwareItems_Response::generated_message_descriptor_data());
            messages.push(store_item::RelatedItems::generated_message_descriptor_data());
            messages.push(store_item::IncludedItems::generated_message_descriptor_data());
            messages.push(store_item::Categories::generated_message_descriptor_data());
            messages.push(store_item::Reviews::generated_message_descriptor_data());
            messages.push(store_item::BasicInfo::generated_message_descriptor_data());
            messages.push(store_item::Tag::generated_message_descriptor_data());
            messages.push(store_item::Assets::generated_message_descriptor_data());
            messages.push(store_item::ReleaseInfo::generated_message_descriptor_data());
            messages.push(store_item::Platforms::generated_message_descriptor_data());
            messages.push(store_item::PurchaseOption::generated_message_descriptor_data());
            messages.push(store_item::Screenshots::generated_message_descriptor_data());
            messages.push(store_item::Trailers::generated_message_descriptor_data());
            messages.push(store_item::SupportedLanguage::generated_message_descriptor_data());
            messages.push(store_item::FreeWeekend::generated_message_descriptor_data());
            messages.push(store_item::reviews::StoreReviewSummary::generated_message_descriptor_data());
            messages.push(store_item::basic_info::CreatorHomeLink::generated_message_descriptor_data());
            messages.push(store_item::platforms::VRSupport::generated_message_descriptor_data());
            messages.push(store_item::purchase_option::Discount::generated_message_descriptor_data());
            messages.push(store_item::purchase_option::RecurrenceInfo::generated_message_descriptor_data());
            messages.push(store_item::screenshots::Screenshot::generated_message_descriptor_data());
            messages.push(store_item::trailers::VideoSource::generated_message_descriptor_data());
            messages.push(store_item::trailers::Trailer::generated_message_descriptor_data());
            messages.push(cstore_browse_get_store_categories_response::Category::generated_message_descriptor_data());
            messages.push(cstore_browse_get_dlcfor_apps_response::DLCData::generated_message_descriptor_data());
            messages.push(cstore_browse_get_dlcfor_apps_response::PlaytimeForApp::generated_message_descriptor_data());
            messages.push(cstore_browse_get_dlcfor_apps_solr_response::DLCList::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(EStoreItemType::generated_enum_descriptor_data());
            enums.push(EStoreAppType::generated_enum_descriptor_data());
            enums.push(EUserReviewScore::generated_enum_descriptor_data());
            enums.push(EStoreCategoryType::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
