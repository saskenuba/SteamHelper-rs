// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_hiddevices.proto`

// @@protoc_insertion_point(message:CHIDDeviceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHIDDeviceInfo {
    // message fields
    // @@protoc_insertion_point(field:CHIDDeviceInfo.location)
    pub location: ::std::option::Option<crate::EnumOrUnknown<EHIDDeviceLocation>>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.vendor_id)
    pub vendor_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.product_id)
    pub product_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.serial_number)
    pub serial_number: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.release_number)
    pub release_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.manufacturer_string)
    pub manufacturer_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.product_string)
    pub product_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.usage_page)
    pub usage_page: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.usage)
    pub usage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.interface_number)
    pub interface_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.ostype)
    pub ostype: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.is_generic_gamepad)
    pub is_generic_gamepad: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.is_generic_joystick)
    pub is_generic_joystick: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.caps_bits)
    pub caps_bits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.session_id)
    pub session_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.eControllerType_OBSOLETE)
    pub eControllerType_OBSOLETE: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.is_xinput_device_OBSOLETE)
    pub is_xinput_device_OBSOLETE: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.session_remote_play_together_appid)
    pub session_remote_play_together_appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInfo.is_steamvr_device)
    pub is_steamvr_device: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CHIDDeviceInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHIDDeviceInfo {
    fn default() -> &'a CHIDDeviceInfo {
        <CHIDDeviceInfo as crate::Message>::default_instance()
    }
}

impl CHIDDeviceInfo {
    pub fn new() -> CHIDDeviceInfo {
        ::std::default::Default::default()
    }

    // optional .EHIDDeviceLocation location = 1;

    pub fn location(&self) -> EHIDDeviceLocation {
        match self.location {
            Some(e) => e.enum_value_or(EHIDDeviceLocation::k_EDeviceLocationLocal),
            None => EHIDDeviceLocation::k_EDeviceLocationLocal,
        }
    }

    pub fn clear_location(&mut self) {
        self.location = ::std::option::Option::None;
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: EHIDDeviceLocation) {
        self.location = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 vendor_id = 3;

    pub fn vendor_id(&self) -> u32 {
        self.vendor_id.unwrap_or(0)
    }

    pub fn clear_vendor_id(&mut self) {
        self.vendor_id = ::std::option::Option::None;
    }

    pub fn has_vendor_id(&self) -> bool {
        self.vendor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendor_id(&mut self, v: u32) {
        self.vendor_id = ::std::option::Option::Some(v);
    }

    // optional uint32 product_id = 4;

    pub fn product_id(&self) -> u32 {
        self.product_id.unwrap_or(0)
    }

    pub fn clear_product_id(&mut self) {
        self.product_id = ::std::option::Option::None;
    }

    pub fn has_product_id(&self) -> bool {
        self.product_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_id(&mut self, v: u32) {
        self.product_id = ::std::option::Option::Some(v);
    }

    // optional string serial_number = 5;

    pub fn serial_number(&self) -> &str {
        match self.serial_number.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_serial_number(&mut self) {
        self.serial_number = ::std::option::Option::None;
    }

    pub fn has_serial_number(&self) -> bool {
        self.serial_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serial_number(&mut self, v: ::std::string::String) {
        self.serial_number = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serial_number(&mut self) -> &mut ::std::string::String {
        if self.serial_number.is_none() {
            self.serial_number = ::std::option::Option::Some(::std::string::String::new());
        }
        self.serial_number.as_mut().unwrap()
    }

    // Take field
    pub fn take_serial_number(&mut self) -> ::std::string::String {
        self.serial_number.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 release_number = 6;

    pub fn release_number(&self) -> u32 {
        self.release_number.unwrap_or(0)
    }

    pub fn clear_release_number(&mut self) {
        self.release_number = ::std::option::Option::None;
    }

    pub fn has_release_number(&self) -> bool {
        self.release_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release_number(&mut self, v: u32) {
        self.release_number = ::std::option::Option::Some(v);
    }

    // optional string manufacturer_string = 7;

    pub fn manufacturer_string(&self) -> &str {
        match self.manufacturer_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_manufacturer_string(&mut self) {
        self.manufacturer_string = ::std::option::Option::None;
    }

    pub fn has_manufacturer_string(&self) -> bool {
        self.manufacturer_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manufacturer_string(&mut self, v: ::std::string::String) {
        self.manufacturer_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manufacturer_string(&mut self) -> &mut ::std::string::String {
        if self.manufacturer_string.is_none() {
            self.manufacturer_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.manufacturer_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_manufacturer_string(&mut self) -> ::std::string::String {
        self.manufacturer_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string product_string = 8;

    pub fn product_string(&self) -> &str {
        match self.product_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_product_string(&mut self) {
        self.product_string = ::std::option::Option::None;
    }

    pub fn has_product_string(&self) -> bool {
        self.product_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_product_string(&mut self, v: ::std::string::String) {
        self.product_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_string(&mut self) -> &mut ::std::string::String {
        if self.product_string.is_none() {
            self.product_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.product_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_product_string(&mut self) -> ::std::string::String {
        self.product_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 usage_page = 9;

    pub fn usage_page(&self) -> u32 {
        self.usage_page.unwrap_or(0)
    }

    pub fn clear_usage_page(&mut self) {
        self.usage_page = ::std::option::Option::None;
    }

    pub fn has_usage_page(&self) -> bool {
        self.usage_page.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage_page(&mut self, v: u32) {
        self.usage_page = ::std::option::Option::Some(v);
    }

    // optional uint32 usage = 10;

    pub fn usage(&self) -> u32 {
        self.usage.unwrap_or(0)
    }

    pub fn clear_usage(&mut self) {
        self.usage = ::std::option::Option::None;
    }

    pub fn has_usage(&self) -> bool {
        self.usage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: u32) {
        self.usage = ::std::option::Option::Some(v);
    }

    // optional int32 interface_number = 11;

    pub fn interface_number(&self) -> i32 {
        self.interface_number.unwrap_or(-1i32)
    }

    pub fn clear_interface_number(&mut self) {
        self.interface_number = ::std::option::Option::None;
    }

    pub fn has_interface_number(&self) -> bool {
        self.interface_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interface_number(&mut self, v: i32) {
        self.interface_number = ::std::option::Option::Some(v);
    }

    // optional int32 ostype = 12;

    pub fn ostype(&self) -> i32 {
        self.ostype.unwrap_or(-1i32)
    }

    pub fn clear_ostype(&mut self) {
        self.ostype = ::std::option::Option::None;
    }

    pub fn has_ostype(&self) -> bool {
        self.ostype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ostype(&mut self, v: i32) {
        self.ostype = ::std::option::Option::Some(v);
    }

    // optional bool is_generic_gamepad = 13;

    pub fn is_generic_gamepad(&self) -> bool {
        self.is_generic_gamepad.unwrap_or(false)
    }

    pub fn clear_is_generic_gamepad(&mut self) {
        self.is_generic_gamepad = ::std::option::Option::None;
    }

    pub fn has_is_generic_gamepad(&self) -> bool {
        self.is_generic_gamepad.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_generic_gamepad(&mut self, v: bool) {
        self.is_generic_gamepad = ::std::option::Option::Some(v);
    }

    // optional bool is_generic_joystick = 14;

    pub fn is_generic_joystick(&self) -> bool {
        self.is_generic_joystick.unwrap_or(false)
    }

    pub fn clear_is_generic_joystick(&mut self) {
        self.is_generic_joystick = ::std::option::Option::None;
    }

    pub fn has_is_generic_joystick(&self) -> bool {
        self.is_generic_joystick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_generic_joystick(&mut self, v: bool) {
        self.is_generic_joystick = ::std::option::Option::Some(v);
    }

    // optional uint32 caps_bits = 15;

    pub fn caps_bits(&self) -> u32 {
        self.caps_bits.unwrap_or(0)
    }

    pub fn clear_caps_bits(&mut self) {
        self.caps_bits = ::std::option::Option::None;
    }

    pub fn has_caps_bits(&self) -> bool {
        self.caps_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caps_bits(&mut self, v: u32) {
        self.caps_bits = ::std::option::Option::Some(v);
    }

    // optional uint32 session_id = 16;

    pub fn session_id(&self) -> u32 {
        self.session_id.unwrap_or(0)
    }

    pub fn clear_session_id(&mut self) {
        self.session_id = ::std::option::Option::None;
    }

    pub fn has_session_id(&self) -> bool {
        self.session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_id(&mut self, v: u32) {
        self.session_id = ::std::option::Option::Some(v);
    }

    // optional uint32 eControllerType_OBSOLETE = 17;

    pub fn eControllerType_OBSOLETE(&self) -> u32 {
        self.eControllerType_OBSOLETE.unwrap_or(0u32)
    }

    pub fn clear_eControllerType_OBSOLETE(&mut self) {
        self.eControllerType_OBSOLETE = ::std::option::Option::None;
    }

    pub fn has_eControllerType_OBSOLETE(&self) -> bool {
        self.eControllerType_OBSOLETE.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eControllerType_OBSOLETE(&mut self, v: u32) {
        self.eControllerType_OBSOLETE = ::std::option::Option::Some(v);
    }

    // optional bool is_xinput_device_OBSOLETE = 18;

    pub fn is_xinput_device_OBSOLETE(&self) -> bool {
        self.is_xinput_device_OBSOLETE.unwrap_or(false)
    }

    pub fn clear_is_xinput_device_OBSOLETE(&mut self) {
        self.is_xinput_device_OBSOLETE = ::std::option::Option::None;
    }

    pub fn has_is_xinput_device_OBSOLETE(&self) -> bool {
        self.is_xinput_device_OBSOLETE.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_xinput_device_OBSOLETE(&mut self, v: bool) {
        self.is_xinput_device_OBSOLETE = ::std::option::Option::Some(v);
    }

    // optional uint32 session_remote_play_together_appid = 19;

    pub fn session_remote_play_together_appid(&self) -> u32 {
        self.session_remote_play_together_appid.unwrap_or(0)
    }

    pub fn clear_session_remote_play_together_appid(&mut self) {
        self.session_remote_play_together_appid = ::std::option::Option::None;
    }

    pub fn has_session_remote_play_together_appid(&self) -> bool {
        self.session_remote_play_together_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_remote_play_together_appid(&mut self, v: u32) {
        self.session_remote_play_together_appid = ::std::option::Option::Some(v);
    }

    // optional bool is_steamvr_device = 20;

    pub fn is_steamvr_device(&self) -> bool {
        self.is_steamvr_device.unwrap_or(false)
    }

    pub fn clear_is_steamvr_device(&mut self) {
        self.is_steamvr_device = ::std::option::Option::None;
    }

    pub fn has_is_steamvr_device(&self) -> bool {
        self.is_steamvr_device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steamvr_device(&mut self, v: bool) {
        self.is_steamvr_device = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(20);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "location",
            |m: &CHIDDeviceInfo| { &m.location },
            |m: &mut CHIDDeviceInfo| { &mut m.location },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CHIDDeviceInfo| { &m.path },
            |m: &mut CHIDDeviceInfo| { &mut m.path },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "vendor_id",
            |m: &CHIDDeviceInfo| { &m.vendor_id },
            |m: &mut CHIDDeviceInfo| { &mut m.vendor_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "product_id",
            |m: &CHIDDeviceInfo| { &m.product_id },
            |m: &mut CHIDDeviceInfo| { &mut m.product_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "serial_number",
            |m: &CHIDDeviceInfo| { &m.serial_number },
            |m: &mut CHIDDeviceInfo| { &mut m.serial_number },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "release_number",
            |m: &CHIDDeviceInfo| { &m.release_number },
            |m: &mut CHIDDeviceInfo| { &mut m.release_number },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "manufacturer_string",
            |m: &CHIDDeviceInfo| { &m.manufacturer_string },
            |m: &mut CHIDDeviceInfo| { &mut m.manufacturer_string },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "product_string",
            |m: &CHIDDeviceInfo| { &m.product_string },
            |m: &mut CHIDDeviceInfo| { &mut m.product_string },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "usage_page",
            |m: &CHIDDeviceInfo| { &m.usage_page },
            |m: &mut CHIDDeviceInfo| { &mut m.usage_page },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "usage",
            |m: &CHIDDeviceInfo| { &m.usage },
            |m: &mut CHIDDeviceInfo| { &mut m.usage },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "interface_number",
            |m: &CHIDDeviceInfo| { &m.interface_number },
            |m: &mut CHIDDeviceInfo| { &mut m.interface_number },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ostype",
            |m: &CHIDDeviceInfo| { &m.ostype },
            |m: &mut CHIDDeviceInfo| { &mut m.ostype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_generic_gamepad",
            |m: &CHIDDeviceInfo| { &m.is_generic_gamepad },
            |m: &mut CHIDDeviceInfo| { &mut m.is_generic_gamepad },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_generic_joystick",
            |m: &CHIDDeviceInfo| { &m.is_generic_joystick },
            |m: &mut CHIDDeviceInfo| { &mut m.is_generic_joystick },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "caps_bits",
            |m: &CHIDDeviceInfo| { &m.caps_bits },
            |m: &mut CHIDDeviceInfo| { &mut m.caps_bits },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_id",
            |m: &CHIDDeviceInfo| { &m.session_id },
            |m: &mut CHIDDeviceInfo| { &mut m.session_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "eControllerType_OBSOLETE",
            |m: &CHIDDeviceInfo| { &m.eControllerType_OBSOLETE },
            |m: &mut CHIDDeviceInfo| { &mut m.eControllerType_OBSOLETE },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_xinput_device_OBSOLETE",
            |m: &CHIDDeviceInfo| { &m.is_xinput_device_OBSOLETE },
            |m: &mut CHIDDeviceInfo| { &mut m.is_xinput_device_OBSOLETE },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "session_remote_play_together_appid",
            |m: &CHIDDeviceInfo| { &m.session_remote_play_together_appid },
            |m: &mut CHIDDeviceInfo| { &mut m.session_remote_play_together_appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_steamvr_device",
            |m: &CHIDDeviceInfo| { &m.is_steamvr_device },
            |m: &mut CHIDDeviceInfo| { &mut m.is_steamvr_device },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CHIDDeviceInfo>(
            "CHIDDeviceInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CHIDDeviceInfo {
    const NAME: &'static str = "CHIDDeviceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.location = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.vendor_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.product_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.serial_number = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.release_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.manufacturer_string = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.product_string = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.usage_page = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.usage = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.interface_number = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.ostype = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.is_generic_gamepad = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.is_generic_joystick = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.caps_bits = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.session_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.eControllerType_OBSOLETE = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.is_xinput_device_OBSOLETE = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.session_remote_play_together_appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.is_steamvr_device = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.location {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.path.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.vendor_id {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.product_id {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.serial_number.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.release_number {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.manufacturer_string.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.product_string.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.usage_page {
            my_size += crate::rt::uint32_size(9, v);
        }
        if let Some(v) = self.usage {
            my_size += crate::rt::uint32_size(10, v);
        }
        if let Some(v) = self.interface_number {
            my_size += crate::rt::int32_size(11, v);
        }
        if let Some(v) = self.ostype {
            my_size += crate::rt::int32_size(12, v);
        }
        if let Some(v) = self.is_generic_gamepad {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_generic_joystick {
            my_size += 1 + 1;
        }
        if let Some(v) = self.caps_bits {
            my_size += crate::rt::uint32_size(15, v);
        }
        if let Some(v) = self.session_id {
            my_size += crate::rt::uint32_size(16, v);
        }
        if let Some(v) = self.eControllerType_OBSOLETE {
            my_size += crate::rt::uint32_size(17, v);
        }
        if let Some(v) = self.is_xinput_device_OBSOLETE {
            my_size += 2 + 1;
        }
        if let Some(v) = self.session_remote_play_together_appid {
            my_size += crate::rt::uint32_size(19, v);
        }
        if let Some(v) = self.is_steamvr_device {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.location {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.vendor_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.product_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.serial_number.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.release_number {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.manufacturer_string.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.product_string.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.usage_page {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.usage {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.interface_number {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.ostype {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.is_generic_gamepad {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.is_generic_joystick {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.caps_bits {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.session_id {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.eControllerType_OBSOLETE {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.is_xinput_device_OBSOLETE {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.session_remote_play_together_appid {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.is_steamvr_device {
            os.write_bool(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHIDDeviceInfo {
        CHIDDeviceInfo::new()
    }

    fn clear(&mut self) {
        self.location = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.vendor_id = ::std::option::Option::None;
        self.product_id = ::std::option::Option::None;
        self.serial_number = ::std::option::Option::None;
        self.release_number = ::std::option::Option::None;
        self.manufacturer_string = ::std::option::Option::None;
        self.product_string = ::std::option::Option::None;
        self.usage_page = ::std::option::Option::None;
        self.usage = ::std::option::Option::None;
        self.interface_number = ::std::option::Option::None;
        self.ostype = ::std::option::Option::None;
        self.is_generic_gamepad = ::std::option::Option::None;
        self.is_generic_joystick = ::std::option::Option::None;
        self.caps_bits = ::std::option::Option::None;
        self.session_id = ::std::option::Option::None;
        self.eControllerType_OBSOLETE = ::std::option::Option::None;
        self.is_xinput_device_OBSOLETE = ::std::option::Option::None;
        self.session_remote_play_together_appid = ::std::option::Option::None;
        self.is_steamvr_device = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHIDDeviceInfo {
        static instance: CHIDDeviceInfo = CHIDDeviceInfo {
            location: ::std::option::Option::None,
            path: ::std::option::Option::None,
            vendor_id: ::std::option::Option::None,
            product_id: ::std::option::Option::None,
            serial_number: ::std::option::Option::None,
            release_number: ::std::option::Option::None,
            manufacturer_string: ::std::option::Option::None,
            product_string: ::std::option::Option::None,
            usage_page: ::std::option::Option::None,
            usage: ::std::option::Option::None,
            interface_number: ::std::option::Option::None,
            ostype: ::std::option::Option::None,
            is_generic_gamepad: ::std::option::Option::None,
            is_generic_joystick: ::std::option::Option::None,
            caps_bits: ::std::option::Option::None,
            session_id: ::std::option::Option::None,
            eControllerType_OBSOLETE: ::std::option::Option::None,
            is_xinput_device_OBSOLETE: ::std::option::Option::None,
            session_remote_play_together_appid: ::std::option::Option::None,
            is_steamvr_device: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CHIDDeviceInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHIDDeviceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHIDDeviceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CHIDDeviceInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CHIDDeviceInputReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHIDDeviceInputReport {
    // message fields
    // @@protoc_insertion_point(field:CHIDDeviceInputReport.full_report)
    pub full_report: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CHIDDeviceInputReport.delta_report)
    pub delta_report: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CHIDDeviceInputReport.delta_report_size)
    pub delta_report_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CHIDDeviceInputReport.delta_report_crc)
    pub delta_report_crc: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CHIDDeviceInputReport.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHIDDeviceInputReport {
    fn default() -> &'a CHIDDeviceInputReport {
        <CHIDDeviceInputReport as crate::Message>::default_instance()
    }
}

impl CHIDDeviceInputReport {
    pub fn new() -> CHIDDeviceInputReport {
        ::std::default::Default::default()
    }

    // optional bytes full_report = 1;

    pub fn full_report(&self) -> &[u8] {
        match self.full_report.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_full_report(&mut self) {
        self.full_report = ::std::option::Option::None;
    }

    pub fn has_full_report(&self) -> bool {
        self.full_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_report(&mut self, v: ::bytes::Bytes) {
        self.full_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_full_report(&mut self) -> &mut ::bytes::Bytes {
        if self.full_report.is_none() {
            self.full_report = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.full_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_full_report(&mut self) -> ::bytes::Bytes {
        self.full_report.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bytes delta_report = 2;

    pub fn delta_report(&self) -> &[u8] {
        match self.delta_report.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_delta_report(&mut self) {
        self.delta_report = ::std::option::Option::None;
    }

    pub fn has_delta_report(&self) -> bool {
        self.delta_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_report(&mut self, v: ::bytes::Bytes) {
        self.delta_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delta_report(&mut self) -> &mut ::bytes::Bytes {
        if self.delta_report.is_none() {
            self.delta_report = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.delta_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_delta_report(&mut self) -> ::bytes::Bytes {
        self.delta_report.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 delta_report_size = 3;

    pub fn delta_report_size(&self) -> u32 {
        self.delta_report_size.unwrap_or(0)
    }

    pub fn clear_delta_report_size(&mut self) {
        self.delta_report_size = ::std::option::Option::None;
    }

    pub fn has_delta_report_size(&self) -> bool {
        self.delta_report_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_report_size(&mut self, v: u32) {
        self.delta_report_size = ::std::option::Option::Some(v);
    }

    // optional uint32 delta_report_crc = 4;

    pub fn delta_report_crc(&self) -> u32 {
        self.delta_report_crc.unwrap_or(0)
    }

    pub fn clear_delta_report_crc(&mut self) {
        self.delta_report_crc = ::std::option::Option::None;
    }

    pub fn has_delta_report_crc(&self) -> bool {
        self.delta_report_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_report_crc(&mut self, v: u32) {
        self.delta_report_crc = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "full_report",
            |m: &CHIDDeviceInputReport| { &m.full_report },
            |m: &mut CHIDDeviceInputReport| { &mut m.full_report },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta_report",
            |m: &CHIDDeviceInputReport| { &m.delta_report },
            |m: &mut CHIDDeviceInputReport| { &mut m.delta_report },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta_report_size",
            |m: &CHIDDeviceInputReport| { &m.delta_report_size },
            |m: &mut CHIDDeviceInputReport| { &mut m.delta_report_size },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta_report_crc",
            |m: &CHIDDeviceInputReport| { &m.delta_report_crc },
            |m: &mut CHIDDeviceInputReport| { &mut m.delta_report_crc },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CHIDDeviceInputReport>(
            "CHIDDeviceInputReport",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CHIDDeviceInputReport {
    const NAME: &'static str = "CHIDDeviceInputReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.full_report = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                18 => {
                    self.delta_report = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.delta_report_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.delta_report_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.full_report.as_ref() {
            my_size += crate::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.delta_report.as_ref() {
            my_size += crate::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.delta_report_size {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.delta_report_crc {
            my_size += crate::rt::uint32_size(4, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.full_report.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.delta_report.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.delta_report_size {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.delta_report_crc {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHIDDeviceInputReport {
        CHIDDeviceInputReport::new()
    }

    fn clear(&mut self) {
        self.full_report = ::std::option::Option::None;
        self.delta_report = ::std::option::Option::None;
        self.delta_report_size = ::std::option::Option::None;
        self.delta_report_crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHIDDeviceInputReport {
        static instance: CHIDDeviceInputReport = CHIDDeviceInputReport {
            full_report: ::std::option::Option::None,
            delta_report: ::std::option::Option::None,
            delta_report_size: ::std::option::Option::None,
            delta_report_crc: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CHIDDeviceInputReport {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHIDDeviceInputReport").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHIDDeviceInputReport {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CHIDDeviceInputReport {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CHIDMessageToRemote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHIDMessageToRemote {
    // message fields
    // @@protoc_insertion_point(field:CHIDMessageToRemote.request_id)
    pub request_id: ::std::option::Option<u32>,
    // message oneof groups
    pub command: ::std::option::Option<chidmessage_to_remote::Command>,
    // special fields
    // @@protoc_insertion_point(special_field:CHIDMessageToRemote.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHIDMessageToRemote {
    fn default() -> &'a CHIDMessageToRemote {
        <CHIDMessageToRemote as crate::Message>::default_instance()
    }
}

impl CHIDMessageToRemote {
    pub fn new() -> CHIDMessageToRemote {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional .CHIDMessageToRemote.DeviceOpen device_open = 2;

    pub fn device_open(&self) -> &chidmessage_to_remote::DeviceOpen {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceOpen as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_open(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_open(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_open(&mut self, v: chidmessage_to_remote::DeviceOpen) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_open(&mut self) -> &mut chidmessage_to_remote::DeviceOpen {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(chidmessage_to_remote::DeviceOpen::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_open(&mut self) -> chidmessage_to_remote::DeviceOpen {
        if self.has_device_open() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceOpen::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceClose device_close = 3;

    pub fn device_close(&self) -> &chidmessage_to_remote::DeviceClose {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceClose as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_close(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_close(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_close(&mut self, v: chidmessage_to_remote::DeviceClose) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_close(&mut self) -> &mut chidmessage_to_remote::DeviceClose {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(chidmessage_to_remote::DeviceClose::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_close(&mut self) -> chidmessage_to_remote::DeviceClose {
        if self.has_device_close() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceClose::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceWrite device_write = 4;

    pub fn device_write(&self) -> &chidmessage_to_remote::DeviceWrite {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceWrite as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_write(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_write(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_write(&mut self, v: chidmessage_to_remote::DeviceWrite) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_write(&mut self) -> &mut chidmessage_to_remote::DeviceWrite {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(chidmessage_to_remote::DeviceWrite::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_write(&mut self) -> chidmessage_to_remote::DeviceWrite {
        if self.has_device_write() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceWrite::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceRead device_read = 5;

    pub fn device_read(&self) -> &chidmessage_to_remote::DeviceRead {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceRead as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_read(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_read(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_read(&mut self, v: chidmessage_to_remote::DeviceRead) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_read(&mut self) -> &mut chidmessage_to_remote::DeviceRead {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(chidmessage_to_remote::DeviceRead::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_read(&mut self) -> chidmessage_to_remote::DeviceRead {
        if self.has_device_read() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceRead::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceSendFeatureReport device_send_feature_report = 6;

    pub fn device_send_feature_report(&self) -> &chidmessage_to_remote::DeviceSendFeatureReport {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceSendFeatureReport as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_send_feature_report(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_send_feature_report(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_send_feature_report(&mut self, v: chidmessage_to_remote::DeviceSendFeatureReport) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_send_feature_report(&mut self) -> &mut chidmessage_to_remote::DeviceSendFeatureReport {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(chidmessage_to_remote::DeviceSendFeatureReport::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_send_feature_report(&mut self) -> chidmessage_to_remote::DeviceSendFeatureReport {
        if self.has_device_send_feature_report() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceSendFeatureReport::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceGetFeatureReport device_get_feature_report = 7;

    pub fn device_get_feature_report(&self) -> &chidmessage_to_remote::DeviceGetFeatureReport {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceGetFeatureReport as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_get_feature_report(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_get_feature_report(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_get_feature_report(&mut self, v: chidmessage_to_remote::DeviceGetFeatureReport) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_get_feature_report(&mut self) -> &mut chidmessage_to_remote::DeviceGetFeatureReport {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(chidmessage_to_remote::DeviceGetFeatureReport::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_get_feature_report(&mut self) -> chidmessage_to_remote::DeviceGetFeatureReport {
        if self.has_device_get_feature_report() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceGetFeatureReport::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceGetVendorString device_get_vendor_string = 8;

    pub fn device_get_vendor_string(&self) -> &chidmessage_to_remote::DeviceGetVendorString {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceGetVendorString as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_get_vendor_string(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_get_vendor_string(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_get_vendor_string(&mut self, v: chidmessage_to_remote::DeviceGetVendorString) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_get_vendor_string(&mut self) -> &mut chidmessage_to_remote::DeviceGetVendorString {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(chidmessage_to_remote::DeviceGetVendorString::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_get_vendor_string(&mut self) -> chidmessage_to_remote::DeviceGetVendorString {
        if self.has_device_get_vendor_string() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceGetVendorString::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceGetProductString device_get_product_string = 9;

    pub fn device_get_product_string(&self) -> &chidmessage_to_remote::DeviceGetProductString {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceGetProductString as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_get_product_string(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_get_product_string(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_get_product_string(&mut self, v: chidmessage_to_remote::DeviceGetProductString) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_get_product_string(&mut self) -> &mut chidmessage_to_remote::DeviceGetProductString {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(chidmessage_to_remote::DeviceGetProductString::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_get_product_string(&mut self) -> chidmessage_to_remote::DeviceGetProductString {
        if self.has_device_get_product_string() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceGetProductString::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceGetSerialNumberString device_get_serial_number_string = 10;

    pub fn device_get_serial_number_string(&self) -> &chidmessage_to_remote::DeviceGetSerialNumberString {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceGetSerialNumberString as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_get_serial_number_string(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_get_serial_number_string(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_get_serial_number_string(&mut self, v: chidmessage_to_remote::DeviceGetSerialNumberString) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_get_serial_number_string(&mut self) -> &mut chidmessage_to_remote::DeviceGetSerialNumberString {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(chidmessage_to_remote::DeviceGetSerialNumberString::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_get_serial_number_string(&mut self) -> chidmessage_to_remote::DeviceGetSerialNumberString {
        if self.has_device_get_serial_number_string() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceGetSerialNumberString::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceStartInputReports device_start_input_reports = 11;

    pub fn device_start_input_reports(&self) -> &chidmessage_to_remote::DeviceStartInputReports {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceStartInputReports as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_start_input_reports(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_start_input_reports(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_start_input_reports(&mut self, v: chidmessage_to_remote::DeviceStartInputReports) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_start_input_reports(&mut self) -> &mut chidmessage_to_remote::DeviceStartInputReports {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(chidmessage_to_remote::DeviceStartInputReports::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_start_input_reports(&mut self) -> chidmessage_to_remote::DeviceStartInputReports {
        if self.has_device_start_input_reports() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceStartInputReports::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceRequestFullReport device_request_full_report = 12;

    pub fn device_request_full_report(&self) -> &chidmessage_to_remote::DeviceRequestFullReport {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceRequestFullReport as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_request_full_report(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_request_full_report(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_request_full_report(&mut self, v: chidmessage_to_remote::DeviceRequestFullReport) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_request_full_report(&mut self) -> &mut chidmessage_to_remote::DeviceRequestFullReport {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(chidmessage_to_remote::DeviceRequestFullReport::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_request_full_report(&mut self) -> chidmessage_to_remote::DeviceRequestFullReport {
        if self.has_device_request_full_report() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceRequestFullReport::new()
        }
    }

    // optional .CHIDMessageToRemote.DeviceDisconnect device_disconnect = 13;

    pub fn device_disconnect(&self) -> &chidmessage_to_remote::DeviceDisconnect {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(ref v)) => v,
            _ => <chidmessage_to_remote::DeviceDisconnect as crate::Message>::default_instance(),
        }
    }

    pub fn clear_device_disconnect(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_device_disconnect(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_device_disconnect(&mut self, v: chidmessage_to_remote::DeviceDisconnect) {
        self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_device_disconnect(&mut self) -> &mut chidmessage_to_remote::DeviceDisconnect {
        if let ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(chidmessage_to_remote::DeviceDisconnect::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_device_disconnect(&mut self) -> chidmessage_to_remote::DeviceDisconnect {
        if self.has_device_disconnect() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_to_remote::DeviceDisconnect::new()
        }
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CHIDMessageToRemote| { &m.request_id },
            |m: &mut CHIDMessageToRemote| { &mut m.request_id },
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceOpen>(
            "device_open",
            CHIDMessageToRemote::has_device_open,
            CHIDMessageToRemote::device_open,
            CHIDMessageToRemote::mut_device_open,
            CHIDMessageToRemote::set_device_open,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceClose>(
            "device_close",
            CHIDMessageToRemote::has_device_close,
            CHIDMessageToRemote::device_close,
            CHIDMessageToRemote::mut_device_close,
            CHIDMessageToRemote::set_device_close,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceWrite>(
            "device_write",
            CHIDMessageToRemote::has_device_write,
            CHIDMessageToRemote::device_write,
            CHIDMessageToRemote::mut_device_write,
            CHIDMessageToRemote::set_device_write,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceRead>(
            "device_read",
            CHIDMessageToRemote::has_device_read,
            CHIDMessageToRemote::device_read,
            CHIDMessageToRemote::mut_device_read,
            CHIDMessageToRemote::set_device_read,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceSendFeatureReport>(
            "device_send_feature_report",
            CHIDMessageToRemote::has_device_send_feature_report,
            CHIDMessageToRemote::device_send_feature_report,
            CHIDMessageToRemote::mut_device_send_feature_report,
            CHIDMessageToRemote::set_device_send_feature_report,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceGetFeatureReport>(
            "device_get_feature_report",
            CHIDMessageToRemote::has_device_get_feature_report,
            CHIDMessageToRemote::device_get_feature_report,
            CHIDMessageToRemote::mut_device_get_feature_report,
            CHIDMessageToRemote::set_device_get_feature_report,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceGetVendorString>(
            "device_get_vendor_string",
            CHIDMessageToRemote::has_device_get_vendor_string,
            CHIDMessageToRemote::device_get_vendor_string,
            CHIDMessageToRemote::mut_device_get_vendor_string,
            CHIDMessageToRemote::set_device_get_vendor_string,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceGetProductString>(
            "device_get_product_string",
            CHIDMessageToRemote::has_device_get_product_string,
            CHIDMessageToRemote::device_get_product_string,
            CHIDMessageToRemote::mut_device_get_product_string,
            CHIDMessageToRemote::set_device_get_product_string,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceGetSerialNumberString>(
            "device_get_serial_number_string",
            CHIDMessageToRemote::has_device_get_serial_number_string,
            CHIDMessageToRemote::device_get_serial_number_string,
            CHIDMessageToRemote::mut_device_get_serial_number_string,
            CHIDMessageToRemote::set_device_get_serial_number_string,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceStartInputReports>(
            "device_start_input_reports",
            CHIDMessageToRemote::has_device_start_input_reports,
            CHIDMessageToRemote::device_start_input_reports,
            CHIDMessageToRemote::mut_device_start_input_reports,
            CHIDMessageToRemote::set_device_start_input_reports,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceRequestFullReport>(
            "device_request_full_report",
            CHIDMessageToRemote::has_device_request_full_report,
            CHIDMessageToRemote::device_request_full_report,
            CHIDMessageToRemote::mut_device_request_full_report,
            CHIDMessageToRemote::set_device_request_full_report,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_to_remote::DeviceDisconnect>(
            "device_disconnect",
            CHIDMessageToRemote::has_device_disconnect,
            CHIDMessageToRemote::device_disconnect,
            CHIDMessageToRemote::mut_device_disconnect,
            CHIDMessageToRemote::set_device_disconnect,
        ));
        oneofs.push(chidmessage_to_remote::Command::generated_oneof_descriptor_data());
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CHIDMessageToRemote>(
            "CHIDMessageToRemote",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CHIDMessageToRemote {
    const NAME: &'static str = "CHIDMessageToRemote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceOpen(is.read_message()?));
                },
                26 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceClose(is.read_message()?));
                },
                34 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceWrite(is.read_message()?));
                },
                42 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRead(is.read_message()?));
                },
                50 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceSendFeatureReport(is.read_message()?));
                },
                58 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetFeatureReport(is.read_message()?));
                },
                66 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetVendorString(is.read_message()?));
                },
                74 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetProductString(is.read_message()?));
                },
                82 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceGetSerialNumberString(is.read_message()?));
                },
                90 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceStartInputReports(is.read_message()?));
                },
                98 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceRequestFullReport(is.read_message()?));
                },
                106 => {
                    self.command = ::std::option::Option::Some(chidmessage_to_remote::Command::DeviceDisconnect(is.read_message()?));
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &chidmessage_to_remote::Command::DeviceOpen(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceClose(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceWrite(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceRead(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceSendFeatureReport(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceGetFeatureReport(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceGetVendorString(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceGetProductString(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceGetSerialNumberString(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceStartInputReports(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceRequestFullReport(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_to_remote::Command::DeviceDisconnect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &chidmessage_to_remote::Command::DeviceOpen(ref v) => {
                    crate::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceClose(ref v) => {
                    crate::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceWrite(ref v) => {
                    crate::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceRead(ref v) => {
                    crate::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceSendFeatureReport(ref v) => {
                    crate::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceGetFeatureReport(ref v) => {
                    crate::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceGetVendorString(ref v) => {
                    crate::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceGetProductString(ref v) => {
                    crate::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceGetSerialNumberString(ref v) => {
                    crate::rt::write_message_field_with_cached_size(10, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceStartInputReports(ref v) => {
                    crate::rt::write_message_field_with_cached_size(11, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceRequestFullReport(ref v) => {
                    crate::rt::write_message_field_with_cached_size(12, v, os)?;
                },
                &chidmessage_to_remote::Command::DeviceDisconnect(ref v) => {
                    crate::rt::write_message_field_with_cached_size(13, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHIDMessageToRemote {
        CHIDMessageToRemote::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHIDMessageToRemote {
        static instance: CHIDMessageToRemote = CHIDMessageToRemote {
            request_id: ::std::option::Option::None,
            command: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CHIDMessageToRemote {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHIDMessageToRemote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHIDMessageToRemote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CHIDMessageToRemote {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CHIDMessageToRemote`
pub mod chidmessage_to_remote {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CHIDMessageToRemote.command)
    pub enum Command {
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_open)
        DeviceOpen(DeviceOpen),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_close)
        DeviceClose(DeviceClose),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_write)
        DeviceWrite(DeviceWrite),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_read)
        DeviceRead(DeviceRead),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_send_feature_report)
        DeviceSendFeatureReport(DeviceSendFeatureReport),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_get_feature_report)
        DeviceGetFeatureReport(DeviceGetFeatureReport),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_get_vendor_string)
        DeviceGetVendorString(DeviceGetVendorString),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_get_product_string)
        DeviceGetProductString(DeviceGetProductString),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_get_serial_number_string)
        DeviceGetSerialNumberString(DeviceGetSerialNumberString),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_start_input_reports)
        DeviceStartInputReports(DeviceStartInputReports),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_request_full_report)
        DeviceRequestFullReport(DeviceRequestFullReport),
        // @@protoc_insertion_point(oneof_field:CHIDMessageToRemote.device_disconnect)
        DeviceDisconnect(DeviceDisconnect),
    }

    impl crate::Oneof for Command {
    }

    impl crate::OneofFull for Command {
        fn descriptor() -> crate::reflect::OneofDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::OneofDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| <super::CHIDMessageToRemote as crate::MessageFull>::descriptor().oneof_by_name("command").unwrap()).clone()
        }
    }

    impl Command {
        pub(in super) fn generated_oneof_descriptor_data() -> crate::reflect::GeneratedOneofDescriptorData {
            crate::reflect::GeneratedOneofDescriptorData::new::<Command>("command")
        }
    }
    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceOpen)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceOpen {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceOpen.info)
        pub info: crate::MessageField<super::CHIDDeviceInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceOpen.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceOpen {
        fn default() -> &'a DeviceOpen {
            <DeviceOpen as crate::Message>::default_instance()
        }
    }

    impl DeviceOpen {
        pub fn new() -> DeviceOpen {
            ::std::default::Default::default()
        }

        // optional .CHIDDeviceInfo info = 1;

        pub fn info(&self) -> &super::CHIDDeviceInfo {
            self.info.as_ref().unwrap_or_else(|| <super::CHIDDeviceInfo as crate::Message>::default_instance())
        }

        pub fn clear_info(&mut self) {
            self.info.clear();
        }

        pub fn has_info(&self) -> bool {
            self.info.is_some()
        }

        // Param is passed by value, moved
        pub fn set_info(&mut self, v: super::CHIDDeviceInfo) {
            self.info = crate::MessageField::some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_info(&mut self) -> &mut super::CHIDDeviceInfo {
            self.info.mut_or_insert_default()
        }

        // Take field
        pub fn take_info(&mut self) -> super::CHIDDeviceInfo {
            self.info.take().unwrap_or_else(|| super::CHIDDeviceInfo::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::CHIDDeviceInfo>(
                "info",
                |m: &DeviceOpen| { &m.info },
                |m: &mut DeviceOpen| { &mut m.info },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceOpen>(
                "CHIDMessageToRemote.DeviceOpen",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceOpen {
        const NAME: &'static str = "DeviceOpen";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.info)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.info.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.info.as_ref() {
                crate::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceOpen {
            DeviceOpen::new()
        }

        fn clear(&mut self) {
            self.info.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceOpen {
            static instance: DeviceOpen = DeviceOpen {
                info: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceOpen {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceOpen").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceOpen {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceOpen {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceClose)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceClose {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceClose.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceClose.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceClose {
        fn default() -> &'a DeviceClose {
            <DeviceClose as crate::Message>::default_instance()
        }
    }

    impl DeviceClose {
        pub fn new() -> DeviceClose {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceClose| { &m.device },
                |m: &mut DeviceClose| { &mut m.device },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceClose>(
                "CHIDMessageToRemote.DeviceClose",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceClose {
        const NAME: &'static str = "DeviceClose";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceClose {
            DeviceClose::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceClose {
            static instance: DeviceClose = DeviceClose {
                device: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceClose {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceClose").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceClose {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceClose {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceWrite)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceWrite {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceWrite.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceWrite.data)
        pub data: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceWrite.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceWrite {
        fn default() -> &'a DeviceWrite {
            <DeviceWrite as crate::Message>::default_instance()
        }
    }

    impl DeviceWrite {
        pub fn new() -> DeviceWrite {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional bytes data = 2;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::bytes::Bytes) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::bytes::Bytes {
            self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceWrite| { &m.device },
                |m: &mut DeviceWrite| { &mut m.device },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &DeviceWrite| { &m.data },
                |m: &mut DeviceWrite| { &mut m.data },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceWrite>(
                "CHIDMessageToRemote.DeviceWrite",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceWrite {
        const NAME: &'static str = "DeviceWrite";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += crate::rt::bytes_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceWrite {
            DeviceWrite::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceWrite {
            static instance: DeviceWrite = DeviceWrite {
                device: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceWrite {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceWrite").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceWrite {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceWrite {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceRead)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceRead {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceRead.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceRead.length)
        pub length: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceRead.timeout_ms)
        pub timeout_ms: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceRead.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceRead {
        fn default() -> &'a DeviceRead {
            <DeviceRead as crate::Message>::default_instance()
        }
    }

    impl DeviceRead {
        pub fn new() -> DeviceRead {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional uint32 length = 2;

        pub fn length(&self) -> u32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: u32) {
            self.length = ::std::option::Option::Some(v);
        }

        // optional int32 timeout_ms = 3;

        pub fn timeout_ms(&self) -> i32 {
            self.timeout_ms.unwrap_or(0)
        }

        pub fn clear_timeout_ms(&mut self) {
            self.timeout_ms = ::std::option::Option::None;
        }

        pub fn has_timeout_ms(&self) -> bool {
            self.timeout_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timeout_ms(&mut self, v: i32) {
            self.timeout_ms = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceRead| { &m.device },
                |m: &mut DeviceRead| { &mut m.device },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "length",
                |m: &DeviceRead| { &m.length },
                |m: &mut DeviceRead| { &mut m.length },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "timeout_ms",
                |m: &DeviceRead| { &m.timeout_ms },
                |m: &mut DeviceRead| { &mut m.timeout_ms },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceRead>(
                "CHIDMessageToRemote.DeviceRead",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceRead {
        const NAME: &'static str = "DeviceRead";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.length = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.timeout_ms = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.length {
                my_size += crate::rt::uint32_size(2, v);
            }
            if let Some(v) = self.timeout_ms {
                my_size += crate::rt::int32_size(3, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.length {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.timeout_ms {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceRead {
            DeviceRead::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.timeout_ms = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceRead {
            static instance: DeviceRead = DeviceRead {
                device: ::std::option::Option::None,
                length: ::std::option::Option::None,
                timeout_ms: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceRead {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceRead").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceRead {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceRead {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceSendFeatureReport)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceSendFeatureReport {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceSendFeatureReport.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceSendFeatureReport.data)
        pub data: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceSendFeatureReport.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceSendFeatureReport {
        fn default() -> &'a DeviceSendFeatureReport {
            <DeviceSendFeatureReport as crate::Message>::default_instance()
        }
    }

    impl DeviceSendFeatureReport {
        pub fn new() -> DeviceSendFeatureReport {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional bytes data = 2;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::bytes::Bytes) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::bytes::Bytes {
            self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceSendFeatureReport| { &m.device },
                |m: &mut DeviceSendFeatureReport| { &mut m.device },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &DeviceSendFeatureReport| { &m.data },
                |m: &mut DeviceSendFeatureReport| { &mut m.data },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceSendFeatureReport>(
                "CHIDMessageToRemote.DeviceSendFeatureReport",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceSendFeatureReport {
        const NAME: &'static str = "DeviceSendFeatureReport";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += crate::rt::bytes_size(2, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceSendFeatureReport {
            DeviceSendFeatureReport::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceSendFeatureReport {
            static instance: DeviceSendFeatureReport = DeviceSendFeatureReport {
                device: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceSendFeatureReport {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceSendFeatureReport").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceSendFeatureReport {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceSendFeatureReport {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceGetFeatureReport)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceGetFeatureReport {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetFeatureReport.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetFeatureReport.report_number)
        pub report_number: ::std::option::Option<::bytes::Bytes>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetFeatureReport.length)
        pub length: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceGetFeatureReport.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceGetFeatureReport {
        fn default() -> &'a DeviceGetFeatureReport {
            <DeviceGetFeatureReport as crate::Message>::default_instance()
        }
    }

    impl DeviceGetFeatureReport {
        pub fn new() -> DeviceGetFeatureReport {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional bytes report_number = 2;

        pub fn report_number(&self) -> &[u8] {
            match self.report_number.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_report_number(&mut self) {
            self.report_number = ::std::option::Option::None;
        }

        pub fn has_report_number(&self) -> bool {
            self.report_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_report_number(&mut self, v: ::bytes::Bytes) {
            self.report_number = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_report_number(&mut self) -> &mut ::bytes::Bytes {
            if self.report_number.is_none() {
                self.report_number = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.report_number.as_mut().unwrap()
        }

        // Take field
        pub fn take_report_number(&mut self) -> ::bytes::Bytes {
            self.report_number.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        // optional uint32 length = 3;

        pub fn length(&self) -> u32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: u32) {
            self.length = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceGetFeatureReport| { &m.device },
                |m: &mut DeviceGetFeatureReport| { &mut m.device },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "report_number",
                |m: &DeviceGetFeatureReport| { &m.report_number },
                |m: &mut DeviceGetFeatureReport| { &mut m.report_number },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "length",
                |m: &DeviceGetFeatureReport| { &m.length },
                |m: &mut DeviceGetFeatureReport| { &mut m.length },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceGetFeatureReport>(
                "CHIDMessageToRemote.DeviceGetFeatureReport",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceGetFeatureReport {
        const NAME: &'static str = "DeviceGetFeatureReport";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.report_number = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    24 => {
                        self.length = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.report_number.as_ref() {
                my_size += crate::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.length {
                my_size += crate::rt::uint32_size(3, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.report_number.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.length {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceGetFeatureReport {
            DeviceGetFeatureReport::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.report_number = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceGetFeatureReport {
            static instance: DeviceGetFeatureReport = DeviceGetFeatureReport {
                device: ::std::option::Option::None,
                report_number: ::std::option::Option::None,
                length: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceGetFeatureReport {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceGetFeatureReport").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceGetFeatureReport {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceGetFeatureReport {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceGetVendorString)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceGetVendorString {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetVendorString.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceGetVendorString.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceGetVendorString {
        fn default() -> &'a DeviceGetVendorString {
            <DeviceGetVendorString as crate::Message>::default_instance()
        }
    }

    impl DeviceGetVendorString {
        pub fn new() -> DeviceGetVendorString {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceGetVendorString| { &m.device },
                |m: &mut DeviceGetVendorString| { &mut m.device },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceGetVendorString>(
                "CHIDMessageToRemote.DeviceGetVendorString",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceGetVendorString {
        const NAME: &'static str = "DeviceGetVendorString";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceGetVendorString {
            DeviceGetVendorString::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceGetVendorString {
            static instance: DeviceGetVendorString = DeviceGetVendorString {
                device: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceGetVendorString {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceGetVendorString").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceGetVendorString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceGetVendorString {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceGetProductString)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceGetProductString {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetProductString.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceGetProductString.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceGetProductString {
        fn default() -> &'a DeviceGetProductString {
            <DeviceGetProductString as crate::Message>::default_instance()
        }
    }

    impl DeviceGetProductString {
        pub fn new() -> DeviceGetProductString {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceGetProductString| { &m.device },
                |m: &mut DeviceGetProductString| { &mut m.device },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceGetProductString>(
                "CHIDMessageToRemote.DeviceGetProductString",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceGetProductString {
        const NAME: &'static str = "DeviceGetProductString";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceGetProductString {
            DeviceGetProductString::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceGetProductString {
            static instance: DeviceGetProductString = DeviceGetProductString {
                device: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceGetProductString {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceGetProductString").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceGetProductString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceGetProductString {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceGetSerialNumberString)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceGetSerialNumberString {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceGetSerialNumberString.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceGetSerialNumberString.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceGetSerialNumberString {
        fn default() -> &'a DeviceGetSerialNumberString {
            <DeviceGetSerialNumberString as crate::Message>::default_instance()
        }
    }

    impl DeviceGetSerialNumberString {
        pub fn new() -> DeviceGetSerialNumberString {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceGetSerialNumberString| { &m.device },
                |m: &mut DeviceGetSerialNumberString| { &mut m.device },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceGetSerialNumberString>(
                "CHIDMessageToRemote.DeviceGetSerialNumberString",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceGetSerialNumberString {
        const NAME: &'static str = "DeviceGetSerialNumberString";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceGetSerialNumberString {
            DeviceGetSerialNumberString::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceGetSerialNumberString {
            static instance: DeviceGetSerialNumberString = DeviceGetSerialNumberString {
                device: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceGetSerialNumberString {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceGetSerialNumberString").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceGetSerialNumberString {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceGetSerialNumberString {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceStartInputReports)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceStartInputReports {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceStartInputReports.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceStartInputReports.length)
        pub length: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceStartInputReports.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceStartInputReports {
        fn default() -> &'a DeviceStartInputReports {
            <DeviceStartInputReports as crate::Message>::default_instance()
        }
    }

    impl DeviceStartInputReports {
        pub fn new() -> DeviceStartInputReports {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional uint32 length = 2;

        pub fn length(&self) -> u32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: u32) {
            self.length = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceStartInputReports| { &m.device },
                |m: &mut DeviceStartInputReports| { &mut m.device },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "length",
                |m: &DeviceStartInputReports| { &m.length },
                |m: &mut DeviceStartInputReports| { &mut m.length },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceStartInputReports>(
                "CHIDMessageToRemote.DeviceStartInputReports",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceStartInputReports {
        const NAME: &'static str = "DeviceStartInputReports";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.length = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.length {
                my_size += crate::rt::uint32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.length {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceStartInputReports {
            DeviceStartInputReports::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceStartInputReports {
            static instance: DeviceStartInputReports = DeviceStartInputReports {
                device: ::std::option::Option::None,
                length: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceStartInputReports {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceStartInputReports").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceStartInputReports {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceStartInputReports {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceRequestFullReport)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceRequestFullReport {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceRequestFullReport.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceRequestFullReport.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceRequestFullReport {
        fn default() -> &'a DeviceRequestFullReport {
            <DeviceRequestFullReport as crate::Message>::default_instance()
        }
    }

    impl DeviceRequestFullReport {
        pub fn new() -> DeviceRequestFullReport {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceRequestFullReport| { &m.device },
                |m: &mut DeviceRequestFullReport| { &mut m.device },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceRequestFullReport>(
                "CHIDMessageToRemote.DeviceRequestFullReport",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceRequestFullReport {
        const NAME: &'static str = "DeviceRequestFullReport";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceRequestFullReport {
            DeviceRequestFullReport::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceRequestFullReport {
            static instance: DeviceRequestFullReport = DeviceRequestFullReport {
                device: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceRequestFullReport {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceRequestFullReport").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceRequestFullReport {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceRequestFullReport {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageToRemote.DeviceDisconnect)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceDisconnect {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceDisconnect.device)
        pub device: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceDisconnect.disconnectMethod)
        pub disconnectMethod: ::std::option::Option<crate::EnumOrUnknown<super::EHIDDeviceDisconnectMethod>>,
        // @@protoc_insertion_point(field:CHIDMessageToRemote.DeviceDisconnect.data)
        pub data: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageToRemote.DeviceDisconnect.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceDisconnect {
        fn default() -> &'a DeviceDisconnect {
            <DeviceDisconnect as crate::Message>::default_instance()
        }
    }

    impl DeviceDisconnect {
        pub fn new() -> DeviceDisconnect {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        // optional .EHIDDeviceDisconnectMethod disconnectMethod = 2;

        pub fn disconnectMethod(&self) -> super::EHIDDeviceDisconnectMethod {
            match self.disconnectMethod {
                Some(e) => e.enum_value_or(super::EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown),
                None => super::EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown,
            }
        }

        pub fn clear_disconnectMethod(&mut self) {
            self.disconnectMethod = ::std::option::Option::None;
        }

        pub fn has_disconnectMethod(&self) -> bool {
            self.disconnectMethod.is_some()
        }

        // Param is passed by value, moved
        pub fn set_disconnectMethod(&mut self, v: super::EHIDDeviceDisconnectMethod) {
            self.disconnectMethod = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional bytes data = 3;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::bytes::Bytes) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::bytes::Bytes {
            self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &DeviceDisconnect| { &m.device },
                |m: &mut DeviceDisconnect| { &mut m.device },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "disconnectMethod",
                |m: &DeviceDisconnect| { &m.disconnectMethod },
                |m: &mut DeviceDisconnect| { &mut m.disconnectMethod },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &DeviceDisconnect| { &m.data },
                |m: &mut DeviceDisconnect| { &mut m.data },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceDisconnect>(
                "CHIDMessageToRemote.DeviceDisconnect",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceDisconnect {
        const NAME: &'static str = "DeviceDisconnect";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.disconnectMethod = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    26 => {
                        self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.disconnectMethod {
                my_size += crate::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.data.as_ref() {
                my_size += crate::rt::bytes_size(3, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.disconnectMethod {
                os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceDisconnect {
            DeviceDisconnect::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.disconnectMethod = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceDisconnect {
            static instance: DeviceDisconnect = DeviceDisconnect {
                device: ::std::option::Option::None,
                disconnectMethod: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceDisconnect {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageToRemote.DeviceDisconnect").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceDisconnect {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceDisconnect {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CHIDMessageFromRemote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CHIDMessageFromRemote {
    // message oneof groups
    pub command: ::std::option::Option<chidmessage_from_remote::Command>,
    // special fields
    // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CHIDMessageFromRemote {
    fn default() -> &'a CHIDMessageFromRemote {
        <CHIDMessageFromRemote as crate::Message>::default_instance()
    }
}

impl CHIDMessageFromRemote {
    pub fn new() -> CHIDMessageFromRemote {
        ::std::default::Default::default()
    }

    // optional .CHIDMessageFromRemote.UpdateDeviceList update_device_list = 1;

    pub fn update_device_list(&self) -> &chidmessage_from_remote::UpdateDeviceList {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(ref v)) => v,
            _ => <chidmessage_from_remote::UpdateDeviceList as crate::Message>::default_instance(),
        }
    }

    pub fn clear_update_device_list(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_update_device_list(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_update_device_list(&mut self, v: chidmessage_from_remote::UpdateDeviceList) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_update_device_list(&mut self) -> &mut chidmessage_from_remote::UpdateDeviceList {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(chidmessage_from_remote::UpdateDeviceList::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_update_device_list(&mut self) -> chidmessage_from_remote::UpdateDeviceList {
        if self.has_update_device_list() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::UpdateDeviceList::new()
        }
    }

    // optional .CHIDMessageFromRemote.RequestResponse response = 2;

    pub fn response(&self) -> &chidmessage_from_remote::RequestResponse {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Response(ref v)) => v,
            _ => <chidmessage_from_remote::RequestResponse as crate::Message>::default_instance(),
        }
    }

    pub fn clear_response(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: chidmessage_from_remote::RequestResponse) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response(&mut self) -> &mut chidmessage_from_remote::RequestResponse {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::Response(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Response(chidmessage_from_remote::RequestResponse::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response(&mut self) -> chidmessage_from_remote::RequestResponse {
        if self.has_response() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::Response(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::RequestResponse::new()
        }
    }

    // optional .CHIDMessageFromRemote.DeviceInputReports reports = 3;

    pub fn reports(&self) -> &chidmessage_from_remote::DeviceInputReports {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(ref v)) => v,
            _ => <chidmessage_from_remote::DeviceInputReports as crate::Message>::default_instance(),
        }
    }

    pub fn clear_reports(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_reports(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_reports(&mut self, v: chidmessage_from_remote::DeviceInputReports) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(v))
    }

    // Mutable pointer to the field.
    pub fn mut_reports(&mut self) -> &mut chidmessage_from_remote::DeviceInputReports {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(chidmessage_from_remote::DeviceInputReports::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_reports(&mut self) -> chidmessage_from_remote::DeviceInputReports {
        if self.has_reports() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::DeviceInputReports::new()
        }
    }

    // optional .CHIDMessageFromRemote.CloseDevice close_device = 4;

    pub fn close_device(&self) -> &chidmessage_from_remote::CloseDevice {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(ref v)) => v,
            _ => <chidmessage_from_remote::CloseDevice as crate::Message>::default_instance(),
        }
    }

    pub fn clear_close_device(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_close_device(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_device(&mut self, v: chidmessage_from_remote::CloseDevice) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_device(&mut self) -> &mut chidmessage_from_remote::CloseDevice {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(chidmessage_from_remote::CloseDevice::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_device(&mut self) -> chidmessage_from_remote::CloseDevice {
        if self.has_close_device() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::CloseDevice::new()
        }
    }

    // optional .CHIDMessageFromRemote.CloseAllDevices close_all_devices = 5;

    pub fn close_all_devices(&self) -> &chidmessage_from_remote::CloseAllDevices {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(ref v)) => v,
            _ => <chidmessage_from_remote::CloseAllDevices as crate::Message>::default_instance(),
        }
    }

    pub fn clear_close_all_devices(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_close_all_devices(&self) -> bool {
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_close_all_devices(&mut self, v: chidmessage_from_remote::CloseAllDevices) {
        self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(v))
    }

    // Mutable pointer to the field.
    pub fn mut_close_all_devices(&mut self) -> &mut chidmessage_from_remote::CloseAllDevices {
        if let ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(_)) = self.command {
        } else {
            self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(chidmessage_from_remote::CloseAllDevices::new()));
        }
        match self.command {
            ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_close_all_devices(&mut self) -> chidmessage_from_remote::CloseAllDevices {
        if self.has_close_all_devices() {
            match self.command.take() {
                ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(v)) => v,
                _ => panic!(),
            }
        } else {
            chidmessage_from_remote::CloseAllDevices::new()
        }
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_from_remote::UpdateDeviceList>(
            "update_device_list",
            CHIDMessageFromRemote::has_update_device_list,
            CHIDMessageFromRemote::update_device_list,
            CHIDMessageFromRemote::mut_update_device_list,
            CHIDMessageFromRemote::set_update_device_list,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_from_remote::RequestResponse>(
            "response",
            CHIDMessageFromRemote::has_response,
            CHIDMessageFromRemote::response,
            CHIDMessageFromRemote::mut_response,
            CHIDMessageFromRemote::set_response,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_from_remote::DeviceInputReports>(
            "reports",
            CHIDMessageFromRemote::has_reports,
            CHIDMessageFromRemote::reports,
            CHIDMessageFromRemote::mut_reports,
            CHIDMessageFromRemote::set_reports,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_from_remote::CloseDevice>(
            "close_device",
            CHIDMessageFromRemote::has_close_device,
            CHIDMessageFromRemote::close_device,
            CHIDMessageFromRemote::mut_close_device,
            CHIDMessageFromRemote::set_close_device,
        ));
        fields.push(crate::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, chidmessage_from_remote::CloseAllDevices>(
            "close_all_devices",
            CHIDMessageFromRemote::has_close_all_devices,
            CHIDMessageFromRemote::close_all_devices,
            CHIDMessageFromRemote::mut_close_all_devices,
            CHIDMessageFromRemote::set_close_all_devices,
        ));
        oneofs.push(chidmessage_from_remote::Command::generated_oneof_descriptor_data());
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CHIDMessageFromRemote>(
            "CHIDMessageFromRemote",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CHIDMessageFromRemote {
    const NAME: &'static str = "CHIDMessageFromRemote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::UpdateDeviceList(is.read_message()?));
                },
                18 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Response(is.read_message()?));
                },
                26 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::Reports(is.read_message()?));
                },
                34 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseDevice(is.read_message()?));
                },
                42 => {
                    self.command = ::std::option::Option::Some(chidmessage_from_remote::Command::CloseAllDevices(is.read_message()?));
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &chidmessage_from_remote::Command::UpdateDeviceList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_from_remote::Command::Response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_from_remote::Command::Reports(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_from_remote::Command::CloseDevice(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
                &chidmessage_from_remote::Command::CloseAllDevices(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let ::std::option::Option::Some(ref v) = self.command {
            match v {
                &chidmessage_from_remote::Command::UpdateDeviceList(ref v) => {
                    crate::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &chidmessage_from_remote::Command::Response(ref v) => {
                    crate::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &chidmessage_from_remote::Command::Reports(ref v) => {
                    crate::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &chidmessage_from_remote::Command::CloseDevice(ref v) => {
                    crate::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &chidmessage_from_remote::Command::CloseAllDevices(ref v) => {
                    crate::rt::write_message_field_with_cached_size(5, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CHIDMessageFromRemote {
        CHIDMessageFromRemote::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CHIDMessageFromRemote {
        static instance: CHIDMessageFromRemote = CHIDMessageFromRemote {
            command: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CHIDMessageFromRemote {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CHIDMessageFromRemote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CHIDMessageFromRemote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CHIDMessageFromRemote {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CHIDMessageFromRemote`
pub mod chidmessage_from_remote {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:CHIDMessageFromRemote.command)
    pub enum Command {
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.update_device_list)
        UpdateDeviceList(UpdateDeviceList),
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.response)
        Response(RequestResponse),
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.reports)
        Reports(DeviceInputReports),
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.close_device)
        CloseDevice(CloseDevice),
        // @@protoc_insertion_point(oneof_field:CHIDMessageFromRemote.close_all_devices)
        CloseAllDevices(CloseAllDevices),
    }

    impl crate::Oneof for Command {
    }

    impl crate::OneofFull for Command {
        fn descriptor() -> crate::reflect::OneofDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::OneofDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| <super::CHIDMessageFromRemote as crate::MessageFull>::descriptor().oneof_by_name("command").unwrap()).clone()
        }
    }

    impl Command {
        pub(in super) fn generated_oneof_descriptor_data() -> crate::reflect::GeneratedOneofDescriptorData {
            crate::reflect::GeneratedOneofDescriptorData::new::<Command>("command")
        }
    }
    // @@protoc_insertion_point(message:CHIDMessageFromRemote.UpdateDeviceList)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateDeviceList {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.UpdateDeviceList.devices)
        pub devices: ::std::vec::Vec<super::CHIDDeviceInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.UpdateDeviceList.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateDeviceList {
        fn default() -> &'a UpdateDeviceList {
            <UpdateDeviceList as crate::Message>::default_instance()
        }
    }

    impl UpdateDeviceList {
        pub fn new() -> UpdateDeviceList {
            ::std::default::Default::default()
        }

        // repeated .CHIDDeviceInfo devices = 1;

        pub fn devices(&self) -> &[super::CHIDDeviceInfo] {
            &self.devices
        }

        pub fn clear_devices(&mut self) {
            self.devices.clear();
        }

        // Param is passed by value, moved
        pub fn set_devices(&mut self, v: ::std::vec::Vec<super::CHIDDeviceInfo>) {
            self.devices = v;
        }

        // Mutable pointer to the field.
        pub fn mut_devices(&mut self) -> &mut ::std::vec::Vec<super::CHIDDeviceInfo> {
            &mut self.devices
        }

        // Take field
        pub fn take_devices(&mut self) -> ::std::vec::Vec<super::CHIDDeviceInfo> {
            ::std::mem::replace(&mut self.devices, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "devices",
                |m: &UpdateDeviceList| { &m.devices },
                |m: &mut UpdateDeviceList| { &mut m.devices },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<UpdateDeviceList>(
                "CHIDMessageFromRemote.UpdateDeviceList",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for UpdateDeviceList {
        const NAME: &'static str = "UpdateDeviceList";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.devices.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.devices {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            for v in &self.devices {
                crate::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateDeviceList {
            UpdateDeviceList::new()
        }

        fn clear(&mut self) {
            self.devices.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateDeviceList {
            static instance: UpdateDeviceList = UpdateDeviceList {
                devices: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for UpdateDeviceList {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageFromRemote.UpdateDeviceList").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for UpdateDeviceList {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for UpdateDeviceList {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageFromRemote.RequestResponse)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RequestResponse {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.RequestResponse.request_id)
        pub request_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.RequestResponse.result)
        pub result: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.RequestResponse.data)
        pub data: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.RequestResponse.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RequestResponse {
        fn default() -> &'a RequestResponse {
            <RequestResponse as crate::Message>::default_instance()
        }
    }

    impl RequestResponse {
        pub fn new() -> RequestResponse {
            ::std::default::Default::default()
        }

        // optional uint32 request_id = 1;

        pub fn request_id(&self) -> u32 {
            self.request_id.unwrap_or(0)
        }

        pub fn clear_request_id(&mut self) {
            self.request_id = ::std::option::Option::None;
        }

        pub fn has_request_id(&self) -> bool {
            self.request_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_request_id(&mut self, v: u32) {
            self.request_id = ::std::option::Option::Some(v);
        }

        // optional int32 result = 2;

        pub fn result(&self) -> i32 {
            self.result.unwrap_or(0)
        }

        pub fn clear_result(&mut self) {
            self.result = ::std::option::Option::None;
        }

        pub fn has_result(&self) -> bool {
            self.result.is_some()
        }

        // Param is passed by value, moved
        pub fn set_result(&mut self, v: i32) {
            self.result = ::std::option::Option::Some(v);
        }

        // optional bytes data = 3;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::bytes::Bytes) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::bytes::Bytes {
            self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "request_id",
                |m: &RequestResponse| { &m.request_id },
                |m: &mut RequestResponse| { &mut m.request_id },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "result",
                |m: &RequestResponse| { &m.result },
                |m: &mut RequestResponse| { &mut m.result },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "data",
                |m: &RequestResponse| { &m.data },
                |m: &mut RequestResponse| { &mut m.data },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<RequestResponse>(
                "CHIDMessageFromRemote.RequestResponse",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for RequestResponse {
        const NAME: &'static str = "RequestResponse";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.result = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.request_id {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.result {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.data.as_ref() {
                my_size += crate::rt::bytes_size(3, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.request_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.result {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RequestResponse {
            RequestResponse::new()
        }

        fn clear(&mut self) {
            self.request_id = ::std::option::Option::None;
            self.result = ::std::option::Option::None;
            self.data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RequestResponse {
            static instance: RequestResponse = RequestResponse {
                request_id: ::std::option::Option::None,
                result: ::std::option::Option::None,
                data: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for RequestResponse {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageFromRemote.RequestResponse").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RequestResponse {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for RequestResponse {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageFromRemote.DeviceInputReports)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DeviceInputReports {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.DeviceInputReports.device_reports)
        pub device_reports: ::std::vec::Vec<device_input_reports::DeviceInputReport>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.DeviceInputReports.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DeviceInputReports {
        fn default() -> &'a DeviceInputReports {
            <DeviceInputReports as crate::Message>::default_instance()
        }
    }

    impl DeviceInputReports {
        pub fn new() -> DeviceInputReports {
            ::std::default::Default::default()
        }

        // repeated .CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport device_reports = 1;

        pub fn device_reports(&self) -> &[device_input_reports::DeviceInputReport] {
            &self.device_reports
        }

        pub fn clear_device_reports(&mut self) {
            self.device_reports.clear();
        }

        // Param is passed by value, moved
        pub fn set_device_reports(&mut self, v: ::std::vec::Vec<device_input_reports::DeviceInputReport>) {
            self.device_reports = v;
        }

        // Mutable pointer to the field.
        pub fn mut_device_reports(&mut self) -> &mut ::std::vec::Vec<device_input_reports::DeviceInputReport> {
            &mut self.device_reports
        }

        // Take field
        pub fn take_device_reports(&mut self) -> ::std::vec::Vec<device_input_reports::DeviceInputReport> {
            ::std::mem::replace(&mut self.device_reports, ::std::vec::Vec::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "device_reports",
                |m: &DeviceInputReports| { &m.device_reports },
                |m: &mut DeviceInputReports| { &mut m.device_reports },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInputReports>(
                "CHIDMessageFromRemote.DeviceInputReports",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for DeviceInputReports {
        const NAME: &'static str = "DeviceInputReports";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.device_reports.push(is.read_message()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.device_reports {
                let len = value.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            for v in &self.device_reports {
                crate::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DeviceInputReports {
            DeviceInputReports::new()
        }

        fn clear(&mut self) {
            self.device_reports.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DeviceInputReports {
            static instance: DeviceInputReports = DeviceInputReports {
                device_reports: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for DeviceInputReports {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageFromRemote.DeviceInputReports").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DeviceInputReports {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for DeviceInputReports {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `DeviceInputReports`
    pub mod device_input_reports {
        // @@protoc_insertion_point(message:CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DeviceInputReport {
            // message fields
            // @@protoc_insertion_point(field:CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport.device)
            pub device: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport.reports)
            pub reports: ::std::vec::Vec<super::super::CHIDDeviceInputReport>,
            // special fields
            // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport.special_fields)
            pub special_fields: crate::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DeviceInputReport {
            fn default() -> &'a DeviceInputReport {
                <DeviceInputReport as crate::Message>::default_instance()
            }
        }

        impl DeviceInputReport {
            pub fn new() -> DeviceInputReport {
                ::std::default::Default::default()
            }

            // optional uint32 device = 1;

            pub fn device(&self) -> u32 {
                self.device.unwrap_or(0)
            }

            pub fn clear_device(&mut self) {
                self.device = ::std::option::Option::None;
            }

            pub fn has_device(&self) -> bool {
                self.device.is_some()
            }

            // Param is passed by value, moved
            pub fn set_device(&mut self, v: u32) {
                self.device = ::std::option::Option::Some(v);
            }

            // repeated .CHIDDeviceInputReport reports = 2;

            pub fn reports(&self) -> &[super::super::CHIDDeviceInputReport] {
                &self.reports
            }

            pub fn clear_reports(&mut self) {
                self.reports.clear();
            }

            // Param is passed by value, moved
            pub fn set_reports(&mut self, v: ::std::vec::Vec<super::super::CHIDDeviceInputReport>) {
                self.reports = v;
            }

            // Mutable pointer to the field.
            pub fn mut_reports(&mut self) -> &mut ::std::vec::Vec<super::super::CHIDDeviceInputReport> {
                &mut self.reports
            }

            // Take field
            pub fn take_reports(&mut self) -> ::std::vec::Vec<super::super::CHIDDeviceInputReport> {
                ::std::mem::replace(&mut self.reports, ::std::vec::Vec::new())
            }

            pub(in super::super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(2);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                    "device",
                    |m: &DeviceInputReport| { &m.device },
                    |m: &mut DeviceInputReport| { &mut m.device },
                ));
                fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                    "reports",
                    |m: &DeviceInputReport| { &m.reports },
                    |m: &mut DeviceInputReport| { &mut m.reports },
                ));
                crate::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInputReport>(
                    "CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport",
                    fields,
                    oneofs,
                )
            }
        }

        impl crate::Message for DeviceInputReport {
            const NAME: &'static str = "DeviceInputReport";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.device = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            self.reports.push(is.read_message()?);
                        },
                        tag => {
                            crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.device {
                    my_size += crate::rt::uint32_size(1, v);
                }
                for value in &self.reports {
                    let len = value.compute_size();
                    my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
                if let Some(v) = self.device {
                    os.write_uint32(1, v)?;
                }
                for v in &self.reports {
                    crate::rt::write_message_field_with_cached_size(2, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &crate::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DeviceInputReport {
                DeviceInputReport::new()
            }

            fn clear(&mut self) {
                self.device = ::std::option::Option::None;
                self.reports.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DeviceInputReport {
                static instance: DeviceInputReport = DeviceInputReport {
                    device: ::std::option::Option::None,
                    reports: ::std::vec::Vec::new(),
                    special_fields: crate::SpecialFields::new(),
                };
                &instance
            }
        }

        impl crate::MessageFull for DeviceInputReport {
            fn descriptor() -> crate::reflect::MessageDescriptor {
                static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CHIDMessageFromRemote.DeviceInputReports.DeviceInputReport").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for DeviceInputReport {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                crate::text_format::fmt(self, f)
            }
        }

        impl crate::reflect::ProtobufValue for DeviceInputReport {
            type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    // @@protoc_insertion_point(message:CHIDMessageFromRemote.CloseDevice)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CloseDevice {
        // message fields
        // @@protoc_insertion_point(field:CHIDMessageFromRemote.CloseDevice.device)
        pub device: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.CloseDevice.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CloseDevice {
        fn default() -> &'a CloseDevice {
            <CloseDevice as crate::Message>::default_instance()
        }
    }

    impl CloseDevice {
        pub fn new() -> CloseDevice {
            ::std::default::Default::default()
        }

        // optional uint32 device = 1;

        pub fn device(&self) -> u32 {
            self.device.unwrap_or(0)
        }

        pub fn clear_device(&mut self) {
            self.device = ::std::option::Option::None;
        }

        pub fn has_device(&self) -> bool {
            self.device.is_some()
        }

        // Param is passed by value, moved
        pub fn set_device(&mut self, v: u32) {
            self.device = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "device",
                |m: &CloseDevice| { &m.device },
                |m: &mut CloseDevice| { &mut m.device },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<CloseDevice>(
                "CHIDMessageFromRemote.CloseDevice",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for CloseDevice {
        const NAME: &'static str = "CloseDevice";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.device = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.device {
                my_size += crate::rt::uint32_size(1, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.device {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CloseDevice {
            CloseDevice::new()
        }

        fn clear(&mut self) {
            self.device = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CloseDevice {
            static instance: CloseDevice = CloseDevice {
                device: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for CloseDevice {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageFromRemote.CloseDevice").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CloseDevice {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for CloseDevice {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:CHIDMessageFromRemote.CloseAllDevices)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CloseAllDevices {
        // special fields
        // @@protoc_insertion_point(special_field:CHIDMessageFromRemote.CloseAllDevices.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CloseAllDevices {
        fn default() -> &'a CloseAllDevices {
            <CloseAllDevices as crate::Message>::default_instance()
        }
    }

    impl CloseAllDevices {
        pub fn new() -> CloseAllDevices {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            crate::reflect::GeneratedMessageDescriptorData::new_2::<CloseAllDevices>(
                "CHIDMessageFromRemote.CloseAllDevices",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for CloseAllDevices {
        const NAME: &'static str = "CloseAllDevices";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CloseAllDevices {
            CloseAllDevices::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CloseAllDevices {
            static instance: CloseAllDevices = CloseAllDevices {
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for CloseAllDevices {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CHIDMessageFromRemote.CloseAllDevices").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CloseAllDevices {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for CloseAllDevices {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHIDDeviceLocation)
pub enum EHIDDeviceLocation {
    // @@protoc_insertion_point(enum_value:EHIDDeviceLocation.k_EDeviceLocationLocal)
    k_EDeviceLocationLocal = 0,
    // @@protoc_insertion_point(enum_value:EHIDDeviceLocation.k_EDeviceLocationRemote)
    k_EDeviceLocationRemote = 2,
    // @@protoc_insertion_point(enum_value:EHIDDeviceLocation.k_EDeviceLocationAny)
    k_EDeviceLocationAny = 3,
}

impl crate::Enum for EHIDDeviceLocation {
    const NAME: &'static str = "EHIDDeviceLocation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHIDDeviceLocation> {
        match value {
            0 => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationLocal),
            2 => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationRemote),
            3 => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationAny),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHIDDeviceLocation> {
        match str {
            "k_EDeviceLocationLocal" => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationLocal),
            "k_EDeviceLocationRemote" => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationRemote),
            "k_EDeviceLocationAny" => ::std::option::Option::Some(EHIDDeviceLocation::k_EDeviceLocationAny),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHIDDeviceLocation] = &[
        EHIDDeviceLocation::k_EDeviceLocationLocal,
        EHIDDeviceLocation::k_EDeviceLocationRemote,
        EHIDDeviceLocation::k_EDeviceLocationAny,
    ];
}

impl crate::EnumFull for EHIDDeviceLocation {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EHIDDeviceLocation").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EHIDDeviceLocation::k_EDeviceLocationLocal => 0,
            EHIDDeviceLocation::k_EDeviceLocationRemote => 1,
            EHIDDeviceLocation::k_EDeviceLocationAny => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EHIDDeviceLocation {
    fn default() -> Self {
        EHIDDeviceLocation::k_EDeviceLocationLocal
    }
}

impl EHIDDeviceLocation {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EHIDDeviceLocation>("EHIDDeviceLocation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHIDDeviceDisconnectMethod)
pub enum EHIDDeviceDisconnectMethod {
    // @@protoc_insertion_point(enum_value:EHIDDeviceDisconnectMethod.k_EDeviceDisconnectMethodUnknown)
    k_EDeviceDisconnectMethodUnknown = 0,
    // @@protoc_insertion_point(enum_value:EHIDDeviceDisconnectMethod.k_EDeviceDisconnectMethodBluetooth)
    k_EDeviceDisconnectMethodBluetooth = 1,
    // @@protoc_insertion_point(enum_value:EHIDDeviceDisconnectMethod.k_EDeviceDisconnectMethodFeatureReport)
    k_EDeviceDisconnectMethodFeatureReport = 2,
    // @@protoc_insertion_point(enum_value:EHIDDeviceDisconnectMethod.k_EDeviceDisconnectMethodOutputReport)
    k_EDeviceDisconnectMethodOutputReport = 3,
}

impl crate::Enum for EHIDDeviceDisconnectMethod {
    const NAME: &'static str = "EHIDDeviceDisconnectMethod";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHIDDeviceDisconnectMethod> {
        match value {
            0 => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown),
            1 => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodBluetooth),
            2 => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodFeatureReport),
            3 => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodOutputReport),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHIDDeviceDisconnectMethod> {
        match str {
            "k_EDeviceDisconnectMethodUnknown" => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown),
            "k_EDeviceDisconnectMethodBluetooth" => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodBluetooth),
            "k_EDeviceDisconnectMethodFeatureReport" => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodFeatureReport),
            "k_EDeviceDisconnectMethodOutputReport" => ::std::option::Option::Some(EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodOutputReport),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHIDDeviceDisconnectMethod] = &[
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown,
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodBluetooth,
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodFeatureReport,
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodOutputReport,
    ];
}

impl crate::EnumFull for EHIDDeviceDisconnectMethod {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EHIDDeviceDisconnectMethod").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EHIDDeviceDisconnectMethod {
    fn default() -> Self {
        EHIDDeviceDisconnectMethod::k_EDeviceDisconnectMethodUnknown
    }
}

impl EHIDDeviceDisconnectMethod {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EHIDDeviceDisconnectMethod>("EHIDDeviceDisconnectMethod")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1esteammessages_hiddevices.proto\"\xe6\x06\n\x0eCHIDDeviceInfo\x12G\
    \n\x08location\x18\x01\x20\x01(\x0e2\x13.EHIDDeviceLocation:\x16k_EDevic\
    eLocationLocalR\x08location\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04pat\
    h\x12\x1b\n\tvendor_id\x18\x03\x20\x01(\rR\x08vendorId\x12\x1d\n\nproduc\
    t_id\x18\x04\x20\x01(\rR\tproductId\x12#\n\rserial_number\x18\x05\x20\
    \x01(\tR\x0cserialNumber\x12%\n\x0erelease_number\x18\x06\x20\x01(\rR\rr\
    eleaseNumber\x12/\n\x13manufacturer_string\x18\x07\x20\x01(\tR\x12manufa\
    cturerString\x12%\n\x0eproduct_string\x18\x08\x20\x01(\tR\rproductString\
    \x12\x1d\n\nusage_page\x18\t\x20\x01(\rR\tusagePage\x12\x14\n\x05usage\
    \x18\n\x20\x01(\rR\x05usage\x12-\n\x10interface_number\x18\x0b\x20\x01(\
    \x05:\x02-1R\x0finterfaceNumber\x12\x1a\n\x06ostype\x18\x0c\x20\x01(\x05\
    :\x02-1R\x06ostype\x12,\n\x12is_generic_gamepad\x18\r\x20\x01(\x08R\x10i\
    sGenericGamepad\x12.\n\x13is_generic_joystick\x18\x0e\x20\x01(\x08R\x11i\
    sGenericJoystick\x12\x1b\n\tcaps_bits\x18\x0f\x20\x01(\rR\x08capsBits\
    \x12\x1d\n\nsession_id\x18\x10\x20\x01(\rR\tsessionId\x12<\n\x18eControl\
    lerType_OBSOLETE\x18\x11\x20\x01(\r:\x010R\x17eControllerTypeOBSOLETE\
    \x12@\n\x19is_xinput_device_OBSOLETE\x18\x12\x20\x01(\x08:\x05falseR\x16\
    isXinputDeviceOBSOLETE\x12J\n\"session_remote_play_together_appid\x18\
    \x13\x20\x01(\rR\x1esessionRemotePlayTogetherAppid\x121\n\x11is_steamvr_\
    device\x18\x14\x20\x01(\x08:\x05falseR\x0fisSteamvrDevice\"\xb1\x01\n\
    \x15CHIDDeviceInputReport\x12\x1f\n\x0bfull_report\x18\x01\x20\x01(\x0cR\
    \nfullReport\x12!\n\x0cdelta_report\x18\x02\x20\x01(\x0cR\x0bdeltaReport\
    \x12*\n\x11delta_report_size\x18\x03\x20\x01(\rR\x0fdeltaReportSize\x12(\
    \n\x10delta_report_crc\x18\x04\x20\x01(\rR\x0edeltaReportCrc\"\x93\x10\n\
    \x13CHIDMessageToRemote\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\rR\treque\
    stId\x12B\n\x0bdevice_open\x18\x02\x20\x01(\x0b2\x1f.CHIDMessageToRemote\
    .DeviceOpenH\0R\ndeviceOpen\x12E\n\x0cdevice_close\x18\x03\x20\x01(\x0b2\
    \x20.CHIDMessageToRemote.DeviceCloseH\0R\x0bdeviceClose\x12E\n\x0cdevice\
    _write\x18\x04\x20\x01(\x0b2\x20.CHIDMessageToRemote.DeviceWriteH\0R\x0b\
    deviceWrite\x12B\n\x0bdevice_read\x18\x05\x20\x01(\x0b2\x1f.CHIDMessageT\
    oRemote.DeviceReadH\0R\ndeviceRead\x12k\n\x1adevice_send_feature_report\
    \x18\x06\x20\x01(\x0b2,.CHIDMessageToRemote.DeviceSendFeatureReportH\0R\
    \x17deviceSendFeatureReport\x12h\n\x19device_get_feature_report\x18\x07\
    \x20\x01(\x0b2+.CHIDMessageToRemote.DeviceGetFeatureReportH\0R\x16device\
    GetFeatureReport\x12e\n\x18device_get_vendor_string\x18\x08\x20\x01(\x0b\
    2*.CHIDMessageToRemote.DeviceGetVendorStringH\0R\x15deviceGetVendorStrin\
    g\x12h\n\x19device_get_product_string\x18\t\x20\x01(\x0b2+.CHIDMessageTo\
    Remote.DeviceGetProductStringH\0R\x16deviceGetProductString\x12x\n\x1fde\
    vice_get_serial_number_string\x18\n\x20\x01(\x0b20.CHIDMessageToRemote.D\
    eviceGetSerialNumberStringH\0R\x1bdeviceGetSerialNumberString\x12k\n\x1a\
    device_start_input_reports\x18\x0b\x20\x01(\x0b2,.CHIDMessageToRemote.De\
    viceStartInputReportsH\0R\x17deviceStartInputReports\x12k\n\x1adevice_re\
    quest_full_report\x18\x0c\x20\x01(\x0b2,.CHIDMessageToRemote.DeviceReque\
    stFullReportH\0R\x17deviceRequestFullReport\x12T\n\x11device_disconnect\
    \x18\r\x20\x01(\x0b2%.CHIDMessageToRemote.DeviceDisconnectH\0R\x10device\
    Disconnect\x1a1\n\nDeviceOpen\x12#\n\x04info\x18\x01\x20\x01(\x0b2\x0f.C\
    HIDDeviceInfoR\x04info\x1a%\n\x0bDeviceClose\x12\x16\n\x06device\x18\x01\
    \x20\x01(\rR\x06device\x1a9\n\x0bDeviceWrite\x12\x16\n\x06device\x18\x01\
    \x20\x01(\rR\x06device\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\
    \x1a[\n\nDeviceRead\x12\x16\n\x06device\x18\x01\x20\x01(\rR\x06device\
    \x12\x16\n\x06length\x18\x02\x20\x01(\rR\x06length\x12\x1d\n\ntimeout_ms\
    \x18\x03\x20\x01(\x05R\ttimeoutMs\x1aE\n\x17DeviceSendFeatureReport\x12\
    \x16\n\x06device\x18\x01\x20\x01(\rR\x06device\x12\x12\n\x04data\x18\x02\
    \x20\x01(\x0cR\x04data\x1am\n\x16DeviceGetFeatureReport\x12\x16\n\x06dev\
    ice\x18\x01\x20\x01(\rR\x06device\x12#\n\rreport_number\x18\x02\x20\x01(\
    \x0cR\x0creportNumber\x12\x16\n\x06length\x18\x03\x20\x01(\rR\x06length\
    \x1a/\n\x15DeviceGetVendorString\x12\x16\n\x06device\x18\x01\x20\x01(\rR\
    \x06device\x1a0\n\x16DeviceGetProductString\x12\x16\n\x06device\x18\x01\
    \x20\x01(\rR\x06device\x1a5\n\x1bDeviceGetSerialNumberString\x12\x16\n\
    \x06device\x18\x01\x20\x01(\rR\x06device\x1aI\n\x17DeviceStartInputRepor\
    ts\x12\x16\n\x06device\x18\x01\x20\x01(\rR\x06device\x12\x16\n\x06length\
    \x18\x02\x20\x01(\rR\x06length\x1a1\n\x17DeviceRequestFullReport\x12\x16\
    \n\x06device\x18\x01\x20\x01(\rR\x06device\x1a\xa9\x01\n\x10DeviceDiscon\
    nect\x12\x16\n\x06device\x18\x01\x20\x01(\rR\x06device\x12i\n\x10disconn\
    ectMethod\x18\x02\x20\x01(\x0e2\x1b.EHIDDeviceDisconnectMethod:\x20k_EDe\
    viceDisconnectMethodUnknownR\x10disconnectMethod\x12\x12\n\x04data\x18\
    \x03\x20\x01(\x0cR\x04dataB\t\n\x07command\"\xd8\x06\n\x15CHIDMessageFro\
    mRemote\x12W\n\x12update_device_list\x18\x01\x20\x01(\x0b2'.CHIDMessageF\
    romRemote.UpdateDeviceListH\0R\x10updateDeviceList\x12D\n\x08response\
    \x18\x02\x20\x01(\x0b2&.CHIDMessageFromRemote.RequestResponseH\0R\x08res\
    ponse\x12E\n\x07reports\x18\x03\x20\x01(\x0b2).CHIDMessageFromRemote.Dev\
    iceInputReportsH\0R\x07reports\x12G\n\x0cclose_device\x18\x04\x20\x01(\
    \x0b2\".CHIDMessageFromRemote.CloseDeviceH\0R\x0bcloseDevice\x12T\n\x11c\
    lose_all_devices\x18\x05\x20\x01(\x0b2&.CHIDMessageFromRemote.CloseAllDe\
    vicesH\0R\x0fcloseAllDevices\x1a=\n\x10UpdateDeviceList\x12)\n\x07device\
    s\x18\x01\x20\x03(\x0b2\x0f.CHIDDeviceInfoR\x07devices\x1a\\\n\x0fReques\
    tResponse\x12\x1d\n\nrequest_id\x18\x01\x20\x01(\rR\trequestId\x12\x16\n\
    \x06result\x18\x02\x20\x01(\x05R\x06result\x12\x12\n\x04data\x18\x03\x20\
    \x01(\x0cR\x04data\x1a\xd7\x01\n\x12DeviceInputReports\x12b\n\x0edevice_\
    reports\x18\x01\x20\x03(\x0b2;.CHIDMessageFromRemote.DeviceInputReports.\
    DeviceInputReportR\rdeviceReports\x1a]\n\x11DeviceInputReport\x12\x16\n\
    \x06device\x18\x01\x20\x01(\rR\x06device\x120\n\x07reports\x18\x02\x20\
    \x03(\x0b2\x16.CHIDDeviceInputReportR\x07reports\x1a%\n\x0bCloseDevice\
    \x12\x16\n\x06device\x18\x01\x20\x01(\rR\x06device\x1a\x11\n\x0fCloseAll\
    DevicesB\t\n\x07command*g\n\x12EHIDDeviceLocation\x12\x1a\n\x16k_EDevice\
    LocationLocal\x10\0\x12\x1b\n\x17k_EDeviceLocationRemote\x10\x02\x12\x18\
    \n\x14k_EDeviceLocationAny\x10\x03*\xc1\x01\n\x1aEHIDDeviceDisconnectMet\
    hod\x12$\n\x20k_EDeviceDisconnectMethodUnknown\x10\0\x12&\n\"k_EDeviceDi\
    sconnectMethodBluetooth\x10\x01\x12*\n&k_EDeviceDisconnectMethodFeatureR\
    eport\x10\x02\x12)\n%k_EDeviceDisconnectMethodOutputReport\x10\x03B\x05H\
    \x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(22);
            messages.push(CHIDDeviceInfo::generated_message_descriptor_data());
            messages.push(CHIDDeviceInputReport::generated_message_descriptor_data());
            messages.push(CHIDMessageToRemote::generated_message_descriptor_data());
            messages.push(CHIDMessageFromRemote::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceOpen::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceClose::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceWrite::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceRead::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceSendFeatureReport::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceGetFeatureReport::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceGetVendorString::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceGetProductString::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceGetSerialNumberString::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceStartInputReports::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceRequestFullReport::generated_message_descriptor_data());
            messages.push(chidmessage_to_remote::DeviceDisconnect::generated_message_descriptor_data());
            messages.push(chidmessage_from_remote::UpdateDeviceList::generated_message_descriptor_data());
            messages.push(chidmessage_from_remote::RequestResponse::generated_message_descriptor_data());
            messages.push(chidmessage_from_remote::DeviceInputReports::generated_message_descriptor_data());
            messages.push(chidmessage_from_remote::CloseDevice::generated_message_descriptor_data());
            messages.push(chidmessage_from_remote::CloseAllDevices::generated_message_descriptor_data());
            messages.push(chidmessage_from_remote::device_input_reports::DeviceInputReport::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(EHIDDeviceLocation::generated_enum_descriptor_data());
            enums.push(EHIDDeviceDisconnectMethod::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
