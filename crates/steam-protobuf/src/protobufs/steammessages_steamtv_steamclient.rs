// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `steammessages_steamtv.steamclient.proto`

// @@protoc_insertion_point(message:CSteamTV_CreateBroadcastChannel_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_CreateBroadcastChannel_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_CreateBroadcastChannel_Request.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_CreateBroadcastChannel_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_CreateBroadcastChannel_Request {
    fn default() -> &'a CSteamTV_CreateBroadcastChannel_Request {
        <CSteamTV_CreateBroadcastChannel_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_CreateBroadcastChannel_Request {
    pub fn new() -> CSteamTV_CreateBroadcastChannel_Request {
        ::std::default::Default::default()
    }

    // optional string unique_name = 1;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_name",
            |m: &CSteamTV_CreateBroadcastChannel_Request| { &m.unique_name },
            |m: &mut CSteamTV_CreateBroadcastChannel_Request| { &mut m.unique_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_CreateBroadcastChannel_Request>(
            "CSteamTV_CreateBroadcastChannel_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_CreateBroadcastChannel_Request {
    const NAME: &'static str = "CSteamTV_CreateBroadcastChannel_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unique_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_CreateBroadcastChannel_Request {
        CSteamTV_CreateBroadcastChannel_Request::new()
    }

    fn clear(&mut self) {
        self.unique_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_CreateBroadcastChannel_Request {
        static instance: CSteamTV_CreateBroadcastChannel_Request = CSteamTV_CreateBroadcastChannel_Request {
            unique_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_CreateBroadcastChannel_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_CreateBroadcastChannel_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_CreateBroadcastChannel_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_CreateBroadcastChannel_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_CreateBroadcastChannel_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_CreateBroadcastChannel_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_CreateBroadcastChannel_Response.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_CreateBroadcastChannel_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_CreateBroadcastChannel_Response {
    fn default() -> &'a CSteamTV_CreateBroadcastChannel_Response {
        <CSteamTV_CreateBroadcastChannel_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_CreateBroadcastChannel_Response {
    pub fn new() -> CSteamTV_CreateBroadcastChannel_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_CreateBroadcastChannel_Response| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_CreateBroadcastChannel_Response| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_CreateBroadcastChannel_Response>(
            "CSteamTV_CreateBroadcastChannel_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_CreateBroadcastChannel_Response {
    const NAME: &'static str = "CSteamTV_CreateBroadcastChannel_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_CreateBroadcastChannel_Response {
        CSteamTV_CreateBroadcastChannel_Response::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_CreateBroadcastChannel_Response {
        static instance: CSteamTV_CreateBroadcastChannel_Response = CSteamTV_CreateBroadcastChannel_Response {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_CreateBroadcastChannel_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_CreateBroadcastChannel_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_CreateBroadcastChannel_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_CreateBroadcastChannel_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelID_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelID_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelID_Request.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelID_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelID_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelID_Request {
        <CSteamTV_GetBroadcastChannelID_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelID_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelID_Request {
        ::std::default::Default::default()
    }

    // optional string unique_name = 1;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_name",
            |m: &CSteamTV_GetBroadcastChannelID_Request| { &m.unique_name },
            |m: &mut CSteamTV_GetBroadcastChannelID_Request| { &mut m.unique_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelID_Request>(
            "CSteamTV_GetBroadcastChannelID_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelID_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelID_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unique_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelID_Request {
        CSteamTV_GetBroadcastChannelID_Request::new()
    }

    fn clear(&mut self) {
        self.unique_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelID_Request {
        static instance: CSteamTV_GetBroadcastChannelID_Request = CSteamTV_GetBroadcastChannelID_Request {
            unique_name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelID_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelID_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelID_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelID_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelID_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelID_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelID_Response.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelID_Response.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelID_Response.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelID_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelID_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelID_Response {
        <CSteamTV_GetBroadcastChannelID_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelID_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelID_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string unique_name = 2;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetBroadcastChannelID_Response| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetBroadcastChannelID_Response| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_name",
            |m: &CSteamTV_GetBroadcastChannelID_Response| { &m.unique_name },
            |m: &mut CSteamTV_GetBroadcastChannelID_Response| { &mut m.unique_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CSteamTV_GetBroadcastChannelID_Response| { &m.steamid },
            |m: &mut CSteamTV_GetBroadcastChannelID_Response| { &mut m.steamid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelID_Response>(
            "CSteamTV_GetBroadcastChannelID_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelID_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelID_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unique_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelID_Response {
        CSteamTV_GetBroadcastChannelID_Response::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.unique_name = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelID_Response {
        static instance: CSteamTV_GetBroadcastChannelID_Response = CSteamTV_GetBroadcastChannelID_Response {
            broadcast_channel_id: ::std::option::Option::None,
            unique_name: ::std::option::Option::None,
            steamid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelID_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelID_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelID_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelID_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelProfile_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelProfile_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.summary)
    pub summary: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.avatar_hash)
    pub avatar_hash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.schedule)
    pub schedule: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.rules)
    pub rules: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelProfile_Request.panels)
    pub panels: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelProfile_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelProfile_Request {
    fn default() -> &'a CSteamTV_SetBroadcastChannelProfile_Request {
        <CSteamTV_SetBroadcastChannelProfile_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelProfile_Request {
    pub fn new() -> CSteamTV_SetBroadcastChannelProfile_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 3;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string headline = 4;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 5;

    pub fn summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_summary(&mut self) {
        self.summary = ::std::option::Option::None;
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary = ::std::option::Option::Some(::std::string::String::new());
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string avatar_hash = 6;

    pub fn avatar_hash(&self) -> &str {
        match self.avatar_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_hash(&mut self) {
        self.avatar_hash = ::std::option::Option::None;
    }

    pub fn has_avatar_hash(&self) -> bool {
        self.avatar_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_hash(&mut self, v: ::std::string::String) {
        self.avatar_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_hash(&mut self) -> &mut ::std::string::String {
        if self.avatar_hash.is_none() {
            self.avatar_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_hash(&mut self) -> ::std::string::String {
        self.avatar_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string schedule = 7;

    pub fn schedule(&self) -> &str {
        match self.schedule.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_schedule(&mut self) {
        self.schedule = ::std::option::Option::None;
    }

    pub fn has_schedule(&self) -> bool {
        self.schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule(&mut self, v: ::std::string::String) {
        self.schedule = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedule(&mut self) -> &mut ::std::string::String {
        if self.schedule.is_none() {
            self.schedule = ::std::option::Option::Some(::std::string::String::new());
        }
        self.schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedule(&mut self) -> ::std::string::String {
        self.schedule.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rules = 8;

    pub fn rules(&self) -> &str {
        match self.rules.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rules(&mut self) {
        self.rules = ::std::option::Option::None;
    }

    pub fn has_rules(&self) -> bool {
        self.rules.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::string::String) {
        self.rules = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rules(&mut self) -> &mut ::std::string::String {
        if self.rules.is_none() {
            self.rules = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rules.as_mut().unwrap()
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::string::String {
        self.rules.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string panels = 9;

    pub fn panels(&self) -> &str {
        match self.panels.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_panels(&mut self) {
        self.panels = ::std::option::Option::None;
    }

    pub fn has_panels(&self) -> bool {
        self.panels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_panels(&mut self, v: ::std::string::String) {
        self.panels = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_panels(&mut self) -> &mut ::std::string::String {
        if self.panels.is_none() {
            self.panels = ::std::option::Option::Some(::std::string::String::new());
        }
        self.panels.as_mut().unwrap()
    }

    // Take field
    pub fn take_panels(&mut self) -> ::std::string::String {
        self.panels.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_SetBroadcastChannelProfile_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_SetBroadcastChannelProfile_Request| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSteamTV_SetBroadcastChannelProfile_Request| { &m.name },
            |m: &mut CSteamTV_SetBroadcastChannelProfile_Request| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CSteamTV_SetBroadcastChannelProfile_Request| { &m.language },
            |m: &mut CSteamTV_SetBroadcastChannelProfile_Request| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "headline",
            |m: &CSteamTV_SetBroadcastChannelProfile_Request| { &m.headline },
            |m: &mut CSteamTV_SetBroadcastChannelProfile_Request| { &mut m.headline },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "summary",
            |m: &CSteamTV_SetBroadcastChannelProfile_Request| { &m.summary },
            |m: &mut CSteamTV_SetBroadcastChannelProfile_Request| { &mut m.summary },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_hash",
            |m: &CSteamTV_SetBroadcastChannelProfile_Request| { &m.avatar_hash },
            |m: &mut CSteamTV_SetBroadcastChannelProfile_Request| { &mut m.avatar_hash },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "schedule",
            |m: &CSteamTV_SetBroadcastChannelProfile_Request| { &m.schedule },
            |m: &mut CSteamTV_SetBroadcastChannelProfile_Request| { &mut m.schedule },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rules",
            |m: &CSteamTV_SetBroadcastChannelProfile_Request| { &m.rules },
            |m: &mut CSteamTV_SetBroadcastChannelProfile_Request| { &mut m.rules },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "panels",
            |m: &CSteamTV_SetBroadcastChannelProfile_Request| { &m.panels },
            |m: &mut CSteamTV_SetBroadcastChannelProfile_Request| { &mut m.panels },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SetBroadcastChannelProfile_Request>(
            "CSteamTV_SetBroadcastChannelProfile_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SetBroadcastChannelProfile_Request {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelProfile_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.summary = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.avatar_hash = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.schedule = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.rules = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.panels = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.summary.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.avatar_hash.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.schedule.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.rules.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.panels.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.summary.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.avatar_hash.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.schedule.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.rules.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.panels.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelProfile_Request {
        CSteamTV_SetBroadcastChannelProfile_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.summary = ::std::option::Option::None;
        self.avatar_hash = ::std::option::Option::None;
        self.schedule = ::std::option::Option::None;
        self.rules = ::std::option::Option::None;
        self.panels = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelProfile_Request {
        static instance: CSteamTV_SetBroadcastChannelProfile_Request = CSteamTV_SetBroadcastChannelProfile_Request {
            broadcast_channel_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            language: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            summary: ::std::option::Option::None,
            avatar_hash: ::std::option::Option::None,
            schedule: ::std::option::Option::None,
            rules: ::std::option::Option::None,
            panels: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SetBroadcastChannelProfile_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SetBroadcastChannelProfile_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SetBroadcastChannelProfile_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SetBroadcastChannelProfile_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelProfile_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelProfile_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelProfile_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelProfile_Response {
    fn default() -> &'a CSteamTV_SetBroadcastChannelProfile_Response {
        <CSteamTV_SetBroadcastChannelProfile_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelProfile_Response {
    pub fn new() -> CSteamTV_SetBroadcastChannelProfile_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SetBroadcastChannelProfile_Response>(
            "CSteamTV_SetBroadcastChannelProfile_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SetBroadcastChannelProfile_Response {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelProfile_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelProfile_Response {
        CSteamTV_SetBroadcastChannelProfile_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelProfile_Response {
        static instance: CSteamTV_SetBroadcastChannelProfile_Response = CSteamTV_SetBroadcastChannelProfile_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SetBroadcastChannelProfile_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SetBroadcastChannelProfile_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SetBroadcastChannelProfile_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SetBroadcastChannelProfile_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelProfile_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelProfile_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelProfile_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelProfile_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelProfile_Request {
        <CSteamTV_GetBroadcastChannelProfile_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelProfile_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelProfile_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetBroadcastChannelProfile_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelProfile_Request>(
            "CSteamTV_GetBroadcastChannelProfile_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelProfile_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelProfile_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelProfile_Request {
        CSteamTV_GetBroadcastChannelProfile_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelProfile_Request {
        static instance: CSteamTV_GetBroadcastChannelProfile_Request = CSteamTV_GetBroadcastChannelProfile_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelProfile_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelProfile_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelProfile_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelProfile_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelProfile_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelProfile_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.owner_steamid)
    pub owner_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.summary)
    pub summary: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.schedule)
    pub schedule: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.rules)
    pub rules: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.panels)
    pub panels: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelProfile_Response.is_partnered)
    pub is_partnered: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelProfile_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelProfile_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelProfile_Response {
        <CSteamTV_GetBroadcastChannelProfile_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelProfile_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelProfile_Response {
        ::std::default::Default::default()
    }

    // optional string unique_name = 1;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 owner_steamid = 2;

    pub fn owner_steamid(&self) -> u64 {
        self.owner_steamid.unwrap_or(0)
    }

    pub fn clear_owner_steamid(&mut self) {
        self.owner_steamid = ::std::option::Option::None;
    }

    pub fn has_owner_steamid(&self) -> bool {
        self.owner_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steamid(&mut self, v: u64) {
        self.owner_steamid = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language = 4;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string headline = 5;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 6;

    pub fn summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_summary(&mut self) {
        self.summary = ::std::option::Option::None;
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary = ::std::option::Option::Some(::std::string::String::new());
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string schedule = 7;

    pub fn schedule(&self) -> &str {
        match self.schedule.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_schedule(&mut self) {
        self.schedule = ::std::option::Option::None;
    }

    pub fn has_schedule(&self) -> bool {
        self.schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule(&mut self, v: ::std::string::String) {
        self.schedule = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedule(&mut self) -> &mut ::std::string::String {
        if self.schedule.is_none() {
            self.schedule = ::std::option::Option::Some(::std::string::String::new());
        }
        self.schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedule(&mut self) -> ::std::string::String {
        self.schedule.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string rules = 8;

    pub fn rules(&self) -> &str {
        match self.rules.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rules(&mut self) {
        self.rules = ::std::option::Option::None;
    }

    pub fn has_rules(&self) -> bool {
        self.rules.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::std::string::String) {
        self.rules = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rules(&mut self) -> &mut ::std::string::String {
        if self.rules.is_none() {
            self.rules = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rules.as_mut().unwrap()
    }

    // Take field
    pub fn take_rules(&mut self) -> ::std::string::String {
        self.rules.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string panels = 9;

    pub fn panels(&self) -> &str {
        match self.panels.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_panels(&mut self) {
        self.panels = ::std::option::Option::None;
    }

    pub fn has_panels(&self) -> bool {
        self.panels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_panels(&mut self, v: ::std::string::String) {
        self.panels = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_panels(&mut self) -> &mut ::std::string::String {
        if self.panels.is_none() {
            self.panels = ::std::option::Option::Some(::std::string::String::new());
        }
        self.panels.as_mut().unwrap()
    }

    // Take field
    pub fn take_panels(&mut self) -> ::std::string::String {
        self.panels.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_partnered = 10;

    pub fn is_partnered(&self) -> bool {
        self.is_partnered.unwrap_or(false)
    }

    pub fn clear_is_partnered(&mut self) {
        self.is_partnered = ::std::option::Option::None;
    }

    pub fn has_is_partnered(&self) -> bool {
        self.is_partnered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_partnered(&mut self, v: bool) {
        self.is_partnered = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_name",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.unique_name },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.unique_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "owner_steamid",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.owner_steamid },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.owner_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.name },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.language },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "headline",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.headline },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.headline },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "summary",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.summary },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.summary },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "schedule",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.schedule },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.schedule },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "rules",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.rules },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.rules },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "panels",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.panels },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.panels },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_partnered",
            |m: &CSteamTV_GetBroadcastChannelProfile_Response| { &m.is_partnered },
            |m: &mut CSteamTV_GetBroadcastChannelProfile_Response| { &mut m.is_partnered },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelProfile_Response>(
            "CSteamTV_GetBroadcastChannelProfile_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelProfile_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelProfile_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                17 => {
                    self.owner_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.summary = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.schedule = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.rules = ::std::option::Option::Some(is.read_string()?);
                },
                74 => {
                    self.panels = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.is_partnered = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.unique_name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.owner_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        if let Some(v) = self.summary.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.schedule.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.rules.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.panels.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        if let Some(v) = self.is_partnered {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.owner_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.summary.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.schedule.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.rules.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.panels.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.is_partnered {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelProfile_Response {
        CSteamTV_GetBroadcastChannelProfile_Response::new()
    }

    fn clear(&mut self) {
        self.unique_name = ::std::option::Option::None;
        self.owner_steamid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.summary = ::std::option::Option::None;
        self.schedule = ::std::option::Option::None;
        self.rules = ::std::option::Option::None;
        self.panels = ::std::option::Option::None;
        self.is_partnered = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelProfile_Response {
        static instance: CSteamTV_GetBroadcastChannelProfile_Response = CSteamTV_GetBroadcastChannelProfile_Response {
            unique_name: ::std::option::Option::None,
            owner_steamid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            language: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            summary: ::std::option::Option::None,
            schedule: ::std::option::Option::None,
            rules: ::std::option::Option::None,
            panels: ::std::option::Option::None,
            is_partnered: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelProfile_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelProfile_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelProfile_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelProfile_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelImage_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelImage_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.image_type)
    pub image_type: ::std::option::Option<crate::EnumOrUnknown<EBroadcastImageType>>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.image_index)
    pub image_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.image_width)
    pub image_width: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.image_height)
    pub image_height: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.file_extension)
    pub file_extension: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.file_hash)
    pub file_hash: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelImage_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelImage_Request {
    fn default() -> &'a CSteamTV_SetBroadcastChannelImage_Request {
        <CSteamTV_SetBroadcastChannelImage_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelImage_Request {
    pub fn new() -> CSteamTV_SetBroadcastChannelImage_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional .EBroadcastImageType image_type = 2;

    pub fn image_type(&self) -> EBroadcastImageType {
        match self.image_type {
            Some(e) => e.enum_value_or(EBroadcastImageType::k_EBroadcastImageType_None),
            None => EBroadcastImageType::k_EBroadcastImageType_None,
        }
    }

    pub fn clear_image_type(&mut self) {
        self.image_type = ::std::option::Option::None;
    }

    pub fn has_image_type(&self) -> bool {
        self.image_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_type(&mut self, v: EBroadcastImageType) {
        self.image_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 image_index = 3;

    pub fn image_index(&self) -> u32 {
        self.image_index.unwrap_or(0)
    }

    pub fn clear_image_index(&mut self) {
        self.image_index = ::std::option::Option::None;
    }

    pub fn has_image_index(&self) -> bool {
        self.image_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_index(&mut self, v: u32) {
        self.image_index = ::std::option::Option::Some(v);
    }

    // optional uint32 image_width = 4;

    pub fn image_width(&self) -> u32 {
        self.image_width.unwrap_or(0)
    }

    pub fn clear_image_width(&mut self) {
        self.image_width = ::std::option::Option::None;
    }

    pub fn has_image_width(&self) -> bool {
        self.image_width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_width(&mut self, v: u32) {
        self.image_width = ::std::option::Option::Some(v);
    }

    // optional uint32 image_height = 5;

    pub fn image_height(&self) -> u32 {
        self.image_height.unwrap_or(0)
    }

    pub fn clear_image_height(&mut self) {
        self.image_height = ::std::option::Option::None;
    }

    pub fn has_image_height(&self) -> bool {
        self.image_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image_height(&mut self, v: u32) {
        self.image_height = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 6;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional string file_extension = 7;

    pub fn file_extension(&self) -> &str {
        match self.file_extension.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_extension(&mut self) {
        self.file_extension = ::std::option::Option::None;
    }

    pub fn has_file_extension(&self) -> bool {
        self.file_extension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_extension(&mut self, v: ::std::string::String) {
        self.file_extension = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_extension(&mut self) -> &mut ::std::string::String {
        if self.file_extension.is_none() {
            self.file_extension = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_extension.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_extension(&mut self) -> ::std::string::String {
        self.file_extension.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file_hash = 8;

    pub fn file_hash(&self) -> &str {
        match self.file_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_hash(&mut self) {
        self.file_hash = ::std::option::Option::None;
    }

    pub fn has_file_hash(&self) -> bool {
        self.file_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_hash(&mut self, v: ::std::string::String) {
        self.file_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_hash(&mut self) -> &mut ::std::string::String {
        if self.file_hash.is_none() {
            self.file_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_hash(&mut self) -> ::std::string::String {
        self.file_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool undo = 9;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_SetBroadcastChannelImage_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Request| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_type",
            |m: &CSteamTV_SetBroadcastChannelImage_Request| { &m.image_type },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Request| { &mut m.image_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_index",
            |m: &CSteamTV_SetBroadcastChannelImage_Request| { &m.image_index },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Request| { &mut m.image_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_width",
            |m: &CSteamTV_SetBroadcastChannelImage_Request| { &m.image_width },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Request| { &mut m.image_width },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image_height",
            |m: &CSteamTV_SetBroadcastChannelImage_Request| { &m.image_height },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Request| { &mut m.image_height },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_size",
            |m: &CSteamTV_SetBroadcastChannelImage_Request| { &m.file_size },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Request| { &mut m.file_size },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_extension",
            |m: &CSteamTV_SetBroadcastChannelImage_Request| { &m.file_extension },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Request| { &mut m.file_extension },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_hash",
            |m: &CSteamTV_SetBroadcastChannelImage_Request| { &m.file_hash },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Request| { &mut m.file_hash },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "undo",
            |m: &CSteamTV_SetBroadcastChannelImage_Request| { &m.undo },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Request| { &mut m.undo },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SetBroadcastChannelImage_Request>(
            "CSteamTV_SetBroadcastChannelImage_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SetBroadcastChannelImage_Request {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelImage_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.image_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.image_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.image_width = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.image_height = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.file_extension = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.file_hash = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.image_type {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.image_index {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.image_width {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.image_height {
            my_size += crate::rt::uint32_size(5, v);
        }
        if let Some(v) = self.file_size {
            my_size += crate::rt::uint32_size(6, v);
        }
        if let Some(v) = self.file_extension.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.file_hash.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.image_type {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.image_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.image_width {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.image_height {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.file_extension.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.file_hash.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelImage_Request {
        CSteamTV_SetBroadcastChannelImage_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.image_type = ::std::option::Option::None;
        self.image_index = ::std::option::Option::None;
        self.image_width = ::std::option::Option::None;
        self.image_height = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.file_extension = ::std::option::Option::None;
        self.file_hash = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelImage_Request {
        static instance: CSteamTV_SetBroadcastChannelImage_Request = CSteamTV_SetBroadcastChannelImage_Request {
            broadcast_channel_id: ::std::option::Option::None,
            image_type: ::std::option::Option::None,
            image_index: ::std::option::Option::None,
            image_width: ::std::option::Option::None,
            image_height: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            file_extension: ::std::option::Option::None,
            file_hash: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SetBroadcastChannelImage_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SetBroadcastChannelImage_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SetBroadcastChannelImage_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SetBroadcastChannelImage_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelImage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelImage_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelImage_Response.replace_image_hash)
    pub replace_image_hash: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelImage_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelImage_Response {
    fn default() -> &'a CSteamTV_SetBroadcastChannelImage_Response {
        <CSteamTV_SetBroadcastChannelImage_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelImage_Response {
    pub fn new() -> CSteamTV_SetBroadcastChannelImage_Response {
        ::std::default::Default::default()
    }

    // optional string replace_image_hash = 1;

    pub fn replace_image_hash(&self) -> &str {
        match self.replace_image_hash.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_replace_image_hash(&mut self) {
        self.replace_image_hash = ::std::option::Option::None;
    }

    pub fn has_replace_image_hash(&self) -> bool {
        self.replace_image_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replace_image_hash(&mut self, v: ::std::string::String) {
        self.replace_image_hash = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_replace_image_hash(&mut self) -> &mut ::std::string::String {
        if self.replace_image_hash.is_none() {
            self.replace_image_hash = ::std::option::Option::Some(::std::string::String::new());
        }
        self.replace_image_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_replace_image_hash(&mut self) -> ::std::string::String {
        self.replace_image_hash.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "replace_image_hash",
            |m: &CSteamTV_SetBroadcastChannelImage_Response| { &m.replace_image_hash },
            |m: &mut CSteamTV_SetBroadcastChannelImage_Response| { &mut m.replace_image_hash },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SetBroadcastChannelImage_Response>(
            "CSteamTV_SetBroadcastChannelImage_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SetBroadcastChannelImage_Response {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelImage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.replace_image_hash = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.replace_image_hash.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.replace_image_hash.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelImage_Response {
        CSteamTV_SetBroadcastChannelImage_Response::new()
    }

    fn clear(&mut self) {
        self.replace_image_hash = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelImage_Response {
        static instance: CSteamTV_SetBroadcastChannelImage_Response = CSteamTV_SetBroadcastChannelImage_Response {
            replace_image_hash: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SetBroadcastChannelImage_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SetBroadcastChannelImage_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SetBroadcastChannelImage_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SetBroadcastChannelImage_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelImages_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelImages_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Request.image_types)
    pub image_types: ::std::vec::Vec<crate::EnumOrUnknown<EBroadcastImageType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelImages_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelImages_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelImages_Request {
        <CSteamTV_GetBroadcastChannelImages_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelImages_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelImages_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // repeated .EBroadcastImageType image_types = 2;

    pub fn image_types(&self) -> &[crate::EnumOrUnknown<EBroadcastImageType>] {
        &self.image_types
    }

    pub fn clear_image_types(&mut self) {
        self.image_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_types(&mut self, v: ::std::vec::Vec<crate::EnumOrUnknown<EBroadcastImageType>>) {
        self.image_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_image_types(&mut self) -> &mut ::std::vec::Vec<crate::EnumOrUnknown<EBroadcastImageType>> {
        &mut self.image_types
    }

    // Take field
    pub fn take_image_types(&mut self) -> ::std::vec::Vec<crate::EnumOrUnknown<EBroadcastImageType>> {
        ::std::mem::replace(&mut self.image_types, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetBroadcastChannelImages_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetBroadcastChannelImages_Request| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "image_types",
            |m: &CSteamTV_GetBroadcastChannelImages_Request| { &m.image_types },
            |m: &mut CSteamTV_GetBroadcastChannelImages_Request| { &mut m.image_types },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelImages_Request>(
            "CSteamTV_GetBroadcastChannelImages_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelImages_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelImages_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.image_types.push(is.read_enum_or_unknown()?);
                },
                18 => {
                    crate::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.image_types)?
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        for value in &self.image_types {
            my_size += crate::rt::int32_size(2, value.value());
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        for v in &self.image_types {
            os.write_enum(2, crate::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelImages_Request {
        CSteamTV_GetBroadcastChannelImages_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.image_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelImages_Request {
        static instance: CSteamTV_GetBroadcastChannelImages_Request = CSteamTV_GetBroadcastChannelImages_Request {
            broadcast_channel_id: ::std::option::Option::None,
            image_types: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelImages_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelImages_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelImages_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelImages_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelImages_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelImages_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Response.images)
    pub images: ::std::vec::Vec<csteam_tv_get_broadcast_channel_images_response::Images>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelImages_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelImages_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelImages_Response {
        <CSteamTV_GetBroadcastChannelImages_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelImages_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelImages_Response {
        ::std::default::Default::default()
    }

    // repeated .CSteamTV_GetBroadcastChannelImages_Response.Images images = 1;

    pub fn images(&self) -> &[csteam_tv_get_broadcast_channel_images_response::Images] {
        &self.images
    }

    pub fn clear_images(&mut self) {
        self.images.clear();
    }

    // Param is passed by value, moved
    pub fn set_images(&mut self, v: ::std::vec::Vec<csteam_tv_get_broadcast_channel_images_response::Images>) {
        self.images = v;
    }

    // Mutable pointer to the field.
    pub fn mut_images(&mut self) -> &mut ::std::vec::Vec<csteam_tv_get_broadcast_channel_images_response::Images> {
        &mut self.images
    }

    // Take field
    pub fn take_images(&mut self) -> ::std::vec::Vec<csteam_tv_get_broadcast_channel_images_response::Images> {
        ::std::mem::replace(&mut self.images, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "images",
            |m: &CSteamTV_GetBroadcastChannelImages_Response| { &m.images },
            |m: &mut CSteamTV_GetBroadcastChannelImages_Response| { &mut m.images },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelImages_Response>(
            "CSteamTV_GetBroadcastChannelImages_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelImages_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelImages_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.images.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.images {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.images {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelImages_Response {
        CSteamTV_GetBroadcastChannelImages_Response::new()
    }

    fn clear(&mut self) {
        self.images.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelImages_Response {
        static instance: CSteamTV_GetBroadcastChannelImages_Response = CSteamTV_GetBroadcastChannelImages_Response {
            images: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelImages_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelImages_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelImages_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelImages_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSteamTV_GetBroadcastChannelImages_Response`
pub mod csteam_tv_get_broadcast_channel_images_response {
    // @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelImages_Response.Images)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Images {
        // message fields
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Response.Images.image_type)
        pub image_type: ::std::option::Option<crate::EnumOrUnknown<super::EBroadcastImageType>>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Response.Images.image_path)
        pub image_path: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelImages_Response.Images.image_index)
        pub image_index: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelImages_Response.Images.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Images {
        fn default() -> &'a Images {
            <Images as crate::Message>::default_instance()
        }
    }

    impl Images {
        pub fn new() -> Images {
            ::std::default::Default::default()
        }

        // optional .EBroadcastImageType image_type = 1;

        pub fn image_type(&self) -> super::EBroadcastImageType {
            match self.image_type {
                Some(e) => e.enum_value_or(super::EBroadcastImageType::k_EBroadcastImageType_None),
                None => super::EBroadcastImageType::k_EBroadcastImageType_None,
            }
        }

        pub fn clear_image_type(&mut self) {
            self.image_type = ::std::option::Option::None;
        }

        pub fn has_image_type(&self) -> bool {
            self.image_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_type(&mut self, v: super::EBroadcastImageType) {
            self.image_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
        }

        // optional string image_path = 2;

        pub fn image_path(&self) -> &str {
            match self.image_path.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_image_path(&mut self) {
            self.image_path = ::std::option::Option::None;
        }

        pub fn has_image_path(&self) -> bool {
            self.image_path.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_path(&mut self, v: ::std::string::String) {
            self.image_path = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_image_path(&mut self) -> &mut ::std::string::String {
            if self.image_path.is_none() {
                self.image_path = ::std::option::Option::Some(::std::string::String::new());
            }
            self.image_path.as_mut().unwrap()
        }

        // Take field
        pub fn take_image_path(&mut self) -> ::std::string::String {
            self.image_path.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 image_index = 3;

        pub fn image_index(&self) -> u32 {
            self.image_index.unwrap_or(0)
        }

        pub fn clear_image_index(&mut self) {
            self.image_index = ::std::option::Option::None;
        }

        pub fn has_image_index(&self) -> bool {
            self.image_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_image_index(&mut self, v: u32) {
            self.image_index = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_type",
                |m: &Images| { &m.image_type },
                |m: &mut Images| { &mut m.image_type },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_path",
                |m: &Images| { &m.image_path },
                |m: &mut Images| { &mut m.image_path },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "image_index",
                |m: &Images| { &m.image_index },
                |m: &mut Images| { &mut m.image_index },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Images>(
                "CSteamTV_GetBroadcastChannelImages_Response.Images",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Images {
        const NAME: &'static str = "Images";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.image_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.image_path = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.image_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.image_type {
                my_size += crate::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.image_path.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.image_index {
                my_size += crate::rt::uint32_size(3, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.image_type {
                os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.image_path.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.image_index {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Images {
            Images::new()
        }

        fn clear(&mut self) {
            self.image_type = ::std::option::Option::None;
            self.image_path = ::std::option::Option::None;
            self.image_index = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Images {
            static instance: Images = Images {
                image_type: ::std::option::Option::None,
                image_path: ::std::option::Option::None,
                image_index: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Images {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelImages_Response.Images").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Images {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Images {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelLinkRegions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelLinkRegions_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.links)
    pub links: ::std::vec::Vec<csteam_tv_set_broadcast_channel_link_regions_request::Links>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelLinkRegions_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelLinkRegions_Request {
    fn default() -> &'a CSteamTV_SetBroadcastChannelLinkRegions_Request {
        <CSteamTV_SetBroadcastChannelLinkRegions_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelLinkRegions_Request {
    pub fn new() -> CSteamTV_SetBroadcastChannelLinkRegions_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // repeated .CSteamTV_SetBroadcastChannelLinkRegions_Request.Links links = 2;

    pub fn links(&self) -> &[csteam_tv_set_broadcast_channel_link_regions_request::Links] {
        &self.links
    }

    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::std::vec::Vec<csteam_tv_set_broadcast_channel_link_regions_request::Links>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::std::vec::Vec<csteam_tv_set_broadcast_channel_link_regions_request::Links> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::std::vec::Vec<csteam_tv_set_broadcast_channel_link_regions_request::Links> {
        ::std::mem::replace(&mut self.links, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_SetBroadcastChannelLinkRegions_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_SetBroadcastChannelLinkRegions_Request| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "links",
            |m: &CSteamTV_SetBroadcastChannelLinkRegions_Request| { &m.links },
            |m: &mut CSteamTV_SetBroadcastChannelLinkRegions_Request| { &mut m.links },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SetBroadcastChannelLinkRegions_Request>(
            "CSteamTV_SetBroadcastChannelLinkRegions_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SetBroadcastChannelLinkRegions_Request {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelLinkRegions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.links.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        for v in &self.links {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelLinkRegions_Request {
        CSteamTV_SetBroadcastChannelLinkRegions_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelLinkRegions_Request {
        static instance: CSteamTV_SetBroadcastChannelLinkRegions_Request = CSteamTV_SetBroadcastChannelLinkRegions_Request {
            broadcast_channel_id: ::std::option::Option::None,
            links: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SetBroadcastChannelLinkRegions_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SetBroadcastChannelLinkRegions_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SetBroadcastChannelLinkRegions_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SetBroadcastChannelLinkRegions_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSteamTV_SetBroadcastChannelLinkRegions_Request`
pub mod csteam_tv_set_broadcast_channel_link_regions_request {
    // @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Links {
        // message fields
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_index)
        pub link_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.url)
        pub url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_description)
        pub link_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.left)
        pub left: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.top)
        pub top: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.width)
        pub width: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.height)
        pub height: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Links {
        fn default() -> &'a Links {
            <Links as crate::Message>::default_instance()
        }
    }

    impl Links {
        pub fn new() -> Links {
            ::std::default::Default::default()
        }

        // optional uint32 link_index = 1;

        pub fn link_index(&self) -> u32 {
            self.link_index.unwrap_or(0)
        }

        pub fn clear_link_index(&mut self) {
            self.link_index = ::std::option::Option::None;
        }

        pub fn has_link_index(&self) -> bool {
            self.link_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_link_index(&mut self, v: u32) {
            self.link_index = ::std::option::Option::Some(v);
        }

        // optional string url = 2;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string link_description = 3;

        pub fn link_description(&self) -> &str {
            match self.link_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_link_description(&mut self) {
            self.link_description = ::std::option::Option::None;
        }

        pub fn has_link_description(&self) -> bool {
            self.link_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_link_description(&mut self, v: ::std::string::String) {
            self.link_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_link_description(&mut self) -> &mut ::std::string::String {
            if self.link_description.is_none() {
                self.link_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.link_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_link_description(&mut self) -> ::std::string::String {
            self.link_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 left = 4;

        pub fn left(&self) -> u32 {
            self.left.unwrap_or(0)
        }

        pub fn clear_left(&mut self) {
            self.left = ::std::option::Option::None;
        }

        pub fn has_left(&self) -> bool {
            self.left.is_some()
        }

        // Param is passed by value, moved
        pub fn set_left(&mut self, v: u32) {
            self.left = ::std::option::Option::Some(v);
        }

        // optional uint32 top = 5;

        pub fn top(&self) -> u32 {
            self.top.unwrap_or(0)
        }

        pub fn clear_top(&mut self) {
            self.top = ::std::option::Option::None;
        }

        pub fn has_top(&self) -> bool {
            self.top.is_some()
        }

        // Param is passed by value, moved
        pub fn set_top(&mut self, v: u32) {
            self.top = ::std::option::Option::Some(v);
        }

        // optional uint32 width = 6;

        pub fn width(&self) -> u32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: u32) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional uint32 height = 7;

        pub fn height(&self) -> u32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: u32) {
            self.height = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "link_index",
                |m: &Links| { &m.link_index },
                |m: &mut Links| { &mut m.link_index },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "url",
                |m: &Links| { &m.url },
                |m: &mut Links| { &mut m.url },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "link_description",
                |m: &Links| { &m.link_description },
                |m: &mut Links| { &mut m.link_description },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "left",
                |m: &Links| { &m.left },
                |m: &mut Links| { &mut m.left },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "top",
                |m: &Links| { &m.top },
                |m: &mut Links| { &mut m.top },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &Links| { &m.width },
                |m: &mut Links| { &mut m.width },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "height",
                |m: &Links| { &m.height },
                |m: &mut Links| { &mut m.height },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Links>(
                "CSteamTV_SetBroadcastChannelLinkRegions_Request.Links",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Links {
        const NAME: &'static str = "Links";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.link_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.link_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.left = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.top = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.width = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.height = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.link_index {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.url.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.link_description.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.left {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.top {
                my_size += crate::rt::uint32_size(5, v);
            }
            if let Some(v) = self.width {
                my_size += crate::rt::uint32_size(6, v);
            }
            if let Some(v) = self.height {
                my_size += crate::rt::uint32_size(7, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.link_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.link_description.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.left {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.top {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.width {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.height {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Links {
            Links::new()
        }

        fn clear(&mut self) {
            self.link_index = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.link_description = ::std::option::Option::None;
            self.left = ::std::option::Option::None;
            self.top = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Links {
            static instance: Links = Links {
                link_index: ::std::option::Option::None,
                url: ::std::option::Option::None,
                link_description: ::std::option::Option::None,
                left: ::std::option::Option::None,
                top: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Links {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSteamTV_SetBroadcastChannelLinkRegions_Request.Links").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Links {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Links {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSteamTV_SetBroadcastChannelLinkRegions_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetBroadcastChannelLinkRegions_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetBroadcastChannelLinkRegions_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetBroadcastChannelLinkRegions_Response {
    fn default() -> &'a CSteamTV_SetBroadcastChannelLinkRegions_Response {
        <CSteamTV_SetBroadcastChannelLinkRegions_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_SetBroadcastChannelLinkRegions_Response {
    pub fn new() -> CSteamTV_SetBroadcastChannelLinkRegions_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SetBroadcastChannelLinkRegions_Response>(
            "CSteamTV_SetBroadcastChannelLinkRegions_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SetBroadcastChannelLinkRegions_Response {
    const NAME: &'static str = "CSteamTV_SetBroadcastChannelLinkRegions_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetBroadcastChannelLinkRegions_Response {
        CSteamTV_SetBroadcastChannelLinkRegions_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetBroadcastChannelLinkRegions_Response {
        static instance: CSteamTV_SetBroadcastChannelLinkRegions_Response = CSteamTV_SetBroadcastChannelLinkRegions_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SetBroadcastChannelLinkRegions_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SetBroadcastChannelLinkRegions_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SetBroadcastChannelLinkRegions_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SetBroadcastChannelLinkRegions_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelLinks_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelLinks_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelLinks_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelLinks_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelLinks_Request {
        <CSteamTV_GetBroadcastChannelLinks_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelLinks_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelLinks_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetBroadcastChannelLinks_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetBroadcastChannelLinks_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelLinks_Request>(
            "CSteamTV_GetBroadcastChannelLinks_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelLinks_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelLinks_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelLinks_Request {
        CSteamTV_GetBroadcastChannelLinks_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelLinks_Request {
        static instance: CSteamTV_GetBroadcastChannelLinks_Request = CSteamTV_GetBroadcastChannelLinks_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelLinks_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelLinks_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelLinks_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelLinks_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelLinks_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelLinks_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.links)
    pub links: ::std::vec::Vec<csteam_tv_get_broadcast_channel_links_response::Links>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelLinks_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelLinks_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelLinks_Response {
        <CSteamTV_GetBroadcastChannelLinks_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelLinks_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelLinks_Response {
        ::std::default::Default::default()
    }

    // repeated .CSteamTV_GetBroadcastChannelLinks_Response.Links links = 1;

    pub fn links(&self) -> &[csteam_tv_get_broadcast_channel_links_response::Links] {
        &self.links
    }

    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: ::std::vec::Vec<csteam_tv_get_broadcast_channel_links_response::Links>) {
        self.links = v;
    }

    // Mutable pointer to the field.
    pub fn mut_links(&mut self) -> &mut ::std::vec::Vec<csteam_tv_get_broadcast_channel_links_response::Links> {
        &mut self.links
    }

    // Take field
    pub fn take_links(&mut self) -> ::std::vec::Vec<csteam_tv_get_broadcast_channel_links_response::Links> {
        ::std::mem::replace(&mut self.links, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "links",
            |m: &CSteamTV_GetBroadcastChannelLinks_Response| { &m.links },
            |m: &mut CSteamTV_GetBroadcastChannelLinks_Response| { &mut m.links },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelLinks_Response>(
            "CSteamTV_GetBroadcastChannelLinks_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelLinks_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelLinks_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.links.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.links {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.links {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelLinks_Response {
        CSteamTV_GetBroadcastChannelLinks_Response::new()
    }

    fn clear(&mut self) {
        self.links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelLinks_Response {
        static instance: CSteamTV_GetBroadcastChannelLinks_Response = CSteamTV_GetBroadcastChannelLinks_Response {
            links: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelLinks_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelLinks_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelLinks_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelLinks_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSteamTV_GetBroadcastChannelLinks_Response`
pub mod csteam_tv_get_broadcast_channel_links_response {
    // @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelLinks_Response.Links)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Links {
        // message fields
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_index)
        pub link_index: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.url)
        pub url: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_description)
        pub link_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.left)
        pub left: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.top)
        pub top: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.width)
        pub width: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelLinks_Response.Links.height)
        pub height: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelLinks_Response.Links.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Links {
        fn default() -> &'a Links {
            <Links as crate::Message>::default_instance()
        }
    }

    impl Links {
        pub fn new() -> Links {
            ::std::default::Default::default()
        }

        // optional uint32 link_index = 1;

        pub fn link_index(&self) -> u32 {
            self.link_index.unwrap_or(0)
        }

        pub fn clear_link_index(&mut self) {
            self.link_index = ::std::option::Option::None;
        }

        pub fn has_link_index(&self) -> bool {
            self.link_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_link_index(&mut self, v: u32) {
            self.link_index = ::std::option::Option::Some(v);
        }

        // optional string url = 2;

        pub fn url(&self) -> &str {
            match self.url.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_url(&mut self) {
            self.url = ::std::option::Option::None;
        }

        pub fn has_url(&self) -> bool {
            self.url.is_some()
        }

        // Param is passed by value, moved
        pub fn set_url(&mut self, v: ::std::string::String) {
            self.url = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_url(&mut self) -> &mut ::std::string::String {
            if self.url.is_none() {
                self.url = ::std::option::Option::Some(::std::string::String::new());
            }
            self.url.as_mut().unwrap()
        }

        // Take field
        pub fn take_url(&mut self) -> ::std::string::String {
            self.url.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string link_description = 3;

        pub fn link_description(&self) -> &str {
            match self.link_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_link_description(&mut self) {
            self.link_description = ::std::option::Option::None;
        }

        pub fn has_link_description(&self) -> bool {
            self.link_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_link_description(&mut self, v: ::std::string::String) {
            self.link_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_link_description(&mut self) -> &mut ::std::string::String {
            if self.link_description.is_none() {
                self.link_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.link_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_link_description(&mut self) -> ::std::string::String {
            self.link_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 left = 4;

        pub fn left(&self) -> u32 {
            self.left.unwrap_or(0)
        }

        pub fn clear_left(&mut self) {
            self.left = ::std::option::Option::None;
        }

        pub fn has_left(&self) -> bool {
            self.left.is_some()
        }

        // Param is passed by value, moved
        pub fn set_left(&mut self, v: u32) {
            self.left = ::std::option::Option::Some(v);
        }

        // optional uint32 top = 5;

        pub fn top(&self) -> u32 {
            self.top.unwrap_or(0)
        }

        pub fn clear_top(&mut self) {
            self.top = ::std::option::Option::None;
        }

        pub fn has_top(&self) -> bool {
            self.top.is_some()
        }

        // Param is passed by value, moved
        pub fn set_top(&mut self, v: u32) {
            self.top = ::std::option::Option::Some(v);
        }

        // optional uint32 width = 6;

        pub fn width(&self) -> u32 {
            self.width.unwrap_or(0)
        }

        pub fn clear_width(&mut self) {
            self.width = ::std::option::Option::None;
        }

        pub fn has_width(&self) -> bool {
            self.width.is_some()
        }

        // Param is passed by value, moved
        pub fn set_width(&mut self, v: u32) {
            self.width = ::std::option::Option::Some(v);
        }

        // optional uint32 height = 7;

        pub fn height(&self) -> u32 {
            self.height.unwrap_or(0)
        }

        pub fn clear_height(&mut self) {
            self.height = ::std::option::Option::None;
        }

        pub fn has_height(&self) -> bool {
            self.height.is_some()
        }

        // Param is passed by value, moved
        pub fn set_height(&mut self, v: u32) {
            self.height = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "link_index",
                |m: &Links| { &m.link_index },
                |m: &mut Links| { &mut m.link_index },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "url",
                |m: &Links| { &m.url },
                |m: &mut Links| { &mut m.url },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "link_description",
                |m: &Links| { &m.link_description },
                |m: &mut Links| { &mut m.link_description },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "left",
                |m: &Links| { &m.left },
                |m: &mut Links| { &mut m.left },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "top",
                |m: &Links| { &m.top },
                |m: &mut Links| { &mut m.top },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "width",
                |m: &Links| { &m.width },
                |m: &mut Links| { &mut m.width },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "height",
                |m: &Links| { &m.height },
                |m: &mut Links| { &mut m.height },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Links>(
                "CSteamTV_GetBroadcastChannelLinks_Response.Links",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Links {
        const NAME: &'static str = "Links";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.link_index = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.url = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.link_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.left = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.top = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.width = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.height = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.link_index {
                my_size += crate::rt::uint32_size(1, v);
            }
            if let Some(v) = self.url.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.link_description.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.left {
                my_size += crate::rt::uint32_size(4, v);
            }
            if let Some(v) = self.top {
                my_size += crate::rt::uint32_size(5, v);
            }
            if let Some(v) = self.width {
                my_size += crate::rt::uint32_size(6, v);
            }
            if let Some(v) = self.height {
                my_size += crate::rt::uint32_size(7, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.link_index {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.url.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.link_description.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.left {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.top {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.width {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.height {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Links {
            Links::new()
        }

        fn clear(&mut self) {
            self.link_index = ::std::option::Option::None;
            self.url = ::std::option::Option::None;
            self.link_description = ::std::option::Option::None;
            self.left = ::std::option::Option::None;
            self.top = ::std::option::Option::None;
            self.width = ::std::option::Option::None;
            self.height = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Links {
            static instance: Links = Links {
                link_index: ::std::option::Option::None,
                url: ::std::option::Option::None,
                link_description: ::std::option::Option::None,
                left: ::std::option::Option::None,
                top: ::std::option::Option::None,
                width: ::std::option::Option::None,
                height: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Links {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelLinks_Response.Links").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Links {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Links {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelBroadcasters_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelBroadcasters_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelBroadcasters_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelBroadcasters_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelBroadcasters_Request {
        <CSteamTV_GetBroadcastChannelBroadcasters_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelBroadcasters_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelBroadcasters_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetBroadcastChannelBroadcasters_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetBroadcastChannelBroadcasters_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelBroadcasters_Request>(
            "CSteamTV_GetBroadcastChannelBroadcasters_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelBroadcasters_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelBroadcasters_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelBroadcasters_Request {
        CSteamTV_GetBroadcastChannelBroadcasters_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelBroadcasters_Request {
        static instance: CSteamTV_GetBroadcastChannelBroadcasters_Request = CSteamTV_GetBroadcastChannelBroadcasters_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelBroadcasters_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelBroadcasters_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelBroadcasters_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelBroadcasters_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelBroadcasters_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelBroadcasters_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Response.broadcasters)
    pub broadcasters: ::std::vec::Vec<csteam_tv_get_broadcast_channel_broadcasters_response::Broadcaster>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelBroadcasters_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelBroadcasters_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelBroadcasters_Response {
        <CSteamTV_GetBroadcastChannelBroadcasters_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelBroadcasters_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelBroadcasters_Response {
        ::std::default::Default::default()
    }

    // repeated .CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster broadcasters = 1;

    pub fn broadcasters(&self) -> &[csteam_tv_get_broadcast_channel_broadcasters_response::Broadcaster] {
        &self.broadcasters
    }

    pub fn clear_broadcasters(&mut self) {
        self.broadcasters.clear();
    }

    // Param is passed by value, moved
    pub fn set_broadcasters(&mut self, v: ::std::vec::Vec<csteam_tv_get_broadcast_channel_broadcasters_response::Broadcaster>) {
        self.broadcasters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_broadcasters(&mut self) -> &mut ::std::vec::Vec<csteam_tv_get_broadcast_channel_broadcasters_response::Broadcaster> {
        &mut self.broadcasters
    }

    // Take field
    pub fn take_broadcasters(&mut self) -> ::std::vec::Vec<csteam_tv_get_broadcast_channel_broadcasters_response::Broadcaster> {
        ::std::mem::replace(&mut self.broadcasters, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcasters",
            |m: &CSteamTV_GetBroadcastChannelBroadcasters_Response| { &m.broadcasters },
            |m: &mut CSteamTV_GetBroadcastChannelBroadcasters_Response| { &mut m.broadcasters },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelBroadcasters_Response>(
            "CSteamTV_GetBroadcastChannelBroadcasters_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelBroadcasters_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelBroadcasters_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasters.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasters {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.broadcasters {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelBroadcasters_Response {
        CSteamTV_GetBroadcastChannelBroadcasters_Response::new()
    }

    fn clear(&mut self) {
        self.broadcasters.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelBroadcasters_Response {
        static instance: CSteamTV_GetBroadcastChannelBroadcasters_Response = CSteamTV_GetBroadcastChannelBroadcasters_Response {
            broadcasters: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelBroadcasters_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelBroadcasters_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelBroadcasters_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelBroadcasters_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSteamTV_GetBroadcastChannelBroadcasters_Response`
pub mod csteam_tv_get_broadcast_channel_broadcasters_response {
    // @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Broadcaster {
        // message fields
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.steamid)
        pub steamid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.rtmp_token)
        pub rtmp_token: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Broadcaster {
        fn default() -> &'a Broadcaster {
            <Broadcaster as crate::Message>::default_instance()
        }
    }

    impl Broadcaster {
        pub fn new() -> Broadcaster {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 1;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string rtmp_token = 3;

        pub fn rtmp_token(&self) -> &str {
            match self.rtmp_token.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rtmp_token(&mut self) {
            self.rtmp_token = ::std::option::Option::None;
        }

        pub fn has_rtmp_token(&self) -> bool {
            self.rtmp_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rtmp_token(&mut self, v: ::std::string::String) {
            self.rtmp_token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rtmp_token(&mut self) -> &mut ::std::string::String {
            if self.rtmp_token.is_none() {
                self.rtmp_token = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rtmp_token.as_mut().unwrap()
        }

        // Take field
        pub fn take_rtmp_token(&mut self) -> ::std::string::String {
            self.rtmp_token.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "steamid",
                |m: &Broadcaster| { &m.steamid },
                |m: &mut Broadcaster| { &mut m.steamid },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Broadcaster| { &m.name },
                |m: &mut Broadcaster| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "rtmp_token",
                |m: &Broadcaster| { &m.rtmp_token },
                |m: &mut Broadcaster| { &mut m.rtmp_token },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Broadcaster>(
                "CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Broadcaster {
        const NAME: &'static str = "Broadcaster";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.rtmp_token = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.rtmp_token.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.rtmp_token.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Broadcaster {
            Broadcaster::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.rtmp_token = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Broadcaster {
            static instance: Broadcaster = Broadcaster {
                steamid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                rtmp_token: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Broadcaster {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Broadcaster {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Broadcaster {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:CSteamTV_GetFollowedChannels_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetFollowedChannels_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetFollowedChannels_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetFollowedChannels_Request {
    fn default() -> &'a CSteamTV_GetFollowedChannels_Request {
        <CSteamTV_GetFollowedChannels_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetFollowedChannels_Request {
    pub fn new() -> CSteamTV_GetFollowedChannels_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetFollowedChannels_Request>(
            "CSteamTV_GetFollowedChannels_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetFollowedChannels_Request {
    const NAME: &'static str = "CSteamTV_GetFollowedChannels_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetFollowedChannels_Request {
        CSteamTV_GetFollowedChannels_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetFollowedChannels_Request {
        static instance: CSteamTV_GetFollowedChannels_Request = CSteamTV_GetFollowedChannels_Request {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetFollowedChannels_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetFollowedChannels_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetFollowedChannels_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetFollowedChannels_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetBroadcastChannelEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetBroadcastChannelEntry {
    // message fields
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.viewers)
    pub viewers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.views)
    pub views: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.thumbnail_url)
    pub thumbnail_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.followers)
    pub followers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.headline)
    pub headline: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.avatar_url)
    pub avatar_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.subscribers)
    pub subscribers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.background_url)
    pub background_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.is_featured)
    pub is_featured: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.is_disabled)
    pub is_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.is_live)
    pub is_live: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.language)
    pub language: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.reports)
    pub reports: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GetBroadcastChannelEntry.is_partnered)
    pub is_partnered: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:GetBroadcastChannelEntry.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetBroadcastChannelEntry {
    fn default() -> &'a GetBroadcastChannelEntry {
        <GetBroadcastChannelEntry as crate::Message>::default_instance()
    }
}

impl GetBroadcastChannelEntry {
    pub fn new() -> GetBroadcastChannelEntry {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string unique_name = 2;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 appid = 4;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 viewers = 5;

    pub fn viewers(&self) -> u64 {
        self.viewers.unwrap_or(0)
    }

    pub fn clear_viewers(&mut self) {
        self.viewers = ::std::option::Option::None;
    }

    pub fn has_viewers(&self) -> bool {
        self.viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers(&mut self, v: u64) {
        self.viewers = ::std::option::Option::Some(v);
    }

    // optional uint64 views = 6;

    pub fn views(&self) -> u64 {
        self.views.unwrap_or(0)
    }

    pub fn clear_views(&mut self) {
        self.views = ::std::option::Option::None;
    }

    pub fn has_views(&self) -> bool {
        self.views.is_some()
    }

    // Param is passed by value, moved
    pub fn set_views(&mut self, v: u64) {
        self.views = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_url = 7;

    pub fn thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url = ::std::option::Option::None;
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 followers = 8;

    pub fn followers(&self) -> u64 {
        self.followers.unwrap_or(0)
    }

    pub fn clear_followers(&mut self) {
        self.followers = ::std::option::Option::None;
    }

    pub fn has_followers(&self) -> bool {
        self.followers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_followers(&mut self, v: u64) {
        self.followers = ::std::option::Option::Some(v);
    }

    // optional string headline = 9;

    pub fn headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_headline(&mut self) {
        self.headline = ::std::option::Option::None;
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline = ::std::option::Option::Some(::std::string::String::new());
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string avatar_url = 10;

    pub fn avatar_url(&self) -> &str {
        match self.avatar_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_avatar_url(&mut self) {
        self.avatar_url = ::std::option::Option::None;
    }

    pub fn has_avatar_url(&self) -> bool {
        self.avatar_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_url(&mut self, v: ::std::string::String) {
        self.avatar_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_url(&mut self) -> &mut ::std::string::String {
        if self.avatar_url.is_none() {
            self.avatar_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.avatar_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_url(&mut self) -> ::std::string::String {
        self.avatar_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 broadcaster_steamid = 11;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 subscribers = 12;

    pub fn subscribers(&self) -> u64 {
        self.subscribers.unwrap_or(0)
    }

    pub fn clear_subscribers(&mut self) {
        self.subscribers = ::std::option::Option::None;
    }

    pub fn has_subscribers(&self) -> bool {
        self.subscribers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribers(&mut self, v: u64) {
        self.subscribers = ::std::option::Option::Some(v);
    }

    // optional string background_url = 13;

    pub fn background_url(&self) -> &str {
        match self.background_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_background_url(&mut self) {
        self.background_url = ::std::option::Option::None;
    }

    pub fn has_background_url(&self) -> bool {
        self.background_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_background_url(&mut self, v: ::std::string::String) {
        self.background_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_background_url(&mut self) -> &mut ::std::string::String {
        if self.background_url.is_none() {
            self.background_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.background_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_background_url(&mut self) -> ::std::string::String {
        self.background_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_featured = 14;

    pub fn is_featured(&self) -> bool {
        self.is_featured.unwrap_or(false)
    }

    pub fn clear_is_featured(&mut self) {
        self.is_featured = ::std::option::Option::None;
    }

    pub fn has_is_featured(&self) -> bool {
        self.is_featured.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_featured(&mut self, v: bool) {
        self.is_featured = ::std::option::Option::Some(v);
    }

    // optional bool is_disabled = 15;

    pub fn is_disabled(&self) -> bool {
        self.is_disabled.unwrap_or(false)
    }

    pub fn clear_is_disabled(&mut self) {
        self.is_disabled = ::std::option::Option::None;
    }

    pub fn has_is_disabled(&self) -> bool {
        self.is_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_disabled(&mut self, v: bool) {
        self.is_disabled = ::std::option::Option::Some(v);
    }

    // optional bool is_live = 16;

    pub fn is_live(&self) -> bool {
        self.is_live.unwrap_or(false)
    }

    pub fn clear_is_live(&mut self) {
        self.is_live = ::std::option::Option::None;
    }

    pub fn has_is_live(&self) -> bool {
        self.is_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_live(&mut self, v: bool) {
        self.is_live = ::std::option::Option::Some(v);
    }

    // optional string language = 17;

    pub fn language(&self) -> &str {
        match self.language.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: ::std::string::String) {
        self.language = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language(&mut self) -> &mut ::std::string::String {
        if self.language.is_none() {
            self.language = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language.as_mut().unwrap()
    }

    // Take field
    pub fn take_language(&mut self) -> ::std::string::String {
        self.language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 reports = 18;

    pub fn reports(&self) -> u32 {
        self.reports.unwrap_or(0)
    }

    pub fn clear_reports(&mut self) {
        self.reports = ::std::option::Option::None;
    }

    pub fn has_reports(&self) -> bool {
        self.reports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reports(&mut self, v: u32) {
        self.reports = ::std::option::Option::Some(v);
    }

    // optional bool is_partnered = 19;

    pub fn is_partnered(&self) -> bool {
        self.is_partnered.unwrap_or(false)
    }

    pub fn clear_is_partnered(&mut self) {
        self.is_partnered = ::std::option::Option::None;
    }

    pub fn has_is_partnered(&self) -> bool {
        self.is_partnered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_partnered(&mut self, v: bool) {
        self.is_partnered = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &GetBroadcastChannelEntry| { &m.broadcast_channel_id },
            |m: &mut GetBroadcastChannelEntry| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_name",
            |m: &GetBroadcastChannelEntry| { &m.unique_name },
            |m: &mut GetBroadcastChannelEntry| { &mut m.unique_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &GetBroadcastChannelEntry| { &m.name },
            |m: &mut GetBroadcastChannelEntry| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &GetBroadcastChannelEntry| { &m.appid },
            |m: &mut GetBroadcastChannelEntry| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewers",
            |m: &GetBroadcastChannelEntry| { &m.viewers },
            |m: &mut GetBroadcastChannelEntry| { &mut m.viewers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "views",
            |m: &GetBroadcastChannelEntry| { &m.views },
            |m: &mut GetBroadcastChannelEntry| { &mut m.views },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnail_url",
            |m: &GetBroadcastChannelEntry| { &m.thumbnail_url },
            |m: &mut GetBroadcastChannelEntry| { &mut m.thumbnail_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "followers",
            |m: &GetBroadcastChannelEntry| { &m.followers },
            |m: &mut GetBroadcastChannelEntry| { &mut m.followers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "headline",
            |m: &GetBroadcastChannelEntry| { &m.headline },
            |m: &mut GetBroadcastChannelEntry| { &mut m.headline },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "avatar_url",
            |m: &GetBroadcastChannelEntry| { &m.avatar_url },
            |m: &mut GetBroadcastChannelEntry| { &mut m.avatar_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcaster_steamid",
            |m: &GetBroadcastChannelEntry| { &m.broadcaster_steamid },
            |m: &mut GetBroadcastChannelEntry| { &mut m.broadcaster_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscribers",
            |m: &GetBroadcastChannelEntry| { &m.subscribers },
            |m: &mut GetBroadcastChannelEntry| { &mut m.subscribers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "background_url",
            |m: &GetBroadcastChannelEntry| { &m.background_url },
            |m: &mut GetBroadcastChannelEntry| { &mut m.background_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_featured",
            |m: &GetBroadcastChannelEntry| { &m.is_featured },
            |m: &mut GetBroadcastChannelEntry| { &mut m.is_featured },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_disabled",
            |m: &GetBroadcastChannelEntry| { &m.is_disabled },
            |m: &mut GetBroadcastChannelEntry| { &mut m.is_disabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_live",
            |m: &GetBroadcastChannelEntry| { &m.is_live },
            |m: &mut GetBroadcastChannelEntry| { &mut m.is_live },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "language",
            |m: &GetBroadcastChannelEntry| { &m.language },
            |m: &mut GetBroadcastChannelEntry| { &mut m.language },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reports",
            |m: &GetBroadcastChannelEntry| { &m.reports },
            |m: &mut GetBroadcastChannelEntry| { &mut m.reports },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_partnered",
            |m: &GetBroadcastChannelEntry| { &m.is_partnered },
            |m: &mut GetBroadcastChannelEntry| { &mut m.is_partnered },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<GetBroadcastChannelEntry>(
            "GetBroadcastChannelEntry",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for GetBroadcastChannelEntry {
    const NAME: &'static str = "GetBroadcastChannelEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.viewers = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.views = ::std::option::Option::Some(is.read_uint64()?);
                },
                58 => {
                    self.thumbnail_url = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.followers = ::std::option::Option::Some(is.read_uint64()?);
                },
                74 => {
                    self.headline = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.avatar_url = ::std::option::Option::Some(is.read_string()?);
                },
                89 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                96 => {
                    self.subscribers = ::std::option::Option::Some(is.read_uint64()?);
                },
                106 => {
                    self.background_url = ::std::option::Option::Some(is.read_string()?);
                },
                112 => {
                    self.is_featured = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.is_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.is_live = ::std::option::Option::Some(is.read_bool()?);
                },
                138 => {
                    self.language = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.reports = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.is_partnered = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.unique_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(4, v);
        }
        if let Some(v) = self.viewers {
            my_size += crate::rt::uint64_size(5, v);
        }
        if let Some(v) = self.views {
            my_size += crate::rt::uint64_size(6, v);
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.followers {
            my_size += crate::rt::uint64_size(8, v);
        }
        if let Some(v) = self.headline.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        if let Some(v) = self.avatar_url.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.subscribers {
            my_size += crate::rt::uint64_size(12, v);
        }
        if let Some(v) = self.background_url.as_ref() {
            my_size += crate::rt::string_size(13, &v);
        }
        if let Some(v) = self.is_featured {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_live {
            my_size += 2 + 1;
        }
        if let Some(v) = self.language.as_ref() {
            my_size += crate::rt::string_size(17, &v);
        }
        if let Some(v) = self.reports {
            my_size += crate::rt::uint32_size(18, v);
        }
        if let Some(v) = self.is_partnered {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.viewers {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.views {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.followers {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.headline.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.avatar_url.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.subscribers {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.background_url.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.is_featured {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.is_disabled {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.is_live {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.language.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.reports {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.is_partnered {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetBroadcastChannelEntry {
        GetBroadcastChannelEntry::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.unique_name = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.viewers = ::std::option::Option::None;
        self.views = ::std::option::Option::None;
        self.thumbnail_url = ::std::option::Option::None;
        self.followers = ::std::option::Option::None;
        self.headline = ::std::option::Option::None;
        self.avatar_url = ::std::option::Option::None;
        self.broadcaster_steamid = ::std::option::Option::None;
        self.subscribers = ::std::option::Option::None;
        self.background_url = ::std::option::Option::None;
        self.is_featured = ::std::option::Option::None;
        self.is_disabled = ::std::option::Option::None;
        self.is_live = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.reports = ::std::option::Option::None;
        self.is_partnered = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetBroadcastChannelEntry {
        static instance: GetBroadcastChannelEntry = GetBroadcastChannelEntry {
            broadcast_channel_id: ::std::option::Option::None,
            unique_name: ::std::option::Option::None,
            name: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            viewers: ::std::option::Option::None,
            views: ::std::option::Option::None,
            thumbnail_url: ::std::option::Option::None,
            followers: ::std::option::Option::None,
            headline: ::std::option::Option::None,
            avatar_url: ::std::option::Option::None,
            broadcaster_steamid: ::std::option::Option::None,
            subscribers: ::std::option::Option::None,
            background_url: ::std::option::Option::None,
            is_featured: ::std::option::Option::None,
            is_disabled: ::std::option::Option::None,
            is_live: ::std::option::Option::None,
            language: ::std::option::Option::None,
            reports: ::std::option::Option::None,
            is_partnered: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for GetBroadcastChannelEntry {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetBroadcastChannelEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetBroadcastChannelEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for GetBroadcastChannelEntry {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetFollowedChannels_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetFollowedChannels_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetFollowedChannels_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetFollowedChannels_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetFollowedChannels_Response {
    fn default() -> &'a CSteamTV_GetFollowedChannels_Response {
        <CSteamTV_GetFollowedChannels_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetFollowedChannels_Response {
    pub fn new() -> CSteamTV_GetFollowedChannels_Response {
        ::std::default::Default::default()
    }

    // repeated .GetBroadcastChannelEntry results = 1;

    pub fn results(&self) -> &[GetBroadcastChannelEntry] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CSteamTV_GetFollowedChannels_Response| { &m.results },
            |m: &mut CSteamTV_GetFollowedChannels_Response| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetFollowedChannels_Response>(
            "CSteamTV_GetFollowedChannels_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetFollowedChannels_Response {
    const NAME: &'static str = "CSteamTV_GetFollowedChannels_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.results {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetFollowedChannels_Response {
        CSteamTV_GetFollowedChannels_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetFollowedChannels_Response {
        static instance: CSteamTV_GetFollowedChannels_Response = CSteamTV_GetFollowedChannels_Response {
            results: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetFollowedChannels_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetFollowedChannels_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetFollowedChannels_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetFollowedChannels_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetSubscribedChannels_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetSubscribedChannels_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetSubscribedChannels_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetSubscribedChannels_Request {
    fn default() -> &'a CSteamTV_GetSubscribedChannels_Request {
        <CSteamTV_GetSubscribedChannels_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetSubscribedChannels_Request {
    pub fn new() -> CSteamTV_GetSubscribedChannels_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetSubscribedChannels_Request>(
            "CSteamTV_GetSubscribedChannels_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetSubscribedChannels_Request {
    const NAME: &'static str = "CSteamTV_GetSubscribedChannels_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetSubscribedChannels_Request {
        CSteamTV_GetSubscribedChannels_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetSubscribedChannels_Request {
        static instance: CSteamTV_GetSubscribedChannels_Request = CSteamTV_GetSubscribedChannels_Request {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetSubscribedChannels_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetSubscribedChannels_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetSubscribedChannels_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetSubscribedChannels_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetSubscribedChannels_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetSubscribedChannels_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetSubscribedChannels_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetSubscribedChannels_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetSubscribedChannels_Response {
    fn default() -> &'a CSteamTV_GetSubscribedChannels_Response {
        <CSteamTV_GetSubscribedChannels_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetSubscribedChannels_Response {
    pub fn new() -> CSteamTV_GetSubscribedChannels_Response {
        ::std::default::Default::default()
    }

    // repeated .GetBroadcastChannelEntry results = 1;

    pub fn results(&self) -> &[GetBroadcastChannelEntry] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CSteamTV_GetSubscribedChannels_Response| { &m.results },
            |m: &mut CSteamTV_GetSubscribedChannels_Response| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetSubscribedChannels_Response>(
            "CSteamTV_GetSubscribedChannels_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetSubscribedChannels_Response {
    const NAME: &'static str = "CSteamTV_GetSubscribedChannels_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.results {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetSubscribedChannels_Response {
        CSteamTV_GetSubscribedChannels_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetSubscribedChannels_Response {
        static instance: CSteamTV_GetSubscribedChannels_Response = CSteamTV_GetSubscribedChannels_Response {
            results: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetSubscribedChannels_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetSubscribedChannels_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetSubscribedChannels_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetSubscribedChannels_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelStatus_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelStatus_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelStatus_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelStatus_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelStatus_Request {
        <CSteamTV_GetBroadcastChannelStatus_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelStatus_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelStatus_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetBroadcastChannelStatus_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelStatus_Request>(
            "CSteamTV_GetBroadcastChannelStatus_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelStatus_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelStatus_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelStatus_Request {
        CSteamTV_GetBroadcastChannelStatus_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelStatus_Request {
        static instance: CSteamTV_GetBroadcastChannelStatus_Request = CSteamTV_GetBroadcastChannelStatus_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelStatus_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelStatus_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelStatus_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelStatus_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelStatus_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelStatus_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.is_live)
    pub is_live: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.is_disabled)
    pub is_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.viewers)
    pub viewers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.views)
    pub views: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.thumbnail_url)
    pub thumbnail_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.followers)
    pub followers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.subscribers)
    pub subscribers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.unique_name)
    pub unique_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelStatus_Response.broadcast_session_id)
    pub broadcast_session_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelStatus_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelStatus_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelStatus_Response {
        <CSteamTV_GetBroadcastChannelStatus_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelStatus_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelStatus_Response {
        ::std::default::Default::default()
    }

    // optional bool is_live = 1;

    pub fn is_live(&self) -> bool {
        self.is_live.unwrap_or(false)
    }

    pub fn clear_is_live(&mut self) {
        self.is_live = ::std::option::Option::None;
    }

    pub fn has_is_live(&self) -> bool {
        self.is_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_live(&mut self, v: bool) {
        self.is_live = ::std::option::Option::Some(v);
    }

    // optional bool is_disabled = 2;

    pub fn is_disabled(&self) -> bool {
        self.is_disabled.unwrap_or(false)
    }

    pub fn clear_is_disabled(&mut self) {
        self.is_disabled = ::std::option::Option::None;
    }

    pub fn has_is_disabled(&self) -> bool {
        self.is_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_disabled(&mut self, v: bool) {
        self.is_disabled = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 3;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 viewers = 4;

    pub fn viewers(&self) -> u64 {
        self.viewers.unwrap_or(0)
    }

    pub fn clear_viewers(&mut self) {
        self.viewers = ::std::option::Option::None;
    }

    pub fn has_viewers(&self) -> bool {
        self.viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers(&mut self, v: u64) {
        self.viewers = ::std::option::Option::Some(v);
    }

    // optional uint64 views = 5;

    pub fn views(&self) -> u64 {
        self.views.unwrap_or(0)
    }

    pub fn clear_views(&mut self) {
        self.views = ::std::option::Option::None;
    }

    pub fn has_views(&self) -> bool {
        self.views.is_some()
    }

    // Param is passed by value, moved
    pub fn set_views(&mut self, v: u64) {
        self.views = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcaster_steamid = 6;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_url = 7;

    pub fn thumbnail_url(&self) -> &str {
        match self.thumbnail_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_url(&mut self) {
        self.thumbnail_url = ::std::option::Option::None;
    }

    pub fn has_thumbnail_url(&self) -> bool {
        self.thumbnail_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_url(&mut self, v: ::std::string::String) {
        self.thumbnail_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_url(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_url.is_none() {
            self.thumbnail_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_url(&mut self) -> ::std::string::String {
        self.thumbnail_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 followers = 8;

    pub fn followers(&self) -> u64 {
        self.followers.unwrap_or(0)
    }

    pub fn clear_followers(&mut self) {
        self.followers = ::std::option::Option::None;
    }

    pub fn has_followers(&self) -> bool {
        self.followers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_followers(&mut self, v: u64) {
        self.followers = ::std::option::Option::Some(v);
    }

    // optional uint64 subscribers = 9;

    pub fn subscribers(&self) -> u64 {
        self.subscribers.unwrap_or(0)
    }

    pub fn clear_subscribers(&mut self) {
        self.subscribers = ::std::option::Option::None;
    }

    pub fn has_subscribers(&self) -> bool {
        self.subscribers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribers(&mut self, v: u64) {
        self.subscribers = ::std::option::Option::Some(v);
    }

    // optional string unique_name = 10;

    pub fn unique_name(&self) -> &str {
        match self.unique_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_unique_name(&mut self) {
        self.unique_name = ::std::option::Option::None;
    }

    pub fn has_unique_name(&self) -> bool {
        self.unique_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_name(&mut self, v: ::std::string::String) {
        self.unique_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unique_name(&mut self) -> &mut ::std::string::String {
        if self.unique_name.is_none() {
            self.unique_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.unique_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_unique_name(&mut self) -> ::std::string::String {
        self.unique_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 broadcast_session_id = 11;

    pub fn broadcast_session_id(&self) -> u64 {
        self.broadcast_session_id.unwrap_or(0)
    }

    pub fn clear_broadcast_session_id(&mut self) {
        self.broadcast_session_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_session_id(&self) -> bool {
        self.broadcast_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_session_id(&mut self, v: u64) {
        self.broadcast_session_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_live",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.is_live },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.is_live },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_disabled",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.is_disabled },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.is_disabled },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.appid },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewers",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.viewers },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.viewers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "views",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.views },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.views },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcaster_steamid",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.broadcaster_steamid },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.broadcaster_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnail_url",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.thumbnail_url },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.thumbnail_url },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "followers",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.followers },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.followers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscribers",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.subscribers },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.subscribers },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "unique_name",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.unique_name },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.unique_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_session_id",
            |m: &CSteamTV_GetBroadcastChannelStatus_Response| { &m.broadcast_session_id },
            |m: &mut CSteamTV_GetBroadcastChannelStatus_Response| { &mut m.broadcast_session_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelStatus_Response>(
            "CSteamTV_GetBroadcastChannelStatus_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelStatus_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelStatus_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_live = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.is_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.viewers = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.views = ::std::option::Option::Some(is.read_uint64()?);
                },
                49 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                58 => {
                    self.thumbnail_url = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.followers = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.subscribers = ::std::option::Option::Some(is.read_uint64()?);
                },
                82 => {
                    self.unique_name = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.broadcast_session_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_live {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_disabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.viewers {
            my_size += crate::rt::uint64_size(4, v);
        }
        if let Some(v) = self.views {
            my_size += crate::rt::uint64_size(5, v);
        }
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.followers {
            my_size += crate::rt::uint64_size(8, v);
        }
        if let Some(v) = self.subscribers {
            my_size += crate::rt::uint64_size(9, v);
        }
        if let Some(v) = self.unique_name.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        if let Some(v) = self.broadcast_session_id {
            my_size += crate::rt::uint64_size(11, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.is_live {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.is_disabled {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.viewers {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.views {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.thumbnail_url.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.followers {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.subscribers {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.unique_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.broadcast_session_id {
            os.write_uint64(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelStatus_Response {
        CSteamTV_GetBroadcastChannelStatus_Response::new()
    }

    fn clear(&mut self) {
        self.is_live = ::std::option::Option::None;
        self.is_disabled = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.viewers = ::std::option::Option::None;
        self.views = ::std::option::Option::None;
        self.broadcaster_steamid = ::std::option::Option::None;
        self.thumbnail_url = ::std::option::Option::None;
        self.followers = ::std::option::Option::None;
        self.subscribers = ::std::option::Option::None;
        self.unique_name = ::std::option::Option::None;
        self.broadcast_session_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelStatus_Response {
        static instance: CSteamTV_GetBroadcastChannelStatus_Response = CSteamTV_GetBroadcastChannelStatus_Response {
            is_live: ::std::option::Option::None,
            is_disabled: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            viewers: ::std::option::Option::None,
            views: ::std::option::Option::None,
            broadcaster_steamid: ::std::option::Option::None,
            thumbnail_url: ::std::option::Option::None,
            followers: ::std::option::Option::None,
            subscribers: ::std::option::Option::None,
            unique_name: ::std::option::Option::None,
            broadcast_session_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelStatus_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelStatus_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelStatus_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelStatus_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_FollowBroadcastChannel_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_FollowBroadcastChannel_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_FollowBroadcastChannel_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_FollowBroadcastChannel_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_FollowBroadcastChannel_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_FollowBroadcastChannel_Request {
    fn default() -> &'a CSteamTV_FollowBroadcastChannel_Request {
        <CSteamTV_FollowBroadcastChannel_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_FollowBroadcastChannel_Request {
    pub fn new() -> CSteamTV_FollowBroadcastChannel_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional bool undo = 2;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_FollowBroadcastChannel_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_FollowBroadcastChannel_Request| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "undo",
            |m: &CSteamTV_FollowBroadcastChannel_Request| { &m.undo },
            |m: &mut CSteamTV_FollowBroadcastChannel_Request| { &mut m.undo },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_FollowBroadcastChannel_Request>(
            "CSteamTV_FollowBroadcastChannel_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_FollowBroadcastChannel_Request {
    const NAME: &'static str = "CSteamTV_FollowBroadcastChannel_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_FollowBroadcastChannel_Request {
        CSteamTV_FollowBroadcastChannel_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_FollowBroadcastChannel_Request {
        static instance: CSteamTV_FollowBroadcastChannel_Request = CSteamTV_FollowBroadcastChannel_Request {
            broadcast_channel_id: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_FollowBroadcastChannel_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_FollowBroadcastChannel_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_FollowBroadcastChannel_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_FollowBroadcastChannel_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_FollowBroadcastChannel_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_FollowBroadcastChannel_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_FollowBroadcastChannel_Response.is_followed)
    pub is_followed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_FollowBroadcastChannel_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_FollowBroadcastChannel_Response {
    fn default() -> &'a CSteamTV_FollowBroadcastChannel_Response {
        <CSteamTV_FollowBroadcastChannel_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_FollowBroadcastChannel_Response {
    pub fn new() -> CSteamTV_FollowBroadcastChannel_Response {
        ::std::default::Default::default()
    }

    // optional bool is_followed = 1;

    pub fn is_followed(&self) -> bool {
        self.is_followed.unwrap_or(false)
    }

    pub fn clear_is_followed(&mut self) {
        self.is_followed = ::std::option::Option::None;
    }

    pub fn has_is_followed(&self) -> bool {
        self.is_followed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_followed(&mut self, v: bool) {
        self.is_followed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_followed",
            |m: &CSteamTV_FollowBroadcastChannel_Response| { &m.is_followed },
            |m: &mut CSteamTV_FollowBroadcastChannel_Response| { &mut m.is_followed },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_FollowBroadcastChannel_Response>(
            "CSteamTV_FollowBroadcastChannel_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_FollowBroadcastChannel_Response {
    const NAME: &'static str = "CSteamTV_FollowBroadcastChannel_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_followed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_followed {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.is_followed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_FollowBroadcastChannel_Response {
        CSteamTV_FollowBroadcastChannel_Response::new()
    }

    fn clear(&mut self) {
        self.is_followed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_FollowBroadcastChannel_Response {
        static instance: CSteamTV_FollowBroadcastChannel_Response = CSteamTV_FollowBroadcastChannel_Response {
            is_followed: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_FollowBroadcastChannel_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_FollowBroadcastChannel_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_FollowBroadcastChannel_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_FollowBroadcastChannel_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_SubscribeBroadcastChannel_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SubscribeBroadcastChannel_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SubscribeBroadcastChannel_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SubscribeBroadcastChannel_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SubscribeBroadcastChannel_Request {
    fn default() -> &'a CSteamTV_SubscribeBroadcastChannel_Request {
        <CSteamTV_SubscribeBroadcastChannel_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_SubscribeBroadcastChannel_Request {
    pub fn new() -> CSteamTV_SubscribeBroadcastChannel_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_SubscribeBroadcastChannel_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_SubscribeBroadcastChannel_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SubscribeBroadcastChannel_Request>(
            "CSteamTV_SubscribeBroadcastChannel_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SubscribeBroadcastChannel_Request {
    const NAME: &'static str = "CSteamTV_SubscribeBroadcastChannel_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SubscribeBroadcastChannel_Request {
        CSteamTV_SubscribeBroadcastChannel_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SubscribeBroadcastChannel_Request {
        static instance: CSteamTV_SubscribeBroadcastChannel_Request = CSteamTV_SubscribeBroadcastChannel_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SubscribeBroadcastChannel_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SubscribeBroadcastChannel_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SubscribeBroadcastChannel_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SubscribeBroadcastChannel_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_SubscribeBroadcastChannel_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SubscribeBroadcastChannel_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SubscribeBroadcastChannel_Response.is_subscribed)
    pub is_subscribed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SubscribeBroadcastChannel_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SubscribeBroadcastChannel_Response {
    fn default() -> &'a CSteamTV_SubscribeBroadcastChannel_Response {
        <CSteamTV_SubscribeBroadcastChannel_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_SubscribeBroadcastChannel_Response {
    pub fn new() -> CSteamTV_SubscribeBroadcastChannel_Response {
        ::std::default::Default::default()
    }

    // optional bool is_subscribed = 1;

    pub fn is_subscribed(&self) -> bool {
        self.is_subscribed.unwrap_or(false)
    }

    pub fn clear_is_subscribed(&mut self) {
        self.is_subscribed = ::std::option::Option::None;
    }

    pub fn has_is_subscribed(&self) -> bool {
        self.is_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_subscribed(&mut self, v: bool) {
        self.is_subscribed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_subscribed",
            |m: &CSteamTV_SubscribeBroadcastChannel_Response| { &m.is_subscribed },
            |m: &mut CSteamTV_SubscribeBroadcastChannel_Response| { &mut m.is_subscribed },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SubscribeBroadcastChannel_Response>(
            "CSteamTV_SubscribeBroadcastChannel_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SubscribeBroadcastChannel_Response {
    const NAME: &'static str = "CSteamTV_SubscribeBroadcastChannel_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_subscribed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_subscribed {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.is_subscribed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SubscribeBroadcastChannel_Response {
        CSteamTV_SubscribeBroadcastChannel_Response::new()
    }

    fn clear(&mut self) {
        self.is_subscribed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SubscribeBroadcastChannel_Response {
        static instance: CSteamTV_SubscribeBroadcastChannel_Response = CSteamTV_SubscribeBroadcastChannel_Response {
            is_subscribed: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SubscribeBroadcastChannel_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SubscribeBroadcastChannel_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SubscribeBroadcastChannel_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SubscribeBroadcastChannel_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelClips_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelClips_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelClips_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelClips_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelClips_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelClips_Request {
        <CSteamTV_GetBroadcastChannelClips_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelClips_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelClips_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetBroadcastChannelClips_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetBroadcastChannelClips_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelClips_Request>(
            "CSteamTV_GetBroadcastChannelClips_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelClips_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelClips_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelClips_Request {
        CSteamTV_GetBroadcastChannelClips_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelClips_Request {
        static instance: CSteamTV_GetBroadcastChannelClips_Request = CSteamTV_GetBroadcastChannelClips_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelClips_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelClips_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelClips_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelClips_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_BroadcastClipInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_BroadcastClipInfo {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.broadcast_clip_id)
    pub broadcast_clip_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.channel_id)
    pub channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.broadcaster_steamid)
    pub broadcaster_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.creator_steamid)
    pub creator_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.video_description)
    pub video_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.live_time)
    pub live_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.length_ms)
    pub length_ms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_BroadcastClipInfo.thumbnail_path)
    pub thumbnail_path: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_BroadcastClipInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_BroadcastClipInfo {
    fn default() -> &'a CSteamTV_BroadcastClipInfo {
        <CSteamTV_BroadcastClipInfo as crate::Message>::default_instance()
    }
}

impl CSteamTV_BroadcastClipInfo {
    pub fn new() -> CSteamTV_BroadcastClipInfo {
        ::std::default::Default::default()
    }

    // optional uint64 broadcast_clip_id = 1;

    pub fn broadcast_clip_id(&self) -> u64 {
        self.broadcast_clip_id.unwrap_or(0)
    }

    pub fn clear_broadcast_clip_id(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_clip_id(&self) -> bool {
        self.broadcast_clip_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_clip_id(&mut self, v: u64) {
        self.broadcast_clip_id = ::std::option::Option::Some(v);
    }

    // optional uint64 channel_id = 2;

    pub fn channel_id(&self) -> u64 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u64) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional uint32 app_id = 3;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 broadcaster_steamid = 4;

    pub fn broadcaster_steamid(&self) -> u64 {
        self.broadcaster_steamid.unwrap_or(0)
    }

    pub fn clear_broadcaster_steamid(&mut self) {
        self.broadcaster_steamid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_steamid(&self) -> bool {
        self.broadcaster_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_steamid(&mut self, v: u64) {
        self.broadcaster_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator_steamid = 5;

    pub fn creator_steamid(&self) -> u64 {
        self.creator_steamid.unwrap_or(0)
    }

    pub fn clear_creator_steamid(&mut self) {
        self.creator_steamid = ::std::option::Option::None;
    }

    pub fn has_creator_steamid(&self) -> bool {
        self.creator_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_steamid(&mut self, v: u64) {
        self.creator_steamid = ::std::option::Option::Some(v);
    }

    // optional string video_description = 6;

    pub fn video_description(&self) -> &str {
        match self.video_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_video_description(&mut self) {
        self.video_description = ::std::option::Option::None;
    }

    pub fn has_video_description(&self) -> bool {
        self.video_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_description(&mut self, v: ::std::string::String) {
        self.video_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_description(&mut self) -> &mut ::std::string::String {
        if self.video_description.is_none() {
            self.video_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.video_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_description(&mut self) -> ::std::string::String {
        self.video_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 live_time = 7;

    pub fn live_time(&self) -> u32 {
        self.live_time.unwrap_or(0)
    }

    pub fn clear_live_time(&mut self) {
        self.live_time = ::std::option::Option::None;
    }

    pub fn has_live_time(&self) -> bool {
        self.live_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_live_time(&mut self, v: u32) {
        self.live_time = ::std::option::Option::Some(v);
    }

    // optional uint32 length_ms = 8;

    pub fn length_ms(&self) -> u32 {
        self.length_ms.unwrap_or(0)
    }

    pub fn clear_length_ms(&mut self) {
        self.length_ms = ::std::option::Option::None;
    }

    pub fn has_length_ms(&self) -> bool {
        self.length_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length_ms(&mut self, v: u32) {
        self.length_ms = ::std::option::Option::Some(v);
    }

    // optional string thumbnail_path = 9;

    pub fn thumbnail_path(&self) -> &str {
        match self.thumbnail_path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_path(&mut self) {
        self.thumbnail_path = ::std::option::Option::None;
    }

    pub fn has_thumbnail_path(&self) -> bool {
        self.thumbnail_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_path(&mut self, v: ::std::string::String) {
        self.thumbnail_path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_path(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_path.is_none() {
            self.thumbnail_path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_path.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_path(&mut self) -> ::std::string::String {
        self.thumbnail_path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_clip_id",
            |m: &CSteamTV_BroadcastClipInfo| { &m.broadcast_clip_id },
            |m: &mut CSteamTV_BroadcastClipInfo| { &mut m.broadcast_clip_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel_id",
            |m: &CSteamTV_BroadcastClipInfo| { &m.channel_id },
            |m: &mut CSteamTV_BroadcastClipInfo| { &mut m.channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CSteamTV_BroadcastClipInfo| { &m.app_id },
            |m: &mut CSteamTV_BroadcastClipInfo| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcaster_steamid",
            |m: &CSteamTV_BroadcastClipInfo| { &m.broadcaster_steamid },
            |m: &mut CSteamTV_BroadcastClipInfo| { &mut m.broadcaster_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "creator_steamid",
            |m: &CSteamTV_BroadcastClipInfo| { &m.creator_steamid },
            |m: &mut CSteamTV_BroadcastClipInfo| { &mut m.creator_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "video_description",
            |m: &CSteamTV_BroadcastClipInfo| { &m.video_description },
            |m: &mut CSteamTV_BroadcastClipInfo| { &mut m.video_description },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "live_time",
            |m: &CSteamTV_BroadcastClipInfo| { &m.live_time },
            |m: &mut CSteamTV_BroadcastClipInfo| { &mut m.live_time },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "length_ms",
            |m: &CSteamTV_BroadcastClipInfo| { &m.length_ms },
            |m: &mut CSteamTV_BroadcastClipInfo| { &mut m.length_ms },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnail_path",
            |m: &CSteamTV_BroadcastClipInfo| { &m.thumbnail_path },
            |m: &mut CSteamTV_BroadcastClipInfo| { &mut m.thumbnail_path },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_BroadcastClipInfo>(
            "CSteamTV_BroadcastClipInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_BroadcastClipInfo {
    const NAME: &'static str = "CSteamTV_BroadcastClipInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.broadcast_clip_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                33 => {
                    self.broadcaster_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                41 => {
                    self.creator_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.video_description = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.live_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.length_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.thumbnail_path = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_clip_id {
            my_size += crate::rt::uint64_size(1, v);
        }
        if let Some(v) = self.channel_id {
            my_size += crate::rt::uint64_size(2, v);
        }
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.broadcaster_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.creator_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.video_description.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.live_time {
            my_size += crate::rt::uint32_size(7, v);
        }
        if let Some(v) = self.length_ms {
            my_size += crate::rt::uint32_size(8, v);
        }
        if let Some(v) = self.thumbnail_path.as_ref() {
            my_size += crate::rt::string_size(9, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_clip_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.channel_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.broadcaster_steamid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.creator_steamid {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.video_description.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.live_time {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.length_ms {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.thumbnail_path.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_BroadcastClipInfo {
        CSteamTV_BroadcastClipInfo::new()
    }

    fn clear(&mut self) {
        self.broadcast_clip_id = ::std::option::Option::None;
        self.channel_id = ::std::option::Option::None;
        self.app_id = ::std::option::Option::None;
        self.broadcaster_steamid = ::std::option::Option::None;
        self.creator_steamid = ::std::option::Option::None;
        self.video_description = ::std::option::Option::None;
        self.live_time = ::std::option::Option::None;
        self.length_ms = ::std::option::Option::None;
        self.thumbnail_path = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_BroadcastClipInfo {
        static instance: CSteamTV_BroadcastClipInfo = CSteamTV_BroadcastClipInfo {
            broadcast_clip_id: ::std::option::Option::None,
            channel_id: ::std::option::Option::None,
            app_id: ::std::option::Option::None,
            broadcaster_steamid: ::std::option::Option::None,
            creator_steamid: ::std::option::Option::None,
            video_description: ::std::option::Option::None,
            live_time: ::std::option::Option::None,
            length_ms: ::std::option::Option::None,
            thumbnail_path: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_BroadcastClipInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_BroadcastClipInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_BroadcastClipInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_BroadcastClipInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelClips_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelClips_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelClips_Response.clips)
    pub clips: ::std::vec::Vec<CSteamTV_BroadcastClipInfo>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelClips_Response.thumbnail_host)
    pub thumbnail_host: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelClips_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelClips_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelClips_Response {
        <CSteamTV_GetBroadcastChannelClips_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelClips_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelClips_Response {
        ::std::default::Default::default()
    }

    // repeated .CSteamTV_BroadcastClipInfo clips = 1;

    pub fn clips(&self) -> &[CSteamTV_BroadcastClipInfo] {
        &self.clips
    }

    pub fn clear_clips(&mut self) {
        self.clips.clear();
    }

    // Param is passed by value, moved
    pub fn set_clips(&mut self, v: ::std::vec::Vec<CSteamTV_BroadcastClipInfo>) {
        self.clips = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clips(&mut self) -> &mut ::std::vec::Vec<CSteamTV_BroadcastClipInfo> {
        &mut self.clips
    }

    // Take field
    pub fn take_clips(&mut self) -> ::std::vec::Vec<CSteamTV_BroadcastClipInfo> {
        ::std::mem::replace(&mut self.clips, ::std::vec::Vec::new())
    }

    // optional string thumbnail_host = 2;

    pub fn thumbnail_host(&self) -> &str {
        match self.thumbnail_host.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_thumbnail_host(&mut self) {
        self.thumbnail_host = ::std::option::Option::None;
    }

    pub fn has_thumbnail_host(&self) -> bool {
        self.thumbnail_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thumbnail_host(&mut self, v: ::std::string::String) {
        self.thumbnail_host = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_thumbnail_host(&mut self) -> &mut ::std::string::String {
        if self.thumbnail_host.is_none() {
            self.thumbnail_host = ::std::option::Option::Some(::std::string::String::new());
        }
        self.thumbnail_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_thumbnail_host(&mut self) -> ::std::string::String {
        self.thumbnail_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "clips",
            |m: &CSteamTV_GetBroadcastChannelClips_Response| { &m.clips },
            |m: &mut CSteamTV_GetBroadcastChannelClips_Response| { &mut m.clips },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "thumbnail_host",
            |m: &CSteamTV_GetBroadcastChannelClips_Response| { &m.thumbnail_host },
            |m: &mut CSteamTV_GetBroadcastChannelClips_Response| { &mut m.thumbnail_host },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelClips_Response>(
            "CSteamTV_GetBroadcastChannelClips_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelClips_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelClips_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.clips.push(is.read_message()?);
                },
                18 => {
                    self.thumbnail_host = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.clips {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.thumbnail_host.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.clips {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.thumbnail_host.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelClips_Response {
        CSteamTV_GetBroadcastChannelClips_Response::new()
    }

    fn clear(&mut self) {
        self.clips.clear();
        self.thumbnail_host = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelClips_Response {
        static instance: CSteamTV_GetBroadcastChannelClips_Response = CSteamTV_GetBroadcastChannelClips_Response {
            clips: ::std::vec::Vec::new(),
            thumbnail_host: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelClips_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelClips_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelClips_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelClips_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_ReportBroadcastChannel_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_ReportBroadcastChannel_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_ReportBroadcastChannel_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_ReportBroadcastChannel_Request.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_ReportBroadcastChannel_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_ReportBroadcastChannel_Request {
    fn default() -> &'a CSteamTV_ReportBroadcastChannel_Request {
        <CSteamTV_ReportBroadcastChannel_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_ReportBroadcastChannel_Request {
    pub fn new() -> CSteamTV_ReportBroadcastChannel_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string reason = 2;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_ReportBroadcastChannel_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_ReportBroadcastChannel_Request| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CSteamTV_ReportBroadcastChannel_Request| { &m.reason },
            |m: &mut CSteamTV_ReportBroadcastChannel_Request| { &mut m.reason },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_ReportBroadcastChannel_Request>(
            "CSteamTV_ReportBroadcastChannel_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_ReportBroadcastChannel_Request {
    const NAME: &'static str = "CSteamTV_ReportBroadcastChannel_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_ReportBroadcastChannel_Request {
        CSteamTV_ReportBroadcastChannel_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_ReportBroadcastChannel_Request {
        static instance: CSteamTV_ReportBroadcastChannel_Request = CSteamTV_ReportBroadcastChannel_Request {
            broadcast_channel_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_ReportBroadcastChannel_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_ReportBroadcastChannel_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_ReportBroadcastChannel_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_ReportBroadcastChannel_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_ReportBroadcastChannel_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_ReportBroadcastChannel_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_ReportBroadcastChannel_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_ReportBroadcastChannel_Response {
    fn default() -> &'a CSteamTV_ReportBroadcastChannel_Response {
        <CSteamTV_ReportBroadcastChannel_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_ReportBroadcastChannel_Response {
    pub fn new() -> CSteamTV_ReportBroadcastChannel_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_ReportBroadcastChannel_Response>(
            "CSteamTV_ReportBroadcastChannel_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_ReportBroadcastChannel_Response {
    const NAME: &'static str = "CSteamTV_ReportBroadcastChannel_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_ReportBroadcastChannel_Response {
        CSteamTV_ReportBroadcastChannel_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_ReportBroadcastChannel_Response {
        static instance: CSteamTV_ReportBroadcastChannel_Response = CSteamTV_ReportBroadcastChannel_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_ReportBroadcastChannel_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_ReportBroadcastChannel_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_ReportBroadcastChannel_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_ReportBroadcastChannel_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelInteraction_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelInteraction_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelInteraction_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelInteraction_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelInteraction_Request {
    fn default() -> &'a CSteamTV_GetBroadcastChannelInteraction_Request {
        <CSteamTV_GetBroadcastChannelInteraction_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelInteraction_Request {
    pub fn new() -> CSteamTV_GetBroadcastChannelInteraction_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetBroadcastChannelInteraction_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetBroadcastChannelInteraction_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelInteraction_Request>(
            "CSteamTV_GetBroadcastChannelInteraction_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelInteraction_Request {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelInteraction_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelInteraction_Request {
        CSteamTV_GetBroadcastChannelInteraction_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelInteraction_Request {
        static instance: CSteamTV_GetBroadcastChannelInteraction_Request = CSteamTV_GetBroadcastChannelInteraction_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelInteraction_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelInteraction_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelInteraction_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelInteraction_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetBroadcastChannelInteraction_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetBroadcastChannelInteraction_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelInteraction_Response.is_followed)
    pub is_followed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_GetBroadcastChannelInteraction_Response.is_subscribed)
    pub is_subscribed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetBroadcastChannelInteraction_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetBroadcastChannelInteraction_Response {
    fn default() -> &'a CSteamTV_GetBroadcastChannelInteraction_Response {
        <CSteamTV_GetBroadcastChannelInteraction_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetBroadcastChannelInteraction_Response {
    pub fn new() -> CSteamTV_GetBroadcastChannelInteraction_Response {
        ::std::default::Default::default()
    }

    // optional bool is_followed = 1;

    pub fn is_followed(&self) -> bool {
        self.is_followed.unwrap_or(false)
    }

    pub fn clear_is_followed(&mut self) {
        self.is_followed = ::std::option::Option::None;
    }

    pub fn has_is_followed(&self) -> bool {
        self.is_followed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_followed(&mut self, v: bool) {
        self.is_followed = ::std::option::Option::Some(v);
    }

    // optional bool is_subscribed = 2;

    pub fn is_subscribed(&self) -> bool {
        self.is_subscribed.unwrap_or(false)
    }

    pub fn clear_is_subscribed(&mut self) {
        self.is_subscribed = ::std::option::Option::None;
    }

    pub fn has_is_subscribed(&self) -> bool {
        self.is_subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_subscribed(&mut self, v: bool) {
        self.is_subscribed = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_followed",
            |m: &CSteamTV_GetBroadcastChannelInteraction_Response| { &m.is_followed },
            |m: &mut CSteamTV_GetBroadcastChannelInteraction_Response| { &mut m.is_followed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_subscribed",
            |m: &CSteamTV_GetBroadcastChannelInteraction_Response| { &m.is_subscribed },
            |m: &mut CSteamTV_GetBroadcastChannelInteraction_Response| { &mut m.is_subscribed },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetBroadcastChannelInteraction_Response>(
            "CSteamTV_GetBroadcastChannelInteraction_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetBroadcastChannelInteraction_Response {
    const NAME: &'static str = "CSteamTV_GetBroadcastChannelInteraction_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_followed = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.is_subscribed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_followed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_subscribed {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.is_followed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.is_subscribed {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetBroadcastChannelInteraction_Response {
        CSteamTV_GetBroadcastChannelInteraction_Response::new()
    }

    fn clear(&mut self) {
        self.is_followed = ::std::option::Option::None;
        self.is_subscribed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetBroadcastChannelInteraction_Response {
        static instance: CSteamTV_GetBroadcastChannelInteraction_Response = CSteamTV_GetBroadcastChannelInteraction_Response {
            is_followed: ::std::option::Option::None,
            is_subscribed: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetBroadcastChannelInteraction_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetBroadcastChannelInteraction_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetBroadcastChannelInteraction_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetBroadcastChannelInteraction_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetGames_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetGames_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetGames_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_GetGames_Request.algorithm)
    pub algorithm: ::std::option::Option<crate::EnumOrUnknown<EGetGamesAlgorithm>>,
    // @@protoc_insertion_point(field:CSteamTV_GetGames_Request.count)
    pub count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetGames_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetGames_Request {
    fn default() -> &'a CSteamTV_GetGames_Request {
        <CSteamTV_GetGames_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetGames_Request {
    pub fn new() -> CSteamTV_GetGames_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional .EGetGamesAlgorithm algorithm = 2;

    pub fn algorithm(&self) -> EGetGamesAlgorithm {
        match self.algorithm {
            Some(e) => e.enum_value_or(EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default),
            None => EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default,
        }
    }

    pub fn clear_algorithm(&mut self) {
        self.algorithm = ::std::option::Option::None;
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: EGetGamesAlgorithm) {
        self.algorithm = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 count = 3;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSteamTV_GetGames_Request| { &m.appid },
            |m: &mut CSteamTV_GetGames_Request| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "algorithm",
            |m: &CSteamTV_GetGames_Request| { &m.algorithm },
            |m: &mut CSteamTV_GetGames_Request| { &mut m.algorithm },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CSteamTV_GetGames_Request| { &m.count },
            |m: &mut CSteamTV_GetGames_Request| { &mut m.count },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetGames_Request>(
            "CSteamTV_GetGames_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetGames_Request {
    const NAME: &'static str = "CSteamTV_GetGames_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.algorithm = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.algorithm {
            my_size += crate::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.count {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.algorithm {
            os.write_enum(2, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetGames_Request {
        CSteamTV_GetGames_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.algorithm = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetGames_Request {
        static instance: CSteamTV_GetGames_Request = CSteamTV_GetGames_Request {
            appid: ::std::option::Option::None,
            algorithm: ::std::option::Option::None,
            count: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetGames_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetGames_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetGames_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetGames_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_Game)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_Game {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_Game.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_Game.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_Game.image)
    pub image: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_Game.viewers)
    pub viewers: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_Game.channels)
    pub channels: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_Game.release_date)
    pub release_date: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_Game.developer)
    pub developer: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_Game.publisher)
    pub publisher: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_Game.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_Game {
    fn default() -> &'a CSteamTV_Game {
        <CSteamTV_Game as crate::Message>::default_instance()
    }
}

impl CSteamTV_Game {
    pub fn new() -> CSteamTV_Game {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image = 3;

    pub fn image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_image(&mut self) {
        self.image = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image = ::std::option::Option::Some(::std::string::String::new());
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 viewers = 4;

    pub fn viewers(&self) -> u64 {
        self.viewers.unwrap_or(0)
    }

    pub fn clear_viewers(&mut self) {
        self.viewers = ::std::option::Option::None;
    }

    pub fn has_viewers(&self) -> bool {
        self.viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers(&mut self, v: u64) {
        self.viewers = ::std::option::Option::Some(v);
    }

    // repeated .GetBroadcastChannelEntry channels = 5;

    pub fn channels(&self) -> &[GetBroadcastChannelEntry] {
        &self.channels
    }

    pub fn clear_channels(&mut self) {
        self.channels.clear();
    }

    // Param is passed by value, moved
    pub fn set_channels(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.channels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_channels(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.channels
    }

    // Take field
    pub fn take_channels(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.channels, ::std::vec::Vec::new())
    }

    // optional string release_date = 6;

    pub fn release_date(&self) -> &str {
        match self.release_date.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_release_date(&mut self) {
        self.release_date = ::std::option::Option::None;
    }

    pub fn has_release_date(&self) -> bool {
        self.release_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_release_date(&mut self, v: ::std::string::String) {
        self.release_date = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_release_date(&mut self) -> &mut ::std::string::String {
        if self.release_date.is_none() {
            self.release_date = ::std::option::Option::Some(::std::string::String::new());
        }
        self.release_date.as_mut().unwrap()
    }

    // Take field
    pub fn take_release_date(&mut self) -> ::std::string::String {
        self.release_date.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string developer = 7;

    pub fn developer(&self) -> &str {
        match self.developer.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_developer(&mut self) {
        self.developer = ::std::option::Option::None;
    }

    pub fn has_developer(&self) -> bool {
        self.developer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_developer(&mut self, v: ::std::string::String) {
        self.developer = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_developer(&mut self) -> &mut ::std::string::String {
        if self.developer.is_none() {
            self.developer = ::std::option::Option::Some(::std::string::String::new());
        }
        self.developer.as_mut().unwrap()
    }

    // Take field
    pub fn take_developer(&mut self) -> ::std::string::String {
        self.developer.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string publisher = 8;

    pub fn publisher(&self) -> &str {
        match self.publisher.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_publisher(&mut self) {
        self.publisher = ::std::option::Option::None;
    }

    pub fn has_publisher(&self) -> bool {
        self.publisher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publisher(&mut self, v: ::std::string::String) {
        self.publisher = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publisher(&mut self) -> &mut ::std::string::String {
        if self.publisher.is_none() {
            self.publisher = ::std::option::Option::Some(::std::string::String::new());
        }
        self.publisher.as_mut().unwrap()
    }

    // Take field
    pub fn take_publisher(&mut self) -> ::std::string::String {
        self.publisher.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSteamTV_Game| { &m.appid },
            |m: &mut CSteamTV_Game| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSteamTV_Game| { &m.name },
            |m: &mut CSteamTV_Game| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "image",
            |m: &CSteamTV_Game| { &m.image },
            |m: &mut CSteamTV_Game| { &mut m.image },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewers",
            |m: &CSteamTV_Game| { &m.viewers },
            |m: &mut CSteamTV_Game| { &mut m.viewers },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "channels",
            |m: &CSteamTV_Game| { &m.channels },
            |m: &mut CSteamTV_Game| { &mut m.channels },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "release_date",
            |m: &CSteamTV_Game| { &m.release_date },
            |m: &mut CSteamTV_Game| { &mut m.release_date },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "developer",
            |m: &CSteamTV_Game| { &m.developer },
            |m: &mut CSteamTV_Game| { &mut m.developer },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "publisher",
            |m: &CSteamTV_Game| { &m.publisher },
            |m: &mut CSteamTV_Game| { &mut m.publisher },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_Game>(
            "CSteamTV_Game",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_Game {
    const NAME: &'static str = "CSteamTV_Game";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.image = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.viewers = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.channels.push(is.read_message()?);
                },
                50 => {
                    self.release_date = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.developer = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.publisher = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.image.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.viewers {
            my_size += crate::rt::uint64_size(4, v);
        }
        for value in &self.channels {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.release_date.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.developer.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.publisher.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.image.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.viewers {
            os.write_uint64(4, v)?;
        }
        for v in &self.channels {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.release_date.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.developer.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.publisher.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_Game {
        CSteamTV_Game::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.image = ::std::option::Option::None;
        self.viewers = ::std::option::Option::None;
        self.channels.clear();
        self.release_date = ::std::option::Option::None;
        self.developer = ::std::option::Option::None;
        self.publisher = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_Game {
        static instance: CSteamTV_Game = CSteamTV_Game {
            appid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            image: ::std::option::Option::None,
            viewers: ::std::option::Option::None,
            channels: ::std::vec::Vec::new(),
            release_date: ::std::option::Option::None,
            developer: ::std::option::Option::None,
            publisher: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_Game {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_Game").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_Game {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_Game {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetGames_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetGames_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetGames_Response.results)
    pub results: ::std::vec::Vec<CSteamTV_Game>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetGames_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetGames_Response {
    fn default() -> &'a CSteamTV_GetGames_Response {
        <CSteamTV_GetGames_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetGames_Response {
    pub fn new() -> CSteamTV_GetGames_Response {
        ::std::default::Default::default()
    }

    // repeated .CSteamTV_Game results = 1;

    pub fn results(&self) -> &[CSteamTV_Game] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<CSteamTV_Game>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<CSteamTV_Game> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<CSteamTV_Game> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CSteamTV_GetGames_Response| { &m.results },
            |m: &mut CSteamTV_GetGames_Response| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetGames_Response>(
            "CSteamTV_GetGames_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetGames_Response {
    const NAME: &'static str = "CSteamTV_GetGames_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.results {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetGames_Response {
        CSteamTV_GetGames_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetGames_Response {
        static instance: CSteamTV_GetGames_Response = CSteamTV_GetGames_Response {
            results: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetGames_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetGames_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetGames_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetGames_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetChannels_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChannels_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChannels_Request.algorithm)
    pub algorithm: ::std::option::Option<crate::EnumOrUnknown<EGetChannelsAlgorithm>>,
    // @@protoc_insertion_point(field:CSteamTV_GetChannels_Request.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_GetChannels_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChannels_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChannels_Request {
    fn default() -> &'a CSteamTV_GetChannels_Request {
        <CSteamTV_GetChannels_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetChannels_Request {
    pub fn new() -> CSteamTV_GetChannels_Request {
        ::std::default::Default::default()
    }

    // optional .EGetChannelsAlgorithm algorithm = 1;

    pub fn algorithm(&self) -> EGetChannelsAlgorithm {
        match self.algorithm {
            Some(e) => e.enum_value_or(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default),
            None => EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default,
        }
    }

    pub fn clear_algorithm(&mut self) {
        self.algorithm = ::std::option::Option::None;
    }

    pub fn has_algorithm(&self) -> bool {
        self.algorithm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_algorithm(&mut self, v: EGetChannelsAlgorithm) {
        self.algorithm = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional uint32 count = 2;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 3;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "algorithm",
            |m: &CSteamTV_GetChannels_Request| { &m.algorithm },
            |m: &mut CSteamTV_GetChannels_Request| { &mut m.algorithm },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CSteamTV_GetChannels_Request| { &m.count },
            |m: &mut CSteamTV_GetChannels_Request| { &mut m.count },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSteamTV_GetChannels_Request| { &m.appid },
            |m: &mut CSteamTV_GetChannels_Request| { &mut m.appid },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetChannels_Request>(
            "CSteamTV_GetChannels_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetChannels_Request {
    const NAME: &'static str = "CSteamTV_GetChannels_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.algorithm = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.algorithm {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.count {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.algorithm {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChannels_Request {
        CSteamTV_GetChannels_Request::new()
    }

    fn clear(&mut self) {
        self.algorithm = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChannels_Request {
        static instance: CSteamTV_GetChannels_Request = CSteamTV_GetChannels_Request {
            algorithm: ::std::option::Option::None,
            count: ::std::option::Option::None,
            appid: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetChannels_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetChannels_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetChannels_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetChannels_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetChannels_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChannels_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChannels_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChannels_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChannels_Response {
    fn default() -> &'a CSteamTV_GetChannels_Response {
        <CSteamTV_GetChannels_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetChannels_Response {
    pub fn new() -> CSteamTV_GetChannels_Response {
        ::std::default::Default::default()
    }

    // repeated .GetBroadcastChannelEntry results = 1;

    pub fn results(&self) -> &[GetBroadcastChannelEntry] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CSteamTV_GetChannels_Response| { &m.results },
            |m: &mut CSteamTV_GetChannels_Response| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetChannels_Response>(
            "CSteamTV_GetChannels_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetChannels_Response {
    const NAME: &'static str = "CSteamTV_GetChannels_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.results {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChannels_Response {
        CSteamTV_GetChannels_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChannels_Response {
        static instance: CSteamTV_GetChannels_Response = CSteamTV_GetChannels_Response {
            results: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetChannels_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetChannels_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetChannels_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetChannels_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_AddChatBan_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddChatBan_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.chatter_steamid)
    pub chatter_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.permanent)
    pub permanent: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatBan_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddChatBan_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddChatBan_Request {
    fn default() -> &'a CSteamTV_AddChatBan_Request {
        <CSteamTV_AddChatBan_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_AddChatBan_Request {
    pub fn new() -> CSteamTV_AddChatBan_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 chatter_steamid = 2;

    pub fn chatter_steamid(&self) -> u64 {
        self.chatter_steamid.unwrap_or(0)
    }

    pub fn clear_chatter_steamid(&mut self) {
        self.chatter_steamid = ::std::option::Option::None;
    }

    pub fn has_chatter_steamid(&self) -> bool {
        self.chatter_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatter_steamid(&mut self, v: u64) {
        self.chatter_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool permanent = 4;

    pub fn permanent(&self) -> bool {
        self.permanent.unwrap_or(false)
    }

    pub fn clear_permanent(&mut self) {
        self.permanent = ::std::option::Option::None;
    }

    pub fn has_permanent(&self) -> bool {
        self.permanent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permanent(&mut self, v: bool) {
        self.permanent = ::std::option::Option::Some(v);
    }

    // optional bool undo = 5;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_AddChatBan_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_AddChatBan_Request| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chatter_steamid",
            |m: &CSteamTV_AddChatBan_Request| { &m.chatter_steamid },
            |m: &mut CSteamTV_AddChatBan_Request| { &mut m.chatter_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CSteamTV_AddChatBan_Request| { &m.duration },
            |m: &mut CSteamTV_AddChatBan_Request| { &mut m.duration },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "permanent",
            |m: &CSteamTV_AddChatBan_Request| { &m.permanent },
            |m: &mut CSteamTV_AddChatBan_Request| { &mut m.permanent },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "undo",
            |m: &CSteamTV_AddChatBan_Request| { &m.undo },
            |m: &mut CSteamTV_AddChatBan_Request| { &mut m.undo },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_AddChatBan_Request>(
            "CSteamTV_AddChatBan_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_AddChatBan_Request {
    const NAME: &'static str = "CSteamTV_AddChatBan_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.chatter_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.permanent = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chatter_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.duration {
            my_size += crate::rt::uint32_size(3, v);
        }
        if let Some(v) = self.permanent {
            my_size += 1 + 1;
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chatter_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.permanent {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddChatBan_Request {
        CSteamTV_AddChatBan_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.chatter_steamid = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.permanent = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddChatBan_Request {
        static instance: CSteamTV_AddChatBan_Request = CSteamTV_AddChatBan_Request {
            broadcast_channel_id: ::std::option::Option::None,
            chatter_steamid: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            permanent: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_AddChatBan_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_AddChatBan_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_AddChatBan_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_AddChatBan_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_AddChatBan_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddChatBan_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddChatBan_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddChatBan_Response {
    fn default() -> &'a CSteamTV_AddChatBan_Response {
        <CSteamTV_AddChatBan_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_AddChatBan_Response {
    pub fn new() -> CSteamTV_AddChatBan_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_AddChatBan_Response>(
            "CSteamTV_AddChatBan_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_AddChatBan_Response {
    const NAME: &'static str = "CSteamTV_AddChatBan_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddChatBan_Response {
        CSteamTV_AddChatBan_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddChatBan_Response {
        static instance: CSteamTV_AddChatBan_Response = CSteamTV_AddChatBan_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_AddChatBan_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_AddChatBan_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_AddChatBan_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_AddChatBan_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetChatBans_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChatBans_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChatBans_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChatBans_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChatBans_Request {
    fn default() -> &'a CSteamTV_GetChatBans_Request {
        <CSteamTV_GetChatBans_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetChatBans_Request {
    pub fn new() -> CSteamTV_GetChatBans_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetChatBans_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetChatBans_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetChatBans_Request>(
            "CSteamTV_GetChatBans_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetChatBans_Request {
    const NAME: &'static str = "CSteamTV_GetChatBans_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChatBans_Request {
        CSteamTV_GetChatBans_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChatBans_Request {
        static instance: CSteamTV_GetChatBans_Request = CSteamTV_GetChatBans_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetChatBans_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetChatBans_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetChatBans_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetChatBans_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_ChatBan)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_ChatBan {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.issuer_steamid)
    pub issuer_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.chatter_steamid)
    pub chatter_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.time_expires)
    pub time_expires: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.permanent)
    pub permanent: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_ChatBan.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_ChatBan.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_ChatBan {
    fn default() -> &'a CSteamTV_ChatBan {
        <CSteamTV_ChatBan as crate::Message>::default_instance()
    }
}

impl CSteamTV_ChatBan {
    pub fn new() -> CSteamTV_ChatBan {
        ::std::default::Default::default()
    }

    // optional fixed64 issuer_steamid = 1;

    pub fn issuer_steamid(&self) -> u64 {
        self.issuer_steamid.unwrap_or(0)
    }

    pub fn clear_issuer_steamid(&mut self) {
        self.issuer_steamid = ::std::option::Option::None;
    }

    pub fn has_issuer_steamid(&self) -> bool {
        self.issuer_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_issuer_steamid(&mut self, v: u64) {
        self.issuer_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 chatter_steamid = 2;

    pub fn chatter_steamid(&self) -> u64 {
        self.chatter_steamid.unwrap_or(0)
    }

    pub fn clear_chatter_steamid(&mut self) {
        self.chatter_steamid = ::std::option::Option::None;
    }

    pub fn has_chatter_steamid(&self) -> bool {
        self.chatter_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatter_steamid(&mut self, v: u64) {
        self.chatter_steamid = ::std::option::Option::Some(v);
    }

    // optional string time_expires = 3;

    pub fn time_expires(&self) -> &str {
        match self.time_expires.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: ::std::string::String) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_expires(&mut self) -> &mut ::std::string::String {
        if self.time_expires.is_none() {
            self.time_expires = ::std::option::Option::Some(::std::string::String::new());
        }
        self.time_expires.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_expires(&mut self) -> ::std::string::String {
        self.time_expires.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool permanent = 4;

    pub fn permanent(&self) -> bool {
        self.permanent.unwrap_or(false)
    }

    pub fn clear_permanent(&mut self) {
        self.permanent = ::std::option::Option::None;
    }

    pub fn has_permanent(&self) -> bool {
        self.permanent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permanent(&mut self, v: bool) {
        self.permanent = ::std::option::Option::Some(v);
    }

    // optional string name = 5;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "issuer_steamid",
            |m: &CSteamTV_ChatBan| { &m.issuer_steamid },
            |m: &mut CSteamTV_ChatBan| { &mut m.issuer_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chatter_steamid",
            |m: &CSteamTV_ChatBan| { &m.chatter_steamid },
            |m: &mut CSteamTV_ChatBan| { &mut m.chatter_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_expires",
            |m: &CSteamTV_ChatBan| { &m.time_expires },
            |m: &mut CSteamTV_ChatBan| { &mut m.time_expires },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "permanent",
            |m: &CSteamTV_ChatBan| { &m.permanent },
            |m: &mut CSteamTV_ChatBan| { &mut m.permanent },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSteamTV_ChatBan| { &m.name },
            |m: &mut CSteamTV_ChatBan| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_ChatBan>(
            "CSteamTV_ChatBan",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_ChatBan {
    const NAME: &'static str = "CSteamTV_ChatBan";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.issuer_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.chatter_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.time_expires = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.permanent = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.issuer_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.chatter_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.time_expires.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.permanent {
            my_size += 1 + 1;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(5, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.issuer_steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chatter_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.time_expires.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.permanent {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_ChatBan {
        CSteamTV_ChatBan::new()
    }

    fn clear(&mut self) {
        self.issuer_steamid = ::std::option::Option::None;
        self.chatter_steamid = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.permanent = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_ChatBan {
        static instance: CSteamTV_ChatBan = CSteamTV_ChatBan {
            issuer_steamid: ::std::option::Option::None,
            chatter_steamid: ::std::option::Option::None,
            time_expires: ::std::option::Option::None,
            permanent: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_ChatBan {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_ChatBan").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_ChatBan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_ChatBan {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetChatBans_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChatBans_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChatBans_Response.results)
    pub results: ::std::vec::Vec<CSteamTV_ChatBan>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChatBans_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChatBans_Response {
    fn default() -> &'a CSteamTV_GetChatBans_Response {
        <CSteamTV_GetChatBans_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetChatBans_Response {
    pub fn new() -> CSteamTV_GetChatBans_Response {
        ::std::default::Default::default()
    }

    // repeated .CSteamTV_ChatBan results = 1;

    pub fn results(&self) -> &[CSteamTV_ChatBan] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<CSteamTV_ChatBan>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<CSteamTV_ChatBan> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<CSteamTV_ChatBan> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CSteamTV_GetChatBans_Response| { &m.results },
            |m: &mut CSteamTV_GetChatBans_Response| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetChatBans_Response>(
            "CSteamTV_GetChatBans_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetChatBans_Response {
    const NAME: &'static str = "CSteamTV_GetChatBans_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.results {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChatBans_Response {
        CSteamTV_GetChatBans_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChatBans_Response {
        static instance: CSteamTV_GetChatBans_Response = CSteamTV_GetChatBans_Response {
            results: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetChatBans_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetChatBans_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetChatBans_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetChatBans_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_AddChatModerator_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddChatModerator_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AddChatModerator_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatModerator_Request.moderator_steamid)
    pub moderator_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddChatModerator_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddChatModerator_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddChatModerator_Request {
    fn default() -> &'a CSteamTV_AddChatModerator_Request {
        <CSteamTV_AddChatModerator_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_AddChatModerator_Request {
    pub fn new() -> CSteamTV_AddChatModerator_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 moderator_steamid = 2;

    pub fn moderator_steamid(&self) -> u64 {
        self.moderator_steamid.unwrap_or(0)
    }

    pub fn clear_moderator_steamid(&mut self) {
        self.moderator_steamid = ::std::option::Option::None;
    }

    pub fn has_moderator_steamid(&self) -> bool {
        self.moderator_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moderator_steamid(&mut self, v: u64) {
        self.moderator_steamid = ::std::option::Option::Some(v);
    }

    // optional bool undo = 3;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_AddChatModerator_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_AddChatModerator_Request| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "moderator_steamid",
            |m: &CSteamTV_AddChatModerator_Request| { &m.moderator_steamid },
            |m: &mut CSteamTV_AddChatModerator_Request| { &mut m.moderator_steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "undo",
            |m: &CSteamTV_AddChatModerator_Request| { &m.undo },
            |m: &mut CSteamTV_AddChatModerator_Request| { &mut m.undo },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_AddChatModerator_Request>(
            "CSteamTV_AddChatModerator_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_AddChatModerator_Request {
    const NAME: &'static str = "CSteamTV_AddChatModerator_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.moderator_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.moderator_steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.moderator_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddChatModerator_Request {
        CSteamTV_AddChatModerator_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.moderator_steamid = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddChatModerator_Request {
        static instance: CSteamTV_AddChatModerator_Request = CSteamTV_AddChatModerator_Request {
            broadcast_channel_id: ::std::option::Option::None,
            moderator_steamid: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_AddChatModerator_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_AddChatModerator_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_AddChatModerator_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_AddChatModerator_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_AddChatModerator_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddChatModerator_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddChatModerator_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddChatModerator_Response {
    fn default() -> &'a CSteamTV_AddChatModerator_Response {
        <CSteamTV_AddChatModerator_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_AddChatModerator_Response {
    pub fn new() -> CSteamTV_AddChatModerator_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_AddChatModerator_Response>(
            "CSteamTV_AddChatModerator_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_AddChatModerator_Response {
    const NAME: &'static str = "CSteamTV_AddChatModerator_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddChatModerator_Response {
        CSteamTV_AddChatModerator_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddChatModerator_Response {
        static instance: CSteamTV_AddChatModerator_Response = CSteamTV_AddChatModerator_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_AddChatModerator_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_AddChatModerator_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_AddChatModerator_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_AddChatModerator_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetChatModerators_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChatModerators_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChatModerators_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChatModerators_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChatModerators_Request {
    fn default() -> &'a CSteamTV_GetChatModerators_Request {
        <CSteamTV_GetChatModerators_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetChatModerators_Request {
    pub fn new() -> CSteamTV_GetChatModerators_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetChatModerators_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetChatModerators_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetChatModerators_Request>(
            "CSteamTV_GetChatModerators_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetChatModerators_Request {
    const NAME: &'static str = "CSteamTV_GetChatModerators_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChatModerators_Request {
        CSteamTV_GetChatModerators_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChatModerators_Request {
        static instance: CSteamTV_GetChatModerators_Request = CSteamTV_GetChatModerators_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetChatModerators_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetChatModerators_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetChatModerators_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetChatModerators_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_ChatModerator)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_ChatModerator {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_ChatModerator.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_ChatModerator.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_ChatModerator.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_ChatModerator {
    fn default() -> &'a CSteamTV_ChatModerator {
        <CSteamTV_ChatModerator as crate::Message>::default_instance()
    }
}

impl CSteamTV_ChatModerator {
    pub fn new() -> CSteamTV_ChatModerator {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "steamid",
            |m: &CSteamTV_ChatModerator| { &m.steamid },
            |m: &mut CSteamTV_ChatModerator| { &mut m.steamid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSteamTV_ChatModerator| { &m.name },
            |m: &mut CSteamTV_ChatModerator| { &mut m.name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_ChatModerator>(
            "CSteamTV_ChatModerator",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_ChatModerator {
    const NAME: &'static str = "CSteamTV_ChatModerator";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_ChatModerator {
        CSteamTV_ChatModerator::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_ChatModerator {
        static instance: CSteamTV_ChatModerator = CSteamTV_ChatModerator {
            steamid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_ChatModerator {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_ChatModerator").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_ChatModerator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_ChatModerator {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetChatModerators_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetChatModerators_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetChatModerators_Response.results)
    pub results: ::std::vec::Vec<CSteamTV_ChatModerator>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetChatModerators_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetChatModerators_Response {
    fn default() -> &'a CSteamTV_GetChatModerators_Response {
        <CSteamTV_GetChatModerators_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetChatModerators_Response {
    pub fn new() -> CSteamTV_GetChatModerators_Response {
        ::std::default::Default::default()
    }

    // repeated .CSteamTV_ChatModerator results = 1;

    pub fn results(&self) -> &[CSteamTV_ChatModerator] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<CSteamTV_ChatModerator>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<CSteamTV_ChatModerator> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<CSteamTV_ChatModerator> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CSteamTV_GetChatModerators_Response| { &m.results },
            |m: &mut CSteamTV_GetChatModerators_Response| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetChatModerators_Response>(
            "CSteamTV_GetChatModerators_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetChatModerators_Response {
    const NAME: &'static str = "CSteamTV_GetChatModerators_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.results {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetChatModerators_Response {
        CSteamTV_GetChatModerators_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetChatModerators_Response {
        static instance: CSteamTV_GetChatModerators_Response = CSteamTV_GetChatModerators_Response {
            results: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetChatModerators_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetChatModerators_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetChatModerators_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetChatModerators_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_AddWordBan_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddWordBan_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AddWordBan_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AddWordBan_Request.word)
    pub word: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_AddWordBan_Request.undo)
    pub undo: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddWordBan_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddWordBan_Request {
    fn default() -> &'a CSteamTV_AddWordBan_Request {
        <CSteamTV_AddWordBan_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_AddWordBan_Request {
    pub fn new() -> CSteamTV_AddWordBan_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    // optional string word = 2;

    pub fn word(&self) -> &str {
        match self.word.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_word(&mut self) {
        self.word = ::std::option::Option::None;
    }

    pub fn has_word(&self) -> bool {
        self.word.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word(&mut self, v: ::std::string::String) {
        self.word = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_word(&mut self) -> &mut ::std::string::String {
        if self.word.is_none() {
            self.word = ::std::option::Option::Some(::std::string::String::new());
        }
        self.word.as_mut().unwrap()
    }

    // Take field
    pub fn take_word(&mut self) -> ::std::string::String {
        self.word.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool undo = 3;

    pub fn undo(&self) -> bool {
        self.undo.unwrap_or(false)
    }

    pub fn clear_undo(&mut self) {
        self.undo = ::std::option::Option::None;
    }

    pub fn has_undo(&self) -> bool {
        self.undo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_undo(&mut self, v: bool) {
        self.undo = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_AddWordBan_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_AddWordBan_Request| { &mut m.broadcast_channel_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "word",
            |m: &CSteamTV_AddWordBan_Request| { &m.word },
            |m: &mut CSteamTV_AddWordBan_Request| { &mut m.word },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "undo",
            |m: &CSteamTV_AddWordBan_Request| { &m.undo },
            |m: &mut CSteamTV_AddWordBan_Request| { &mut m.undo },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_AddWordBan_Request>(
            "CSteamTV_AddWordBan_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_AddWordBan_Request {
    const NAME: &'static str = "CSteamTV_AddWordBan_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.word = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.undo = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.word.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.undo {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.word.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.undo {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddWordBan_Request {
        CSteamTV_AddWordBan_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.word = ::std::option::Option::None;
        self.undo = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddWordBan_Request {
        static instance: CSteamTV_AddWordBan_Request = CSteamTV_AddWordBan_Request {
            broadcast_channel_id: ::std::option::Option::None,
            word: ::std::option::Option::None,
            undo: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_AddWordBan_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_AddWordBan_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_AddWordBan_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_AddWordBan_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_AddWordBan_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AddWordBan_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AddWordBan_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AddWordBan_Response {
    fn default() -> &'a CSteamTV_AddWordBan_Response {
        <CSteamTV_AddWordBan_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_AddWordBan_Response {
    pub fn new() -> CSteamTV_AddWordBan_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_AddWordBan_Response>(
            "CSteamTV_AddWordBan_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_AddWordBan_Response {
    const NAME: &'static str = "CSteamTV_AddWordBan_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AddWordBan_Response {
        CSteamTV_AddWordBan_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AddWordBan_Response {
        static instance: CSteamTV_AddWordBan_Response = CSteamTV_AddWordBan_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_AddWordBan_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_AddWordBan_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_AddWordBan_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_AddWordBan_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetWordBans_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetWordBans_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetWordBans_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetWordBans_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetWordBans_Request {
    fn default() -> &'a CSteamTV_GetWordBans_Request {
        <CSteamTV_GetWordBans_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetWordBans_Request {
    pub fn new() -> CSteamTV_GetWordBans_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_GetWordBans_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_GetWordBans_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetWordBans_Request>(
            "CSteamTV_GetWordBans_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetWordBans_Request {
    const NAME: &'static str = "CSteamTV_GetWordBans_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetWordBans_Request {
        CSteamTV_GetWordBans_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetWordBans_Request {
        static instance: CSteamTV_GetWordBans_Request = CSteamTV_GetWordBans_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetWordBans_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetWordBans_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetWordBans_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetWordBans_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetWordBans_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetWordBans_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetWordBans_Response.results)
    pub results: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetWordBans_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetWordBans_Response {
    fn default() -> &'a CSteamTV_GetWordBans_Response {
        <CSteamTV_GetWordBans_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetWordBans_Response {
    pub fn new() -> CSteamTV_GetWordBans_Response {
        ::std::default::Default::default()
    }

    // repeated string results = 1;

    pub fn results(&self) -> &[::std::string::String] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<::std::string::String>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<::std::string::String> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<::std::string::String> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CSteamTV_GetWordBans_Response| { &m.results },
            |m: &mut CSteamTV_GetWordBans_Response| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetWordBans_Response>(
            "CSteamTV_GetWordBans_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetWordBans_Response {
    const NAME: &'static str = "CSteamTV_GetWordBans_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            my_size += crate::rt::string_size(1, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.results {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetWordBans_Response {
        CSteamTV_GetWordBans_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetWordBans_Response {
        static instance: CSteamTV_GetWordBans_Response = CSteamTV_GetWordBans_Response {
            results: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetWordBans_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetWordBans_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetWordBans_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetWordBans_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_JoinChat_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_JoinChat_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_JoinChat_Request.broadcast_channel_id)
    pub broadcast_channel_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_JoinChat_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_JoinChat_Request {
    fn default() -> &'a CSteamTV_JoinChat_Request {
        <CSteamTV_JoinChat_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_JoinChat_Request {
    pub fn new() -> CSteamTV_JoinChat_Request {
        ::std::default::Default::default()
    }

    // optional fixed64 broadcast_channel_id = 1;

    pub fn broadcast_channel_id(&self) -> u64 {
        self.broadcast_channel_id.unwrap_or(0)
    }

    pub fn clear_broadcast_channel_id(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_channel_id(&self) -> bool {
        self.broadcast_channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_channel_id(&mut self, v: u64) {
        self.broadcast_channel_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "broadcast_channel_id",
            |m: &CSteamTV_JoinChat_Request| { &m.broadcast_channel_id },
            |m: &mut CSteamTV_JoinChat_Request| { &mut m.broadcast_channel_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_JoinChat_Request>(
            "CSteamTV_JoinChat_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_JoinChat_Request {
    const NAME: &'static str = "CSteamTV_JoinChat_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.broadcast_channel_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast_channel_id {
            my_size += 1 + 8;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast_channel_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_JoinChat_Request {
        CSteamTV_JoinChat_Request::new()
    }

    fn clear(&mut self) {
        self.broadcast_channel_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_JoinChat_Request {
        static instance: CSteamTV_JoinChat_Request = CSteamTV_JoinChat_Request {
            broadcast_channel_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_JoinChat_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_JoinChat_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_JoinChat_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_JoinChat_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_JoinChat_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_JoinChat_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_JoinChat_Response.chat_id)
    pub chat_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_JoinChat_Response.view_url_template)
    pub view_url_template: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_JoinChat_Response.flair_group_ids)
    pub flair_group_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_JoinChat_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_JoinChat_Response {
    fn default() -> &'a CSteamTV_JoinChat_Response {
        <CSteamTV_JoinChat_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_JoinChat_Response {
    pub fn new() -> CSteamTV_JoinChat_Response {
        ::std::default::Default::default()
    }

    // optional fixed64 chat_id = 1;

    pub fn chat_id(&self) -> u64 {
        self.chat_id.unwrap_or(0)
    }

    pub fn clear_chat_id(&mut self) {
        self.chat_id = ::std::option::Option::None;
    }

    pub fn has_chat_id(&self) -> bool {
        self.chat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_id(&mut self, v: u64) {
        self.chat_id = ::std::option::Option::Some(v);
    }

    // optional string view_url_template = 2;

    pub fn view_url_template(&self) -> &str {
        match self.view_url_template.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_view_url_template(&mut self) {
        self.view_url_template = ::std::option::Option::None;
    }

    pub fn has_view_url_template(&self) -> bool {
        self.view_url_template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_url_template(&mut self, v: ::std::string::String) {
        self.view_url_template = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_view_url_template(&mut self) -> &mut ::std::string::String {
        if self.view_url_template.is_none() {
            self.view_url_template = ::std::option::Option::Some(::std::string::String::new());
        }
        self.view_url_template.as_mut().unwrap()
    }

    // Take field
    pub fn take_view_url_template(&mut self) -> ::std::string::String {
        self.view_url_template.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated uint64 flair_group_ids = 3;

    pub fn flair_group_ids(&self) -> &[u64] {
        &self.flair_group_ids
    }

    pub fn clear_flair_group_ids(&mut self) {
        self.flair_group_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_flair_group_ids(&mut self, v: ::std::vec::Vec<u64>) {
        self.flair_group_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_flair_group_ids(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.flair_group_ids
    }

    // Take field
    pub fn take_flair_group_ids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.flair_group_ids, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_id",
            |m: &CSteamTV_JoinChat_Response| { &m.chat_id },
            |m: &mut CSteamTV_JoinChat_Response| { &mut m.chat_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "view_url_template",
            |m: &CSteamTV_JoinChat_Response| { &m.view_url_template },
            |m: &mut CSteamTV_JoinChat_Response| { &mut m.view_url_template },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "flair_group_ids",
            |m: &CSteamTV_JoinChat_Response| { &m.flair_group_ids },
            |m: &mut CSteamTV_JoinChat_Response| { &mut m.flair_group_ids },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_JoinChat_Response>(
            "CSteamTV_JoinChat_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_JoinChat_Response {
    const NAME: &'static str = "CSteamTV_JoinChat_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.chat_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.view_url_template = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.flair_group_ids)?;
                },
                24 => {
                    self.flair_group_ids.push(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chat_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.view_url_template.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        for value in &self.flair_group_ids {
            my_size += crate::rt::uint64_size(3, *value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.chat_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.view_url_template.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.flair_group_ids {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_JoinChat_Response {
        CSteamTV_JoinChat_Response::new()
    }

    fn clear(&mut self) {
        self.chat_id = ::std::option::Option::None;
        self.view_url_template = ::std::option::Option::None;
        self.flair_group_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_JoinChat_Response {
        static instance: CSteamTV_JoinChat_Response = CSteamTV_JoinChat_Response {
            chat_id: ::std::option::Option::None,
            view_url_template: ::std::option::Option::None,
            flair_group_ids: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_JoinChat_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_JoinChat_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_JoinChat_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_JoinChat_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_Search_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_Search_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_Search_Request.term)
    pub term: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_Search_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_Search_Request {
    fn default() -> &'a CSteamTV_Search_Request {
        <CSteamTV_Search_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_Search_Request {
    pub fn new() -> CSteamTV_Search_Request {
        ::std::default::Default::default()
    }

    // optional string term = 1;

    pub fn term(&self) -> &str {
        match self.term.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_term(&mut self) {
        self.term = ::std::option::Option::None;
    }

    pub fn has_term(&self) -> bool {
        self.term.is_some()
    }

    // Param is passed by value, moved
    pub fn set_term(&mut self, v: ::std::string::String) {
        self.term = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_term(&mut self) -> &mut ::std::string::String {
        if self.term.is_none() {
            self.term = ::std::option::Option::Some(::std::string::String::new());
        }
        self.term.as_mut().unwrap()
    }

    // Take field
    pub fn take_term(&mut self) -> ::std::string::String {
        self.term.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "term",
            |m: &CSteamTV_Search_Request| { &m.term },
            |m: &mut CSteamTV_Search_Request| { &mut m.term },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_Search_Request>(
            "CSteamTV_Search_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_Search_Request {
    const NAME: &'static str = "CSteamTV_Search_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.term = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.term.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.term.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_Search_Request {
        CSteamTV_Search_Request::new()
    }

    fn clear(&mut self) {
        self.term = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_Search_Request {
        static instance: CSteamTV_Search_Request = CSteamTV_Search_Request {
            term: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_Search_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_Search_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_Search_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_Search_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_Search_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_Search_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_Search_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_Search_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_Search_Response {
    fn default() -> &'a CSteamTV_Search_Response {
        <CSteamTV_Search_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_Search_Response {
    pub fn new() -> CSteamTV_Search_Response {
        ::std::default::Default::default()
    }

    // repeated .GetBroadcastChannelEntry results = 1;

    pub fn results(&self) -> &[GetBroadcastChannelEntry] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CSteamTV_Search_Response| { &m.results },
            |m: &mut CSteamTV_Search_Response| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_Search_Response>(
            "CSteamTV_Search_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_Search_Response {
    const NAME: &'static str = "CSteamTV_Search_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.results {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_Search_Response {
        CSteamTV_Search_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_Search_Response {
        static instance: CSteamTV_Search_Response = CSteamTV_Search_Response {
            results: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_Search_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_Search_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_Search_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_Search_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetSteamTVUserSettings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetSteamTVUserSettings_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetSteamTVUserSettings_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetSteamTVUserSettings_Request {
    fn default() -> &'a CSteamTV_GetSteamTVUserSettings_Request {
        <CSteamTV_GetSteamTVUserSettings_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetSteamTVUserSettings_Request {
    pub fn new() -> CSteamTV_GetSteamTVUserSettings_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetSteamTVUserSettings_Request>(
            "CSteamTV_GetSteamTVUserSettings_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetSteamTVUserSettings_Request {
    const NAME: &'static str = "CSteamTV_GetSteamTVUserSettings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetSteamTVUserSettings_Request {
        CSteamTV_GetSteamTVUserSettings_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetSteamTVUserSettings_Request {
        static instance: CSteamTV_GetSteamTVUserSettings_Request = CSteamTV_GetSteamTVUserSettings_Request {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetSteamTVUserSettings_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetSteamTVUserSettings_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetSteamTVUserSettings_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetSteamTVUserSettings_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetSteamTVUserSettings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetSteamTVUserSettings_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetSteamTVUserSettings_Response.stream_live_email)
    pub stream_live_email: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_GetSteamTVUserSettings_Response.stream_live_notification)
    pub stream_live_notification: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetSteamTVUserSettings_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetSteamTVUserSettings_Response {
    fn default() -> &'a CSteamTV_GetSteamTVUserSettings_Response {
        <CSteamTV_GetSteamTVUserSettings_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetSteamTVUserSettings_Response {
    pub fn new() -> CSteamTV_GetSteamTVUserSettings_Response {
        ::std::default::Default::default()
    }

    // optional bool stream_live_email = 1;

    pub fn stream_live_email(&self) -> bool {
        self.stream_live_email.unwrap_or(false)
    }

    pub fn clear_stream_live_email(&mut self) {
        self.stream_live_email = ::std::option::Option::None;
    }

    pub fn has_stream_live_email(&self) -> bool {
        self.stream_live_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_live_email(&mut self, v: bool) {
        self.stream_live_email = ::std::option::Option::Some(v);
    }

    // optional bool stream_live_notification = 2;

    pub fn stream_live_notification(&self) -> bool {
        self.stream_live_notification.unwrap_or(false)
    }

    pub fn clear_stream_live_notification(&mut self) {
        self.stream_live_notification = ::std::option::Option::None;
    }

    pub fn has_stream_live_notification(&self) -> bool {
        self.stream_live_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_live_notification(&mut self, v: bool) {
        self.stream_live_notification = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_live_email",
            |m: &CSteamTV_GetSteamTVUserSettings_Response| { &m.stream_live_email },
            |m: &mut CSteamTV_GetSteamTVUserSettings_Response| { &mut m.stream_live_email },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_live_notification",
            |m: &CSteamTV_GetSteamTVUserSettings_Response| { &m.stream_live_notification },
            |m: &mut CSteamTV_GetSteamTVUserSettings_Response| { &mut m.stream_live_notification },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetSteamTVUserSettings_Response>(
            "CSteamTV_GetSteamTVUserSettings_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetSteamTVUserSettings_Response {
    const NAME: &'static str = "CSteamTV_GetSteamTVUserSettings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stream_live_email = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.stream_live_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stream_live_email {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stream_live_notification {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.stream_live_email {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stream_live_notification {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetSteamTVUserSettings_Response {
        CSteamTV_GetSteamTVUserSettings_Response::new()
    }

    fn clear(&mut self) {
        self.stream_live_email = ::std::option::Option::None;
        self.stream_live_notification = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetSteamTVUserSettings_Response {
        static instance: CSteamTV_GetSteamTVUserSettings_Response = CSteamTV_GetSteamTVUserSettings_Response {
            stream_live_email: ::std::option::Option::None,
            stream_live_notification: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetSteamTVUserSettings_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetSteamTVUserSettings_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetSteamTVUserSettings_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetSteamTVUserSettings_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_SetSteamTVUserSettings_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetSteamTVUserSettings_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_SetSteamTVUserSettings_Request.stream_live_email)
    pub stream_live_email: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSteamTV_SetSteamTVUserSettings_Request.stream_live_notification)
    pub stream_live_notification: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetSteamTVUserSettings_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetSteamTVUserSettings_Request {
    fn default() -> &'a CSteamTV_SetSteamTVUserSettings_Request {
        <CSteamTV_SetSteamTVUserSettings_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_SetSteamTVUserSettings_Request {
    pub fn new() -> CSteamTV_SetSteamTVUserSettings_Request {
        ::std::default::Default::default()
    }

    // optional bool stream_live_email = 1;

    pub fn stream_live_email(&self) -> bool {
        self.stream_live_email.unwrap_or(false)
    }

    pub fn clear_stream_live_email(&mut self) {
        self.stream_live_email = ::std::option::Option::None;
    }

    pub fn has_stream_live_email(&self) -> bool {
        self.stream_live_email.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_live_email(&mut self, v: bool) {
        self.stream_live_email = ::std::option::Option::Some(v);
    }

    // optional bool stream_live_notification = 2;

    pub fn stream_live_notification(&self) -> bool {
        self.stream_live_notification.unwrap_or(false)
    }

    pub fn clear_stream_live_notification(&mut self) {
        self.stream_live_notification = ::std::option::Option::None;
    }

    pub fn has_stream_live_notification(&self) -> bool {
        self.stream_live_notification.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_live_notification(&mut self, v: bool) {
        self.stream_live_notification = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_live_email",
            |m: &CSteamTV_SetSteamTVUserSettings_Request| { &m.stream_live_email },
            |m: &mut CSteamTV_SetSteamTVUserSettings_Request| { &mut m.stream_live_email },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "stream_live_notification",
            |m: &CSteamTV_SetSteamTVUserSettings_Request| { &m.stream_live_notification },
            |m: &mut CSteamTV_SetSteamTVUserSettings_Request| { &mut m.stream_live_notification },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SetSteamTVUserSettings_Request>(
            "CSteamTV_SetSteamTVUserSettings_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SetSteamTVUserSettings_Request {
    const NAME: &'static str = "CSteamTV_SetSteamTVUserSettings_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stream_live_email = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.stream_live_notification = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stream_live_email {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stream_live_notification {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.stream_live_email {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stream_live_notification {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetSteamTVUserSettings_Request {
        CSteamTV_SetSteamTVUserSettings_Request::new()
    }

    fn clear(&mut self) {
        self.stream_live_email = ::std::option::Option::None;
        self.stream_live_notification = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetSteamTVUserSettings_Request {
        static instance: CSteamTV_SetSteamTVUserSettings_Request = CSteamTV_SetSteamTVUserSettings_Request {
            stream_live_email: ::std::option::Option::None,
            stream_live_notification: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SetSteamTVUserSettings_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SetSteamTVUserSettings_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SetSteamTVUserSettings_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SetSteamTVUserSettings_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_SetSteamTVUserSettings_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_SetSteamTVUserSettings_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_SetSteamTVUserSettings_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_SetSteamTVUserSettings_Response {
    fn default() -> &'a CSteamTV_SetSteamTVUserSettings_Response {
        <CSteamTV_SetSteamTVUserSettings_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_SetSteamTVUserSettings_Response {
    pub fn new() -> CSteamTV_SetSteamTVUserSettings_Response {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_SetSteamTVUserSettings_Response>(
            "CSteamTV_SetSteamTVUserSettings_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_SetSteamTVUserSettings_Response {
    const NAME: &'static str = "CSteamTV_SetSteamTVUserSettings_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_SetSteamTVUserSettings_Response {
        CSteamTV_SetSteamTVUserSettings_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_SetSteamTVUserSettings_Response {
        static instance: CSteamTV_SetSteamTVUserSettings_Response = CSteamTV_SetSteamTVUserSettings_Response {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_SetSteamTVUserSettings_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_SetSteamTVUserSettings_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_SetSteamTVUserSettings_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_SetSteamTVUserSettings_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetMyBroadcastChannels_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetMyBroadcastChannels_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetMyBroadcastChannels_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetMyBroadcastChannels_Request {
    fn default() -> &'a CSteamTV_GetMyBroadcastChannels_Request {
        <CSteamTV_GetMyBroadcastChannels_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetMyBroadcastChannels_Request {
    pub fn new() -> CSteamTV_GetMyBroadcastChannels_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetMyBroadcastChannels_Request>(
            "CSteamTV_GetMyBroadcastChannels_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetMyBroadcastChannels_Request {
    const NAME: &'static str = "CSteamTV_GetMyBroadcastChannels_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetMyBroadcastChannels_Request {
        CSteamTV_GetMyBroadcastChannels_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetMyBroadcastChannels_Request {
        static instance: CSteamTV_GetMyBroadcastChannels_Request = CSteamTV_GetMyBroadcastChannels_Request {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetMyBroadcastChannels_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetMyBroadcastChannels_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetMyBroadcastChannels_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetMyBroadcastChannels_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetMyBroadcastChannels_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetMyBroadcastChannels_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetMyBroadcastChannels_Response.results)
    pub results: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetMyBroadcastChannels_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetMyBroadcastChannels_Response {
    fn default() -> &'a CSteamTV_GetMyBroadcastChannels_Response {
        <CSteamTV_GetMyBroadcastChannels_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetMyBroadcastChannels_Response {
    pub fn new() -> CSteamTV_GetMyBroadcastChannels_Response {
        ::std::default::Default::default()
    }

    // repeated .GetBroadcastChannelEntry results = 1;

    pub fn results(&self) -> &[GetBroadcastChannelEntry] {
        &self.results
    }

    pub fn clear_results(&mut self) {
        self.results.clear();
    }

    // Param is passed by value, moved
    pub fn set_results(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.results = v;
    }

    // Mutable pointer to the field.
    pub fn mut_results(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.results
    }

    // Take field
    pub fn take_results(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.results, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "results",
            |m: &CSteamTV_GetMyBroadcastChannels_Response| { &m.results },
            |m: &mut CSteamTV_GetMyBroadcastChannels_Response| { &mut m.results },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetMyBroadcastChannels_Response>(
            "CSteamTV_GetMyBroadcastChannels_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetMyBroadcastChannels_Response {
    const NAME: &'static str = "CSteamTV_GetMyBroadcastChannels_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.results {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetMyBroadcastChannels_Response {
        CSteamTV_GetMyBroadcastChannels_Response::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetMyBroadcastChannels_Response {
        static instance: CSteamTV_GetMyBroadcastChannels_Response = CSteamTV_GetMyBroadcastChannels_Response {
            results: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetMyBroadcastChannels_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetMyBroadcastChannels_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetMyBroadcastChannels_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetMyBroadcastChannels_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetHomePageContents_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetHomePageContents_Request {
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetHomePageContents_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetHomePageContents_Request {
    fn default() -> &'a CSteamTV_GetHomePageContents_Request {
        <CSteamTV_GetHomePageContents_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetHomePageContents_Request {
    pub fn new() -> CSteamTV_GetHomePageContents_Request {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetHomePageContents_Request>(
            "CSteamTV_GetHomePageContents_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetHomePageContents_Request {
    const NAME: &'static str = "CSteamTV_GetHomePageContents_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetHomePageContents_Request {
        CSteamTV_GetHomePageContents_Request::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetHomePageContents_Request {
        static instance: CSteamTV_GetHomePageContents_Request = CSteamTV_GetHomePageContents_Request {
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetHomePageContents_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetHomePageContents_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetHomePageContents_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetHomePageContents_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_Takeover)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_Takeover {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_Takeover.broadcasts)
    pub broadcasts: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_Takeover.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_Takeover {
    fn default() -> &'a CSteamTV_HomePageTemplate_Takeover {
        <CSteamTV_HomePageTemplate_Takeover as crate::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_Takeover {
    pub fn new() -> CSteamTV_HomePageTemplate_Takeover {
        ::std::default::Default::default()
    }

    // repeated .GetBroadcastChannelEntry broadcasts = 1;

    pub fn broadcasts(&self) -> &[GetBroadcastChannelEntry] {
        &self.broadcasts
    }

    pub fn clear_broadcasts(&mut self) {
        self.broadcasts.clear();
    }

    // Param is passed by value, moved
    pub fn set_broadcasts(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.broadcasts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_broadcasts(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.broadcasts
    }

    // Take field
    pub fn take_broadcasts(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.broadcasts, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcasts",
            |m: &CSteamTV_HomePageTemplate_Takeover| { &m.broadcasts },
            |m: &mut CSteamTV_HomePageTemplate_Takeover| { &mut m.broadcasts },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_HomePageTemplate_Takeover>(
            "CSteamTV_HomePageTemplate_Takeover",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_HomePageTemplate_Takeover {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_Takeover";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasts.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasts {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.broadcasts {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_Takeover {
        CSteamTV_HomePageTemplate_Takeover::new()
    }

    fn clear(&mut self) {
        self.broadcasts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_Takeover {
        static instance: CSteamTV_HomePageTemplate_Takeover = CSteamTV_HomePageTemplate_Takeover {
            broadcasts: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_HomePageTemplate_Takeover {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_HomePageTemplate_Takeover").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_HomePageTemplate_Takeover {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_HomePageTemplate_Takeover {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_SingleGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_SingleGame {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_SingleGame.broadcasts)
    pub broadcasts: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_SingleGame.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_SingleGame.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_SingleGame.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_SingleGame {
    fn default() -> &'a CSteamTV_HomePageTemplate_SingleGame {
        <CSteamTV_HomePageTemplate_SingleGame as crate::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_SingleGame {
    pub fn new() -> CSteamTV_HomePageTemplate_SingleGame {
        ::std::default::Default::default()
    }

    // repeated .GetBroadcastChannelEntry broadcasts = 1;

    pub fn broadcasts(&self) -> &[GetBroadcastChannelEntry] {
        &self.broadcasts
    }

    pub fn clear_broadcasts(&mut self) {
        self.broadcasts.clear();
    }

    // Param is passed by value, moved
    pub fn set_broadcasts(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.broadcasts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_broadcasts(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.broadcasts
    }

    // Take field
    pub fn take_broadcasts(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.broadcasts, ::std::vec::Vec::new())
    }

    // optional uint32 appid = 2;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string title = 3;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcasts",
            |m: &CSteamTV_HomePageTemplate_SingleGame| { &m.broadcasts },
            |m: &mut CSteamTV_HomePageTemplate_SingleGame| { &mut m.broadcasts },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &CSteamTV_HomePageTemplate_SingleGame| { &m.appid },
            |m: &mut CSteamTV_HomePageTemplate_SingleGame| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CSteamTV_HomePageTemplate_SingleGame| { &m.title },
            |m: &mut CSteamTV_HomePageTemplate_SingleGame| { &mut m.title },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_HomePageTemplate_SingleGame>(
            "CSteamTV_HomePageTemplate_SingleGame",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_HomePageTemplate_SingleGame {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_SingleGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasts.push(is.read_message()?);
                },
                16 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasts {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(2, v);
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.broadcasts {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.appid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_SingleGame {
        CSteamTV_HomePageTemplate_SingleGame::new()
    }

    fn clear(&mut self) {
        self.broadcasts.clear();
        self.appid = ::std::option::Option::None;
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_SingleGame {
        static instance: CSteamTV_HomePageTemplate_SingleGame = CSteamTV_HomePageTemplate_SingleGame {
            broadcasts: ::std::vec::Vec::new(),
            appid: ::std::option::Option::None,
            title: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_HomePageTemplate_SingleGame {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_HomePageTemplate_SingleGame").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_HomePageTemplate_SingleGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_HomePageTemplate_SingleGame {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GameListEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GameListEntry {
    // message fields
    // @@protoc_insertion_point(field:GameListEntry.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GameListEntry.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GameListEntry.broadcast)
    pub broadcast: crate::MessageField<GetBroadcastChannelEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:GameListEntry.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GameListEntry {
    fn default() -> &'a GameListEntry {
        <GameListEntry as crate::Message>::default_instance()
    }
}

impl GameListEntry {
    pub fn new() -> GameListEntry {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string game_name = 2;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .GetBroadcastChannelEntry broadcast = 3;

    pub fn broadcast(&self) -> &GetBroadcastChannelEntry {
        self.broadcast.as_ref().unwrap_or_else(|| <GetBroadcastChannelEntry as crate::Message>::default_instance())
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast.clear();
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: GetBroadcastChannelEntry) {
        self.broadcast = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_broadcast(&mut self) -> &mut GetBroadcastChannelEntry {
        self.broadcast.mut_or_insert_default()
    }

    // Take field
    pub fn take_broadcast(&mut self) -> GetBroadcastChannelEntry {
        self.broadcast.take().unwrap_or_else(|| GetBroadcastChannelEntry::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "appid",
            |m: &GameListEntry| { &m.appid },
            |m: &mut GameListEntry| { &mut m.appid },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_name",
            |m: &GameListEntry| { &m.game_name },
            |m: &mut GameListEntry| { &mut m.game_name },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, GetBroadcastChannelEntry>(
            "broadcast",
            |m: &GameListEntry| { &m.broadcast },
            |m: &mut GameListEntry| { &mut m.broadcast },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<GameListEntry>(
            "GameListEntry",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for GameListEntry {
    const NAME: &'static str = "GameListEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.broadcast)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.broadcast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.broadcast.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GameListEntry {
        GameListEntry::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.broadcast.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GameListEntry {
        static instance: GameListEntry = GameListEntry {
            appid: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            broadcast: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for GameListEntry {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GameListEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GameListEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for GameListEntry {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_GameList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_GameList {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_GameList.entries)
    pub entries: ::std::vec::Vec<GameListEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_GameList.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_GameList.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_GameList {
    fn default() -> &'a CSteamTV_HomePageTemplate_GameList {
        <CSteamTV_HomePageTemplate_GameList as crate::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_GameList {
    pub fn new() -> CSteamTV_HomePageTemplate_GameList {
        ::std::default::Default::default()
    }

    // repeated .GameListEntry entries = 1;

    pub fn entries(&self) -> &[GameListEntry] {
        &self.entries
    }

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::std::vec::Vec<GameListEntry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::std::vec::Vec<GameListEntry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::std::vec::Vec<GameListEntry> {
        ::std::mem::replace(&mut self.entries, ::std::vec::Vec::new())
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CSteamTV_HomePageTemplate_GameList| { &m.entries },
            |m: &mut CSteamTV_HomePageTemplate_GameList| { &mut m.entries },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CSteamTV_HomePageTemplate_GameList| { &m.title },
            |m: &mut CSteamTV_HomePageTemplate_GameList| { &mut m.title },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_HomePageTemplate_GameList>(
            "CSteamTV_HomePageTemplate_GameList",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_HomePageTemplate_GameList {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_GameList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entries.push(is.read_message()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.entries {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_GameList {
        CSteamTV_HomePageTemplate_GameList::new()
    }

    fn clear(&mut self) {
        self.entries.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_GameList {
        static instance: CSteamTV_HomePageTemplate_GameList = CSteamTV_HomePageTemplate_GameList {
            entries: ::std::vec::Vec::new(),
            title: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_HomePageTemplate_GameList {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_HomePageTemplate_GameList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_HomePageTemplate_GameList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_HomePageTemplate_GameList {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_QuickExplore)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_QuickExplore {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_QuickExplore.broadcasts)
    pub broadcasts: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_QuickExplore.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_QuickExplore.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_QuickExplore {
    fn default() -> &'a CSteamTV_HomePageTemplate_QuickExplore {
        <CSteamTV_HomePageTemplate_QuickExplore as crate::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_QuickExplore {
    pub fn new() -> CSteamTV_HomePageTemplate_QuickExplore {
        ::std::default::Default::default()
    }

    // repeated .GetBroadcastChannelEntry broadcasts = 1;

    pub fn broadcasts(&self) -> &[GetBroadcastChannelEntry] {
        &self.broadcasts
    }

    pub fn clear_broadcasts(&mut self) {
        self.broadcasts.clear();
    }

    // Param is passed by value, moved
    pub fn set_broadcasts(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.broadcasts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_broadcasts(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.broadcasts
    }

    // Take field
    pub fn take_broadcasts(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.broadcasts, ::std::vec::Vec::new())
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcasts",
            |m: &CSteamTV_HomePageTemplate_QuickExplore| { &m.broadcasts },
            |m: &mut CSteamTV_HomePageTemplate_QuickExplore| { &mut m.broadcasts },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CSteamTV_HomePageTemplate_QuickExplore| { &m.title },
            |m: &mut CSteamTV_HomePageTemplate_QuickExplore| { &mut m.title },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_HomePageTemplate_QuickExplore>(
            "CSteamTV_HomePageTemplate_QuickExplore",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_HomePageTemplate_QuickExplore {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_QuickExplore";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasts.push(is.read_message()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasts {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.broadcasts {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_QuickExplore {
        CSteamTV_HomePageTemplate_QuickExplore::new()
    }

    fn clear(&mut self) {
        self.broadcasts.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_QuickExplore {
        static instance: CSteamTV_HomePageTemplate_QuickExplore = CSteamTV_HomePageTemplate_QuickExplore {
            broadcasts: ::std::vec::Vec::new(),
            title: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_HomePageTemplate_QuickExplore {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_HomePageTemplate_QuickExplore").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_HomePageTemplate_QuickExplore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_HomePageTemplate_QuickExplore {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_ConveyorBelt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_ConveyorBelt {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_ConveyorBelt.broadcasts)
    pub broadcasts: ::std::vec::Vec<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_ConveyorBelt.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_ConveyorBelt.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_ConveyorBelt {
    fn default() -> &'a CSteamTV_HomePageTemplate_ConveyorBelt {
        <CSteamTV_HomePageTemplate_ConveyorBelt as crate::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_ConveyorBelt {
    pub fn new() -> CSteamTV_HomePageTemplate_ConveyorBelt {
        ::std::default::Default::default()
    }

    // repeated .GetBroadcastChannelEntry broadcasts = 1;

    pub fn broadcasts(&self) -> &[GetBroadcastChannelEntry] {
        &self.broadcasts
    }

    pub fn clear_broadcasts(&mut self) {
        self.broadcasts.clear();
    }

    // Param is passed by value, moved
    pub fn set_broadcasts(&mut self, v: ::std::vec::Vec<GetBroadcastChannelEntry>) {
        self.broadcasts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_broadcasts(&mut self) -> &mut ::std::vec::Vec<GetBroadcastChannelEntry> {
        &mut self.broadcasts
    }

    // Take field
    pub fn take_broadcasts(&mut self) -> ::std::vec::Vec<GetBroadcastChannelEntry> {
        ::std::mem::replace(&mut self.broadcasts, ::std::vec::Vec::new())
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "broadcasts",
            |m: &CSteamTV_HomePageTemplate_ConveyorBelt| { &m.broadcasts },
            |m: &mut CSteamTV_HomePageTemplate_ConveyorBelt| { &mut m.broadcasts },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CSteamTV_HomePageTemplate_ConveyorBelt| { &m.title },
            |m: &mut CSteamTV_HomePageTemplate_ConveyorBelt| { &mut m.title },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_HomePageTemplate_ConveyorBelt>(
            "CSteamTV_HomePageTemplate_ConveyorBelt",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_HomePageTemplate_ConveyorBelt {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_ConveyorBelt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.broadcasts.push(is.read_message()?);
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.broadcasts {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.broadcasts {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_ConveyorBelt {
        CSteamTV_HomePageTemplate_ConveyorBelt::new()
    }

    fn clear(&mut self) {
        self.broadcasts.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_ConveyorBelt {
        static instance: CSteamTV_HomePageTemplate_ConveyorBelt = CSteamTV_HomePageTemplate_ConveyorBelt {
            broadcasts: ::std::vec::Vec::new(),
            title: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_HomePageTemplate_ConveyorBelt {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_HomePageTemplate_ConveyorBelt").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_HomePageTemplate_ConveyorBelt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_HomePageTemplate_ConveyorBelt {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_WatchParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_WatchParty {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_WatchParty.broadcast)
    pub broadcast: crate::MessageField<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_WatchParty.title)
    pub title: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_WatchParty.chat_group_id)
    pub chat_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_WatchParty.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_WatchParty {
    fn default() -> &'a CSteamTV_HomePageTemplate_WatchParty {
        <CSteamTV_HomePageTemplate_WatchParty as crate::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_WatchParty {
    pub fn new() -> CSteamTV_HomePageTemplate_WatchParty {
        ::std::default::Default::default()
    }

    // optional .GetBroadcastChannelEntry broadcast = 1;

    pub fn broadcast(&self) -> &GetBroadcastChannelEntry {
        self.broadcast.as_ref().unwrap_or_else(|| <GetBroadcastChannelEntry as crate::Message>::default_instance())
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast.clear();
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: GetBroadcastChannelEntry) {
        self.broadcast = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_broadcast(&mut self) -> &mut GetBroadcastChannelEntry {
        self.broadcast.mut_or_insert_default()
    }

    // Take field
    pub fn take_broadcast(&mut self) -> GetBroadcastChannelEntry {
        self.broadcast.take().unwrap_or_else(|| GetBroadcastChannelEntry::new())
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 chat_group_id = 3;

    pub fn chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }

    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, GetBroadcastChannelEntry>(
            "broadcast",
            |m: &CSteamTV_HomePageTemplate_WatchParty| { &m.broadcast },
            |m: &mut CSteamTV_HomePageTemplate_WatchParty| { &mut m.broadcast },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CSteamTV_HomePageTemplate_WatchParty| { &m.title },
            |m: &mut CSteamTV_HomePageTemplate_WatchParty| { &mut m.title },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat_group_id",
            |m: &CSteamTV_HomePageTemplate_WatchParty| { &m.chat_group_id },
            |m: &mut CSteamTV_HomePageTemplate_WatchParty| { &mut m.chat_group_id },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_HomePageTemplate_WatchParty>(
            "CSteamTV_HomePageTemplate_WatchParty",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_HomePageTemplate_WatchParty {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_WatchParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.broadcast)?;
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.chat_group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat_group_id {
            my_size += crate::rt::uint64_size(3, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_WatchParty {
        CSteamTV_HomePageTemplate_WatchParty::new()
    }

    fn clear(&mut self) {
        self.broadcast.clear();
        self.title = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_WatchParty {
        static instance: CSteamTV_HomePageTemplate_WatchParty = CSteamTV_HomePageTemplate_WatchParty {
            broadcast: crate::MessageField::none(),
            title: ::std::option::Option::None,
            chat_group_id: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_HomePageTemplate_WatchParty {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_HomePageTemplate_WatchParty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_HomePageTemplate_WatchParty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_HomePageTemplate_WatchParty {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_Developer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_Developer {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_Developer.broadcast)
    pub broadcast: crate::MessageField<GetBroadcastChannelEntry>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_Developer.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_Developer.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_Developer {
    fn default() -> &'a CSteamTV_HomePageTemplate_Developer {
        <CSteamTV_HomePageTemplate_Developer as crate::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_Developer {
    pub fn new() -> CSteamTV_HomePageTemplate_Developer {
        ::std::default::Default::default()
    }

    // optional .GetBroadcastChannelEntry broadcast = 1;

    pub fn broadcast(&self) -> &GetBroadcastChannelEntry {
        self.broadcast.as_ref().unwrap_or_else(|| <GetBroadcastChannelEntry as crate::Message>::default_instance())
    }

    pub fn clear_broadcast(&mut self) {
        self.broadcast.clear();
    }

    pub fn has_broadcast(&self) -> bool {
        self.broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast(&mut self, v: GetBroadcastChannelEntry) {
        self.broadcast = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_broadcast(&mut self) -> &mut GetBroadcastChannelEntry {
        self.broadcast.mut_or_insert_default()
    }

    // Take field
    pub fn take_broadcast(&mut self) -> GetBroadcastChannelEntry {
        self.broadcast.take().unwrap_or_else(|| GetBroadcastChannelEntry::new())
    }

    // optional string title = 2;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, GetBroadcastChannelEntry>(
            "broadcast",
            |m: &CSteamTV_HomePageTemplate_Developer| { &m.broadcast },
            |m: &mut CSteamTV_HomePageTemplate_Developer| { &mut m.broadcast },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CSteamTV_HomePageTemplate_Developer| { &m.title },
            |m: &mut CSteamTV_HomePageTemplate_Developer| { &mut m.title },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_HomePageTemplate_Developer>(
            "CSteamTV_HomePageTemplate_Developer",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_HomePageTemplate_Developer {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_Developer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.broadcast)?;
                },
                18 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.broadcast.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.broadcast.as_ref() {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.title.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_Developer {
        CSteamTV_HomePageTemplate_Developer::new()
    }

    fn clear(&mut self) {
        self.broadcast.clear();
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_Developer {
        static instance: CSteamTV_HomePageTemplate_Developer = CSteamTV_HomePageTemplate_Developer {
            broadcast: crate::MessageField::none(),
            title: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_HomePageTemplate_Developer {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_HomePageTemplate_Developer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_HomePageTemplate_Developer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_HomePageTemplate_Developer {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_HomePageTemplate_Event)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageTemplate_Event {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageTemplate_Event.title)
    pub title: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageTemplate_Event.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageTemplate_Event {
    fn default() -> &'a CSteamTV_HomePageTemplate_Event {
        <CSteamTV_HomePageTemplate_Event as crate::Message>::default_instance()
    }
}

impl CSteamTV_HomePageTemplate_Event {
    pub fn new() -> CSteamTV_HomePageTemplate_Event {
        ::std::default::Default::default()
    }

    // optional string title = 1;

    pub fn title(&self) -> &str {
        match self.title.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_title(&mut self) {
        self.title = ::std::option::Option::None;
    }

    pub fn has_title(&self) -> bool {
        self.title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_title(&mut self, v: ::std::string::String) {
        self.title = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_title(&mut self) -> &mut ::std::string::String {
        if self.title.is_none() {
            self.title = ::std::option::Option::Some(::std::string::String::new());
        }
        self.title.as_mut().unwrap()
    }

    // Take field
    pub fn take_title(&mut self) -> ::std::string::String {
        self.title.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "title",
            |m: &CSteamTV_HomePageTemplate_Event| { &m.title },
            |m: &mut CSteamTV_HomePageTemplate_Event| { &mut m.title },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_HomePageTemplate_Event>(
            "CSteamTV_HomePageTemplate_Event",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_HomePageTemplate_Event {
    const NAME: &'static str = "CSteamTV_HomePageTemplate_Event";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.title = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.title.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.title.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageTemplate_Event {
        CSteamTV_HomePageTemplate_Event::new()
    }

    fn clear(&mut self) {
        self.title = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageTemplate_Event {
        static instance: CSteamTV_HomePageTemplate_Event = CSteamTV_HomePageTemplate_Event {
            title: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_HomePageTemplate_Event {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_HomePageTemplate_Event").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_HomePageTemplate_Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_HomePageTemplate_Event {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_HomePageContentRow)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_HomePageContentRow {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.template_type)
    pub template_type: ::std::option::Option<crate::EnumOrUnknown<ESteamTVContentTemplate>>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.takeover)
    pub takeover: crate::MessageField<CSteamTV_HomePageTemplate_Takeover>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.single_game)
    pub single_game: crate::MessageField<CSteamTV_HomePageTemplate_SingleGame>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.game_list)
    pub game_list: crate::MessageField<CSteamTV_HomePageTemplate_GameList>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.quick_explore)
    pub quick_explore: crate::MessageField<CSteamTV_HomePageTemplate_QuickExplore>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.conveyor_belt)
    pub conveyor_belt: crate::MessageField<CSteamTV_HomePageTemplate_ConveyorBelt>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.watch_party)
    pub watch_party: crate::MessageField<CSteamTV_HomePageTemplate_WatchParty>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.developer)
    pub developer: crate::MessageField<CSteamTV_HomePageTemplate_Developer>,
    // @@protoc_insertion_point(field:CSteamTV_HomePageContentRow.event)
    pub event: crate::MessageField<CSteamTV_HomePageTemplate_Event>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_HomePageContentRow.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_HomePageContentRow {
    fn default() -> &'a CSteamTV_HomePageContentRow {
        <CSteamTV_HomePageContentRow as crate::Message>::default_instance()
    }
}

impl CSteamTV_HomePageContentRow {
    pub fn new() -> CSteamTV_HomePageContentRow {
        ::std::default::Default::default()
    }

    // optional .ESteamTVContentTemplate template_type = 1;

    pub fn template_type(&self) -> ESteamTVContentTemplate {
        match self.template_type {
            Some(e) => e.enum_value_or(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid),
            None => ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid,
        }
    }

    pub fn clear_template_type(&mut self) {
        self.template_type = ::std::option::Option::None;
    }

    pub fn has_template_type(&self) -> bool {
        self.template_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template_type(&mut self, v: ESteamTVContentTemplate) {
        self.template_type = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .CSteamTV_HomePageTemplate_Takeover takeover = 2;

    pub fn takeover(&self) -> &CSteamTV_HomePageTemplate_Takeover {
        self.takeover.as_ref().unwrap_or_else(|| <CSteamTV_HomePageTemplate_Takeover as crate::Message>::default_instance())
    }

    pub fn clear_takeover(&mut self) {
        self.takeover.clear();
    }

    pub fn has_takeover(&self) -> bool {
        self.takeover.is_some()
    }

    // Param is passed by value, moved
    pub fn set_takeover(&mut self, v: CSteamTV_HomePageTemplate_Takeover) {
        self.takeover = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_takeover(&mut self) -> &mut CSteamTV_HomePageTemplate_Takeover {
        self.takeover.mut_or_insert_default()
    }

    // Take field
    pub fn take_takeover(&mut self) -> CSteamTV_HomePageTemplate_Takeover {
        self.takeover.take().unwrap_or_else(|| CSteamTV_HomePageTemplate_Takeover::new())
    }

    // optional .CSteamTV_HomePageTemplate_SingleGame single_game = 3;

    pub fn single_game(&self) -> &CSteamTV_HomePageTemplate_SingleGame {
        self.single_game.as_ref().unwrap_or_else(|| <CSteamTV_HomePageTemplate_SingleGame as crate::Message>::default_instance())
    }

    pub fn clear_single_game(&mut self) {
        self.single_game.clear();
    }

    pub fn has_single_game(&self) -> bool {
        self.single_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_single_game(&mut self, v: CSteamTV_HomePageTemplate_SingleGame) {
        self.single_game = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_single_game(&mut self) -> &mut CSteamTV_HomePageTemplate_SingleGame {
        self.single_game.mut_or_insert_default()
    }

    // Take field
    pub fn take_single_game(&mut self) -> CSteamTV_HomePageTemplate_SingleGame {
        self.single_game.take().unwrap_or_else(|| CSteamTV_HomePageTemplate_SingleGame::new())
    }

    // optional .CSteamTV_HomePageTemplate_GameList game_list = 4;

    pub fn game_list(&self) -> &CSteamTV_HomePageTemplate_GameList {
        self.game_list.as_ref().unwrap_or_else(|| <CSteamTV_HomePageTemplate_GameList as crate::Message>::default_instance())
    }

    pub fn clear_game_list(&mut self) {
        self.game_list.clear();
    }

    pub fn has_game_list(&self) -> bool {
        self.game_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_list(&mut self, v: CSteamTV_HomePageTemplate_GameList) {
        self.game_list = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_list(&mut self) -> &mut CSteamTV_HomePageTemplate_GameList {
        self.game_list.mut_or_insert_default()
    }

    // Take field
    pub fn take_game_list(&mut self) -> CSteamTV_HomePageTemplate_GameList {
        self.game_list.take().unwrap_or_else(|| CSteamTV_HomePageTemplate_GameList::new())
    }

    // optional .CSteamTV_HomePageTemplate_QuickExplore quick_explore = 5;

    pub fn quick_explore(&self) -> &CSteamTV_HomePageTemplate_QuickExplore {
        self.quick_explore.as_ref().unwrap_or_else(|| <CSteamTV_HomePageTemplate_QuickExplore as crate::Message>::default_instance())
    }

    pub fn clear_quick_explore(&mut self) {
        self.quick_explore.clear();
    }

    pub fn has_quick_explore(&self) -> bool {
        self.quick_explore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quick_explore(&mut self, v: CSteamTV_HomePageTemplate_QuickExplore) {
        self.quick_explore = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quick_explore(&mut self) -> &mut CSteamTV_HomePageTemplate_QuickExplore {
        self.quick_explore.mut_or_insert_default()
    }

    // Take field
    pub fn take_quick_explore(&mut self) -> CSteamTV_HomePageTemplate_QuickExplore {
        self.quick_explore.take().unwrap_or_else(|| CSteamTV_HomePageTemplate_QuickExplore::new())
    }

    // optional .CSteamTV_HomePageTemplate_ConveyorBelt conveyor_belt = 6;

    pub fn conveyor_belt(&self) -> &CSteamTV_HomePageTemplate_ConveyorBelt {
        self.conveyor_belt.as_ref().unwrap_or_else(|| <CSteamTV_HomePageTemplate_ConveyorBelt as crate::Message>::default_instance())
    }

    pub fn clear_conveyor_belt(&mut self) {
        self.conveyor_belt.clear();
    }

    pub fn has_conveyor_belt(&self) -> bool {
        self.conveyor_belt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conveyor_belt(&mut self, v: CSteamTV_HomePageTemplate_ConveyorBelt) {
        self.conveyor_belt = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conveyor_belt(&mut self) -> &mut CSteamTV_HomePageTemplate_ConveyorBelt {
        self.conveyor_belt.mut_or_insert_default()
    }

    // Take field
    pub fn take_conveyor_belt(&mut self) -> CSteamTV_HomePageTemplate_ConveyorBelt {
        self.conveyor_belt.take().unwrap_or_else(|| CSteamTV_HomePageTemplate_ConveyorBelt::new())
    }

    // optional .CSteamTV_HomePageTemplate_WatchParty watch_party = 7;

    pub fn watch_party(&self) -> &CSteamTV_HomePageTemplate_WatchParty {
        self.watch_party.as_ref().unwrap_or_else(|| <CSteamTV_HomePageTemplate_WatchParty as crate::Message>::default_instance())
    }

    pub fn clear_watch_party(&mut self) {
        self.watch_party.clear();
    }

    pub fn has_watch_party(&self) -> bool {
        self.watch_party.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch_party(&mut self, v: CSteamTV_HomePageTemplate_WatchParty) {
        self.watch_party = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watch_party(&mut self) -> &mut CSteamTV_HomePageTemplate_WatchParty {
        self.watch_party.mut_or_insert_default()
    }

    // Take field
    pub fn take_watch_party(&mut self) -> CSteamTV_HomePageTemplate_WatchParty {
        self.watch_party.take().unwrap_or_else(|| CSteamTV_HomePageTemplate_WatchParty::new())
    }

    // optional .CSteamTV_HomePageTemplate_Developer developer = 8;

    pub fn developer(&self) -> &CSteamTV_HomePageTemplate_Developer {
        self.developer.as_ref().unwrap_or_else(|| <CSteamTV_HomePageTemplate_Developer as crate::Message>::default_instance())
    }

    pub fn clear_developer(&mut self) {
        self.developer.clear();
    }

    pub fn has_developer(&self) -> bool {
        self.developer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_developer(&mut self, v: CSteamTV_HomePageTemplate_Developer) {
        self.developer = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_developer(&mut self) -> &mut CSteamTV_HomePageTemplate_Developer {
        self.developer.mut_or_insert_default()
    }

    // Take field
    pub fn take_developer(&mut self) -> CSteamTV_HomePageTemplate_Developer {
        self.developer.take().unwrap_or_else(|| CSteamTV_HomePageTemplate_Developer::new())
    }

    // optional .CSteamTV_HomePageTemplate_Event event = 9;

    pub fn event(&self) -> &CSteamTV_HomePageTemplate_Event {
        self.event.as_ref().unwrap_or_else(|| <CSteamTV_HomePageTemplate_Event as crate::Message>::default_instance())
    }

    pub fn clear_event(&mut self) {
        self.event.clear();
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: CSteamTV_HomePageTemplate_Event) {
        self.event = crate::MessageField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event(&mut self) -> &mut CSteamTV_HomePageTemplate_Event {
        self.event.mut_or_insert_default()
    }

    // Take field
    pub fn take_event(&mut self) -> CSteamTV_HomePageTemplate_Event {
        self.event.take().unwrap_or_else(|| CSteamTV_HomePageTemplate_Event::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "template_type",
            |m: &CSteamTV_HomePageContentRow| { &m.template_type },
            |m: &mut CSteamTV_HomePageContentRow| { &mut m.template_type },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CSteamTV_HomePageTemplate_Takeover>(
            "takeover",
            |m: &CSteamTV_HomePageContentRow| { &m.takeover },
            |m: &mut CSteamTV_HomePageContentRow| { &mut m.takeover },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CSteamTV_HomePageTemplate_SingleGame>(
            "single_game",
            |m: &CSteamTV_HomePageContentRow| { &m.single_game },
            |m: &mut CSteamTV_HomePageContentRow| { &mut m.single_game },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CSteamTV_HomePageTemplate_GameList>(
            "game_list",
            |m: &CSteamTV_HomePageContentRow| { &m.game_list },
            |m: &mut CSteamTV_HomePageContentRow| { &mut m.game_list },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CSteamTV_HomePageTemplate_QuickExplore>(
            "quick_explore",
            |m: &CSteamTV_HomePageContentRow| { &m.quick_explore },
            |m: &mut CSteamTV_HomePageContentRow| { &mut m.quick_explore },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CSteamTV_HomePageTemplate_ConveyorBelt>(
            "conveyor_belt",
            |m: &CSteamTV_HomePageContentRow| { &m.conveyor_belt },
            |m: &mut CSteamTV_HomePageContentRow| { &mut m.conveyor_belt },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CSteamTV_HomePageTemplate_WatchParty>(
            "watch_party",
            |m: &CSteamTV_HomePageContentRow| { &m.watch_party },
            |m: &mut CSteamTV_HomePageContentRow| { &mut m.watch_party },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CSteamTV_HomePageTemplate_Developer>(
            "developer",
            |m: &CSteamTV_HomePageContentRow| { &m.developer },
            |m: &mut CSteamTV_HomePageContentRow| { &mut m.developer },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, CSteamTV_HomePageTemplate_Event>(
            "event",
            |m: &CSteamTV_HomePageContentRow| { &m.event },
            |m: &mut CSteamTV_HomePageContentRow| { &mut m.event },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_HomePageContentRow>(
            "CSteamTV_HomePageContentRow",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_HomePageContentRow {
    const NAME: &'static str = "CSteamTV_HomePageContentRow";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.template_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.takeover)?;
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.single_game)?;
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.game_list)?;
                },
                42 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.quick_explore)?;
                },
                50 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.conveyor_belt)?;
                },
                58 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.watch_party)?;
                },
                66 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.developer)?;
                },
                74 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.event)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.template_type {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.takeover.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.single_game.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_list.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quick_explore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.conveyor_belt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.watch_party.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.developer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.template_type {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.takeover.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.single_game.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.game_list.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.quick_explore.as_ref() {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.conveyor_belt.as_ref() {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.watch_party.as_ref() {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.developer.as_ref() {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.event.as_ref() {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_HomePageContentRow {
        CSteamTV_HomePageContentRow::new()
    }

    fn clear(&mut self) {
        self.template_type = ::std::option::Option::None;
        self.takeover.clear();
        self.single_game.clear();
        self.game_list.clear();
        self.quick_explore.clear();
        self.conveyor_belt.clear();
        self.watch_party.clear();
        self.developer.clear();
        self.event.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_HomePageContentRow {
        static instance: CSteamTV_HomePageContentRow = CSteamTV_HomePageContentRow {
            template_type: ::std::option::Option::None,
            takeover: crate::MessageField::none(),
            single_game: crate::MessageField::none(),
            game_list: crate::MessageField::none(),
            quick_explore: crate::MessageField::none(),
            conveyor_belt: crate::MessageField::none(),
            watch_party: crate::MessageField::none(),
            developer: crate::MessageField::none(),
            event: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_HomePageContentRow {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_HomePageContentRow").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_HomePageContentRow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_HomePageContentRow {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_GetHomePageContents_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_GetHomePageContents_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_GetHomePageContents_Response.rows)
    pub rows: ::std::vec::Vec<CSteamTV_HomePageContentRow>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_GetHomePageContents_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_GetHomePageContents_Response {
    fn default() -> &'a CSteamTV_GetHomePageContents_Response {
        <CSteamTV_GetHomePageContents_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_GetHomePageContents_Response {
    pub fn new() -> CSteamTV_GetHomePageContents_Response {
        ::std::default::Default::default()
    }

    // repeated .CSteamTV_HomePageContentRow rows = 1;

    pub fn rows(&self) -> &[CSteamTV_HomePageContentRow] {
        &self.rows
    }

    pub fn clear_rows(&mut self) {
        self.rows.clear();
    }

    // Param is passed by value, moved
    pub fn set_rows(&mut self, v: ::std::vec::Vec<CSteamTV_HomePageContentRow>) {
        self.rows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rows(&mut self) -> &mut ::std::vec::Vec<CSteamTV_HomePageContentRow> {
        &mut self.rows
    }

    // Take field
    pub fn take_rows(&mut self) -> ::std::vec::Vec<CSteamTV_HomePageContentRow> {
        ::std::mem::replace(&mut self.rows, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rows",
            |m: &CSteamTV_GetHomePageContents_Response| { &m.rows },
            |m: &mut CSteamTV_GetHomePageContents_Response| { &mut m.rows },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_GetHomePageContents_Response>(
            "CSteamTV_GetHomePageContents_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_GetHomePageContents_Response {
    const NAME: &'static str = "CSteamTV_GetHomePageContents_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rows.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rows {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.rows {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_GetHomePageContents_Response {
        CSteamTV_GetHomePageContents_Response::new()
    }

    fn clear(&mut self) {
        self.rows.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_GetHomePageContents_Response {
        static instance: CSteamTV_GetHomePageContents_Response = CSteamTV_GetHomePageContents_Response {
            rows: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_GetHomePageContents_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_GetHomePageContents_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_GetHomePageContents_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_GetHomePageContents_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_AppCheer_SingleCheerType)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AppCheer_SingleCheerType {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_SingleCheerType.cheer_type)
    pub cheer_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_SingleCheerType.cheer_amount)
    pub cheer_amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AppCheer_SingleCheerType.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AppCheer_SingleCheerType {
    fn default() -> &'a CSteamTV_AppCheer_SingleCheerType {
        <CSteamTV_AppCheer_SingleCheerType as crate::Message>::default_instance()
    }
}

impl CSteamTV_AppCheer_SingleCheerType {
    pub fn new() -> CSteamTV_AppCheer_SingleCheerType {
        ::std::default::Default::default()
    }

    // optional uint32 cheer_type = 1;

    pub fn cheer_type(&self) -> u32 {
        self.cheer_type.unwrap_or(0)
    }

    pub fn clear_cheer_type(&mut self) {
        self.cheer_type = ::std::option::Option::None;
    }

    pub fn has_cheer_type(&self) -> bool {
        self.cheer_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_type(&mut self, v: u32) {
        self.cheer_type = ::std::option::Option::Some(v);
    }

    // optional uint32 cheer_amount = 2;

    pub fn cheer_amount(&self) -> u32 {
        self.cheer_amount.unwrap_or(0)
    }

    pub fn clear_cheer_amount(&mut self) {
        self.cheer_amount = ::std::option::Option::None;
    }

    pub fn has_cheer_amount(&self) -> bool {
        self.cheer_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_amount(&mut self, v: u32) {
        self.cheer_amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_type",
            |m: &CSteamTV_AppCheer_SingleCheerType| { &m.cheer_type },
            |m: &mut CSteamTV_AppCheer_SingleCheerType| { &mut m.cheer_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_amount",
            |m: &CSteamTV_AppCheer_SingleCheerType| { &m.cheer_amount },
            |m: &mut CSteamTV_AppCheer_SingleCheerType| { &mut m.cheer_amount },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_AppCheer_SingleCheerType>(
            "CSteamTV_AppCheer_SingleCheerType",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_AppCheer_SingleCheerType {
    const NAME: &'static str = "CSteamTV_AppCheer_SingleCheerType";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cheer_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cheer_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheer_type {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cheer_amount {
            my_size += crate::rt::uint32_size(2, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.cheer_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cheer_amount {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AppCheer_SingleCheerType {
        CSteamTV_AppCheer_SingleCheerType::new()
    }

    fn clear(&mut self) {
        self.cheer_type = ::std::option::Option::None;
        self.cheer_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AppCheer_SingleCheerType {
        static instance: CSteamTV_AppCheer_SingleCheerType = CSteamTV_AppCheer_SingleCheerType {
            cheer_type: ::std::option::Option::None,
            cheer_amount: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_AppCheer_SingleCheerType {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_AppCheer_SingleCheerType").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_AppCheer_SingleCheerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_AppCheer_SingleCheerType {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_AppCheer_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AppCheer_Request {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_Request.app_id)
    pub app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_Request.cheer_target_id)
    pub cheer_target_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_Request.cheers)
    pub cheers: ::std::vec::Vec<CSteamTV_AppCheer_SingleCheerType>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AppCheer_Request.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AppCheer_Request {
    fn default() -> &'a CSteamTV_AppCheer_Request {
        <CSteamTV_AppCheer_Request as crate::Message>::default_instance()
    }
}

impl CSteamTV_AppCheer_Request {
    pub fn new() -> CSteamTV_AppCheer_Request {
        ::std::default::Default::default()
    }

    // optional uint32 app_id = 1;

    pub fn app_id(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 cheer_target_id = 2;

    pub fn cheer_target_id(&self) -> u64 {
        self.cheer_target_id.unwrap_or(0)
    }

    pub fn clear_cheer_target_id(&mut self) {
        self.cheer_target_id = ::std::option::Option::None;
    }

    pub fn has_cheer_target_id(&self) -> bool {
        self.cheer_target_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_target_id(&mut self, v: u64) {
        self.cheer_target_id = ::std::option::Option::Some(v);
    }

    // repeated .CSteamTV_AppCheer_SingleCheerType cheers = 3;

    pub fn cheers(&self) -> &[CSteamTV_AppCheer_SingleCheerType] {
        &self.cheers
    }

    pub fn clear_cheers(&mut self) {
        self.cheers.clear();
    }

    // Param is passed by value, moved
    pub fn set_cheers(&mut self, v: ::std::vec::Vec<CSteamTV_AppCheer_SingleCheerType>) {
        self.cheers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cheers(&mut self) -> &mut ::std::vec::Vec<CSteamTV_AppCheer_SingleCheerType> {
        &mut self.cheers
    }

    // Take field
    pub fn take_cheers(&mut self) -> ::std::vec::Vec<CSteamTV_AppCheer_SingleCheerType> {
        ::std::mem::replace(&mut self.cheers, ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "app_id",
            |m: &CSteamTV_AppCheer_Request| { &m.app_id },
            |m: &mut CSteamTV_AppCheer_Request| { &mut m.app_id },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cheer_target_id",
            |m: &CSteamTV_AppCheer_Request| { &m.cheer_target_id },
            |m: &mut CSteamTV_AppCheer_Request| { &mut m.cheer_target_id },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cheers",
            |m: &CSteamTV_AppCheer_Request| { &m.cheers },
            |m: &mut CSteamTV_AppCheer_Request| { &mut m.cheers },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_AppCheer_Request>(
            "CSteamTV_AppCheer_Request",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_AppCheer_Request {
    const NAME: &'static str = "CSteamTV_AppCheer_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.cheer_target_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.cheers.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.app_id {
            my_size += crate::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cheer_target_id {
            my_size += 1 + 8;
        }
        for value in &self.cheers {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cheer_target_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.cheers {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AppCheer_Request {
        CSteamTV_AppCheer_Request::new()
    }

    fn clear(&mut self) {
        self.app_id = ::std::option::Option::None;
        self.cheer_target_id = ::std::option::Option::None;
        self.cheers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AppCheer_Request {
        static instance: CSteamTV_AppCheer_Request = CSteamTV_AppCheer_Request {
            app_id: ::std::option::Option::None,
            cheer_target_id: ::std::option::Option::None,
            cheers: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_AppCheer_Request {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_AppCheer_Request").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_AppCheer_Request {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_AppCheer_Request {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CSteamTV_AppCheer_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSteamTV_AppCheer_Response {
    // message fields
    // @@protoc_insertion_point(field:CSteamTV_AppCheer_Response.aggregation_delay_ms)
    pub aggregation_delay_ms: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSteamTV_AppCheer_Response.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSteamTV_AppCheer_Response {
    fn default() -> &'a CSteamTV_AppCheer_Response {
        <CSteamTV_AppCheer_Response as crate::Message>::default_instance()
    }
}

impl CSteamTV_AppCheer_Response {
    pub fn new() -> CSteamTV_AppCheer_Response {
        ::std::default::Default::default()
    }

    // optional uint32 aggregation_delay_ms = 1;

    pub fn aggregation_delay_ms(&self) -> u32 {
        self.aggregation_delay_ms.unwrap_or(0)
    }

    pub fn clear_aggregation_delay_ms(&mut self) {
        self.aggregation_delay_ms = ::std::option::Option::None;
    }

    pub fn has_aggregation_delay_ms(&self) -> bool {
        self.aggregation_delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregation_delay_ms(&mut self, v: u32) {
        self.aggregation_delay_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "aggregation_delay_ms",
            |m: &CSteamTV_AppCheer_Response| { &m.aggregation_delay_ms },
            |m: &mut CSteamTV_AppCheer_Response| { &mut m.aggregation_delay_ms },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CSteamTV_AppCheer_Response>(
            "CSteamTV_AppCheer_Response",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CSteamTV_AppCheer_Response {
    const NAME: &'static str = "CSteamTV_AppCheer_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.aggregation_delay_ms = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.aggregation_delay_ms {
            my_size += crate::rt::uint32_size(1, v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.aggregation_delay_ms {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSteamTV_AppCheer_Response {
        CSteamTV_AppCheer_Response::new()
    }

    fn clear(&mut self) {
        self.aggregation_delay_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSteamTV_AppCheer_Response {
        static instance: CSteamTV_AppCheer_Response = CSteamTV_AppCheer_Response {
            aggregation_delay_ms: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CSteamTV_AppCheer_Response {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSteamTV_AppCheer_Response").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSteamTV_AppCheer_Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CSteamTV_AppCheer_Response {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBroadcastImageType)
pub enum EBroadcastImageType {
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_None)
    k_EBroadcastImageType_None = 0,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Offline)
    k_EBroadcastImageType_Offline = 1,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Standby)
    k_EBroadcastImageType_Standby = 2,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Avatar)
    k_EBroadcastImageType_Avatar = 3,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Summary)
    k_EBroadcastImageType_Summary = 4,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Background)
    k_EBroadcastImageType_Background = 5,
    // @@protoc_insertion_point(enum_value:EBroadcastImageType.k_EBroadcastImageType_Emoticon)
    k_EBroadcastImageType_Emoticon = 6,
}

impl crate::Enum for EBroadcastImageType {
    const NAME: &'static str = "EBroadcastImageType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBroadcastImageType> {
        match value {
            0 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_None),
            1 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Offline),
            2 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Standby),
            3 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Avatar),
            4 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Summary),
            5 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Background),
            6 => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Emoticon),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBroadcastImageType> {
        match str {
            "k_EBroadcastImageType_None" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_None),
            "k_EBroadcastImageType_Offline" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Offline),
            "k_EBroadcastImageType_Standby" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Standby),
            "k_EBroadcastImageType_Avatar" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Avatar),
            "k_EBroadcastImageType_Summary" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Summary),
            "k_EBroadcastImageType_Background" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Background),
            "k_EBroadcastImageType_Emoticon" => ::std::option::Option::Some(EBroadcastImageType::k_EBroadcastImageType_Emoticon),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBroadcastImageType] = &[
        EBroadcastImageType::k_EBroadcastImageType_None,
        EBroadcastImageType::k_EBroadcastImageType_Offline,
        EBroadcastImageType::k_EBroadcastImageType_Standby,
        EBroadcastImageType::k_EBroadcastImageType_Avatar,
        EBroadcastImageType::k_EBroadcastImageType_Summary,
        EBroadcastImageType::k_EBroadcastImageType_Background,
        EBroadcastImageType::k_EBroadcastImageType_Emoticon,
    ];
}

impl crate::EnumFull for EBroadcastImageType {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EBroadcastImageType").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EBroadcastImageType {
    fn default() -> Self {
        EBroadcastImageType::k_EBroadcastImageType_None
    }
}

impl EBroadcastImageType {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EBroadcastImageType>("EBroadcastImageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGetGamesAlgorithm)
pub enum EGetGamesAlgorithm {
    // @@protoc_insertion_point(enum_value:EGetGamesAlgorithm.k_EGetGamesAlgorithm_Default)
    k_EGetGamesAlgorithm_Default = 1,
    // @@protoc_insertion_point(enum_value:EGetGamesAlgorithm.k_EGetGamesAlgorithm_MostPlayed)
    k_EGetGamesAlgorithm_MostPlayed = 2,
    // @@protoc_insertion_point(enum_value:EGetGamesAlgorithm.k_EGetGamesAlgorithm_PopularNew)
    k_EGetGamesAlgorithm_PopularNew = 3,
}

impl crate::Enum for EGetGamesAlgorithm {
    const NAME: &'static str = "EGetGamesAlgorithm";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGetGamesAlgorithm> {
        match value {
            1 => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default),
            2 => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_MostPlayed),
            3 => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_PopularNew),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGetGamesAlgorithm> {
        match str {
            "k_EGetGamesAlgorithm_Default" => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default),
            "k_EGetGamesAlgorithm_MostPlayed" => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_MostPlayed),
            "k_EGetGamesAlgorithm_PopularNew" => ::std::option::Option::Some(EGetGamesAlgorithm::k_EGetGamesAlgorithm_PopularNew),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGetGamesAlgorithm] = &[
        EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default,
        EGetGamesAlgorithm::k_EGetGamesAlgorithm_MostPlayed,
        EGetGamesAlgorithm::k_EGetGamesAlgorithm_PopularNew,
    ];
}

impl crate::EnumFull for EGetGamesAlgorithm {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGetGamesAlgorithm").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default => 0,
            EGetGamesAlgorithm::k_EGetGamesAlgorithm_MostPlayed => 1,
            EGetGamesAlgorithm::k_EGetGamesAlgorithm_PopularNew => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGetGamesAlgorithm {
    fn default() -> Self {
        EGetGamesAlgorithm::k_EGetGamesAlgorithm_Default
    }
}

impl EGetGamesAlgorithm {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EGetGamesAlgorithm>("EGetGamesAlgorithm")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGetChannelsAlgorithm)
pub enum EGetChannelsAlgorithm {
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Default)
    k_EGetChannelsAlgorithm_Default = 1,
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Friends)
    k_EGetChannelsAlgorithm_Friends = 2,
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Featured)
    k_EGetChannelsAlgorithm_Featured = 3,
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Developer)
    k_EGetChannelsAlgorithm_Developer = 4,
    // @@protoc_insertion_point(enum_value:EGetChannelsAlgorithm.k_EGetChannelsAlgorithm_Following)
    k_EGetChannelsAlgorithm_Following = 5,
}

impl crate::Enum for EGetChannelsAlgorithm {
    const NAME: &'static str = "EGetChannelsAlgorithm";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGetChannelsAlgorithm> {
        match value {
            1 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default),
            2 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Friends),
            3 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Featured),
            4 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Developer),
            5 => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Following),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGetChannelsAlgorithm> {
        match str {
            "k_EGetChannelsAlgorithm_Default" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default),
            "k_EGetChannelsAlgorithm_Friends" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Friends),
            "k_EGetChannelsAlgorithm_Featured" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Featured),
            "k_EGetChannelsAlgorithm_Developer" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Developer),
            "k_EGetChannelsAlgorithm_Following" => ::std::option::Option::Some(EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Following),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGetChannelsAlgorithm] = &[
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default,
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Friends,
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Featured,
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Developer,
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Following,
    ];
}

impl crate::EnumFull for EGetChannelsAlgorithm {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EGetChannelsAlgorithm").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = match self {
            EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default => 0,
            EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Friends => 1,
            EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Featured => 2,
            EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Developer => 3,
            EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Following => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGetChannelsAlgorithm {
    fn default() -> Self {
        EGetChannelsAlgorithm::k_EGetChannelsAlgorithm_Default
    }
}

impl EGetChannelsAlgorithm {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<EGetChannelsAlgorithm>("EGetChannelsAlgorithm")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESteamTVContentTemplate)
pub enum ESteamTVContentTemplate {
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_Invalid)
    k_ESteamTVContentTemplate_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_Takeover)
    k_ESteamTVContentTemplate_Takeover = 1,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_SingleGame)
    k_ESteamTVContentTemplate_SingleGame = 2,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_GameList)
    k_ESteamTVContentTemplate_GameList = 3,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_QuickExplore)
    k_ESteamTVContentTemplate_QuickExplore = 4,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_ConveyorBelt)
    k_ESteamTVContentTemplate_ConveyorBelt = 5,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_WatchParty)
    k_ESteamTVContentTemplate_WatchParty = 6,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_Developer)
    k_ESteamTVContentTemplate_Developer = 7,
    // @@protoc_insertion_point(enum_value:ESteamTVContentTemplate.k_ESteamTVContentTemplate_Event)
    k_ESteamTVContentTemplate_Event = 8,
}

impl crate::Enum for ESteamTVContentTemplate {
    const NAME: &'static str = "ESteamTVContentTemplate";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESteamTVContentTemplate> {
        match value {
            0 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid),
            1 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Takeover),
            2 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_SingleGame),
            3 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_GameList),
            4 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_QuickExplore),
            5 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_ConveyorBelt),
            6 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_WatchParty),
            7 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Developer),
            8 => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Event),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESteamTVContentTemplate> {
        match str {
            "k_ESteamTVContentTemplate_Invalid" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid),
            "k_ESteamTVContentTemplate_Takeover" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Takeover),
            "k_ESteamTVContentTemplate_SingleGame" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_SingleGame),
            "k_ESteamTVContentTemplate_GameList" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_GameList),
            "k_ESteamTVContentTemplate_QuickExplore" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_QuickExplore),
            "k_ESteamTVContentTemplate_ConveyorBelt" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_ConveyorBelt),
            "k_ESteamTVContentTemplate_WatchParty" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_WatchParty),
            "k_ESteamTVContentTemplate_Developer" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Developer),
            "k_ESteamTVContentTemplate_Event" => ::std::option::Option::Some(ESteamTVContentTemplate::k_ESteamTVContentTemplate_Event),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESteamTVContentTemplate] = &[
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Takeover,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_SingleGame,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_GameList,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_QuickExplore,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_ConveyorBelt,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_WatchParty,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Developer,
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Event,
    ];
}

impl crate::EnumFull for ESteamTVContentTemplate {
    fn enum_descriptor() -> crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESteamTVContentTemplate").unwrap()).clone()
    }

    fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESteamTVContentTemplate {
    fn default() -> Self {
        ESteamTVContentTemplate::k_ESteamTVContentTemplate_Invalid
    }
}

impl ESteamTVContentTemplate {
    fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
        crate::reflect::GeneratedEnumDescriptorData::new::<ESteamTVContentTemplate>("ESteamTVContentTemplate")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'steammessages_steamtv.steamclient.proto\x1a\x18steammessages_base.pro\
    to\x1a,steammessages_unified_base.steamclient.proto\"J\n'CSteamTV_Create\
    BroadcastChannel_Request\x12\x1f\n\x0bunique_name\x18\x01\x20\x01(\tR\nu\
    niqueName\"\\\n(CSteamTV_CreateBroadcastChannel_Response\x120\n\x14broad\
    cast_channel_id\x18\x01\x20\x01(\x06R\x12broadcastChannelId\"I\n&CSteamT\
    V_GetBroadcastChannelID_Request\x12\x1f\n\x0bunique_name\x18\x01\x20\x01\
    (\tR\nuniqueName\"\x96\x01\n'CSteamTV_GetBroadcastChannelID_Response\x12\
    0\n\x14broadcast_channel_id\x18\x01\x20\x01(\x06R\x12broadcastChannelId\
    \x12\x1f\n\x0bunique_name\x18\x02\x20\x01(\tR\nuniqueName\x12\x18\n\x07s\
    teamid\x18\x03\x20\x01(\x06R\x07steamid\"\xb0\x02\n+CSteamTV_SetBroadcas\
    tChannelProfile_Request\x120\n\x14broadcast_channel_id\x18\x01\x20\x01(\
    \x06R\x12broadcastChannelId\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04nam\
    e\x12\x1a\n\x08language\x18\x03\x20\x01(\tR\x08language\x12\x1a\n\x08hea\
    dline\x18\x04\x20\x01(\tR\x08headline\x12\x18\n\x07summary\x18\x05\x20\
    \x01(\tR\x07summary\x12\x1f\n\x0bavatar_hash\x18\x06\x20\x01(\tR\navatar\
    Hash\x12\x1a\n\x08schedule\x18\x07\x20\x01(\tR\x08schedule\x12\x14\n\x05\
    rules\x18\x08\x20\x01(\tR\x05rules\x12\x16\n\x06panels\x18\t\x20\x01(\tR\
    \x06panels\".\n,CSteamTV_SetBroadcastChannelProfile_Response\"_\n+CSteam\
    TV_GetBroadcastChannelProfile_Request\x120\n\x14broadcast_channel_id\x18\
    \x01\x20\x01(\x06R\x12broadcastChannelId\"\xc7\x02\n,CSteamTV_GetBroadca\
    stChannelProfile_Response\x12\x1f\n\x0bunique_name\x18\x01\x20\x01(\tR\n\
    uniqueName\x12#\n\rowner_steamid\x18\x02\x20\x01(\x06R\x0cownerSteamid\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1a\n\x08language\x18\
    \x04\x20\x01(\tR\x08language\x12\x1a\n\x08headline\x18\x05\x20\x01(\tR\
    \x08headline\x12\x18\n\x07summary\x18\x06\x20\x01(\tR\x07summary\x12\x1a\
    \n\x08schedule\x18\x07\x20\x01(\tR\x08schedule\x12\x14\n\x05rules\x18\
    \x08\x20\x01(\tR\x05rules\x12\x16\n\x06panels\x18\t\x20\x01(\tR\x06panel\
    s\x12!\n\x0cis_partnered\x18\n\x20\x01(\x08R\x0bisPartnered\"\x88\x03\n)\
    CSteamTV_SetBroadcastChannelImage_Request\x120\n\x14broadcast_channel_id\
    \x18\x01\x20\x01(\x06R\x12broadcastChannelId\x12O\n\nimage_type\x18\x02\
    \x20\x01(\x0e2\x14.EBroadcastImageType:\x1ak_EBroadcastImageType_NoneR\t\
    imageType\x12\x1f\n\x0bimage_index\x18\x03\x20\x01(\rR\nimageIndex\x12\
    \x1f\n\x0bimage_width\x18\x04\x20\x01(\rR\nimageWidth\x12!\n\x0cimage_he\
    ight\x18\x05\x20\x01(\rR\x0bimageHeight\x12\x1b\n\tfile_size\x18\x06\x20\
    \x01(\rR\x08fileSize\x12%\n\x0efile_extension\x18\x07\x20\x01(\tR\rfileE\
    xtension\x12\x1b\n\tfile_hash\x18\x08\x20\x01(\tR\x08fileHash\x12\x12\n\
    \x04undo\x18\t\x20\x01(\x08R\x04undo\"Z\n*CSteamTV_SetBroadcastChannelIm\
    age_Response\x12,\n\x12replace_image_hash\x18\x01\x20\x01(\tR\x10replace\
    ImageHash\"\x95\x01\n*CSteamTV_GetBroadcastChannelImages_Request\x120\n\
    \x14broadcast_channel_id\x18\x01\x20\x01(\x06R\x12broadcastChannelId\x12\
    5\n\x0bimage_types\x18\x02\x20\x03(\x0e2\x14.EBroadcastImageTypeR\nimage\
    Types\"\x96\x02\n+CSteamTV_GetBroadcastChannelImages_Response\x12K\n\x06\
    images\x18\x01\x20\x03(\x0b23.CSteamTV_GetBroadcastChannelImages_Respons\
    e.ImagesR\x06images\x1a\x99\x01\n\x06Images\x12O\n\nimage_type\x18\x01\
    \x20\x01(\x0e2\x14.EBroadcastImageType:\x1ak_EBroadcastImageType_NoneR\t\
    imageType\x12\x1d\n\nimage_path\x18\x02\x20\x01(\tR\timagePath\x12\x1f\n\
    \x0bimage_index\x18\x03\x20\x01(\rR\nimageIndex\"\xeb\x02\n/CSteamTV_Set\
    BroadcastChannelLinkRegions_Request\x120\n\x14broadcast_channel_id\x18\
    \x01\x20\x01(\x06R\x12broadcastChannelId\x12L\n\x05links\x18\x02\x20\x03\
    (\x0b26.CSteamTV_SetBroadcastChannelLinkRegions_Request.LinksR\x05links\
    \x1a\xb7\x01\n\x05Links\x12\x1d\n\nlink_index\x18\x01\x20\x01(\rR\tlinkI\
    ndex\x12\x10\n\x03url\x18\x02\x20\x01(\tR\x03url\x12)\n\x10link_descript\
    ion\x18\x03\x20\x01(\tR\x0flinkDescription\x12\x12\n\x04left\x18\x04\x20\
    \x01(\rR\x04left\x12\x10\n\x03top\x18\x05\x20\x01(\rR\x03top\x12\x14\n\
    \x05width\x18\x06\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x07\x20\
    \x01(\rR\x06height\"2\n0CSteamTV_SetBroadcastChannelLinkRegions_Response\
    \"]\n)CSteamTV_GetBroadcastChannelLinks_Request\x120\n\x14broadcast_chan\
    nel_id\x18\x01\x20\x01(\x06R\x12broadcastChannelId\"\xaf\x02\n*CSteamTV_\
    GetBroadcastChannelLinks_Response\x12G\n\x05links\x18\x01\x20\x03(\x0b21\
    .CSteamTV_GetBroadcastChannelLinks_Response.LinksR\x05links\x1a\xb7\x01\
    \n\x05Links\x12\x1d\n\nlink_index\x18\x01\x20\x01(\rR\tlinkIndex\x12\x10\
    \n\x03url\x18\x02\x20\x01(\tR\x03url\x12)\n\x10link_description\x18\x03\
    \x20\x01(\tR\x0flinkDescription\x12\x12\n\x04left\x18\x04\x20\x01(\rR\
    \x04left\x12\x10\n\x03top\x18\x05\x20\x01(\rR\x03top\x12\x14\n\x05width\
    \x18\x06\x20\x01(\rR\x05width\x12\x16\n\x06height\x18\x07\x20\x01(\rR\
    \x06height\"d\n0CSteamTV_GetBroadcastChannelBroadcasters_Request\x120\n\
    \x14broadcast_channel_id\x18\x01\x20\x01(\x06R\x12broadcastChannelId\"\
    \xf3\x01\n1CSteamTV_GetBroadcastChannelBroadcasters_Response\x12b\n\x0cb\
    roadcasters\x18\x01\x20\x03(\x0b2>.CSteamTV_GetBroadcastChannelBroadcast\
    ers_Response.BroadcasterR\x0cbroadcasters\x1aZ\n\x0bBroadcaster\x12\x18\
    \n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x12\n\x04name\x18\x02\
    \x20\x01(\tR\x04name\x12\x1d\n\nrtmp_token\x18\x03\x20\x01(\tR\trtmpToke\
    n\"&\n$CSteamTV_GetFollowedChannels_Request\"\xf3\x04\n\x18GetBroadcastC\
    hannelEntry\x120\n\x14broadcast_channel_id\x18\x01\x20\x01(\x06R\x12broa\
    dcastChannelId\x12\x1f\n\x0bunique_name\x18\x02\x20\x01(\tR\nuniqueName\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x14\n\x05appid\x18\
    \x04\x20\x01(\rR\x05appid\x12\x18\n\x07viewers\x18\x05\x20\x01(\x04R\x07\
    viewers\x12\x14\n\x05views\x18\x06\x20\x01(\x04R\x05views\x12#\n\rthumbn\
    ail_url\x18\x07\x20\x01(\tR\x0cthumbnailUrl\x12\x1c\n\tfollowers\x18\x08\
    \x20\x01(\x04R\tfollowers\x12\x1a\n\x08headline\x18\t\x20\x01(\tR\x08hea\
    dline\x12\x1d\n\navatar_url\x18\n\x20\x01(\tR\tavatarUrl\x12/\n\x13broad\
    caster_steamid\x18\x0b\x20\x01(\x06R\x12broadcasterSteamid\x12\x20\n\x0b\
    subscribers\x18\x0c\x20\x01(\x04R\x0bsubscribers\x12%\n\x0ebackground_ur\
    l\x18\r\x20\x01(\tR\rbackgroundUrl\x12\x1f\n\x0bis_featured\x18\x0e\x20\
    \x01(\x08R\nisFeatured\x12\x1f\n\x0bis_disabled\x18\x0f\x20\x01(\x08R\ni\
    sDisabled\x12\x17\n\x07is_live\x18\x10\x20\x01(\x08R\x06isLive\x12\x1a\n\
    \x08language\x18\x11\x20\x01(\tR\x08language\x12\x18\n\x07reports\x18\
    \x12\x20\x01(\rR\x07reports\x12!\n\x0cis_partnered\x18\x13\x20\x01(\x08R\
    \x0bisPartnered\"\\\n%CSteamTV_GetFollowedChannels_Response\x123\n\x07re\
    sults\x18\x01\x20\x03(\x0b2\x19.GetBroadcastChannelEntryR\x07results\"(\
    \n&CSteamTV_GetSubscribedChannels_Request\"^\n'CSteamTV_GetSubscribedCha\
    nnels_Response\x123\n\x07results\x18\x01\x20\x03(\x0b2\x19.GetBroadcastC\
    hannelEntryR\x07results\"^\n*CSteamTV_GetBroadcastChannelStatus_Request\
    \x120\n\x14broadcast_channel_id\x18\x01\x20\x01(\x06R\x12broadcastChanne\
    lId\"\x96\x03\n+CSteamTV_GetBroadcastChannelStatus_Response\x12\x17\n\
    \x07is_live\x18\x01\x20\x01(\x08R\x06isLive\x12\x1f\n\x0bis_disabled\x18\
    \x02\x20\x01(\x08R\nisDisabled\x12\x14\n\x05appid\x18\x03\x20\x01(\rR\
    \x05appid\x12\x18\n\x07viewers\x18\x04\x20\x01(\x04R\x07viewers\x12\x14\
    \n\x05views\x18\x05\x20\x01(\x04R\x05views\x12/\n\x13broadcaster_steamid\
    \x18\x06\x20\x01(\x06R\x12broadcasterSteamid\x12#\n\rthumbnail_url\x18\
    \x07\x20\x01(\tR\x0cthumbnailUrl\x12\x1c\n\tfollowers\x18\x08\x20\x01(\
    \x04R\tfollowers\x12\x20\n\x0bsubscribers\x18\t\x20\x01(\x04R\x0bsubscri\
    bers\x12\x1f\n\x0bunique_name\x18\n\x20\x01(\tR\nuniqueName\x120\n\x14br\
    oadcast_session_id\x18\x0b\x20\x01(\x04R\x12broadcastSessionId\"o\n'CSte\
    amTV_FollowBroadcastChannel_Request\x120\n\x14broadcast_channel_id\x18\
    \x01\x20\x01(\x06R\x12broadcastChannelId\x12\x12\n\x04undo\x18\x02\x20\
    \x01(\x08R\x04undo\"K\n(CSteamTV_FollowBroadcastChannel_Response\x12\x1f\
    \n\x0bis_followed\x18\x01\x20\x01(\x08R\nisFollowed\"^\n*CSteamTV_Subscr\
    ibeBroadcastChannel_Request\x120\n\x14broadcast_channel_id\x18\x01\x20\
    \x01(\x06R\x12broadcastChannelId\"R\n+CSteamTV_SubscribeBroadcastChannel\
    _Response\x12#\n\ris_subscribed\x18\x01\x20\x01(\x08R\x0cisSubscribed\"]\
    \n)CSteamTV_GetBroadcastChannelClips_Request\x120\n\x14broadcast_channel\
    _id\x18\x01\x20\x01(\x06R\x12broadcastChannelId\"\xe6\x02\n\x1aCSteamTV_\
    BroadcastClipInfo\x12*\n\x11broadcast_clip_id\x18\x01\x20\x01(\x04R\x0fb\
    roadcastClipId\x12\x1d\n\nchannel_id\x18\x02\x20\x01(\x04R\tchannelId\
    \x12\x15\n\x06app_id\x18\x03\x20\x01(\rR\x05appId\x12/\n\x13broadcaster_\
    steamid\x18\x04\x20\x01(\x06R\x12broadcasterSteamid\x12'\n\x0fcreator_st\
    eamid\x18\x05\x20\x01(\x06R\x0ecreatorSteamid\x12+\n\x11video_descriptio\
    n\x18\x06\x20\x01(\tR\x10videoDescription\x12\x1b\n\tlive_time\x18\x07\
    \x20\x01(\rR\x08liveTime\x12\x1b\n\tlength_ms\x18\x08\x20\x01(\rR\x08len\
    gthMs\x12%\n\x0ethumbnail_path\x18\t\x20\x01(\tR\rthumbnailPath\"\x86\
    \x01\n*CSteamTV_GetBroadcastChannelClips_Response\x121\n\x05clips\x18\
    \x01\x20\x03(\x0b2\x1b.CSteamTV_BroadcastClipInfoR\x05clips\x12%\n\x0eth\
    umbnail_host\x18\x02\x20\x01(\tR\rthumbnailHost\"s\n'CSteamTV_ReportBroa\
    dcastChannel_Request\x120\n\x14broadcast_channel_id\x18\x01\x20\x01(\x06\
    R\x12broadcastChannelId\x12\x16\n\x06reason\x18\x02\x20\x01(\tR\x06reaso\
    n\"*\n(CSteamTV_ReportBroadcastChannel_Response\"c\n/CSteamTV_GetBroadca\
    stChannelInteraction_Request\x120\n\x14broadcast_channel_id\x18\x01\x20\
    \x01(\x06R\x12broadcastChannelId\"x\n0CSteamTV_GetBroadcastChannelIntera\
    ction_Response\x12\x1f\n\x0bis_followed\x18\x01\x20\x01(\x08R\nisFollowe\
    d\x12#\n\ris_subscribed\x18\x02\x20\x01(\x08R\x0cisSubscribed\"\x98\x01\
    \n\x19CSteamTV_GetGames_Request\x12\x14\n\x05appid\x18\x01\x20\x01(\rR\
    \x05appid\x12O\n\talgorithm\x18\x02\x20\x01(\x0e2\x13.EGetGamesAlgorithm\
    :\x1ck_EGetGamesAlgorithm_DefaultR\talgorithm\x12\x14\n\x05count\x18\x03\
    \x20\x01(\rR\x05count\"\xff\x01\n\rCSteamTV_Game\x12\x14\n\x05appid\x18\
    \x01\x20\x01(\rR\x05appid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\
    \x12\x14\n\x05image\x18\x03\x20\x01(\tR\x05image\x12\x18\n\x07viewers\
    \x18\x04\x20\x01(\x04R\x07viewers\x125\n\x08channels\x18\x05\x20\x03(\
    \x0b2\x19.GetBroadcastChannelEntryR\x08channels\x12!\n\x0crelease_date\
    \x18\x06\x20\x01(\tR\x0breleaseDate\x12\x1c\n\tdeveloper\x18\x07\x20\x01\
    (\tR\tdeveloper\x12\x1c\n\tpublisher\x18\x08\x20\x01(\tR\tpublisher\"F\n\
    \x1aCSteamTV_GetGames_Response\x12(\n\x07results\x18\x01\x20\x03(\x0b2\
    \x0e.CSteamTV_GameR\x07results\"\xa1\x01\n\x1cCSteamTV_GetChannels_Reque\
    st\x12U\n\talgorithm\x18\x01\x20\x01(\x0e2\x16.EGetChannelsAlgorithm:\
    \x1fk_EGetChannelsAlgorithm_DefaultR\talgorithm\x12\x14\n\x05count\x18\
    \x02\x20\x01(\rR\x05count\x12\x14\n\x05appid\x18\x03\x20\x01(\rR\x05appi\
    d\"T\n\x1dCSteamTV_GetChannels_Response\x123\n\x07results\x18\x01\x20\
    \x03(\x0b2\x19.GetBroadcastChannelEntryR\x07results\"\xc6\x01\n\x1bCStea\
    mTV_AddChatBan_Request\x120\n\x14broadcast_channel_id\x18\x01\x20\x01(\
    \x06R\x12broadcastChannelId\x12'\n\x0fchatter_steamid\x18\x02\x20\x01(\
    \x06R\x0echatterSteamid\x12\x1a\n\x08duration\x18\x03\x20\x01(\rR\x08dur\
    ation\x12\x1c\n\tpermanent\x18\x04\x20\x01(\x08R\tpermanent\x12\x12\n\
    \x04undo\x18\x05\x20\x01(\x08R\x04undo\"\x1e\n\x1cCSteamTV_AddChatBan_Re\
    sponse\"P\n\x1cCSteamTV_GetChatBans_Request\x120\n\x14broadcast_channel_\
    id\x18\x01\x20\x01(\x06R\x12broadcastChannelId\"\xb7\x01\n\x10CSteamTV_C\
    hatBan\x12%\n\x0eissuer_steamid\x18\x01\x20\x01(\x06R\rissuerSteamid\x12\
    '\n\x0fchatter_steamid\x18\x02\x20\x01(\x06R\x0echatterSteamid\x12!\n\
    \x0ctime_expires\x18\x03\x20\x01(\tR\x0btimeExpires\x12\x1c\n\tpermanent\
    \x18\x04\x20\x01(\x08R\tpermanent\x12\x12\n\x04name\x18\x05\x20\x01(\tR\
    \x04name\"L\n\x1dCSteamTV_GetChatBans_Response\x12+\n\x07results\x18\x01\
    \x20\x03(\x0b2\x11.CSteamTV_ChatBanR\x07results\"\x96\x01\n!CSteamTV_Add\
    ChatModerator_Request\x120\n\x14broadcast_channel_id\x18\x01\x20\x01(\
    \x06R\x12broadcastChannelId\x12+\n\x11moderator_steamid\x18\x02\x20\x01(\
    \x06R\x10moderatorSteamid\x12\x12\n\x04undo\x18\x03\x20\x01(\x08R\x04und\
    o\"$\n\"CSteamTV_AddChatModerator_Response\"V\n\"CSteamTV_GetChatModerat\
    ors_Request\x120\n\x14broadcast_channel_id\x18\x01\x20\x01(\x06R\x12broa\
    dcastChannelId\"F\n\x16CSteamTV_ChatModerator\x12\x18\n\x07steamid\x18\
    \x01\x20\x01(\x06R\x07steamid\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04n\
    ame\"X\n#CSteamTV_GetChatModerators_Response\x121\n\x07results\x18\x01\
    \x20\x03(\x0b2\x17.CSteamTV_ChatModeratorR\x07results\"w\n\x1bCSteamTV_A\
    ddWordBan_Request\x120\n\x14broadcast_channel_id\x18\x01\x20\x01(\x06R\
    \x12broadcastChannelId\x12\x12\n\x04word\x18\x02\x20\x01(\tR\x04word\x12\
    \x12\n\x04undo\x18\x03\x20\x01(\x08R\x04undo\"\x1e\n\x1cCSteamTV_AddWord\
    Ban_Response\"P\n\x1cCSteamTV_GetWordBans_Request\x120\n\x14broadcast_ch\
    annel_id\x18\x01\x20\x01(\x06R\x12broadcastChannelId\"9\n\x1dCSteamTV_Ge\
    tWordBans_Response\x12\x18\n\x07results\x18\x01\x20\x03(\tR\x07results\"\
    M\n\x19CSteamTV_JoinChat_Request\x120\n\x14broadcast_channel_id\x18\x01\
    \x20\x01(\x06R\x12broadcastChannelId\"\x89\x01\n\x1aCSteamTV_JoinChat_Re\
    sponse\x12\x17\n\x07chat_id\x18\x01\x20\x01(\x06R\x06chatId\x12*\n\x11vi\
    ew_url_template\x18\x02\x20\x01(\tR\x0fviewUrlTemplate\x12&\n\x0fflair_g\
    roup_ids\x18\x03\x20\x03(\x04R\rflairGroupIds\"-\n\x17CSteamTV_Search_Re\
    quest\x12\x12\n\x04term\x18\x01\x20\x01(\tR\x04term\"O\n\x18CSteamTV_Sea\
    rch_Response\x123\n\x07results\x18\x01\x20\x03(\x0b2\x19.GetBroadcastCha\
    nnelEntryR\x07results\")\n'CSteamTV_GetSteamTVUserSettings_Request\"\x90\
    \x01\n(CSteamTV_GetSteamTVUserSettings_Response\x12*\n\x11stream_live_em\
    ail\x18\x01\x20\x01(\x08R\x0fstreamLiveEmail\x128\n\x18stream_live_notif\
    ication\x18\x02\x20\x01(\x08R\x16streamLiveNotification\"\x8f\x01\n'CSte\
    amTV_SetSteamTVUserSettings_Request\x12*\n\x11stream_live_email\x18\x01\
    \x20\x01(\x08R\x0fstreamLiveEmail\x128\n\x18stream_live_notification\x18\
    \x02\x20\x01(\x08R\x16streamLiveNotification\"*\n(CSteamTV_SetSteamTVUse\
    rSettings_Response\")\n'CSteamTV_GetMyBroadcastChannels_Request\"_\n(CSt\
    eamTV_GetMyBroadcastChannels_Response\x123\n\x07results\x18\x01\x20\x03(\
    \x0b2\x19.GetBroadcastChannelEntryR\x07results\"&\n$CSteamTV_GetHomePage\
    Contents_Request\"_\n\"CSteamTV_HomePageTemplate_Takeover\x129\n\nbroadc\
    asts\x18\x01\x20\x03(\x0b2\x19.GetBroadcastChannelEntryR\nbroadcasts\"\
    \x8d\x01\n$CSteamTV_HomePageTemplate_SingleGame\x129\n\nbroadcasts\x18\
    \x01\x20\x03(\x0b2\x19.GetBroadcastChannelEntryR\nbroadcasts\x12\x14\n\
    \x05appid\x18\x02\x20\x01(\rR\x05appid\x12\x14\n\x05title\x18\x03\x20\
    \x01(\tR\x05title\"{\n\rGameListEntry\x12\x14\n\x05appid\x18\x01\x20\x01\
    (\rR\x05appid\x12\x1b\n\tgame_name\x18\x02\x20\x01(\tR\x08gameName\x127\
    \n\tbroadcast\x18\x03\x20\x01(\x0b2\x19.GetBroadcastChannelEntryR\tbroad\
    cast\"d\n\"CSteamTV_HomePageTemplate_GameList\x12(\n\x07entries\x18\x01\
    \x20\x03(\x0b2\x0e.GameListEntryR\x07entries\x12\x14\n\x05title\x18\x02\
    \x20\x01(\tR\x05title\"y\n&CSteamTV_HomePageTemplate_QuickExplore\x129\n\
    \nbroadcasts\x18\x01\x20\x03(\x0b2\x19.GetBroadcastChannelEntryR\nbroadc\
    asts\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\"y\n&CSteamTV_HomeP\
    ageTemplate_ConveyorBelt\x129\n\nbroadcasts\x18\x01\x20\x03(\x0b2\x19.Ge\
    tBroadcastChannelEntryR\nbroadcasts\x12\x14\n\x05title\x18\x02\x20\x01(\
    \tR\x05title\"\x99\x01\n$CSteamTV_HomePageTemplate_WatchParty\x127\n\tbr\
    oadcast\x18\x01\x20\x01(\x0b2\x19.GetBroadcastChannelEntryR\tbroadcast\
    \x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\x12\"\n\rchat_group_id\
    \x18\x03\x20\x01(\x04R\x0bchatGroupId\"t\n#CSteamTV_HomePageTemplate_Dev\
    eloper\x127\n\tbroadcast\x18\x01\x20\x01(\x0b2\x19.GetBroadcastChannelEn\
    tryR\tbroadcast\x12\x14\n\x05title\x18\x02\x20\x01(\tR\x05title\"7\n\x1f\
    CSteamTV_HomePageTemplate_Event\x12\x14\n\x05title\x18\x01\x20\x01(\tR\
    \x05title\"\xaa\x05\n\x1bCSteamTV_HomePageContentRow\x12`\n\rtemplate_ty\
    pe\x18\x01\x20\x01(\x0e2\x18.ESteamTVContentTemplate:!k_ESteamTVContentT\
    emplate_InvalidR\x0ctemplateType\x12?\n\x08takeover\x18\x02\x20\x01(\x0b\
    2#.CSteamTV_HomePageTemplate_TakeoverR\x08takeover\x12F\n\x0bsingle_game\
    \x18\x03\x20\x01(\x0b2%.CSteamTV_HomePageTemplate_SingleGameR\nsingleGam\
    e\x12@\n\tgame_list\x18\x04\x20\x01(\x0b2#.CSteamTV_HomePageTemplate_Gam\
    eListR\x08gameList\x12L\n\rquick_explore\x18\x05\x20\x01(\x0b2'.CSteamTV\
    _HomePageTemplate_QuickExploreR\x0cquickExplore\x12L\n\rconveyor_belt\
    \x18\x06\x20\x01(\x0b2'.CSteamTV_HomePageTemplate_ConveyorBeltR\x0cconve\
    yorBelt\x12F\n\x0bwatch_party\x18\x07\x20\x01(\x0b2%.CSteamTV_HomePageTe\
    mplate_WatchPartyR\nwatchParty\x12B\n\tdeveloper\x18\x08\x20\x01(\x0b2$.\
    CSteamTV_HomePageTemplate_DeveloperR\tdeveloper\x126\n\x05event\x18\t\
    \x20\x01(\x0b2\x20.CSteamTV_HomePageTemplate_EventR\x05event\"Y\n%CSteam\
    TV_GetHomePageContents_Response\x120\n\x04rows\x18\x01\x20\x03(\x0b2\x1c\
    .CSteamTV_HomePageContentRowR\x04rows\"e\n!CSteamTV_AppCheer_SingleCheer\
    Type\x12\x1d\n\ncheer_type\x18\x01\x20\x01(\rR\tcheerType\x12!\n\x0cchee\
    r_amount\x18\x02\x20\x01(\rR\x0bcheerAmount\"\x96\x01\n\x19CSteamTV_AppC\
    heer_Request\x12\x15\n\x06app_id\x18\x01\x20\x01(\rR\x05appId\x12&\n\x0f\
    cheer_target_id\x18\x02\x20\x01(\x06R\rcheerTargetId\x12:\n\x06cheers\
    \x18\x03\x20\x03(\x0b2\".CSteamTV_AppCheer_SingleCheerTypeR\x06cheers\"N\
    \n\x1aCSteamTV_AppCheer_Response\x120\n\x14aggregation_delay_ms\x18\x01\
    \x20\x01(\rR\x12aggregationDelayMs*\x8a\x02\n\x13EBroadcastImageType\x12\
    \x1e\n\x1ak_EBroadcastImageType_None\x10\0\x12!\n\x1dk_EBroadcastImageTy\
    pe_Offline\x10\x01\x12!\n\x1dk_EBroadcastImageType_Standby\x10\x02\x12\
    \x20\n\x1ck_EBroadcastImageType_Avatar\x10\x03\x12!\n\x1dk_EBroadcastIma\
    geType_Summary\x10\x04\x12$\n\x20k_EBroadcastImageType_Background\x10\
    \x05\x12\"\n\x1ek_EBroadcastImageType_Emoticon\x10\x06*\x80\x01\n\x12EGe\
    tGamesAlgorithm\x12\x20\n\x1ck_EGetGamesAlgorithm_Default\x10\x01\x12#\n\
    \x1fk_EGetGamesAlgorithm_MostPlayed\x10\x02\x12#\n\x1fk_EGetGamesAlgorit\
    hm_PopularNew\x10\x03*\xd5\x01\n\x15EGetChannelsAlgorithm\x12#\n\x1fk_EG\
    etChannelsAlgorithm_Default\x10\x01\x12#\n\x1fk_EGetChannelsAlgorithm_Fr\
    iends\x10\x02\x12$\n\x20k_EGetChannelsAlgorithm_Featured\x10\x03\x12%\n!\
    k_EGetChannelsAlgorithm_Developer\x10\x04\x12%\n!k_EGetChannelsAlgorithm\
    _Following\x10\x05*\x8a\x03\n\x17ESteamTVContentTemplate\x12%\n!k_ESteam\
    TVContentTemplate_Invalid\x10\0\x12&\n\"k_ESteamTVContentTemplate_Takeov\
    er\x10\x01\x12(\n$k_ESteamTVContentTemplate_SingleGame\x10\x02\x12&\n\"k\
    _ESteamTVContentTemplate_GameList\x10\x03\x12*\n&k_ESteamTVContentTempla\
    te_QuickExplore\x10\x04\x12*\n&k_ESteamTVContentTemplate_ConveyorBelt\
    \x10\x05\x12(\n$k_ESteamTVContentTemplate_WatchParty\x10\x06\x12'\n#k_ES\
    teamTVContentTemplate_Developer\x10\x07\x12#\n\x1fk_ESteamTVContentTempl\
    ate_Event\x10\x082\xea\x19\n\x07SteamTV\x12m\n\x16CreateBroadcastChannel\
    \x12(.CSteamTV_CreateBroadcastChannel_Request\x1a).CSteamTV_CreateBroadc\
    astChannel_Response\x12j\n\x15GetBroadcastChannelID\x12'.CSteamTV_GetBro\
    adcastChannelID_Request\x1a(.CSteamTV_GetBroadcastChannelID_Response\x12\
    y\n\x1aSetBroadcastChannelProfile\x12,.CSteamTV_SetBroadcastChannelProfi\
    le_Request\x1a-.CSteamTV_SetBroadcastChannelProfile_Response\x12y\n\x1aG\
    etBroadcastChannelProfile\x12,.CSteamTV_GetBroadcastChannelProfile_Reque\
    st\x1a-.CSteamTV_GetBroadcastChannelProfile_Response\x12s\n\x18SetBroadc\
    astChannelImage\x12*.CSteamTV_SetBroadcastChannelImage_Request\x1a+.CSte\
    amTV_SetBroadcastChannelImage_Response\x12v\n\x19GetBroadcastChannelImag\
    es\x12+.CSteamTV_GetBroadcastChannelImages_Request\x1a,.CSteamTV_GetBroa\
    dcastChannelImages_Response\x12\x85\x01\n\x1eSetBroadcastChannelLinkRegi\
    ons\x120.CSteamTV_SetBroadcastChannelLinkRegions_Request\x1a1.CSteamTV_S\
    etBroadcastChannelLinkRegions_Response\x12s\n\x18GetBroadcastChannelLink\
    s\x12*.CSteamTV_GetBroadcastChannelLinks_Request\x1a+.CSteamTV_GetBroadc\
    astChannelLinks_Response\x12\x88\x01\n\x1fGetBroadcastChannelBroadcaster\
    s\x121.CSteamTV_GetBroadcastChannelBroadcasters_Request\x1a2.CSteamTV_Ge\
    tBroadcastChannelBroadcasters_Response\x12d\n\x13GetFollowedChannels\x12\
    %.CSteamTV_GetFollowedChannels_Request\x1a&.CSteamTV_GetFollowedChannels\
    _Response\x12j\n\x15GetSubscribedChannels\x12'.CSteamTV_GetSubscribedCha\
    nnels_Request\x1a(.CSteamTV_GetSubscribedChannels_Response\x12v\n\x19Get\
    BroadcastChannelStatus\x12+.CSteamTV_GetBroadcastChannelStatus_Request\
    \x1a,.CSteamTV_GetBroadcastChannelStatus_Response\x12m\n\x16FollowBroadc\
    astChannel\x12(.CSteamTV_FollowBroadcastChannel_Request\x1a).CSteamTV_Fo\
    llowBroadcastChannel_Response\x12v\n\x19SubscribeBroadcastChannel\x12+.C\
    SteamTV_SubscribeBroadcastChannel_Request\x1a,.CSteamTV_SubscribeBroadca\
    stChannel_Response\x12s\n\x18GetBroadcastChannelClips\x12*.CSteamTV_GetB\
    roadcastChannelClips_Request\x1a+.CSteamTV_GetBroadcastChannelClips_Resp\
    onse\x12m\n\x16ReportBroadcastChannel\x12(.CSteamTV_ReportBroadcastChann\
    el_Request\x1a).CSteamTV_ReportBroadcastChannel_Response\x12\x85\x01\n\
    \x1eGetBroadcastChannelInteraction\x120.CSteamTV_GetBroadcastChannelInte\
    raction_Request\x1a1.CSteamTV_GetBroadcastChannelInteraction_Response\
    \x12C\n\x08GetGames\x12\x1a.CSteamTV_GetGames_Request\x1a\x1b.CSteamTV_G\
    etGames_Response\x12L\n\x0bGetChannels\x12\x1d.CSteamTV_GetChannels_Requ\
    est\x1a\x1e.CSteamTV_GetChannels_Response\x12I\n\nAddChatBan\x12\x1c.CSt\
    eamTV_AddChatBan_Request\x1a\x1d.CSteamTV_AddChatBan_Response\x12L\n\x0b\
    GetChatBans\x12\x1d.CSteamTV_GetChatBans_Request\x1a\x1e.CSteamTV_GetCha\
    tBans_Response\x12[\n\x10AddChatModerator\x12\".CSteamTV_AddChatModerato\
    r_Request\x1a#.CSteamTV_AddChatModerator_Response\x12^\n\x11GetChatModer\
    ators\x12#.CSteamTV_GetChatModerators_Request\x1a$.CSteamTV_GetChatModer\
    ators_Response\x12I\n\nAddWordBan\x12\x1c.CSteamTV_AddWordBan_Request\
    \x1a\x1d.CSteamTV_AddWordBan_Response\x12L\n\x0bGetWordBans\x12\x1d.CSte\
    amTV_GetWordBans_Request\x1a\x1e.CSteamTV_GetWordBans_Response\x12C\n\
    \x08JoinChat\x12\x1a.CSteamTV_JoinChat_Request\x1a\x1b.CSteamTV_JoinChat\
    _Response\x12=\n\x06Search\x12\x18.CSteamTV_Search_Request\x1a\x19.CStea\
    mTV_Search_Response\x12m\n\x16GetSteamTVUserSettings\x12(.CSteamTV_GetSt\
    eamTVUserSettings_Request\x1a).CSteamTV_GetSteamTVUserSettings_Response\
    \x12m\n\x16SetSteamTVUserSettings\x12(.CSteamTV_SetSteamTVUserSettings_R\
    equest\x1a).CSteamTV_SetSteamTVUserSettings_Response\x12m\n\x16GetMyBroa\
    dcastChannels\x12(.CSteamTV_GetMyBroadcastChannels_Request\x1a).CSteamTV\
    _GetMyBroadcastChannels_Response\x12d\n\x13GetHomePageContents\x12%.CSte\
    amTV_GetHomePageContents_Request\x1a&.CSteamTV_GetHomePageContents_Respo\
    nse\x12C\n\x08AppCheer\x12\x1a.CSteamTV_AppCheer_Request\x1a\x1b.CSteamT\
    V_AppCheer_ResponseB\x03\x80\x01\x01\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::steammessages_base::file_descriptor().clone());
            deps.push(super::steammessages_unified_base_steamclient::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(84);
            messages.push(CSteamTV_CreateBroadcastChannel_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_CreateBroadcastChannel_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelID_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelID_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_SetBroadcastChannelProfile_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_SetBroadcastChannelProfile_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelProfile_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelProfile_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_SetBroadcastChannelImage_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_SetBroadcastChannelImage_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelImages_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelImages_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_SetBroadcastChannelLinkRegions_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_SetBroadcastChannelLinkRegions_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelLinks_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelLinks_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelBroadcasters_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelBroadcasters_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetFollowedChannels_Request::generated_message_descriptor_data());
            messages.push(GetBroadcastChannelEntry::generated_message_descriptor_data());
            messages.push(CSteamTV_GetFollowedChannels_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetSubscribedChannels_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetSubscribedChannels_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelStatus_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelStatus_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_FollowBroadcastChannel_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_FollowBroadcastChannel_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_SubscribeBroadcastChannel_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_SubscribeBroadcastChannel_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelClips_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_BroadcastClipInfo::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelClips_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_ReportBroadcastChannel_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_ReportBroadcastChannel_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelInteraction_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetBroadcastChannelInteraction_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetGames_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_Game::generated_message_descriptor_data());
            messages.push(CSteamTV_GetGames_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetChannels_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetChannels_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_AddChatBan_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_AddChatBan_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetChatBans_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_ChatBan::generated_message_descriptor_data());
            messages.push(CSteamTV_GetChatBans_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_AddChatModerator_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_AddChatModerator_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetChatModerators_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_ChatModerator::generated_message_descriptor_data());
            messages.push(CSteamTV_GetChatModerators_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_AddWordBan_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_AddWordBan_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetWordBans_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetWordBans_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_JoinChat_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_JoinChat_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_Search_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_Search_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetSteamTVUserSettings_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetSteamTVUserSettings_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_SetSteamTVUserSettings_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_SetSteamTVUserSettings_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetMyBroadcastChannels_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_GetMyBroadcastChannels_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_GetHomePageContents_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_HomePageTemplate_Takeover::generated_message_descriptor_data());
            messages.push(CSteamTV_HomePageTemplate_SingleGame::generated_message_descriptor_data());
            messages.push(GameListEntry::generated_message_descriptor_data());
            messages.push(CSteamTV_HomePageTemplate_GameList::generated_message_descriptor_data());
            messages.push(CSteamTV_HomePageTemplate_QuickExplore::generated_message_descriptor_data());
            messages.push(CSteamTV_HomePageTemplate_ConveyorBelt::generated_message_descriptor_data());
            messages.push(CSteamTV_HomePageTemplate_WatchParty::generated_message_descriptor_data());
            messages.push(CSteamTV_HomePageTemplate_Developer::generated_message_descriptor_data());
            messages.push(CSteamTV_HomePageTemplate_Event::generated_message_descriptor_data());
            messages.push(CSteamTV_HomePageContentRow::generated_message_descriptor_data());
            messages.push(CSteamTV_GetHomePageContents_Response::generated_message_descriptor_data());
            messages.push(CSteamTV_AppCheer_SingleCheerType::generated_message_descriptor_data());
            messages.push(CSteamTV_AppCheer_Request::generated_message_descriptor_data());
            messages.push(CSteamTV_AppCheer_Response::generated_message_descriptor_data());
            messages.push(csteam_tv_get_broadcast_channel_images_response::Images::generated_message_descriptor_data());
            messages.push(csteam_tv_set_broadcast_channel_link_regions_request::Links::generated_message_descriptor_data());
            messages.push(csteam_tv_get_broadcast_channel_links_response::Links::generated_message_descriptor_data());
            messages.push(csteam_tv_get_broadcast_channel_broadcasters_response::Broadcaster::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(EBroadcastImageType::generated_enum_descriptor_data());
            enums.push(EGetGamesAlgorithm::generated_enum_descriptor_data());
            enums.push(EGetChannelsAlgorithm::generated_enum_descriptor_data());
            enums.push(ESteamTVContentTemplate::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
