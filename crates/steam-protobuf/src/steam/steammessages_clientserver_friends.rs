// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_clientserver_friends.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientFriendMsg {
    // message fields
    steamid: ::std::option::Option<u64>,
    chat_entry_type: ::std::option::Option<i32>,
    message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rtime32_server_timestamp: ::std::option::Option<u32>,
    echo_to_sender: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendMsg {
    fn default() -> &'a CMsgClientFriendMsg {
        <CMsgClientFriendMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendMsg {
    pub fn new() -> CMsgClientFriendMsg {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;


    pub fn get_chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }
    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional bytes message = 3;


    pub fn get_message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 rtime32_server_timestamp = 4;


    pub fn get_rtime32_server_timestamp(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }
    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }

    // optional bool echo_to_sender = 5;


    pub fn get_echo_to_sender(&self) -> bool {
        self.echo_to_sender.unwrap_or(false)
    }
    pub fn clear_echo_to_sender(&mut self) {
        self.echo_to_sender = ::std::option::Option::None;
    }

    pub fn has_echo_to_sender(&self) -> bool {
        self.echo_to_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_echo_to_sender(&mut self, v: bool) {
        self.echo_to_sender = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_entry_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime32_server_timestamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.echo_to_sender = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.rtime32_server_timestamp {
            my_size += 5;
        }
        if let Some(v) = self.echo_to_sender {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.rtime32_server_timestamp {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.echo_to_sender {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendMsg {
        CMsgClientFriendMsg::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgClientFriendMsg| { &m.steamid },
                |m: &mut CMsgClientFriendMsg| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_entry_type",
                |m: &CMsgClientFriendMsg| { &m.chat_entry_type },
                |m: &mut CMsgClientFriendMsg| { &mut m.chat_entry_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "message",
                |m: &CMsgClientFriendMsg| { &m.message },
                |m: &mut CMsgClientFriendMsg| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime32_server_timestamp",
                |m: &CMsgClientFriendMsg| { &m.rtime32_server_timestamp },
                |m: &mut CMsgClientFriendMsg| { &mut m.rtime32_server_timestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "echo_to_sender",
                |m: &CMsgClientFriendMsg| { &m.echo_to_sender },
                |m: &mut CMsgClientFriendMsg| { &mut m.echo_to_sender },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendMsg>(
                "CMsgClientFriendMsg",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendMsg {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendMsg> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendMsg::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendMsg {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.message.clear();
        self.rtime32_server_timestamp = ::std::option::Option::None;
        self.echo_to_sender = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendMsg {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientFriendMsgIncoming {
    // message fields
    steamid_from: ::std::option::Option<u64>,
    chat_entry_type: ::std::option::Option<i32>,
    from_limited_account: ::std::option::Option<bool>,
    message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rtime32_server_timestamp: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendMsgIncoming {
    fn default() -> &'a CMsgClientFriendMsgIncoming {
        <CMsgClientFriendMsgIncoming as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendMsgIncoming {
    pub fn new() -> CMsgClientFriendMsgIncoming {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_from = 1;


    pub fn get_steamid_from(&self) -> u64 {
        self.steamid_from.unwrap_or(0)
    }
    pub fn clear_steamid_from(&mut self) {
        self.steamid_from = ::std::option::Option::None;
    }

    pub fn has_steamid_from(&self) -> bool {
        self.steamid_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_from(&mut self, v: u64) {
        self.steamid_from = ::std::option::Option::Some(v);
    }

    // optional int32 chat_entry_type = 2;


    pub fn get_chat_entry_type(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }
    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    // optional bool from_limited_account = 3;


    pub fn get_from_limited_account(&self) -> bool {
        self.from_limited_account.unwrap_or(false)
    }
    pub fn clear_from_limited_account(&mut self) {
        self.from_limited_account = ::std::option::Option::None;
    }

    pub fn has_from_limited_account(&self) -> bool {
        self.from_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_limited_account(&mut self, v: bool) {
        self.from_limited_account = ::std::option::Option::Some(v);
    }

    // optional bytes message = 4;


    pub fn get_message(&self) -> &[u8] {
        match self.message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed32 rtime32_server_timestamp = 5;


    pub fn get_rtime32_server_timestamp(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }
    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendMsgIncoming {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_from = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.chat_entry_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.from_limited_account = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed32()?;
                    self.rtime32_server_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_from {
            my_size += 9;
        }
        if let Some(v) = self.chat_entry_type {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.from_limited_account {
            my_size += 2;
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.rtime32_server_timestamp {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_from {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.chat_entry_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_limited_account {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(v) = self.rtime32_server_timestamp {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendMsgIncoming {
        CMsgClientFriendMsgIncoming::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_from",
                |m: &CMsgClientFriendMsgIncoming| { &m.steamid_from },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.steamid_from },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "chat_entry_type",
                |m: &CMsgClientFriendMsgIncoming| { &m.chat_entry_type },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.chat_entry_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "from_limited_account",
                |m: &CMsgClientFriendMsgIncoming| { &m.from_limited_account },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.from_limited_account },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "message",
                |m: &CMsgClientFriendMsgIncoming| { &m.message },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed32>(
                "rtime32_server_timestamp",
                |m: &CMsgClientFriendMsgIncoming| { &m.rtime32_server_timestamp },
                |m: &mut CMsgClientFriendMsgIncoming| { &mut m.rtime32_server_timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendMsgIncoming>(
                "CMsgClientFriendMsgIncoming",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendMsgIncoming {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendMsgIncoming> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendMsgIncoming::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendMsgIncoming {
    fn clear(&mut self) {
        self.steamid_from = ::std::option::Option::None;
        self.chat_entry_type = ::std::option::Option::None;
        self.from_limited_account = ::std::option::Option::None;
        self.message.clear();
        self.rtime32_server_timestamp = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendMsgIncoming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendMsgIncoming {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientAddFriend {
    // message fields
    steamid_to_add: ::std::option::Option<u64>,
    accountname_or_email_to_add: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriend {
    fn default() -> &'a CMsgClientAddFriend {
        <CMsgClientAddFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriend {
    pub fn new() -> CMsgClientAddFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_to_add = 1;


    pub fn get_steamid_to_add(&self) -> u64 {
        self.steamid_to_add.unwrap_or(0)
    }
    pub fn clear_steamid_to_add(&mut self) {
        self.steamid_to_add = ::std::option::Option::None;
    }

    pub fn has_steamid_to_add(&self) -> bool {
        self.steamid_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_to_add(&mut self, v: u64) {
        self.steamid_to_add = ::std::option::Option::Some(v);
    }

    // optional string accountname_or_email_to_add = 2;


    pub fn get_accountname_or_email_to_add(&self) -> &str {
        match self.accountname_or_email_to_add.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_accountname_or_email_to_add(&mut self) {
        self.accountname_or_email_to_add.clear();
    }

    pub fn has_accountname_or_email_to_add(&self) -> bool {
        self.accountname_or_email_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountname_or_email_to_add(&mut self, v: ::std::string::String) {
        self.accountname_or_email_to_add = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountname_or_email_to_add(&mut self) -> &mut ::std::string::String {
        if self.accountname_or_email_to_add.is_none() {
            self.accountname_or_email_to_add.set_default();
        }
        self.accountname_or_email_to_add.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountname_or_email_to_add(&mut self) -> ::std::string::String {
        self.accountname_or_email_to_add.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientAddFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_to_add = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.accountname_or_email_to_add)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_to_add {
            my_size += 9;
        }
        if let Some(ref v) = self.accountname_or_email_to_add.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_to_add {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.accountname_or_email_to_add.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAddFriend {
        CMsgClientAddFriend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_to_add",
                |m: &CMsgClientAddFriend| { &m.steamid_to_add },
                |m: &mut CMsgClientAddFriend| { &mut m.steamid_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accountname_or_email_to_add",
                |m: &CMsgClientAddFriend| { &m.accountname_or_email_to_add },
                |m: &mut CMsgClientAddFriend| { &mut m.accountname_or_email_to_add },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAddFriend>(
                "CMsgClientAddFriend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAddFriend {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAddFriend> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAddFriend::new)
    }
}

impl ::protobuf::Clear for CMsgClientAddFriend {
    fn clear(&mut self) {
        self.steamid_to_add = ::std::option::Option::None;
        self.accountname_or_email_to_add.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAddFriend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientAddFriendResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    steam_id_added: ::std::option::Option<u64>,
    persona_name_added: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendResponse {
    fn default() -> &'a CMsgClientAddFriendResponse {
        <CMsgClientAddFriendResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriendResponse {
    pub fn new() -> CMsgClientAddFriendResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id_added = 2;


    pub fn get_steam_id_added(&self) -> u64 {
        self.steam_id_added.unwrap_or(0)
    }
    pub fn clear_steam_id_added(&mut self) {
        self.steam_id_added = ::std::option::Option::None;
    }

    pub fn has_steam_id_added(&self) -> bool {
        self.steam_id_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_added(&mut self, v: u64) {
        self.steam_id_added = ::std::option::Option::Some(v);
    }

    // optional string persona_name_added = 3;


    pub fn get_persona_name_added(&self) -> &str {
        match self.persona_name_added.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persona_name_added(&mut self) {
        self.persona_name_added.clear();
    }

    pub fn has_persona_name_added(&self) -> bool {
        self.persona_name_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_added(&mut self, v: ::std::string::String) {
        self.persona_name_added = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_added(&mut self) -> &mut ::std::string::String {
        if self.persona_name_added.is_none() {
            self.persona_name_added.set_default();
        }
        self.persona_name_added.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_added(&mut self) -> ::std::string::String {
        self.persona_name_added.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientAddFriendResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steam_id_added = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name_added)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steam_id_added {
            my_size += 9;
        }
        if let Some(ref v) = self.persona_name_added.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steam_id_added {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.persona_name_added.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAddFriendResponse {
        CMsgClientAddFriendResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientAddFriendResponse| { &m.eresult },
                |m: &mut CMsgClientAddFriendResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steam_id_added",
                |m: &CMsgClientAddFriendResponse| { &m.steam_id_added },
                |m: &mut CMsgClientAddFriendResponse| { &mut m.steam_id_added },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persona_name_added",
                |m: &CMsgClientAddFriendResponse| { &m.persona_name_added },
                |m: &mut CMsgClientAddFriendResponse| { &mut m.persona_name_added },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAddFriendResponse>(
                "CMsgClientAddFriendResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAddFriendResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAddFriendResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAddFriendResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAddFriendResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steam_id_added = ::std::option::Option::None;
        self.persona_name_added.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAddFriendResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientRemoveFriend {
    // message fields
    friendid: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriend {
    fn default() -> &'a CMsgClientRemoveFriend {
        <CMsgClientRemoveFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriend {
    pub fn new() -> CMsgClientRemoveFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 friendid = 1;


    pub fn get_friendid(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }
    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.friendid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friendid {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friendid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRemoveFriend {
        CMsgClientRemoveFriend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "friendid",
                |m: &CMsgClientRemoveFriend| { &m.friendid },
                |m: &mut CMsgClientRemoveFriend| { &mut m.friendid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRemoveFriend>(
                "CMsgClientRemoveFriend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRemoveFriend {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRemoveFriend> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRemoveFriend::new)
    }
}

impl ::protobuf::Clear for CMsgClientRemoveFriend {
    fn clear(&mut self) {
        self.friendid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRemoveFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRemoveFriend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientHideFriend {
    // message fields
    friendid: ::std::option::Option<u64>,
    hide: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientHideFriend {
    fn default() -> &'a CMsgClientHideFriend {
        <CMsgClientHideFriend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHideFriend {
    pub fn new() -> CMsgClientHideFriend {
        ::std::default::Default::default()
    }

    // optional fixed64 friendid = 1;


    pub fn get_friendid(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }
    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }

    // optional bool hide = 2;


    pub fn get_hide(&self) -> bool {
        self.hide.unwrap_or(false)
    }
    pub fn clear_hide(&mut self) {
        self.hide = ::std::option::Option::None;
    }

    pub fn has_hide(&self) -> bool {
        self.hide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide(&mut self, v: bool) {
        self.hide = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientHideFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.friendid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hide = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friendid {
            my_size += 9;
        }
        if let Some(v) = self.hide {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friendid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.hide {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientHideFriend {
        CMsgClientHideFriend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "friendid",
                |m: &CMsgClientHideFriend| { &m.friendid },
                |m: &mut CMsgClientHideFriend| { &mut m.friendid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hide",
                |m: &CMsgClientHideFriend| { &m.hide },
                |m: &mut CMsgClientHideFriend| { &mut m.hide },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientHideFriend>(
                "CMsgClientHideFriend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientHideFriend {
        static instance: ::protobuf::rt::LazyV2<CMsgClientHideFriend> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientHideFriend::new)
    }
}

impl ::protobuf::Clear for CMsgClientHideFriend {
    fn clear(&mut self) {
        self.friendid = ::std::option::Option::None;
        self.hide = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientHideFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientHideFriend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientFriendsList {
    // message fields
    bincremental: ::std::option::Option<bool>,
    pub friends: ::protobuf::RepeatedField<CMsgClientFriendsList_Friend>,
    max_friend_count: ::std::option::Option<u32>,
    active_friend_count: ::std::option::Option<u32>,
    friends_limit_hit: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsList {
    fn default() -> &'a CMsgClientFriendsList {
        <CMsgClientFriendsList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendsList {
    pub fn new() -> CMsgClientFriendsList {
        ::std::default::Default::default()
    }

    // optional bool bincremental = 1;


    pub fn get_bincremental(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }
    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientFriendsList.Friend friends = 2;


    pub fn get_friends(&self) -> &[CMsgClientFriendsList_Friend] {
        &self.friends
    }
    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::protobuf::RepeatedField<CMsgClientFriendsList_Friend>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientFriendsList_Friend> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::protobuf::RepeatedField<CMsgClientFriendsList_Friend> {
        ::std::mem::replace(&mut self.friends, ::protobuf::RepeatedField::new())
    }

    // optional uint32 max_friend_count = 3;


    pub fn get_max_friend_count(&self) -> u32 {
        self.max_friend_count.unwrap_or(0)
    }
    pub fn clear_max_friend_count(&mut self) {
        self.max_friend_count = ::std::option::Option::None;
    }

    pub fn has_max_friend_count(&self) -> bool {
        self.max_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_friend_count(&mut self, v: u32) {
        self.max_friend_count = ::std::option::Option::Some(v);
    }

    // optional uint32 active_friend_count = 4;


    pub fn get_active_friend_count(&self) -> u32 {
        self.active_friend_count.unwrap_or(0)
    }
    pub fn clear_active_friend_count(&mut self) {
        self.active_friend_count = ::std::option::Option::None;
    }

    pub fn has_active_friend_count(&self) -> bool {
        self.active_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_friend_count(&mut self, v: u32) {
        self.active_friend_count = ::std::option::Option::Some(v);
    }

    // optional bool friends_limit_hit = 5;


    pub fn get_friends_limit_hit(&self) -> bool {
        self.friends_limit_hit.unwrap_or(false)
    }
    pub fn clear_friends_limit_hit(&mut self) {
        self.friends_limit_hit = ::std::option::Option::None;
    }

    pub fn has_friends_limit_hit(&self) -> bool {
        self.friends_limit_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_limit_hit(&mut self, v: bool) {
        self.friends_limit_hit = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendsList {
    fn is_initialized(&self) -> bool {
        for v in &self.friends {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bincremental = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friends)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_friend_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active_friend_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.friends_limit_hit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bincremental {
            my_size += 2;
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.max_friend_count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.active_friend_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.friends_limit_hit {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bincremental {
            os.write_bool(1, v)?;
        }
        for v in &self.friends {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.max_friend_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active_friend_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.friends_limit_hit {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendsList {
        CMsgClientFriendsList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bincremental",
                |m: &CMsgClientFriendsList| { &m.bincremental },
                |m: &mut CMsgClientFriendsList| { &mut m.bincremental },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientFriendsList_Friend>>(
                "friends",
                |m: &CMsgClientFriendsList| { &m.friends },
                |m: &mut CMsgClientFriendsList| { &mut m.friends },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_friend_count",
                |m: &CMsgClientFriendsList| { &m.max_friend_count },
                |m: &mut CMsgClientFriendsList| { &mut m.max_friend_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "active_friend_count",
                |m: &CMsgClientFriendsList| { &m.active_friend_count },
                |m: &mut CMsgClientFriendsList| { &mut m.active_friend_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "friends_limit_hit",
                |m: &CMsgClientFriendsList| { &m.friends_limit_hit },
                |m: &mut CMsgClientFriendsList| { &mut m.friends_limit_hit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendsList>(
                "CMsgClientFriendsList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendsList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendsList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendsList::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendsList {
    fn clear(&mut self) {
        self.bincremental = ::std::option::Option::None;
        self.friends.clear();
        self.max_friend_count = ::std::option::Option::None;
        self.active_friend_count = ::std::option::Option::None;
        self.friends_limit_hit = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendsList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientFriendsList_Friend {
    // message fields
    ulfriendid: ::std::option::Option<u64>,
    efriendrelationship: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsList_Friend {
    fn default() -> &'a CMsgClientFriendsList_Friend {
        <CMsgClientFriendsList_Friend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendsList_Friend {
    pub fn new() -> CMsgClientFriendsList_Friend {
        ::std::default::Default::default()
    }

    // optional fixed64 ulfriendid = 1;


    pub fn get_ulfriendid(&self) -> u64 {
        self.ulfriendid.unwrap_or(0)
    }
    pub fn clear_ulfriendid(&mut self) {
        self.ulfriendid = ::std::option::Option::None;
    }

    pub fn has_ulfriendid(&self) -> bool {
        self.ulfriendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ulfriendid(&mut self, v: u64) {
        self.ulfriendid = ::std::option::Option::Some(v);
    }

    // optional uint32 efriendrelationship = 2;


    pub fn get_efriendrelationship(&self) -> u32 {
        self.efriendrelationship.unwrap_or(0)
    }
    pub fn clear_efriendrelationship(&mut self) {
        self.efriendrelationship = ::std::option::Option::None;
    }

    pub fn has_efriendrelationship(&self) -> bool {
        self.efriendrelationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_efriendrelationship(&mut self, v: u32) {
        self.efriendrelationship = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendsList_Friend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.ulfriendid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.efriendrelationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ulfriendid {
            my_size += 9;
        }
        if let Some(v) = self.efriendrelationship {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ulfriendid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.efriendrelationship {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendsList_Friend {
        CMsgClientFriendsList_Friend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "ulfriendid",
                |m: &CMsgClientFriendsList_Friend| { &m.ulfriendid },
                |m: &mut CMsgClientFriendsList_Friend| { &mut m.ulfriendid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "efriendrelationship",
                |m: &CMsgClientFriendsList_Friend| { &m.efriendrelationship },
                |m: &mut CMsgClientFriendsList_Friend| { &mut m.efriendrelationship },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendsList_Friend>(
                "CMsgClientFriendsList.Friend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendsList_Friend {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendsList_Friend> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendsList_Friend::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendsList_Friend {
    fn clear(&mut self) {
        self.ulfriendid = ::std::option::Option::None;
        self.efriendrelationship = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsList_Friend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendsList_Friend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientFriendsGroupsList {
    // message fields
    bremoval: ::std::option::Option<bool>,
    bincremental: ::std::option::Option<bool>,
    pub friendGroups: ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroup>,
    pub memberships: ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroupsMembership>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsGroupsList {
    fn default() -> &'a CMsgClientFriendsGroupsList {
        <CMsgClientFriendsGroupsList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendsGroupsList {
    pub fn new() -> CMsgClientFriendsGroupsList {
        ::std::default::Default::default()
    }

    // optional bool bremoval = 1;


    pub fn get_bremoval(&self) -> bool {
        self.bremoval.unwrap_or(false)
    }
    pub fn clear_bremoval(&mut self) {
        self.bremoval = ::std::option::Option::None;
    }

    pub fn has_bremoval(&self) -> bool {
        self.bremoval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bremoval(&mut self, v: bool) {
        self.bremoval = ::std::option::Option::Some(v);
    }

    // optional bool bincremental = 2;


    pub fn get_bincremental(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }
    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientFriendsGroupsList.FriendGroup friendGroups = 3;


    pub fn get_friendGroups(&self) -> &[CMsgClientFriendsGroupsList_FriendGroup] {
        &self.friendGroups
    }
    pub fn clear_friendGroups(&mut self) {
        self.friendGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_friendGroups(&mut self, v: ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroup>) {
        self.friendGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friendGroups(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroup> {
        &mut self.friendGroups
    }

    // Take field
    pub fn take_friendGroups(&mut self) -> ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroup> {
        ::std::mem::replace(&mut self.friendGroups, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgClientFriendsGroupsList.FriendGroupsMembership memberships = 4;


    pub fn get_memberships(&self) -> &[CMsgClientFriendsGroupsList_FriendGroupsMembership] {
        &self.memberships
    }
    pub fn clear_memberships(&mut self) {
        self.memberships.clear();
    }

    // Param is passed by value, moved
    pub fn set_memberships(&mut self, v: ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroupsMembership>) {
        self.memberships = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memberships(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroupsMembership> {
        &mut self.memberships
    }

    // Take field
    pub fn take_memberships(&mut self) -> ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroupsMembership> {
        ::std::mem::replace(&mut self.memberships, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientFriendsGroupsList {
    fn is_initialized(&self) -> bool {
        for v in &self.friendGroups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.memberships {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bremoval = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bincremental = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friendGroups)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.memberships)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.bremoval {
            my_size += 2;
        }
        if let Some(v) = self.bincremental {
            my_size += 2;
        }
        for value in &self.friendGroups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.memberships {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bremoval {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bincremental {
            os.write_bool(2, v)?;
        }
        for v in &self.friendGroups {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.memberships {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendsGroupsList {
        CMsgClientFriendsGroupsList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bremoval",
                |m: &CMsgClientFriendsGroupsList| { &m.bremoval },
                |m: &mut CMsgClientFriendsGroupsList| { &mut m.bremoval },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bincremental",
                |m: &CMsgClientFriendsGroupsList| { &m.bincremental },
                |m: &mut CMsgClientFriendsGroupsList| { &mut m.bincremental },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientFriendsGroupsList_FriendGroup>>(
                "friendGroups",
                |m: &CMsgClientFriendsGroupsList| { &m.friendGroups },
                |m: &mut CMsgClientFriendsGroupsList| { &mut m.friendGroups },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientFriendsGroupsList_FriendGroupsMembership>>(
                "memberships",
                |m: &CMsgClientFriendsGroupsList| { &m.memberships },
                |m: &mut CMsgClientFriendsGroupsList| { &mut m.memberships },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendsGroupsList>(
                "CMsgClientFriendsGroupsList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendsGroupsList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendsGroupsList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendsGroupsList::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendsGroupsList {
    fn clear(&mut self) {
        self.bremoval = ::std::option::Option::None;
        self.bincremental = ::std::option::Option::None;
        self.friendGroups.clear();
        self.memberships.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsGroupsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendsGroupsList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientFriendsGroupsList_FriendGroup {
    // message fields
    nGroupID: ::std::option::Option<i32>,
    strGroupName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsGroupsList_FriendGroup {
    fn default() -> &'a CMsgClientFriendsGroupsList_FriendGroup {
        <CMsgClientFriendsGroupsList_FriendGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendsGroupsList_FriendGroup {
    pub fn new() -> CMsgClientFriendsGroupsList_FriendGroup {
        ::std::default::Default::default()
    }

    // optional int32 nGroupID = 1;


    pub fn get_nGroupID(&self) -> i32 {
        self.nGroupID.unwrap_or(0)
    }
    pub fn clear_nGroupID(&mut self) {
        self.nGroupID = ::std::option::Option::None;
    }

    pub fn has_nGroupID(&self) -> bool {
        self.nGroupID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nGroupID(&mut self, v: i32) {
        self.nGroupID = ::std::option::Option::Some(v);
    }

    // optional string strGroupName = 2;


    pub fn get_strGroupName(&self) -> &str {
        match self.strGroupName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_strGroupName(&mut self) {
        self.strGroupName.clear();
    }

    pub fn has_strGroupName(&self) -> bool {
        self.strGroupName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strGroupName(&mut self, v: ::std::string::String) {
        self.strGroupName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_strGroupName(&mut self) -> &mut ::std::string::String {
        if self.strGroupName.is_none() {
            self.strGroupName.set_default();
        }
        self.strGroupName.as_mut().unwrap()
    }

    // Take field
    pub fn take_strGroupName(&mut self) -> ::std::string::String {
        self.strGroupName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientFriendsGroupsList_FriendGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nGroupID = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.strGroupName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.nGroupID {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.strGroupName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.nGroupID {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.strGroupName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendsGroupsList_FriendGroup {
        CMsgClientFriendsGroupsList_FriendGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "nGroupID",
                |m: &CMsgClientFriendsGroupsList_FriendGroup| { &m.nGroupID },
                |m: &mut CMsgClientFriendsGroupsList_FriendGroup| { &mut m.nGroupID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "strGroupName",
                |m: &CMsgClientFriendsGroupsList_FriendGroup| { &m.strGroupName },
                |m: &mut CMsgClientFriendsGroupsList_FriendGroup| { &mut m.strGroupName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendsGroupsList_FriendGroup>(
                "CMsgClientFriendsGroupsList.FriendGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendsGroupsList_FriendGroup {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendsGroupsList_FriendGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendsGroupsList_FriendGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendsGroupsList_FriendGroup {
    fn clear(&mut self) {
        self.nGroupID = ::std::option::Option::None;
        self.strGroupName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsGroupsList_FriendGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendsGroupsList_FriendGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientFriendsGroupsList_FriendGroupsMembership {
    // message fields
    ulSteamID: ::std::option::Option<u64>,
    nGroupID: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn default() -> &'a CMsgClientFriendsGroupsList_FriendGroupsMembership {
        <CMsgClientFriendsGroupsList_FriendGroupsMembership as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendsGroupsList_FriendGroupsMembership {
    pub fn new() -> CMsgClientFriendsGroupsList_FriendGroupsMembership {
        ::std::default::Default::default()
    }

    // optional fixed64 ulSteamID = 1;


    pub fn get_ulSteamID(&self) -> u64 {
        self.ulSteamID.unwrap_or(0)
    }
    pub fn clear_ulSteamID(&mut self) {
        self.ulSteamID = ::std::option::Option::None;
    }

    pub fn has_ulSteamID(&self) -> bool {
        self.ulSteamID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ulSteamID(&mut self, v: u64) {
        self.ulSteamID = ::std::option::Option::Some(v);
    }

    // optional int32 nGroupID = 2;


    pub fn get_nGroupID(&self) -> i32 {
        self.nGroupID.unwrap_or(0)
    }
    pub fn clear_nGroupID(&mut self) {
        self.nGroupID = ::std::option::Option::None;
    }

    pub fn has_nGroupID(&self) -> bool {
        self.nGroupID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nGroupID(&mut self, v: i32) {
        self.nGroupID = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.ulSteamID = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nGroupID = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ulSteamID {
            my_size += 9;
        }
        if let Some(v) = self.nGroupID {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ulSteamID {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.nGroupID {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendsGroupsList_FriendGroupsMembership {
        CMsgClientFriendsGroupsList_FriendGroupsMembership::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "ulSteamID",
                |m: &CMsgClientFriendsGroupsList_FriendGroupsMembership| { &m.ulSteamID },
                |m: &mut CMsgClientFriendsGroupsList_FriendGroupsMembership| { &mut m.ulSteamID },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "nGroupID",
                |m: &CMsgClientFriendsGroupsList_FriendGroupsMembership| { &m.nGroupID },
                |m: &mut CMsgClientFriendsGroupsList_FriendGroupsMembership| { &mut m.nGroupID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendsGroupsList_FriendGroupsMembership>(
                "CMsgClientFriendsGroupsList.FriendGroupsMembership",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendsGroupsList_FriendGroupsMembership {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendsGroupsList_FriendGroupsMembership> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendsGroupsList_FriendGroupsMembership::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn clear(&mut self) {
        self.ulSteamID = ::std::option::Option::None;
        self.nGroupID = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientPlayerNicknameList {
    // message fields
    removal: ::std::option::Option<bool>,
    incremental: ::std::option::Option<bool>,
    pub nicknames: ::protobuf::RepeatedField<CMsgClientPlayerNicknameList_PlayerNickname>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayerNicknameList {
    fn default() -> &'a CMsgClientPlayerNicknameList {
        <CMsgClientPlayerNicknameList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPlayerNicknameList {
    pub fn new() -> CMsgClientPlayerNicknameList {
        ::std::default::Default::default()
    }

    // optional bool removal = 1;


    pub fn get_removal(&self) -> bool {
        self.removal.unwrap_or(false)
    }
    pub fn clear_removal(&mut self) {
        self.removal = ::std::option::Option::None;
    }

    pub fn has_removal(&self) -> bool {
        self.removal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_removal(&mut self, v: bool) {
        self.removal = ::std::option::Option::Some(v);
    }

    // optional bool incremental = 2;


    pub fn get_incremental(&self) -> bool {
        self.incremental.unwrap_or(false)
    }
    pub fn clear_incremental(&mut self) {
        self.incremental = ::std::option::Option::None;
    }

    pub fn has_incremental(&self) -> bool {
        self.incremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incremental(&mut self, v: bool) {
        self.incremental = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientPlayerNicknameList.PlayerNickname nicknames = 3;


    pub fn get_nicknames(&self) -> &[CMsgClientPlayerNicknameList_PlayerNickname] {
        &self.nicknames
    }
    pub fn clear_nicknames(&mut self) {
        self.nicknames.clear();
    }

    // Param is passed by value, moved
    pub fn set_nicknames(&mut self, v: ::protobuf::RepeatedField<CMsgClientPlayerNicknameList_PlayerNickname>) {
        self.nicknames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nicknames(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPlayerNicknameList_PlayerNickname> {
        &mut self.nicknames
    }

    // Take field
    pub fn take_nicknames(&mut self) -> ::protobuf::RepeatedField<CMsgClientPlayerNicknameList_PlayerNickname> {
        ::std::mem::replace(&mut self.nicknames, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientPlayerNicknameList {
    fn is_initialized(&self) -> bool {
        for v in &self.nicknames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.removal = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.incremental = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nicknames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.removal {
            my_size += 2;
        }
        if let Some(v) = self.incremental {
            my_size += 2;
        }
        for value in &self.nicknames {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.removal {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.incremental {
            os.write_bool(2, v)?;
        }
        for v in &self.nicknames {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPlayerNicknameList {
        CMsgClientPlayerNicknameList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "removal",
                |m: &CMsgClientPlayerNicknameList| { &m.removal },
                |m: &mut CMsgClientPlayerNicknameList| { &mut m.removal },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "incremental",
                |m: &CMsgClientPlayerNicknameList| { &m.incremental },
                |m: &mut CMsgClientPlayerNicknameList| { &mut m.incremental },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPlayerNicknameList_PlayerNickname>>(
                "nicknames",
                |m: &CMsgClientPlayerNicknameList| { &m.nicknames },
                |m: &mut CMsgClientPlayerNicknameList| { &mut m.nicknames },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPlayerNicknameList>(
                "CMsgClientPlayerNicknameList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPlayerNicknameList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPlayerNicknameList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPlayerNicknameList::new)
    }
}

impl ::protobuf::Clear for CMsgClientPlayerNicknameList {
    fn clear(&mut self) {
        self.removal = ::std::option::Option::None;
        self.incremental = ::std::option::Option::None;
        self.nicknames.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPlayerNicknameList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPlayerNicknameList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientPlayerNicknameList_PlayerNickname {
    // message fields
    steamid: ::std::option::Option<u64>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPlayerNicknameList_PlayerNickname {
    fn default() -> &'a CMsgClientPlayerNicknameList_PlayerNickname {
        <CMsgClientPlayerNicknameList_PlayerNickname as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPlayerNicknameList_PlayerNickname {
    pub fn new() -> CMsgClientPlayerNicknameList_PlayerNickname {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 3;


    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientPlayerNicknameList_PlayerNickname {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPlayerNicknameList_PlayerNickname {
        CMsgClientPlayerNicknameList_PlayerNickname::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgClientPlayerNicknameList_PlayerNickname| { &m.steamid },
                |m: &mut CMsgClientPlayerNicknameList_PlayerNickname| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nickname",
                |m: &CMsgClientPlayerNicknameList_PlayerNickname| { &m.nickname },
                |m: &mut CMsgClientPlayerNicknameList_PlayerNickname| { &mut m.nickname },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPlayerNicknameList_PlayerNickname>(
                "CMsgClientPlayerNicknameList.PlayerNickname",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPlayerNicknameList_PlayerNickname {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPlayerNicknameList_PlayerNickname> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPlayerNicknameList_PlayerNickname::new)
    }
}

impl ::protobuf::Clear for CMsgClientPlayerNicknameList_PlayerNickname {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.nickname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPlayerNicknameList_PlayerNickname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPlayerNicknameList_PlayerNickname {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientSetPlayerNickname {
    // message fields
    steamid: ::std::option::Option<u64>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetPlayerNickname {
    fn default() -> &'a CMsgClientSetPlayerNickname {
        <CMsgClientSetPlayerNickname as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetPlayerNickname {
    pub fn new() -> CMsgClientSetPlayerNickname {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string nickname = 2;


    pub fn get_nickname(&self) -> &str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname(&mut self) -> &mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        }
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientSetPlayerNickname {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.nickname.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSetPlayerNickname {
        CMsgClientSetPlayerNickname::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgClientSetPlayerNickname| { &m.steamid },
                |m: &mut CMsgClientSetPlayerNickname| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nickname",
                |m: &CMsgClientSetPlayerNickname| { &m.nickname },
                |m: &mut CMsgClientSetPlayerNickname| { &mut m.nickname },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSetPlayerNickname>(
                "CMsgClientSetPlayerNickname",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSetPlayerNickname {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSetPlayerNickname> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSetPlayerNickname::new)
    }
}

impl ::protobuf::Clear for CMsgClientSetPlayerNickname {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.nickname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSetPlayerNickname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetPlayerNickname {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientSetPlayerNicknameResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientSetPlayerNicknameResponse {
    fn default() -> &'a CMsgClientSetPlayerNicknameResponse {
        <CMsgClientSetPlayerNicknameResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSetPlayerNicknameResponse {
    pub fn new() -> CMsgClientSetPlayerNicknameResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientSetPlayerNicknameResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientSetPlayerNicknameResponse {
        CMsgClientSetPlayerNicknameResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientSetPlayerNicknameResponse| { &m.eresult },
                |m: &mut CMsgClientSetPlayerNicknameResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientSetPlayerNicknameResponse>(
                "CMsgClientSetPlayerNicknameResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientSetPlayerNicknameResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientSetPlayerNicknameResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientSetPlayerNicknameResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientSetPlayerNicknameResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientSetPlayerNicknameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientSetPlayerNicknameResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientRequestFriendData {
    // message fields
    persona_state_requested: ::std::option::Option<u32>,
    pub friends: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRequestFriendData {
    fn default() -> &'a CMsgClientRequestFriendData {
        <CMsgClientRequestFriendData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRequestFriendData {
    pub fn new() -> CMsgClientRequestFriendData {
        ::std::default::Default::default()
    }

    // optional uint32 persona_state_requested = 1;


    pub fn get_persona_state_requested(&self) -> u32 {
        self.persona_state_requested.unwrap_or(0)
    }
    pub fn clear_persona_state_requested(&mut self) {
        self.persona_state_requested = ::std::option::Option::None;
    }

    pub fn has_persona_state_requested(&self) -> bool {
        self.persona_state_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_requested(&mut self, v: u32) {
        self.persona_state_requested = ::std::option::Option::Some(v);
    }

    // repeated fixed64 friends = 2;


    pub fn get_friends(&self) -> &[u64] {
        &self.friends
    }
    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::std::vec::Vec<u64>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.friends, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientRequestFriendData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.persona_state_requested = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.persona_state_requested {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 9 * self.friends.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.persona_state_requested {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRequestFriendData {
        CMsgClientRequestFriendData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "persona_state_requested",
                |m: &CMsgClientRequestFriendData| { &m.persona_state_requested },
                |m: &mut CMsgClientRequestFriendData| { &mut m.persona_state_requested },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "friends",
                |m: &CMsgClientRequestFriendData| { &m.friends },
                |m: &mut CMsgClientRequestFriendData| { &mut m.friends },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRequestFriendData>(
                "CMsgClientRequestFriendData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRequestFriendData {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRequestFriendData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRequestFriendData::new)
    }
}

impl ::protobuf::Clear for CMsgClientRequestFriendData {
    fn clear(&mut self) {
        self.persona_state_requested = ::std::option::Option::None;
        self.friends.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRequestFriendData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRequestFriendData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientChangeStatus {
    // message fields
    persona_state: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    is_auto_generated_name: ::std::option::Option<bool>,
    high_priority: ::std::option::Option<bool>,
    persona_set_by_user: ::std::option::Option<bool>,
    persona_state_flags: ::std::option::Option<u32>,
    need_persona_response: ::std::option::Option<bool>,
    is_client_idle: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientChangeStatus {
    fn default() -> &'a CMsgClientChangeStatus {
        <CMsgClientChangeStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientChangeStatus {
    pub fn new() -> CMsgClientChangeStatus {
        ::std::default::Default::default()
    }

    // optional uint32 persona_state = 1;


    pub fn get_persona_state(&self) -> u32 {
        self.persona_state.unwrap_or(0)
    }
    pub fn clear_persona_state(&mut self) {
        self.persona_state = ::std::option::Option::None;
    }

    pub fn has_persona_state(&self) -> bool {
        self.persona_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state(&mut self, v: u32) {
        self.persona_state = ::std::option::Option::Some(v);
    }

    // optional string player_name = 2;


    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_auto_generated_name = 3;


    pub fn get_is_auto_generated_name(&self) -> bool {
        self.is_auto_generated_name.unwrap_or(false)
    }
    pub fn clear_is_auto_generated_name(&mut self) {
        self.is_auto_generated_name = ::std::option::Option::None;
    }

    pub fn has_is_auto_generated_name(&self) -> bool {
        self.is_auto_generated_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_auto_generated_name(&mut self, v: bool) {
        self.is_auto_generated_name = ::std::option::Option::Some(v);
    }

    // optional bool high_priority = 4;


    pub fn get_high_priority(&self) -> bool {
        self.high_priority.unwrap_or(false)
    }
    pub fn clear_high_priority(&mut self) {
        self.high_priority = ::std::option::Option::None;
    }

    pub fn has_high_priority(&self) -> bool {
        self.high_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority(&mut self, v: bool) {
        self.high_priority = ::std::option::Option::Some(v);
    }

    // optional bool persona_set_by_user = 5;


    pub fn get_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.unwrap_or(false)
    }
    pub fn clear_persona_set_by_user(&mut self) {
        self.persona_set_by_user = ::std::option::Option::None;
    }

    pub fn has_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_set_by_user(&mut self, v: bool) {
        self.persona_set_by_user = ::std::option::Option::Some(v);
    }

    // optional uint32 persona_state_flags = 6;


    pub fn get_persona_state_flags(&self) -> u32 {
        self.persona_state_flags.unwrap_or(0u32)
    }
    pub fn clear_persona_state_flags(&mut self) {
        self.persona_state_flags = ::std::option::Option::None;
    }

    pub fn has_persona_state_flags(&self) -> bool {
        self.persona_state_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_flags(&mut self, v: u32) {
        self.persona_state_flags = ::std::option::Option::Some(v);
    }

    // optional bool need_persona_response = 7;


    pub fn get_need_persona_response(&self) -> bool {
        self.need_persona_response.unwrap_or(false)
    }
    pub fn clear_need_persona_response(&mut self) {
        self.need_persona_response = ::std::option::Option::None;
    }

    pub fn has_need_persona_response(&self) -> bool {
        self.need_persona_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_persona_response(&mut self, v: bool) {
        self.need_persona_response = ::std::option::Option::Some(v);
    }

    // optional bool is_client_idle = 8;


    pub fn get_is_client_idle(&self) -> bool {
        self.is_client_idle.unwrap_or(false)
    }
    pub fn clear_is_client_idle(&mut self) {
        self.is_client_idle = ::std::option::Option::None;
    }

    pub fn has_is_client_idle(&self) -> bool {
        self.is_client_idle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_client_idle(&mut self, v: bool) {
        self.is_client_idle = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientChangeStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.persona_state = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_auto_generated_name = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.high_priority = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.persona_set_by_user = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.persona_state_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.need_persona_response = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_client_idle = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.persona_state {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_auto_generated_name {
            my_size += 2;
        }
        if let Some(v) = self.high_priority {
            my_size += 2;
        }
        if let Some(v) = self.persona_set_by_user {
            my_size += 2;
        }
        if let Some(v) = self.persona_state_flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.need_persona_response {
            my_size += 2;
        }
        if let Some(v) = self.is_client_idle {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.persona_state {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.is_auto_generated_name {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.high_priority {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.persona_set_by_user {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.persona_state_flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.need_persona_response {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.is_client_idle {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientChangeStatus {
        CMsgClientChangeStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "persona_state",
                |m: &CMsgClientChangeStatus| { &m.persona_state },
                |m: &mut CMsgClientChangeStatus| { &mut m.persona_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "player_name",
                |m: &CMsgClientChangeStatus| { &m.player_name },
                |m: &mut CMsgClientChangeStatus| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_auto_generated_name",
                |m: &CMsgClientChangeStatus| { &m.is_auto_generated_name },
                |m: &mut CMsgClientChangeStatus| { &mut m.is_auto_generated_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "high_priority",
                |m: &CMsgClientChangeStatus| { &m.high_priority },
                |m: &mut CMsgClientChangeStatus| { &mut m.high_priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "persona_set_by_user",
                |m: &CMsgClientChangeStatus| { &m.persona_set_by_user },
                |m: &mut CMsgClientChangeStatus| { &mut m.persona_set_by_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "persona_state_flags",
                |m: &CMsgClientChangeStatus| { &m.persona_state_flags },
                |m: &mut CMsgClientChangeStatus| { &mut m.persona_state_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "need_persona_response",
                |m: &CMsgClientChangeStatus| { &m.need_persona_response },
                |m: &mut CMsgClientChangeStatus| { &mut m.need_persona_response },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_client_idle",
                |m: &CMsgClientChangeStatus| { &m.is_client_idle },
                |m: &mut CMsgClientChangeStatus| { &mut m.is_client_idle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientChangeStatus>(
                "CMsgClientChangeStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientChangeStatus {
        static instance: ::protobuf::rt::LazyV2<CMsgClientChangeStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientChangeStatus::new)
    }
}

impl ::protobuf::Clear for CMsgClientChangeStatus {
    fn clear(&mut self) {
        self.persona_state = ::std::option::Option::None;
        self.player_name.clear();
        self.is_auto_generated_name = ::std::option::Option::None;
        self.high_priority = ::std::option::Option::None;
        self.persona_set_by_user = ::std::option::Option::None;
        self.persona_state_flags = ::std::option::Option::None;
        self.need_persona_response = ::std::option::Option::None;
        self.is_client_idle = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientChangeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientChangeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgPersonaChangeResponse {
    // message fields
    result: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgPersonaChangeResponse {
    fn default() -> &'a CMsgPersonaChangeResponse {
        <CMsgPersonaChangeResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgPersonaChangeResponse {
    pub fn new() -> CMsgPersonaChangeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;


    pub fn get_result(&self) -> u32 {
        self.result.unwrap_or(0)
    }
    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string player_name = 2;


    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgPersonaChangeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgPersonaChangeResponse {
        CMsgPersonaChangeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "result",
                |m: &CMsgPersonaChangeResponse| { &m.result },
                |m: &mut CMsgPersonaChangeResponse| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "player_name",
                |m: &CMsgPersonaChangeResponse| { &m.player_name },
                |m: &mut CMsgPersonaChangeResponse| { &mut m.player_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgPersonaChangeResponse>(
                "CMsgPersonaChangeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgPersonaChangeResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgPersonaChangeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgPersonaChangeResponse::new)
    }
}

impl ::protobuf::Clear for CMsgPersonaChangeResponse {
    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.player_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgPersonaChangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgPersonaChangeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientPersonaState {
    // message fields
    status_flags: ::std::option::Option<u32>,
    pub friends: ::protobuf::RepeatedField<CMsgClientPersonaState_Friend>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPersonaState {
    fn default() -> &'a CMsgClientPersonaState {
        <CMsgClientPersonaState as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPersonaState {
    pub fn new() -> CMsgClientPersonaState {
        ::std::default::Default::default()
    }

    // optional uint32 status_flags = 1;


    pub fn get_status_flags(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }
    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }

    // repeated .CMsgClientPersonaState.Friend friends = 2;


    pub fn get_friends(&self) -> &[CMsgClientPersonaState_Friend] {
        &self.friends
    }
    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::protobuf::RepeatedField<CMsgClientPersonaState_Friend>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPersonaState_Friend> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::protobuf::RepeatedField<CMsgClientPersonaState_Friend> {
        ::std::mem::replace(&mut self.friends, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientPersonaState {
    fn is_initialized(&self) -> bool {
        for v in &self.friends {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status_flags = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.status_flags {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.friends {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status_flags {
            os.write_uint32(1, v)?;
        }
        for v in &self.friends {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPersonaState {
        CMsgClientPersonaState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "status_flags",
                |m: &CMsgClientPersonaState| { &m.status_flags },
                |m: &mut CMsgClientPersonaState| { &mut m.status_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPersonaState_Friend>>(
                "friends",
                |m: &CMsgClientPersonaState| { &m.friends },
                |m: &mut CMsgClientPersonaState| { &mut m.friends },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPersonaState>(
                "CMsgClientPersonaState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPersonaState {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPersonaState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPersonaState::new)
    }
}

impl ::protobuf::Clear for CMsgClientPersonaState {
    fn clear(&mut self) {
        self.status_flags = ::std::option::Option::None;
        self.friends.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPersonaState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPersonaState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientPersonaState_Friend {
    // message fields
    friendid: ::std::option::Option<u64>,
    persona_state: ::std::option::Option<u32>,
    game_played_app_id: ::std::option::Option<u32>,
    game_server_ip: ::std::option::Option<u32>,
    game_server_port: ::std::option::Option<u32>,
    persona_state_flags: ::std::option::Option<u32>,
    online_session_instances: ::std::option::Option<u32>,
    persona_set_by_user: ::std::option::Option<bool>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    query_port: ::std::option::Option<u32>,
    steamid_source: ::std::option::Option<u64>,
    avatar_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    last_logoff: ::std::option::Option<u32>,
    last_logon: ::std::option::Option<u32>,
    last_seen_online: ::std::option::Option<u32>,
    clan_rank: ::std::option::Option<u32>,
    game_name: ::protobuf::SingularField<::std::string::String>,
    gameid: ::std::option::Option<u64>,
    game_data_blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub clan_data: ::protobuf::SingularPtrField<CMsgClientPersonaState_Friend_ClanData>,
    clan_tag: ::protobuf::SingularField<::std::string::String>,
    pub rich_presence: ::protobuf::RepeatedField<CMsgClientPersonaState_Friend_KV>,
    broadcast_id: ::std::option::Option<u64>,
    game_lobby_id: ::std::option::Option<u64>,
    watching_broadcast_accountid: ::std::option::Option<u32>,
    watching_broadcast_appid: ::std::option::Option<u32>,
    watching_broadcast_viewers: ::std::option::Option<u32>,
    watching_broadcast_title: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPersonaState_Friend {
    fn default() -> &'a CMsgClientPersonaState_Friend {
        <CMsgClientPersonaState_Friend as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPersonaState_Friend {
    pub fn new() -> CMsgClientPersonaState_Friend {
        ::std::default::Default::default()
    }

    // optional fixed64 friendid = 1;


    pub fn get_friendid(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }
    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }

    // optional uint32 persona_state = 2;


    pub fn get_persona_state(&self) -> u32 {
        self.persona_state.unwrap_or(0)
    }
    pub fn clear_persona_state(&mut self) {
        self.persona_state = ::std::option::Option::None;
    }

    pub fn has_persona_state(&self) -> bool {
        self.persona_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state(&mut self, v: u32) {
        self.persona_state = ::std::option::Option::Some(v);
    }

    // optional uint32 game_played_app_id = 3;


    pub fn get_game_played_app_id(&self) -> u32 {
        self.game_played_app_id.unwrap_or(0)
    }
    pub fn clear_game_played_app_id(&mut self) {
        self.game_played_app_id = ::std::option::Option::None;
    }

    pub fn has_game_played_app_id(&self) -> bool {
        self.game_played_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_played_app_id(&mut self, v: u32) {
        self.game_played_app_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_ip = 4;


    pub fn get_game_server_ip(&self) -> u32 {
        self.game_server_ip.unwrap_or(0)
    }
    pub fn clear_game_server_ip(&mut self) {
        self.game_server_ip = ::std::option::Option::None;
    }

    pub fn has_game_server_ip(&self) -> bool {
        self.game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_ip(&mut self, v: u32) {
        self.game_server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_port = 5;


    pub fn get_game_server_port(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }
    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 persona_state_flags = 6;


    pub fn get_persona_state_flags(&self) -> u32 {
        self.persona_state_flags.unwrap_or(0)
    }
    pub fn clear_persona_state_flags(&mut self) {
        self.persona_state_flags = ::std::option::Option::None;
    }

    pub fn has_persona_state_flags(&self) -> bool {
        self.persona_state_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_flags(&mut self, v: u32) {
        self.persona_state_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 online_session_instances = 7;


    pub fn get_online_session_instances(&self) -> u32 {
        self.online_session_instances.unwrap_or(0)
    }
    pub fn clear_online_session_instances(&mut self) {
        self.online_session_instances = ::std::option::Option::None;
    }

    pub fn has_online_session_instances(&self) -> bool {
        self.online_session_instances.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online_session_instances(&mut self, v: u32) {
        self.online_session_instances = ::std::option::Option::Some(v);
    }

    // optional bool persona_set_by_user = 10;


    pub fn get_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.unwrap_or(false)
    }
    pub fn clear_persona_set_by_user(&mut self) {
        self.persona_set_by_user = ::std::option::Option::None;
    }

    pub fn has_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_set_by_user(&mut self, v: bool) {
        self.persona_set_by_user = ::std::option::Option::Some(v);
    }

    // optional string player_name = 15;


    pub fn get_player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 query_port = 20;


    pub fn get_query_port(&self) -> u32 {
        self.query_port.unwrap_or(0)
    }
    pub fn clear_query_port(&mut self) {
        self.query_port = ::std::option::Option::None;
    }

    pub fn has_query_port(&self) -> bool {
        self.query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_port(&mut self, v: u32) {
        self.query_port = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_source = 25;


    pub fn get_steamid_source(&self) -> u64 {
        self.steamid_source.unwrap_or(0)
    }
    pub fn clear_steamid_source(&mut self) {
        self.steamid_source = ::std::option::Option::None;
    }

    pub fn has_steamid_source(&self) -> bool {
        self.steamid_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_source(&mut self, v: u64) {
        self.steamid_source = ::std::option::Option::Some(v);
    }

    // optional bytes avatar_hash = 31;


    pub fn get_avatar_hash(&self) -> &[u8] {
        match self.avatar_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_avatar_hash(&mut self) {
        self.avatar_hash.clear();
    }

    pub fn has_avatar_hash(&self) -> bool {
        self.avatar_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.avatar_hash.is_none() {
            self.avatar_hash.set_default();
        }
        self.avatar_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 last_logoff = 45;


    pub fn get_last_logoff(&self) -> u32 {
        self.last_logoff.unwrap_or(0)
    }
    pub fn clear_last_logoff(&mut self) {
        self.last_logoff = ::std::option::Option::None;
    }

    pub fn has_last_logoff(&self) -> bool {
        self.last_logoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_logoff(&mut self, v: u32) {
        self.last_logoff = ::std::option::Option::Some(v);
    }

    // optional uint32 last_logon = 46;


    pub fn get_last_logon(&self) -> u32 {
        self.last_logon.unwrap_or(0)
    }
    pub fn clear_last_logon(&mut self) {
        self.last_logon = ::std::option::Option::None;
    }

    pub fn has_last_logon(&self) -> bool {
        self.last_logon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_logon(&mut self, v: u32) {
        self.last_logon = ::std::option::Option::Some(v);
    }

    // optional uint32 last_seen_online = 47;


    pub fn get_last_seen_online(&self) -> u32 {
        self.last_seen_online.unwrap_or(0)
    }
    pub fn clear_last_seen_online(&mut self) {
        self.last_seen_online = ::std::option::Option::None;
    }

    pub fn has_last_seen_online(&self) -> bool {
        self.last_seen_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_seen_online(&mut self, v: u32) {
        self.last_seen_online = ::std::option::Option::Some(v);
    }

    // optional uint32 clan_rank = 50;


    pub fn get_clan_rank(&self) -> u32 {
        self.clan_rank.unwrap_or(0)
    }
    pub fn clear_clan_rank(&mut self) {
        self.clan_rank = ::std::option::Option::None;
    }

    pub fn has_clan_rank(&self) -> bool {
        self.clan_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_rank(&mut self, v: u32) {
        self.clan_rank = ::std::option::Option::Some(v);
    }

    // optional string game_name = 55;


    pub fn get_game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_game_name(&mut self) {
        self.game_name.clear();
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name.set_default();
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 gameid = 56;


    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional bytes game_data_blob = 60;


    pub fn get_game_data_blob(&self) -> &[u8] {
        match self.game_data_blob.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_game_data_blob(&mut self) {
        self.game_data_blob.clear();
    }

    pub fn has_game_data_blob(&self) -> bool {
        self.game_data_blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data_blob = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data_blob(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data_blob.is_none() {
            self.game_data_blob.set_default();
        }
        self.game_data_blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data_blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .CMsgClientPersonaState.Friend.ClanData clan_data = 64;


    pub fn get_clan_data(&self) -> &CMsgClientPersonaState_Friend_ClanData {
        self.clan_data.as_ref().unwrap_or_else(|| <CMsgClientPersonaState_Friend_ClanData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_clan_data(&mut self) {
        self.clan_data.clear();
    }

    pub fn has_clan_data(&self) -> bool {
        self.clan_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_data(&mut self, v: CMsgClientPersonaState_Friend_ClanData) {
        self.clan_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clan_data(&mut self) -> &mut CMsgClientPersonaState_Friend_ClanData {
        if self.clan_data.is_none() {
            self.clan_data.set_default();
        }
        self.clan_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_clan_data(&mut self) -> CMsgClientPersonaState_Friend_ClanData {
        self.clan_data.take().unwrap_or_else(|| CMsgClientPersonaState_Friend_ClanData::new())
    }

    // optional string clan_tag = 65;


    pub fn get_clan_tag(&self) -> &str {
        match self.clan_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clan_tag(&mut self) {
        self.clan_tag.clear();
    }

    pub fn has_clan_tag(&self) -> bool {
        self.clan_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_tag(&mut self, v: ::std::string::String) {
        self.clan_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clan_tag(&mut self) -> &mut ::std::string::String {
        if self.clan_tag.is_none() {
            self.clan_tag.set_default();
        }
        self.clan_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_clan_tag(&mut self) -> ::std::string::String {
        self.clan_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .CMsgClientPersonaState.Friend.KV rich_presence = 71;


    pub fn get_rich_presence(&self) -> &[CMsgClientPersonaState_Friend_KV] {
        &self.rich_presence
    }
    pub fn clear_rich_presence(&mut self) {
        self.rich_presence.clear();
    }

    // Param is passed by value, moved
    pub fn set_rich_presence(&mut self, v: ::protobuf::RepeatedField<CMsgClientPersonaState_Friend_KV>) {
        self.rich_presence = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rich_presence(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientPersonaState_Friend_KV> {
        &mut self.rich_presence
    }

    // Take field
    pub fn take_rich_presence(&mut self) -> ::protobuf::RepeatedField<CMsgClientPersonaState_Friend_KV> {
        ::std::mem::replace(&mut self.rich_presence, ::protobuf::RepeatedField::new())
    }

    // optional fixed64 broadcast_id = 72;


    pub fn get_broadcast_id(&self) -> u64 {
        self.broadcast_id.unwrap_or(0)
    }
    pub fn clear_broadcast_id(&mut self) {
        self.broadcast_id = ::std::option::Option::None;
    }

    pub fn has_broadcast_id(&self) -> bool {
        self.broadcast_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_id(&mut self, v: u64) {
        self.broadcast_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 game_lobby_id = 73;


    pub fn get_game_lobby_id(&self) -> u64 {
        self.game_lobby_id.unwrap_or(0)
    }
    pub fn clear_game_lobby_id(&mut self) {
        self.game_lobby_id = ::std::option::Option::None;
    }

    pub fn has_game_lobby_id(&self) -> bool {
        self.game_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_lobby_id(&mut self, v: u64) {
        self.game_lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_accountid = 74;


    pub fn get_watching_broadcast_accountid(&self) -> u32 {
        self.watching_broadcast_accountid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_accountid(&mut self) {
        self.watching_broadcast_accountid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_accountid(&self) -> bool {
        self.watching_broadcast_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_accountid(&mut self, v: u32) {
        self.watching_broadcast_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_appid = 75;


    pub fn get_watching_broadcast_appid(&self) -> u32 {
        self.watching_broadcast_appid.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_appid(&mut self) {
        self.watching_broadcast_appid = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_appid(&self) -> bool {
        self.watching_broadcast_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_appid(&mut self, v: u32) {
        self.watching_broadcast_appid = ::std::option::Option::Some(v);
    }

    // optional uint32 watching_broadcast_viewers = 76;


    pub fn get_watching_broadcast_viewers(&self) -> u32 {
        self.watching_broadcast_viewers.unwrap_or(0)
    }
    pub fn clear_watching_broadcast_viewers(&mut self) {
        self.watching_broadcast_viewers = ::std::option::Option::None;
    }

    pub fn has_watching_broadcast_viewers(&self) -> bool {
        self.watching_broadcast_viewers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_viewers(&mut self, v: u32) {
        self.watching_broadcast_viewers = ::std::option::Option::Some(v);
    }

    // optional string watching_broadcast_title = 77;


    pub fn get_watching_broadcast_title(&self) -> &str {
        match self.watching_broadcast_title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_watching_broadcast_title(&mut self) {
        self.watching_broadcast_title.clear();
    }

    pub fn has_watching_broadcast_title(&self) -> bool {
        self.watching_broadcast_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watching_broadcast_title(&mut self, v: ::std::string::String) {
        self.watching_broadcast_title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watching_broadcast_title(&mut self) -> &mut ::std::string::String {
        if self.watching_broadcast_title.is_none() {
            self.watching_broadcast_title.set_default();
        }
        self.watching_broadcast_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_watching_broadcast_title(&mut self) -> ::std::string::String {
        self.watching_broadcast_title.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientPersonaState_Friend {
    fn is_initialized(&self) -> bool {
        for v in &self.clan_data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rich_presence {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.friendid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.persona_state = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_played_app_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_server_ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.game_server_port = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.persona_state_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.online_session_instances = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.persona_set_by_user = ::std::option::Option::Some(tmp);
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.query_port = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_source = ::std::option::Option::Some(tmp);
                },
                31 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.avatar_hash)?;
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_logoff = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_logon = ::std::option::Option::Some(tmp);
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.last_seen_online = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.clan_rank = ::std::option::Option::Some(tmp);
                },
                55 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_name)?;
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                60 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.game_data_blob)?;
                },
                64 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clan_data)?;
                },
                65 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clan_tag)?;
                },
                71 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rich_presence)?;
                },
                72 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.broadcast_id = ::std::option::Option::Some(tmp);
                },
                73 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.game_lobby_id = ::std::option::Option::Some(tmp);
                },
                74 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_accountid = ::std::option::Option::Some(tmp);
                },
                75 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_appid = ::std::option::Option::Some(tmp);
                },
                76 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.watching_broadcast_viewers = ::std::option::Option::Some(tmp);
                },
                77 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.watching_broadcast_title)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.friendid {
            my_size += 9;
        }
        if let Some(v) = self.persona_state {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_played_app_id {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_ip {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.game_server_port {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.persona_state_flags {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.online_session_instances {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.persona_set_by_user {
            my_size += 2;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.query_port {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid_source {
            my_size += 10;
        }
        if let Some(ref v) = self.avatar_hash.as_ref() {
            my_size += ::protobuf::rt::bytes_size(31, &v);
        }
        if let Some(v) = self.last_logoff {
            my_size += ::protobuf::rt::value_size(45, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_logon {
            my_size += ::protobuf::rt::value_size(46, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.last_seen_online {
            my_size += ::protobuf::rt::value_size(47, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.clan_rank {
            my_size += ::protobuf::rt::value_size(50, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(55, &v);
        }
        if let Some(v) = self.gameid {
            my_size += 10;
        }
        if let Some(ref v) = self.game_data_blob.as_ref() {
            my_size += ::protobuf::rt::bytes_size(60, &v);
        }
        if let Some(ref v) = self.clan_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clan_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(65, &v);
        }
        for value in &self.rich_presence {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.broadcast_id {
            my_size += 10;
        }
        if let Some(v) = self.game_lobby_id {
            my_size += 10;
        }
        if let Some(v) = self.watching_broadcast_accountid {
            my_size += ::protobuf::rt::value_size(74, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watching_broadcast_appid {
            my_size += ::protobuf::rt::value_size(75, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.watching_broadcast_viewers {
            my_size += ::protobuf::rt::value_size(76, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.watching_broadcast_title.as_ref() {
            my_size += ::protobuf::rt::string_size(77, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friendid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.persona_state {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_played_app_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_ip {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_server_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.persona_state_flags {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.online_session_instances {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.persona_set_by_user {
            os.write_bool(10, v)?;
        }
        if let Some(ref v) = self.player_name.as_ref() {
            os.write_string(15, &v)?;
        }
        if let Some(v) = self.query_port {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.steamid_source {
            os.write_fixed64(25, v)?;
        }
        if let Some(ref v) = self.avatar_hash.as_ref() {
            os.write_bytes(31, &v)?;
        }
        if let Some(v) = self.last_logoff {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.last_logon {
            os.write_uint32(46, v)?;
        }
        if let Some(v) = self.last_seen_online {
            os.write_uint32(47, v)?;
        }
        if let Some(v) = self.clan_rank {
            os.write_uint32(50, v)?;
        }
        if let Some(ref v) = self.game_name.as_ref() {
            os.write_string(55, &v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(56, v)?;
        }
        if let Some(ref v) = self.game_data_blob.as_ref() {
            os.write_bytes(60, &v)?;
        }
        if let Some(ref v) = self.clan_data.as_ref() {
            os.write_tag(64, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clan_tag.as_ref() {
            os.write_string(65, &v)?;
        }
        for v in &self.rich_presence {
            os.write_tag(71, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.broadcast_id {
            os.write_fixed64(72, v)?;
        }
        if let Some(v) = self.game_lobby_id {
            os.write_fixed64(73, v)?;
        }
        if let Some(v) = self.watching_broadcast_accountid {
            os.write_uint32(74, v)?;
        }
        if let Some(v) = self.watching_broadcast_appid {
            os.write_uint32(75, v)?;
        }
        if let Some(v) = self.watching_broadcast_viewers {
            os.write_uint32(76, v)?;
        }
        if let Some(ref v) = self.watching_broadcast_title.as_ref() {
            os.write_string(77, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPersonaState_Friend {
        CMsgClientPersonaState_Friend::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "friendid",
                |m: &CMsgClientPersonaState_Friend| { &m.friendid },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.friendid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "persona_state",
                |m: &CMsgClientPersonaState_Friend| { &m.persona_state },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.persona_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_played_app_id",
                |m: &CMsgClientPersonaState_Friend| { &m.game_played_app_id },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.game_played_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_server_ip",
                |m: &CMsgClientPersonaState_Friend| { &m.game_server_ip },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.game_server_ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "game_server_port",
                |m: &CMsgClientPersonaState_Friend| { &m.game_server_port },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.game_server_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "persona_state_flags",
                |m: &CMsgClientPersonaState_Friend| { &m.persona_state_flags },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.persona_state_flags },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "online_session_instances",
                |m: &CMsgClientPersonaState_Friend| { &m.online_session_instances },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.online_session_instances },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "persona_set_by_user",
                |m: &CMsgClientPersonaState_Friend| { &m.persona_set_by_user },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.persona_set_by_user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "player_name",
                |m: &CMsgClientPersonaState_Friend| { &m.player_name },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "query_port",
                |m: &CMsgClientPersonaState_Friend| { &m.query_port },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.query_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_source",
                |m: &CMsgClientPersonaState_Friend| { &m.steamid_source },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.steamid_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "avatar_hash",
                |m: &CMsgClientPersonaState_Friend| { &m.avatar_hash },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.avatar_hash },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_logoff",
                |m: &CMsgClientPersonaState_Friend| { &m.last_logoff },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.last_logoff },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_logon",
                |m: &CMsgClientPersonaState_Friend| { &m.last_logon },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.last_logon },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "last_seen_online",
                |m: &CMsgClientPersonaState_Friend| { &m.last_seen_online },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.last_seen_online },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "clan_rank",
                |m: &CMsgClientPersonaState_Friend| { &m.clan_rank },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.clan_rank },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "game_name",
                |m: &CMsgClientPersonaState_Friend| { &m.game_name },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.game_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "gameid",
                |m: &CMsgClientPersonaState_Friend| { &m.gameid },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.gameid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "game_data_blob",
                |m: &CMsgClientPersonaState_Friend| { &m.game_data_blob },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.game_data_blob },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPersonaState_Friend_ClanData>>(
                "clan_data",
                |m: &CMsgClientPersonaState_Friend| { &m.clan_data },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.clan_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clan_tag",
                |m: &CMsgClientPersonaState_Friend| { &m.clan_tag },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.clan_tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientPersonaState_Friend_KV>>(
                "rich_presence",
                |m: &CMsgClientPersonaState_Friend| { &m.rich_presence },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.rich_presence },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "broadcast_id",
                |m: &CMsgClientPersonaState_Friend| { &m.broadcast_id },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.broadcast_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "game_lobby_id",
                |m: &CMsgClientPersonaState_Friend| { &m.game_lobby_id },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.game_lobby_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "watching_broadcast_accountid",
                |m: &CMsgClientPersonaState_Friend| { &m.watching_broadcast_accountid },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.watching_broadcast_accountid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "watching_broadcast_appid",
                |m: &CMsgClientPersonaState_Friend| { &m.watching_broadcast_appid },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.watching_broadcast_appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "watching_broadcast_viewers",
                |m: &CMsgClientPersonaState_Friend| { &m.watching_broadcast_viewers },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.watching_broadcast_viewers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "watching_broadcast_title",
                |m: &CMsgClientPersonaState_Friend| { &m.watching_broadcast_title },
                |m: &mut CMsgClientPersonaState_Friend| { &mut m.watching_broadcast_title },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPersonaState_Friend>(
                "CMsgClientPersonaState.Friend",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPersonaState_Friend {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPersonaState_Friend> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPersonaState_Friend::new)
    }
}

impl ::protobuf::Clear for CMsgClientPersonaState_Friend {
    fn clear(&mut self) {
        self.friendid = ::std::option::Option::None;
        self.persona_state = ::std::option::Option::None;
        self.game_played_app_id = ::std::option::Option::None;
        self.game_server_ip = ::std::option::Option::None;
        self.game_server_port = ::std::option::Option::None;
        self.persona_state_flags = ::std::option::Option::None;
        self.online_session_instances = ::std::option::Option::None;
        self.persona_set_by_user = ::std::option::Option::None;
        self.player_name.clear();
        self.query_port = ::std::option::Option::None;
        self.steamid_source = ::std::option::Option::None;
        self.avatar_hash.clear();
        self.last_logoff = ::std::option::Option::None;
        self.last_logon = ::std::option::Option::None;
        self.last_seen_online = ::std::option::Option::None;
        self.clan_rank = ::std::option::Option::None;
        self.game_name.clear();
        self.gameid = ::std::option::Option::None;
        self.game_data_blob.clear();
        self.clan_data.clear();
        self.clan_tag.clear();
        self.rich_presence.clear();
        self.broadcast_id = ::std::option::Option::None;
        self.game_lobby_id = ::std::option::Option::None;
        self.watching_broadcast_accountid = ::std::option::Option::None;
        self.watching_broadcast_appid = ::std::option::Option::None;
        self.watching_broadcast_viewers = ::std::option::Option::None;
        self.watching_broadcast_title.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPersonaState_Friend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPersonaState_Friend {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientPersonaState_Friend_ClanData {
    // message fields
    ogg_app_id: ::std::option::Option<u32>,
    chat_group_id: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPersonaState_Friend_ClanData {
    fn default() -> &'a CMsgClientPersonaState_Friend_ClanData {
        <CMsgClientPersonaState_Friend_ClanData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPersonaState_Friend_ClanData {
    pub fn new() -> CMsgClientPersonaState_Friend_ClanData {
        ::std::default::Default::default()
    }

    // optional uint32 ogg_app_id = 1;


    pub fn get_ogg_app_id(&self) -> u32 {
        self.ogg_app_id.unwrap_or(0)
    }
    pub fn clear_ogg_app_id(&mut self) {
        self.ogg_app_id = ::std::option::Option::None;
    }

    pub fn has_ogg_app_id(&self) -> bool {
        self.ogg_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ogg_app_id(&mut self, v: u32) {
        self.ogg_app_id = ::std::option::Option::Some(v);
    }

    // optional uint64 chat_group_id = 2;


    pub fn get_chat_group_id(&self) -> u64 {
        self.chat_group_id.unwrap_or(0)
    }
    pub fn clear_chat_group_id(&mut self) {
        self.chat_group_id = ::std::option::Option::None;
    }

    pub fn has_chat_group_id(&self) -> bool {
        self.chat_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_group_id(&mut self, v: u64) {
        self.chat_group_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientPersonaState_Friend_ClanData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ogg_app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.chat_group_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.ogg_app_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.chat_group_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ogg_app_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.chat_group_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPersonaState_Friend_ClanData {
        CMsgClientPersonaState_Friend_ClanData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "ogg_app_id",
                |m: &CMsgClientPersonaState_Friend_ClanData| { &m.ogg_app_id },
                |m: &mut CMsgClientPersonaState_Friend_ClanData| { &mut m.ogg_app_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "chat_group_id",
                |m: &CMsgClientPersonaState_Friend_ClanData| { &m.chat_group_id },
                |m: &mut CMsgClientPersonaState_Friend_ClanData| { &mut m.chat_group_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPersonaState_Friend_ClanData>(
                "CMsgClientPersonaState.Friend.ClanData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPersonaState_Friend_ClanData {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPersonaState_Friend_ClanData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPersonaState_Friend_ClanData::new)
    }
}

impl ::protobuf::Clear for CMsgClientPersonaState_Friend_ClanData {
    fn clear(&mut self) {
        self.ogg_app_id = ::std::option::Option::None;
        self.chat_group_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPersonaState_Friend_ClanData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPersonaState_Friend_ClanData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientPersonaState_Friend_KV {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientPersonaState_Friend_KV {
    fn default() -> &'a CMsgClientPersonaState_Friend_KV {
        <CMsgClientPersonaState_Friend_KV as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPersonaState_Friend_KV {
    pub fn new() -> CMsgClientPersonaState_Friend_KV {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientPersonaState_Friend_KV {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientPersonaState_Friend_KV {
        CMsgClientPersonaState_Friend_KV::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &CMsgClientPersonaState_Friend_KV| { &m.key },
                |m: &mut CMsgClientPersonaState_Friend_KV| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &CMsgClientPersonaState_Friend_KV| { &m.value },
                |m: &mut CMsgClientPersonaState_Friend_KV| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientPersonaState_Friend_KV>(
                "CMsgClientPersonaState.Friend.KV",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientPersonaState_Friend_KV {
        static instance: ::protobuf::rt::LazyV2<CMsgClientPersonaState_Friend_KV> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientPersonaState_Friend_KV::new)
    }
}

impl ::protobuf::Clear for CMsgClientPersonaState_Friend_KV {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientPersonaState_Friend_KV {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientPersonaState_Friend_KV {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientFriendProfileInfo {
    // message fields
    steamid_friend: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendProfileInfo {
    fn default() -> &'a CMsgClientFriendProfileInfo {
        <CMsgClientFriendProfileInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendProfileInfo {
    pub fn new() -> CMsgClientFriendProfileInfo {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid_friend = 1;


    pub fn get_steamid_friend(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }
    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientFriendProfileInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_friend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid_friend {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_friend {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendProfileInfo {
        CMsgClientFriendProfileInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_friend",
                |m: &CMsgClientFriendProfileInfo| { &m.steamid_friend },
                |m: &mut CMsgClientFriendProfileInfo| { &mut m.steamid_friend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendProfileInfo>(
                "CMsgClientFriendProfileInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendProfileInfo {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendProfileInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendProfileInfo::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendProfileInfo {
    fn clear(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendProfileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendProfileInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientFriendProfileInfoResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    steamid_friend: ::std::option::Option<u64>,
    time_created: ::std::option::Option<u32>,
    real_name: ::protobuf::SingularField<::std::string::String>,
    city_name: ::protobuf::SingularField<::std::string::String>,
    state_name: ::protobuf::SingularField<::std::string::String>,
    country_name: ::protobuf::SingularField<::std::string::String>,
    headline: ::protobuf::SingularField<::std::string::String>,
    summary: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientFriendProfileInfoResponse {
    fn default() -> &'a CMsgClientFriendProfileInfoResponse {
        <CMsgClientFriendProfileInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientFriendProfileInfoResponse {
    pub fn new() -> CMsgClientFriendProfileInfoResponse {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;


    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid_friend = 2;


    pub fn get_steamid_friend(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }
    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }

    // optional uint32 time_created = 3;


    pub fn get_time_created(&self) -> u32 {
        self.time_created.unwrap_or(0)
    }
    pub fn clear_time_created(&mut self) {
        self.time_created = ::std::option::Option::None;
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: u32) {
        self.time_created = ::std::option::Option::Some(v);
    }

    // optional string real_name = 4;


    pub fn get_real_name(&self) -> &str {
        match self.real_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_real_name(&mut self) {
        self.real_name.clear();
    }

    pub fn has_real_name(&self) -> bool {
        self.real_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_name(&mut self, v: ::std::string::String) {
        self.real_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_real_name(&mut self) -> &mut ::std::string::String {
        if self.real_name.is_none() {
            self.real_name.set_default();
        }
        self.real_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_real_name(&mut self) -> ::std::string::String {
        self.real_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city_name = 5;


    pub fn get_city_name(&self) -> &str {
        match self.city_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_city_name(&mut self) {
        self.city_name.clear();
    }

    pub fn has_city_name(&self) -> bool {
        self.city_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city_name(&mut self, v: ::std::string::String) {
        self.city_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city_name(&mut self) -> &mut ::std::string::String {
        if self.city_name.is_none() {
            self.city_name.set_default();
        }
        self.city_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_city_name(&mut self) -> ::std::string::String {
        self.city_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string state_name = 6;


    pub fn get_state_name(&self) -> &str {
        match self.state_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_state_name(&mut self) {
        self.state_name.clear();
    }

    pub fn has_state_name(&self) -> bool {
        self.state_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_name(&mut self, v: ::std::string::String) {
        self.state_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_name(&mut self) -> &mut ::std::string::String {
        if self.state_name.is_none() {
            self.state_name.set_default();
        }
        self.state_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_name(&mut self) -> ::std::string::String {
        self.state_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_name = 7;


    pub fn get_country_name(&self) -> &str {
        match self.country_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country_name(&mut self) {
        self.country_name.clear();
    }

    pub fn has_country_name(&self) -> bool {
        self.country_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_name(&mut self, v: ::std::string::String) {
        self.country_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_name(&mut self) -> &mut ::std::string::String {
        if self.country_name.is_none() {
            self.country_name.set_default();
        }
        self.country_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_name(&mut self) -> ::std::string::String {
        self.country_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string headline = 8;


    pub fn get_headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_headline(&mut self) {
        self.headline.clear();
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline.set_default();
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string summary = 9;


    pub fn get_summary(&self) -> &str {
        match self.summary.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary(&mut self) -> &mut ::std::string::String {
        if self.summary.is_none() {
            self.summary.set_default();
        }
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CMsgClientFriendProfileInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid_friend = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_created = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.real_name)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city_name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headline)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.summary)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid_friend {
            my_size += 9;
        }
        if let Some(v) = self.time_created {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.real_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.city_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.state_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.country_name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.summary.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamid_friend {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.time_created {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.real_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.city_name.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.state_name.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.country_name.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.headline.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.summary.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientFriendProfileInfoResponse {
        CMsgClientFriendProfileInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "eresult",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.eresult },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_friend",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.steamid_friend },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.steamid_friend },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_created",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.time_created },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.time_created },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "real_name",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.real_name },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.real_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "city_name",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.city_name },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.city_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state_name",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.state_name },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.state_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country_name",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.country_name },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.country_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "headline",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.headline },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.headline },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "summary",
                |m: &CMsgClientFriendProfileInfoResponse| { &m.summary },
                |m: &mut CMsgClientFriendProfileInfoResponse| { &mut m.summary },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientFriendProfileInfoResponse>(
                "CMsgClientFriendProfileInfoResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientFriendProfileInfoResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientFriendProfileInfoResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientFriendProfileInfoResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientFriendProfileInfoResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.steamid_friend = ::std::option::Option::None;
        self.time_created = ::std::option::Option::None;
        self.real_name.clear();
        self.city_name.clear();
        self.state_name.clear();
        self.country_name.clear();
        self.headline.clear();
        self.summary.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientFriendProfileInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientFriendProfileInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientCreateFriendsGroup {
    // message fields
    steamid: ::std::option::Option<u64>,
    groupname: ::protobuf::SingularField<::std::string::String>,
    pub steamid_friends: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCreateFriendsGroup {
    fn default() -> &'a CMsgClientCreateFriendsGroup {
        <CMsgClientCreateFriendsGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCreateFriendsGroup {
    pub fn new() -> CMsgClientCreateFriendsGroup {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional string groupname = 2;


    pub fn get_groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_groupname(&mut self) {
        self.groupname.clear();
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname.set_default();
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated fixed64 steamid_friends = 3;


    pub fn get_steamid_friends(&self) -> &[u64] {
        &self.steamid_friends
    }
    pub fn clear_steamid_friends(&mut self) {
        self.steamid_friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_friends(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_friends(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_friends
    }

    // Take field
    pub fn take_steamid_friends(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_friends, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientCreateFriendsGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupname)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_friends)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += 9 * self.steamid_friends.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(ref v) = self.groupname.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.steamid_friends {
            os.write_fixed64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCreateFriendsGroup {
        CMsgClientCreateFriendsGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgClientCreateFriendsGroup| { &m.steamid },
                |m: &mut CMsgClientCreateFriendsGroup| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "groupname",
                |m: &CMsgClientCreateFriendsGroup| { &m.groupname },
                |m: &mut CMsgClientCreateFriendsGroup| { &mut m.groupname },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_friends",
                |m: &CMsgClientCreateFriendsGroup| { &m.steamid_friends },
                |m: &mut CMsgClientCreateFriendsGroup| { &mut m.steamid_friends },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientCreateFriendsGroup>(
                "CMsgClientCreateFriendsGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCreateFriendsGroup {
        static instance: ::protobuf::rt::LazyV2<CMsgClientCreateFriendsGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientCreateFriendsGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientCreateFriendsGroup {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.groupname.clear();
        self.steamid_friends.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCreateFriendsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCreateFriendsGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientCreateFriendsGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    groupid: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientCreateFriendsGroupResponse {
    fn default() -> &'a CMsgClientCreateFriendsGroupResponse {
        <CMsgClientCreateFriendsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientCreateFriendsGroupResponse {
    pub fn new() -> CMsgClientCreateFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional int32 groupid = 2;


    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }
    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientCreateFriendsGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.groupid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientCreateFriendsGroupResponse {
        CMsgClientCreateFriendsGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientCreateFriendsGroupResponse| { &m.eresult },
                |m: &mut CMsgClientCreateFriendsGroupResponse| { &mut m.eresult },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "groupid",
                |m: &CMsgClientCreateFriendsGroupResponse| { &m.groupid },
                |m: &mut CMsgClientCreateFriendsGroupResponse| { &mut m.groupid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientCreateFriendsGroupResponse>(
                "CMsgClientCreateFriendsGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientCreateFriendsGroupResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientCreateFriendsGroupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientCreateFriendsGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientCreateFriendsGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.groupid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientCreateFriendsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientCreateFriendsGroupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientDeleteFriendsGroup {
    // message fields
    steamid: ::std::option::Option<u64>,
    groupid: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeleteFriendsGroup {
    fn default() -> &'a CMsgClientDeleteFriendsGroup {
        <CMsgClientDeleteFriendsGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeleteFriendsGroup {
    pub fn new() -> CMsgClientDeleteFriendsGroup {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;


    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 groupid = 2;


    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }
    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeleteFriendsGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.groupid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.groupid {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeleteFriendsGroup {
        CMsgClientDeleteFriendsGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid",
                |m: &CMsgClientDeleteFriendsGroup| { &m.steamid },
                |m: &mut CMsgClientDeleteFriendsGroup| { &mut m.steamid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "groupid",
                |m: &CMsgClientDeleteFriendsGroup| { &m.groupid },
                |m: &mut CMsgClientDeleteFriendsGroup| { &mut m.groupid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDeleteFriendsGroup>(
                "CMsgClientDeleteFriendsGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeleteFriendsGroup {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDeleteFriendsGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDeleteFriendsGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeleteFriendsGroup {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.groupid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeleteFriendsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeleteFriendsGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientDeleteFriendsGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientDeleteFriendsGroupResponse {
    fn default() -> &'a CMsgClientDeleteFriendsGroupResponse {
        <CMsgClientDeleteFriendsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientDeleteFriendsGroupResponse {
    pub fn new() -> CMsgClientDeleteFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientDeleteFriendsGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientDeleteFriendsGroupResponse {
        CMsgClientDeleteFriendsGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientDeleteFriendsGroupResponse| { &m.eresult },
                |m: &mut CMsgClientDeleteFriendsGroupResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientDeleteFriendsGroupResponse>(
                "CMsgClientDeleteFriendsGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientDeleteFriendsGroupResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientDeleteFriendsGroupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientDeleteFriendsGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientDeleteFriendsGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientDeleteFriendsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientDeleteFriendsGroupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientManageFriendsGroup {
    // message fields
    groupid: ::std::option::Option<i32>,
    groupname: ::protobuf::SingularField<::std::string::String>,
    pub steamid_friends_added: ::std::vec::Vec<u64>,
    pub steamid_friends_removed: ::std::vec::Vec<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientManageFriendsGroup {
    fn default() -> &'a CMsgClientManageFriendsGroup {
        <CMsgClientManageFriendsGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientManageFriendsGroup {
    pub fn new() -> CMsgClientManageFriendsGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;


    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }
    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional string groupname = 2;


    pub fn get_groupname(&self) -> &str {
        match self.groupname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_groupname(&mut self) {
        self.groupname.clear();
    }

    pub fn has_groupname(&self) -> bool {
        self.groupname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupname(&mut self, v: ::std::string::String) {
        self.groupname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupname(&mut self) -> &mut ::std::string::String {
        if self.groupname.is_none() {
            self.groupname.set_default();
        }
        self.groupname.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupname(&mut self) -> ::std::string::String {
        self.groupname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated fixed64 steamid_friends_added = 3;


    pub fn get_steamid_friends_added(&self) -> &[u64] {
        &self.steamid_friends_added
    }
    pub fn clear_steamid_friends_added(&mut self) {
        self.steamid_friends_added.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_friends_added(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_friends_added = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_friends_added(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_friends_added
    }

    // Take field
    pub fn take_steamid_friends_added(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_friends_added, ::std::vec::Vec::new())
    }

    // repeated fixed64 steamid_friends_removed = 4;


    pub fn get_steamid_friends_removed(&self) -> &[u64] {
        &self.steamid_friends_removed
    }
    pub fn clear_steamid_friends_removed(&mut self) {
        self.steamid_friends_removed.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamid_friends_removed(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamid_friends_removed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamid_friends_removed(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.steamid_friends_removed
    }

    // Take field
    pub fn take_steamid_friends_removed(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamid_friends_removed, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgClientManageFriendsGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.groupid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupname)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_friends_added)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamid_friends_removed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.groupname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += 9 * self.steamid_friends_added.len() as u32;
        my_size += 9 * self.steamid_friends_removed.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.groupname.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.steamid_friends_added {
            os.write_fixed64(3, *v)?;
        };
        for v in &self.steamid_friends_removed {
            os.write_fixed64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientManageFriendsGroup {
        CMsgClientManageFriendsGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "groupid",
                |m: &CMsgClientManageFriendsGroup| { &m.groupid },
                |m: &mut CMsgClientManageFriendsGroup| { &mut m.groupid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "groupname",
                |m: &CMsgClientManageFriendsGroup| { &m.groupname },
                |m: &mut CMsgClientManageFriendsGroup| { &mut m.groupname },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_friends_added",
                |m: &CMsgClientManageFriendsGroup| { &m.steamid_friends_added },
                |m: &mut CMsgClientManageFriendsGroup| { &mut m.steamid_friends_added },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamid_friends_removed",
                |m: &CMsgClientManageFriendsGroup| { &m.steamid_friends_removed },
                |m: &mut CMsgClientManageFriendsGroup| { &mut m.steamid_friends_removed },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientManageFriendsGroup>(
                "CMsgClientManageFriendsGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientManageFriendsGroup {
        static instance: ::protobuf::rt::LazyV2<CMsgClientManageFriendsGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientManageFriendsGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientManageFriendsGroup {
    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.groupname.clear();
        self.steamid_friends_added.clear();
        self.steamid_friends_removed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientManageFriendsGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientManageFriendsGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientManageFriendsGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientManageFriendsGroupResponse {
    fn default() -> &'a CMsgClientManageFriendsGroupResponse {
        <CMsgClientManageFriendsGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientManageFriendsGroupResponse {
    pub fn new() -> CMsgClientManageFriendsGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientManageFriendsGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientManageFriendsGroupResponse {
        CMsgClientManageFriendsGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientManageFriendsGroupResponse| { &m.eresult },
                |m: &mut CMsgClientManageFriendsGroupResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientManageFriendsGroupResponse>(
                "CMsgClientManageFriendsGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientManageFriendsGroupResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientManageFriendsGroupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientManageFriendsGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientManageFriendsGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientManageFriendsGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientManageFriendsGroupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientAddFriendToGroup {
    // message fields
    groupid: ::std::option::Option<i32>,
    steamiduser: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendToGroup {
    fn default() -> &'a CMsgClientAddFriendToGroup {
        <CMsgClientAddFriendToGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriendToGroup {
    pub fn new() -> CMsgClientAddFriendToGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;


    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }
    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamiduser = 2;


    pub fn get_steamiduser(&self) -> u64 {
        self.steamiduser.unwrap_or(0)
    }
    pub fn clear_steamiduser(&mut self) {
        self.steamiduser = ::std::option::Option::None;
    }

    pub fn has_steamiduser(&self) -> bool {
        self.steamiduser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamiduser(&mut self, v: u64) {
        self.steamiduser = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAddFriendToGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.groupid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamiduser = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamiduser {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamiduser {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAddFriendToGroup {
        CMsgClientAddFriendToGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "groupid",
                |m: &CMsgClientAddFriendToGroup| { &m.groupid },
                |m: &mut CMsgClientAddFriendToGroup| { &mut m.groupid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamiduser",
                |m: &CMsgClientAddFriendToGroup| { &m.steamiduser },
                |m: &mut CMsgClientAddFriendToGroup| { &mut m.steamiduser },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAddFriendToGroup>(
                "CMsgClientAddFriendToGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAddFriendToGroup {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAddFriendToGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAddFriendToGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientAddFriendToGroup {
    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.steamiduser = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriendToGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAddFriendToGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientAddFriendToGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientAddFriendToGroupResponse {
    fn default() -> &'a CMsgClientAddFriendToGroupResponse {
        <CMsgClientAddFriendToGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientAddFriendToGroupResponse {
    pub fn new() -> CMsgClientAddFriendToGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientAddFriendToGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientAddFriendToGroupResponse {
        CMsgClientAddFriendToGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientAddFriendToGroupResponse| { &m.eresult },
                |m: &mut CMsgClientAddFriendToGroupResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientAddFriendToGroupResponse>(
                "CMsgClientAddFriendToGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientAddFriendToGroupResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientAddFriendToGroupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientAddFriendToGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientAddFriendToGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriendToGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientAddFriendToGroupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientRemoveFriendFromGroup {
    // message fields
    groupid: ::std::option::Option<i32>,
    steamiduser: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriendFromGroup {
    fn default() -> &'a CMsgClientRemoveFriendFromGroup {
        <CMsgClientRemoveFriendFromGroup as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriendFromGroup {
    pub fn new() -> CMsgClientRemoveFriendFromGroup {
        ::std::default::Default::default()
    }

    // optional int32 groupid = 1;


    pub fn get_groupid(&self) -> i32 {
        self.groupid.unwrap_or(0)
    }
    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: i32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamiduser = 2;


    pub fn get_steamiduser(&self) -> u64 {
        self.steamiduser.unwrap_or(0)
    }
    pub fn clear_steamiduser(&mut self) {
        self.steamiduser = ::std::option::Option::None;
    }

    pub fn has_steamiduser(&self) -> bool {
        self.steamiduser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamiduser(&mut self, v: u64) {
        self.steamiduser = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriendFromGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.groupid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamiduser = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamiduser {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.groupid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.steamiduser {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRemoveFriendFromGroup {
        CMsgClientRemoveFriendFromGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "groupid",
                |m: &CMsgClientRemoveFriendFromGroup| { &m.groupid },
                |m: &mut CMsgClientRemoveFriendFromGroup| { &mut m.groupid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "steamiduser",
                |m: &CMsgClientRemoveFriendFromGroup| { &m.steamiduser },
                |m: &mut CMsgClientRemoveFriendFromGroup| { &mut m.steamiduser },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRemoveFriendFromGroup>(
                "CMsgClientRemoveFriendFromGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRemoveFriendFromGroup {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRemoveFriendFromGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRemoveFriendFromGroup::new)
    }
}

impl ::protobuf::Clear for CMsgClientRemoveFriendFromGroup {
    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.steamiduser = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRemoveFriendFromGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRemoveFriendFromGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientRemoveFriendFromGroupResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientRemoveFriendFromGroupResponse {
    fn default() -> &'a CMsgClientRemoveFriendFromGroupResponse {
        <CMsgClientRemoveFriendFromGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientRemoveFriendFromGroupResponse {
    pub fn new() -> CMsgClientRemoveFriendFromGroupResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;


    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriendFromGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientRemoveFriendFromGroupResponse {
        CMsgClientRemoveFriendFromGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "eresult",
                |m: &CMsgClientRemoveFriendFromGroupResponse| { &m.eresult },
                |m: &mut CMsgClientRemoveFriendFromGroupResponse| { &mut m.eresult },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientRemoveFriendFromGroupResponse>(
                "CMsgClientRemoveFriendFromGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientRemoveFriendFromGroupResponse {
        static instance: ::protobuf::rt::LazyV2<CMsgClientRemoveFriendFromGroupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientRemoveFriendFromGroupResponse::new)
    }
}

impl ::protobuf::Clear for CMsgClientRemoveFriendFromGroupResponse {
    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientRemoveFriendFromGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientRemoveFriendFromGroupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientGetEmoticonList {
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientGetEmoticonList {
    fn default() -> &'a CMsgClientGetEmoticonList {
        <CMsgClientGetEmoticonList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientGetEmoticonList {
    pub fn new() -> CMsgClientGetEmoticonList {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CMsgClientGetEmoticonList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientGetEmoticonList {
        CMsgClientGetEmoticonList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientGetEmoticonList>(
                "CMsgClientGetEmoticonList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientGetEmoticonList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientGetEmoticonList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientGetEmoticonList::new)
    }
}

impl ::protobuf::Clear for CMsgClientGetEmoticonList {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientGetEmoticonList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientGetEmoticonList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientEmoticonList {
    // message fields
    pub emoticons: ::protobuf::RepeatedField<CMsgClientEmoticonList_Emoticon>,
    pub stickers: ::protobuf::RepeatedField<CMsgClientEmoticonList_Sticker>,
    pub effects: ::protobuf::RepeatedField<CMsgClientEmoticonList_Effect>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmoticonList {
    fn default() -> &'a CMsgClientEmoticonList {
        <CMsgClientEmoticonList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmoticonList {
    pub fn new() -> CMsgClientEmoticonList {
        ::std::default::Default::default()
    }

    // repeated .CMsgClientEmoticonList.Emoticon emoticons = 1;


    pub fn get_emoticons(&self) -> &[CMsgClientEmoticonList_Emoticon] {
        &self.emoticons
    }
    pub fn clear_emoticons(&mut self) {
        self.emoticons.clear();
    }

    // Param is passed by value, moved
    pub fn set_emoticons(&mut self, v: ::protobuf::RepeatedField<CMsgClientEmoticonList_Emoticon>) {
        self.emoticons = v;
    }

    // Mutable pointer to the field.
    pub fn mut_emoticons(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientEmoticonList_Emoticon> {
        &mut self.emoticons
    }

    // Take field
    pub fn take_emoticons(&mut self) -> ::protobuf::RepeatedField<CMsgClientEmoticonList_Emoticon> {
        ::std::mem::replace(&mut self.emoticons, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgClientEmoticonList.Sticker stickers = 2;


    pub fn get_stickers(&self) -> &[CMsgClientEmoticonList_Sticker] {
        &self.stickers
    }
    pub fn clear_stickers(&mut self) {
        self.stickers.clear();
    }

    // Param is passed by value, moved
    pub fn set_stickers(&mut self, v: ::protobuf::RepeatedField<CMsgClientEmoticonList_Sticker>) {
        self.stickers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stickers(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientEmoticonList_Sticker> {
        &mut self.stickers
    }

    // Take field
    pub fn take_stickers(&mut self) -> ::protobuf::RepeatedField<CMsgClientEmoticonList_Sticker> {
        ::std::mem::replace(&mut self.stickers, ::protobuf::RepeatedField::new())
    }

    // repeated .CMsgClientEmoticonList.Effect effects = 3;


    pub fn get_effects(&self) -> &[CMsgClientEmoticonList_Effect] {
        &self.effects
    }
    pub fn clear_effects(&mut self) {
        self.effects.clear();
    }

    // Param is passed by value, moved
    pub fn set_effects(&mut self, v: ::protobuf::RepeatedField<CMsgClientEmoticonList_Effect>) {
        self.effects = v;
    }

    // Mutable pointer to the field.
    pub fn mut_effects(&mut self) -> &mut ::protobuf::RepeatedField<CMsgClientEmoticonList_Effect> {
        &mut self.effects
    }

    // Take field
    pub fn take_effects(&mut self) -> ::protobuf::RepeatedField<CMsgClientEmoticonList_Effect> {
        ::std::mem::replace(&mut self.effects, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CMsgClientEmoticonList {
    fn is_initialized(&self) -> bool {
        for v in &self.emoticons {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stickers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.effects {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.emoticons)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stickers)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.effects)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.emoticons {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.stickers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.effects {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.emoticons {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.stickers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.effects {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientEmoticonList {
        CMsgClientEmoticonList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientEmoticonList_Emoticon>>(
                "emoticons",
                |m: &CMsgClientEmoticonList| { &m.emoticons },
                |m: &mut CMsgClientEmoticonList| { &mut m.emoticons },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientEmoticonList_Sticker>>(
                "stickers",
                |m: &CMsgClientEmoticonList| { &m.stickers },
                |m: &mut CMsgClientEmoticonList| { &mut m.stickers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CMsgClientEmoticonList_Effect>>(
                "effects",
                |m: &CMsgClientEmoticonList| { &m.effects },
                |m: &mut CMsgClientEmoticonList| { &mut m.effects },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientEmoticonList>(
                "CMsgClientEmoticonList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientEmoticonList {
        static instance: ::protobuf::rt::LazyV2<CMsgClientEmoticonList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientEmoticonList::new)
    }
}

impl ::protobuf::Clear for CMsgClientEmoticonList {
    fn clear(&mut self) {
        self.emoticons.clear();
        self.stickers.clear();
        self.effects.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientEmoticonList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientEmoticonList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientEmoticonList_Emoticon {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    count: ::std::option::Option<i32>,
    time_last_used: ::std::option::Option<u32>,
    use_count: ::std::option::Option<u32>,
    time_received: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmoticonList_Emoticon {
    fn default() -> &'a CMsgClientEmoticonList_Emoticon {
        <CMsgClientEmoticonList_Emoticon as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmoticonList_Emoticon {
    pub fn new() -> CMsgClientEmoticonList_Emoticon {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_used = 3;


    pub fn get_time_last_used(&self) -> u32 {
        self.time_last_used.unwrap_or(0)
    }
    pub fn clear_time_last_used(&mut self) {
        self.time_last_used = ::std::option::Option::None;
    }

    pub fn has_time_last_used(&self) -> bool {
        self.time_last_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_used(&mut self, v: u32) {
        self.time_last_used = ::std::option::Option::Some(v);
    }

    // optional uint32 use_count = 4;


    pub fn get_use_count(&self) -> u32 {
        self.use_count.unwrap_or(0)
    }
    pub fn clear_use_count(&mut self) {
        self.use_count = ::std::option::Option::None;
    }

    pub fn has_use_count(&self) -> bool {
        self.use_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_count(&mut self, v: u32) {
        self.use_count = ::std::option::Option::Some(v);
    }

    // optional uint32 time_received = 5;


    pub fn get_time_received(&self) -> u32 {
        self.time_received.unwrap_or(0)
    }
    pub fn clear_time_received(&mut self) {
        self.time_received = ::std::option::Option::None;
    }

    pub fn has_time_received(&self) -> bool {
        self.time_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_received(&mut self, v: u32) {
        self.time_received = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 6;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientEmoticonList_Emoticon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_used = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.use_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_received = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_used {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use_count {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_received {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.time_last_used {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.use_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.time_received {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientEmoticonList_Emoticon {
        CMsgClientEmoticonList_Emoticon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgClientEmoticonList_Emoticon| { &m.name },
                |m: &mut CMsgClientEmoticonList_Emoticon| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &CMsgClientEmoticonList_Emoticon| { &m.count },
                |m: &mut CMsgClientEmoticonList_Emoticon| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_last_used",
                |m: &CMsgClientEmoticonList_Emoticon| { &m.time_last_used },
                |m: &mut CMsgClientEmoticonList_Emoticon| { &mut m.time_last_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "use_count",
                |m: &CMsgClientEmoticonList_Emoticon| { &m.use_count },
                |m: &mut CMsgClientEmoticonList_Emoticon| { &mut m.use_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_received",
                |m: &CMsgClientEmoticonList_Emoticon| { &m.time_received },
                |m: &mut CMsgClientEmoticonList_Emoticon| { &mut m.time_received },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientEmoticonList_Emoticon| { &m.appid },
                |m: &mut CMsgClientEmoticonList_Emoticon| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientEmoticonList_Emoticon>(
                "CMsgClientEmoticonList.Emoticon",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientEmoticonList_Emoticon {
        static instance: ::protobuf::rt::LazyV2<CMsgClientEmoticonList_Emoticon> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientEmoticonList_Emoticon::new)
    }
}

impl ::protobuf::Clear for CMsgClientEmoticonList_Emoticon {
    fn clear(&mut self) {
        self.name.clear();
        self.count = ::std::option::Option::None;
        self.time_last_used = ::std::option::Option::None;
        self.use_count = ::std::option::Option::None;
        self.time_received = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientEmoticonList_Emoticon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientEmoticonList_Emoticon {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientEmoticonList_Sticker {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    count: ::std::option::Option<i32>,
    time_received: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    time_last_used: ::std::option::Option<u32>,
    use_count: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmoticonList_Sticker {
    fn default() -> &'a CMsgClientEmoticonList_Sticker {
        <CMsgClientEmoticonList_Sticker as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmoticonList_Sticker {
    pub fn new() -> CMsgClientEmoticonList_Sticker {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 time_received = 3;


    pub fn get_time_received(&self) -> u32 {
        self.time_received.unwrap_or(0)
    }
    pub fn clear_time_received(&mut self) {
        self.time_received = ::std::option::Option::None;
    }

    pub fn has_time_received(&self) -> bool {
        self.time_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_received(&mut self, v: u32) {
        self.time_received = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 4;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 time_last_used = 5;


    pub fn get_time_last_used(&self) -> u32 {
        self.time_last_used.unwrap_or(0)
    }
    pub fn clear_time_last_used(&mut self) {
        self.time_last_used = ::std::option::Option::None;
    }

    pub fn has_time_last_used(&self) -> bool {
        self.time_last_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_last_used(&mut self, v: u32) {
        self.time_last_used = ::std::option::Option::Some(v);
    }

    // optional uint32 use_count = 6;


    pub fn get_use_count(&self) -> u32 {
        self.use_count.unwrap_or(0)
    }
    pub fn clear_use_count(&mut self) {
        self.use_count = ::std::option::Option::None;
    }

    pub fn has_use_count(&self) -> bool {
        self.use_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_count(&mut self, v: u32) {
        self.use_count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientEmoticonList_Sticker {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_received = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_last_used = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.use_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_received {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_last_used {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.use_count {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.time_received {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.time_last_used {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.use_count {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientEmoticonList_Sticker {
        CMsgClientEmoticonList_Sticker::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgClientEmoticonList_Sticker| { &m.name },
                |m: &mut CMsgClientEmoticonList_Sticker| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &CMsgClientEmoticonList_Sticker| { &m.count },
                |m: &mut CMsgClientEmoticonList_Sticker| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_received",
                |m: &CMsgClientEmoticonList_Sticker| { &m.time_received },
                |m: &mut CMsgClientEmoticonList_Sticker| { &mut m.time_received },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientEmoticonList_Sticker| { &m.appid },
                |m: &mut CMsgClientEmoticonList_Sticker| { &mut m.appid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_last_used",
                |m: &CMsgClientEmoticonList_Sticker| { &m.time_last_used },
                |m: &mut CMsgClientEmoticonList_Sticker| { &mut m.time_last_used },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "use_count",
                |m: &CMsgClientEmoticonList_Sticker| { &m.use_count },
                |m: &mut CMsgClientEmoticonList_Sticker| { &mut m.use_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientEmoticonList_Sticker>(
                "CMsgClientEmoticonList.Sticker",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientEmoticonList_Sticker {
        static instance: ::protobuf::rt::LazyV2<CMsgClientEmoticonList_Sticker> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientEmoticonList_Sticker::new)
    }
}

impl ::protobuf::Clear for CMsgClientEmoticonList_Sticker {
    fn clear(&mut self) {
        self.name.clear();
        self.count = ::std::option::Option::None;
        self.time_received = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.time_last_used = ::std::option::Option::None;
        self.use_count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientEmoticonList_Sticker {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientEmoticonList_Sticker {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgClientEmoticonList_Effect {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    count: ::std::option::Option<i32>,
    time_received: ::std::option::Option<u32>,
    infinite_use: ::std::option::Option<bool>,
    appid: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgClientEmoticonList_Effect {
    fn default() -> &'a CMsgClientEmoticonList_Effect {
        <CMsgClientEmoticonList_Effect as ::protobuf::Message>::default_instance()
    }
}

impl CMsgClientEmoticonList_Effect {
    pub fn new() -> CMsgClientEmoticonList_Effect {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 count = 2;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 time_received = 3;


    pub fn get_time_received(&self) -> u32 {
        self.time_received.unwrap_or(0)
    }
    pub fn clear_time_received(&mut self) {
        self.time_received = ::std::option::Option::None;
    }

    pub fn has_time_received(&self) -> bool {
        self.time_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_received(&mut self, v: u32) {
        self.time_received = ::std::option::Option::Some(v);
    }

    // optional bool infinite_use = 4;


    pub fn get_infinite_use(&self) -> bool {
        self.infinite_use.unwrap_or(false)
    }
    pub fn clear_infinite_use(&mut self) {
        self.infinite_use = ::std::option::Option::None;
    }

    pub fn has_infinite_use(&self) -> bool {
        self.infinite_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_infinite_use(&mut self, v: bool) {
        self.infinite_use = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 5;


    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgClientEmoticonList_Effect {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_received = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.infinite_use = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_received {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.infinite_use {
            my_size += 2;
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.time_received {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.infinite_use {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgClientEmoticonList_Effect {
        CMsgClientEmoticonList_Effect::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CMsgClientEmoticonList_Effect| { &m.name },
                |m: &mut CMsgClientEmoticonList_Effect| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &CMsgClientEmoticonList_Effect| { &m.count },
                |m: &mut CMsgClientEmoticonList_Effect| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "time_received",
                |m: &CMsgClientEmoticonList_Effect| { &m.time_received },
                |m: &mut CMsgClientEmoticonList_Effect| { &mut m.time_received },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "infinite_use",
                |m: &CMsgClientEmoticonList_Effect| { &m.infinite_use },
                |m: &mut CMsgClientEmoticonList_Effect| { &mut m.infinite_use },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "appid",
                |m: &CMsgClientEmoticonList_Effect| { &m.appid },
                |m: &mut CMsgClientEmoticonList_Effect| { &mut m.appid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgClientEmoticonList_Effect>(
                "CMsgClientEmoticonList.Effect",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CMsgClientEmoticonList_Effect {
        static instance: ::protobuf::rt::LazyV2<CMsgClientEmoticonList_Effect> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgClientEmoticonList_Effect::new)
    }
}

impl ::protobuf::Clear for CMsgClientEmoticonList_Effect {
    fn clear(&mut self) {
        self.name.clear();
        self.count = ::std::option::Option::None;
        self.time_received = ::std::option::Option::None;
        self.infinite_use = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgClientEmoticonList_Effect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgClientEmoticonList_Effect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n(steammessages_clientserver_friends.proto\x1a\x18steammessages_base.pr\
    oto\"\xd1\x01\n\x13CMsgClientFriendMsg\x12\x18\n\x07steamid\x18\x01\x20\
    \x01(\x06R\x07steamid\x12&\n\x0fchat_entry_type\x18\x02\x20\x01(\x05R\rc\
    hatEntryType\x12\x18\n\x07message\x18\x03\x20\x01(\x0cR\x07message\x128\
    \n\x18rtime32_server_timestamp\x18\x04\x20\x01(\x07R\x16rtime32ServerTim\
    estamp\x12$\n\x0eecho_to_sender\x18\x05\x20\x01(\x08R\x0cechoToSender\"\
    \xee\x01\n\x1bCMsgClientFriendMsgIncoming\x12!\n\x0csteamid_from\x18\x01\
    \x20\x01(\x06R\x0bsteamidFrom\x12&\n\x0fchat_entry_type\x18\x02\x20\x01(\
    \x05R\rchatEntryType\x120\n\x14from_limited_account\x18\x03\x20\x01(\x08\
    R\x12fromLimitedAccount\x12\x18\n\x07message\x18\x04\x20\x01(\x0cR\x07me\
    ssage\x128\n\x18rtime32_server_timestamp\x18\x05\x20\x01(\x07R\x16rtime3\
    2ServerTimestamp\"y\n\x13CMsgClientAddFriend\x12$\n\x0esteamid_to_add\
    \x18\x01\x20\x01(\x06R\x0csteamidToAdd\x12<\n\x1baccountname_or_email_to\
    _add\x18\x02\x20\x01(\tR\x17accountnameOrEmailToAdd\"\x8e\x01\n\x1bCMsgC\
    lientAddFriendResponse\x12\x1b\n\x07eresult\x18\x01\x20\x01(\x05:\x012R\
    \x07eresult\x12$\n\x0esteam_id_added\x18\x02\x20\x01(\x06R\x0csteamIdAdd\
    ed\x12,\n\x12persona_name_added\x18\x03\x20\x01(\tR\x10personaNameAdded\
    \"4\n\x16CMsgClientRemoveFriend\x12\x1a\n\x08friendid\x18\x01\x20\x01(\
    \x06R\x08friendid\"F\n\x14CMsgClientHideFriend\x12\x1a\n\x08friendid\x18\
    \x01\x20\x01(\x06R\x08friendid\x12\x12\n\x04hide\x18\x02\x20\x01(\x08R\
    \x04hide\"\xd6\x02\n\x15CMsgClientFriendsList\x12\"\n\x0cbincremental\
    \x18\x01\x20\x01(\x08R\x0cbincremental\x127\n\x07friends\x18\x02\x20\x03\
    (\x0b2\x1d.CMsgClientFriendsList.FriendR\x07friends\x12(\n\x10max_friend\
    _count\x18\x03\x20\x01(\rR\x0emaxFriendCount\x12.\n\x13active_friend_cou\
    nt\x18\x04\x20\x01(\rR\x11activeFriendCount\x12*\n\x11friends_limit_hit\
    \x18\x05\x20\x01(\x08R\x0ffriendsLimitHit\x1aZ\n\x06Friend\x12\x1e\n\nul\
    friendid\x18\x01\x20\x01(\x06R\nulfriendid\x120\n\x13efriendrelationship\
    \x18\x02\x20\x01(\rR\x13efriendrelationship\"\xa5\x03\n\x1bCMsgClientFri\
    endsGroupsList\x12\x1a\n\x08bremoval\x18\x01\x20\x01(\x08R\x08bremoval\
    \x12\"\n\x0cbincremental\x18\x02\x20\x01(\x08R\x0cbincremental\x12L\n\
    \x0cfriendGroups\x18\x03\x20\x03(\x0b2(.CMsgClientFriendsGroupsList.Frie\
    ndGroupR\x0cfriendGroups\x12U\n\x0bmemberships\x18\x04\x20\x03(\x0b23.CM\
    sgClientFriendsGroupsList.FriendGroupsMembershipR\x0bmemberships\x1aM\n\
    \x0bFriendGroup\x12\x1a\n\x08nGroupID\x18\x01\x20\x01(\x05R\x08nGroupID\
    \x12\"\n\x0cstrGroupName\x18\x02\x20\x01(\tR\x0cstrGroupName\x1aR\n\x16F\
    riendGroupsMembership\x12\x1c\n\tulSteamID\x18\x01\x20\x01(\x06R\tulStea\
    mID\x12\x1a\n\x08nGroupID\x18\x02\x20\x01(\x05R\x08nGroupID\"\xee\x01\n\
    \x1cCMsgClientPlayerNicknameList\x12\x18\n\x07removal\x18\x01\x20\x01(\
    \x08R\x07removal\x12\x20\n\x0bincremental\x18\x02\x20\x01(\x08R\x0bincre\
    mental\x12J\n\tnicknames\x18\x03\x20\x03(\x0b2,.CMsgClientPlayerNickname\
    List.PlayerNicknameR\tnicknames\x1aF\n\x0ePlayerNickname\x12\x18\n\x07st\
    eamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x1a\n\x08nickname\x18\x03\x20\
    \x01(\tR\x08nickname\"S\n\x1bCMsgClientSetPlayerNickname\x12\x18\n\x07st\
    eamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x1a\n\x08nickname\x18\x02\x20\
    \x01(\tR\x08nickname\"?\n#CMsgClientSetPlayerNicknameResponse\x12\x18\n\
    \x07eresult\x18\x01\x20\x01(\rR\x07eresult\"o\n\x1bCMsgClientRequestFrie\
    ndData\x126\n\x17persona_state_requested\x18\x01\x20\x01(\rR\x15personaS\
    tateRequested\x12\x18\n\x07friends\x18\x02\x20\x03(\x06R\x07friends\"\
    \xf4\x02\n\x16CMsgClientChangeStatus\x12#\n\rpersona_state\x18\x01\x20\
    \x01(\rR\x0cpersonaState\x12\x1f\n\x0bplayer_name\x18\x02\x20\x01(\tR\np\
    layerName\x123\n\x16is_auto_generated_name\x18\x03\x20\x01(\x08R\x13isAu\
    toGeneratedName\x12#\n\rhigh_priority\x18\x04\x20\x01(\x08R\x0chighPrior\
    ity\x12-\n\x13persona_set_by_user\x18\x05\x20\x01(\x08R\x10personaSetByU\
    ser\x121\n\x13persona_state_flags\x18\x06\x20\x01(\r:\x010R\x11personaSt\
    ateFlags\x122\n\x15need_persona_response\x18\x07\x20\x01(\x08R\x13needPe\
    rsonaResponse\x12$\n\x0eis_client_idle\x18\x08\x20\x01(\x08R\x0cisClient\
    Idle\"T\n\x19CMsgPersonaChangeResponse\x12\x16\n\x06result\x18\x01\x20\
    \x01(\rR\x06result\x12\x1f\n\x0bplayer_name\x18\x02\x20\x01(\tR\nplayerN\
    ame\"\xa1\x0b\n\x16CMsgClientPersonaState\x12!\n\x0cstatus_flags\x18\x01\
    \x20\x01(\rR\x0bstatusFlags\x128\n\x07friends\x18\x02\x20\x03(\x0b2\x1e.\
    CMsgClientPersonaState.FriendR\x07friends\x1a\xa9\n\n\x06Friend\x12\x1a\
    \n\x08friendid\x18\x01\x20\x01(\x06R\x08friendid\x12#\n\rpersona_state\
    \x18\x02\x20\x01(\rR\x0cpersonaState\x12+\n\x12game_played_app_id\x18\
    \x03\x20\x01(\rR\x0fgamePlayedAppId\x12$\n\x0egame_server_ip\x18\x04\x20\
    \x01(\rR\x0cgameServerIp\x12(\n\x10game_server_port\x18\x05\x20\x01(\rR\
    \x0egameServerPort\x12.\n\x13persona_state_flags\x18\x06\x20\x01(\rR\x11\
    personaStateFlags\x128\n\x18online_session_instances\x18\x07\x20\x01(\rR\
    \x16onlineSessionInstances\x12-\n\x13persona_set_by_user\x18\n\x20\x01(\
    \x08R\x10personaSetByUser\x12\x1f\n\x0bplayer_name\x18\x0f\x20\x01(\tR\n\
    playerName\x12\x1d\n\nquery_port\x18\x14\x20\x01(\rR\tqueryPort\x12%\n\
    \x0esteamid_source\x18\x19\x20\x01(\x06R\rsteamidSource\x12\x1f\n\x0bava\
    tar_hash\x18\x1f\x20\x01(\x0cR\navatarHash\x12\x1f\n\x0blast_logoff\x18-\
    \x20\x01(\rR\nlastLogoff\x12\x1d\n\nlast_logon\x18.\x20\x01(\rR\tlastLog\
    on\x12(\n\x10last_seen_online\x18/\x20\x01(\rR\x0elastSeenOnline\x12\x1b\
    \n\tclan_rank\x182\x20\x01(\rR\x08clanRank\x12\x1b\n\tgame_name\x187\x20\
    \x01(\tR\x08gameName\x12\x16\n\x06gameid\x188\x20\x01(\x06R\x06gameid\
    \x12$\n\x0egame_data_blob\x18<\x20\x01(\x0cR\x0cgameDataBlob\x12D\n\tcla\
    n_data\x18@\x20\x01(\x0b2'.CMsgClientPersonaState.Friend.ClanDataR\x08cl\
    anData\x12\x19\n\x08clan_tag\x18A\x20\x01(\tR\x07clanTag\x12F\n\rrich_pr\
    esence\x18G\x20\x03(\x0b2!.CMsgClientPersonaState.Friend.KVR\x0crichPres\
    ence\x12!\n\x0cbroadcast_id\x18H\x20\x01(\x06R\x0bbroadcastId\x12\"\n\rg\
    ame_lobby_id\x18I\x20\x01(\x06R\x0bgameLobbyId\x12@\n\x1cwatching_broadc\
    ast_accountid\x18J\x20\x01(\rR\x1awatchingBroadcastAccountid\x128\n\x18w\
    atching_broadcast_appid\x18K\x20\x01(\rR\x16watchingBroadcastAppid\x12<\
    \n\x1awatching_broadcast_viewers\x18L\x20\x01(\rR\x18watchingBroadcastVi\
    ewers\x128\n\x18watching_broadcast_title\x18M\x20\x01(\tR\x16watchingBro\
    adcastTitle\x1aL\n\x08ClanData\x12\x1c\n\nogg_app_id\x18\x01\x20\x01(\rR\
    \x08oggAppId\x12\"\n\rchat_group_id\x18\x02\x20\x01(\x04R\x0bchatGroupId\
    \x1a,\n\x02KV\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05v\
    alue\x18\x02\x20\x01(\tR\x05value\"D\n\x1bCMsgClientFriendProfileInfo\
    \x12%\n\x0esteamid_friend\x18\x01\x20\x01(\x06R\rsteamidFriend\"\xbe\x02\
    \n#CMsgClientFriendProfileInfoResponse\x12\x1b\n\x07eresult\x18\x01\x20\
    \x01(\x05:\x012R\x07eresult\x12%\n\x0esteamid_friend\x18\x02\x20\x01(\
    \x06R\rsteamidFriend\x12!\n\x0ctime_created\x18\x03\x20\x01(\rR\x0btimeC\
    reated\x12\x1b\n\treal_name\x18\x04\x20\x01(\tR\x08realName\x12\x1b\n\tc\
    ity_name\x18\x05\x20\x01(\tR\x08cityName\x12\x1d\n\nstate_name\x18\x06\
    \x20\x01(\tR\tstateName\x12!\n\x0ccountry_name\x18\x07\x20\x01(\tR\x0bco\
    untryName\x12\x1a\n\x08headline\x18\x08\x20\x01(\tR\x08headline\x12\x18\
    \n\x07summary\x18\t\x20\x01(\tR\x07summary\"\x7f\n\x1cCMsgClientCreateFr\
    iendsGroup\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x1c\
    \n\tgroupname\x18\x02\x20\x01(\tR\tgroupname\x12'\n\x0fsteamid_friends\
    \x18\x03\x20\x03(\x06R\x0esteamidFriends\"Z\n$CMsgClientCreateFriendsGro\
    upResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\x12\x18\n\
    \x07groupid\x18\x02\x20\x01(\x05R\x07groupid\"R\n\x1cCMsgClientDeleteFri\
    endsGroup\x12\x18\n\x07steamid\x18\x01\x20\x01(\x06R\x07steamid\x12\x18\
    \n\x07groupid\x18\x02\x20\x01(\x05R\x07groupid\"@\n$CMsgClientDeleteFrie\
    ndsGroupResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresult\"\
    \xc2\x01\n\x1cCMsgClientManageFriendsGroup\x12\x18\n\x07groupid\x18\x01\
    \x20\x01(\x05R\x07groupid\x12\x1c\n\tgroupname\x18\x02\x20\x01(\tR\tgrou\
    pname\x122\n\x15steamid_friends_added\x18\x03\x20\x03(\x06R\x13steamidFr\
    iendsAdded\x126\n\x17steamid_friends_removed\x18\x04\x20\x03(\x06R\x15st\
    eamidFriendsRemoved\"@\n$CMsgClientManageFriendsGroupResponse\x12\x18\n\
    \x07eresult\x18\x01\x20\x01(\rR\x07eresult\"X\n\x1aCMsgClientAddFriendTo\
    Group\x12\x18\n\x07groupid\x18\x01\x20\x01(\x05R\x07groupid\x12\x20\n\
    \x0bsteamiduser\x18\x02\x20\x01(\x06R\x0bsteamiduser\">\n\"CMsgClientAdd\
    FriendToGroupResponse\x12\x18\n\x07eresult\x18\x01\x20\x01(\rR\x07eresul\
    t\"]\n\x1fCMsgClientRemoveFriendFromGroup\x12\x18\n\x07groupid\x18\x01\
    \x20\x01(\x05R\x07groupid\x12\x20\n\x0bsteamiduser\x18\x02\x20\x01(\x06R\
    \x0bsteamiduser\"C\n'CMsgClientRemoveFriendFromGroupResponse\x12\x18\n\
    \x07eresult\x18\x01\x20\x01(\rR\x07eresult\"\x1b\n\x19CMsgClientGetEmoti\
    conList\"\xcb\x05\n\x16CMsgClientEmoticonList\x12>\n\temoticons\x18\x01\
    \x20\x03(\x0b2\x20.CMsgClientEmoticonList.EmoticonR\temoticons\x12;\n\
    \x08stickers\x18\x02\x20\x03(\x0b2\x1f.CMsgClientEmoticonList.StickerR\
    \x08stickers\x128\n\x07effects\x18\x03\x20\x03(\x0b2\x1e.CMsgClientEmoti\
    conList.EffectR\x07effects\x1a\xb2\x01\n\x08Emoticon\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\
    \x05count\x12$\n\x0etime_last_used\x18\x03\x20\x01(\rR\x0ctimeLastUsed\
    \x12\x1b\n\tuse_count\x18\x04\x20\x01(\rR\x08useCount\x12#\n\rtime_recei\
    ved\x18\x05\x20\x01(\rR\x0ctimeReceived\x12\x14\n\x05appid\x18\x06\x20\
    \x01(\rR\x05appid\x1a\xb1\x01\n\x07Sticker\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\x12#\
    \n\rtime_received\x18\x03\x20\x01(\rR\x0ctimeReceived\x12\x14\n\x05appid\
    \x18\x04\x20\x01(\rR\x05appid\x12$\n\x0etime_last_used\x18\x05\x20\x01(\
    \rR\x0ctimeLastUsed\x12\x1b\n\tuse_count\x18\x06\x20\x01(\rR\x08useCount\
    \x1a\x90\x01\n\x06Effect\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\x12#\n\rtime_received\
    \x18\x03\x20\x01(\rR\x0ctimeReceived\x12!\n\x0cinfinite_use\x18\x04\x20\
    \x01(\x08R\x0binfiniteUse\x12\x14\n\x05appid\x18\x05\x20\x01(\rR\x05appi\
    dB\x05H\x01\x80\x01\0\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
